[[header]]
== Matter Test Plan

[#revnumber]#version master d055a55,# [#revdate]#2023-08-18 16:55:59
-0700# +
[#revremark]#Draft#

[[toc]]
[[toctitle]]
Table of Contents

* link:#_notice_of_use_and_disclosure[Notice of Use and Disclosure]
* link:#_participants[Participants]
* link:#_document_control[Document Control]
* link:#_document_history[Document History]
* link:#_introduction[*Introduction*]
* link:#_introduction_2[1. Introduction]
** link:#_scope[1.1. Scope]
** link:#_purpose[1.2. Purpose]
** link:#_prerequisites[1.3. Prerequisites]
* link:#_references[2. References]
** link:#_matter_documents[2.1. Matter Documents]
** link:#_dependency_certification_documents[2.2. Dependency
Certification Documents]
* link:#_definitions[3. Definitions]
** link:#_acronyms[3.1. Acronyms]
** link:#_glossary[3.2. Glossary]
** link:#_identificationsidentifiers[3.3. Identifications/Identifiers]
** link:#_conformance_levels[3.4. Conformance Levels]
** link:#_diagram_definitions[3.5. Diagram Definitions]
* link:#_test_setup[4. Test Setup]
* link:#_mcore_pics_definition[*MCORE PICS Definition*]
** link:#_pics_definition[5. PICS Definition]
*** link:#_communicationtransport[5.1. Communication/Transport]
*** link:#_role[5.2. Role]
*** link:#_user_interface[5.3. User Interface]
* link:#_device_discovery_test_plan[*Device Discovery Test Plan*]
** link:#_pics_definition_2[6. PICS Definition]
** link:#_test_case_list[7. Test Case List]
** link:#_test_cases[8. Test Cases]
*** link:#_onboarding_payload_test_cases[8.1. *Onboarding Payload Test
Cases*]
**** link:#_tc_dd_1_1_qr_code_onboarding_payload_verification_dut_commissionee[8.1.1.
[TC-DD-1.1] QR Code Onboarding Payload Verification [DUT -
Commissionee]]
**** link:#_tc_dd_1_2_manual_pairing_code_payload_verification_dut_commissionee[8.1.2.
[TC-DD-1.2] Manual Pairing Code Payload Verification [DUT -
Commissionee]]
**** link:#_tc_dd_1_3_nfc_onboarding_payload_verification_dut_commissionee_removed[8.1.3.
[TC-DD-1.3] NFC Onboarding Payload Verification [DUT - Commissionee] -
REMOVED]
**** link:#_tc_dd_1_4_concatenation_qr_code_onboarding_payload_verification_dut_commissionee_removed[8.1.4.
[TC-DD-1.4] Concatenation - QR Code Onboarding Payload Verification [DUT
- Commissionee] - REMOVED]
**** link:#_tc_dd_1_5_nfc_rules_of_advertisement_and_onboarding_dut_commissionee_removed[8.1.5.
[TC-DD-1.5] NFC Rules of Advertisement and Onboarding [DUT -
Commissionee] - REMOVED]
**** link:#_tc_dd_1_6_qr_code_format_and_label_dut_commissionee[8.1.6.
[TC-DD-1.6] QR Code Format and Label [DUT - Commissionee]]
**** link:#_tc_dd_1_7_setup_code_format_and_label_dut_commissionee[8.1.7.
[TC-DD-1.7] Setup Code Format and Label [DUT - Commissionee]]
**** link:#_tc_dd_1_8_qr_code_onboarding_payload_verification_dut_commissioner[8.1.8.
[TC-DD-1.8] QR Code Onboarding Payload Verification [DUT -
Commissioner]]
**** link:#_tc_dd_1_9_manual_pairing_code_payload_verification_dut_commissioner[8.1.9.
[TC-DD-1.9] Manual Pairing Code Payload Verification [DUT -
Commissioner]]
**** link:#_tc_dd_1_10_nfc_onboarding_payload_verification_dut_commissioner_removed[8.1.10.
[TC-DD-1.10] NFC Onboarding Payload Verification [DUT - Commissioner] -
REMOVED]
**** link:#_tc_dd_1_11_concatenation_qr_code_onboarding_payload_verification_dut_commissioner_removed[8.1.11.
[TC-DD-1.11] Concatenation - QR Code Onboarding Payload Verification
[DUT - Commissioner] - REMOVED]
**** link:#_tc_dd_1_12_onboarding_payload_verification_custom_flow_0_dut_commissionee[8.1.12.
[TC-DD-1.12] Onboarding Payload Verification - Custom Flow = 0 [DUT -
Commissionee]]
**** link:#_tc_dd_1_13_onboarding_payload_verification_custom_flow_1_dut_commissionee[8.1.13.
[TC-DD-1.13] Onboarding Payload Verification - Custom Flow = 1 [DUT -
Commissionee]]
**** link:#_tc_dd_1_14_onboarding_payload_verification_custom_flow_2_dut_commissionee[8.1.14.
[TC-DD-1.14] Onboarding Payload Verification - Custom Flow = 2 [DUT -
Commissionee]]
**** link:#_tc_dd_1_15_onboarding_payload_verification_unique_discriminator_and_passcode_values_dut_commissionee[8.1.15.
[TC-DD-1.15] Onboarding Payload Verification - Unique Discriminator and
Passcode Values [DUT - Commissionee]]
*** link:#_pre_commissioning_discovery_test_cases[8.2.
*Pre-Commissioning Discovery Test Cases*]
**** link:#_tc_dd_2_1_announcement_by_device_verification_dut_commissionee[8.2.1.
[TC-DD-2.1] Announcement by Device Verification [DUT - Commissionee]]
**** link:#_tc_dd_2_2_discovery_by_commissioner_verification_dut_commissioner[8.2.2.
[TC-DD-2.2] Discovery by Commissioner Verification [DUT - Commissioner]]
*** link:#_commissioning_flows_test_cases[8.3. *Commissioning Flows Test
Cases*]
**** link:#_tc_dd_3_1_commissioning_flow_concurrent_dut_commissionee[8.3.1.
[TC-DD-3.1] Commissioning Flow - Concurrent [DUT - Commissionee]]
**** link:#_tc_dd_3_2_commissioning_flow_non_concurrent_dut_commissionee_removed[8.3.2.
[TC-DD-3.2] Commissioning Flow - Non-concurrent [DUT - Commissionee] -
REMOVED]
**** link:#_tc_dd_3_3_user_directed_commissioning_dut_commissionee[8.3.3.
[TC-DD-3.3] User Directed Commissioning [DUT - Commissionee]]
**** link:#_tc_dd_3_4_user_directed_commissioning_dut_commissioner[8.3.4.
[TC-DD-3.4] User Directed Commissioning [DUT - Commissioner]]
**** link:#_tc_dd_3_5_commissioning_flow_concurrent_dut_commissioner[8.3.5.
[TC-DD-3.5] Commissioning Flow - Concurrent [DUT - Commissioner]]
**** link:#_tc_dd_3_6_commissioning_flow_non_concurrent_dut_commissioner_removed[8.3.6.
[TC-DD-3.6] Commissioning Flow - Non-concurrent [DUT - Commissioner] -
REMOVED]
**** link:#_tc_dd_3_7_commissioning_flow_concurrent_negative_scenario_dut_commissioner_removed[8.3.7.
[TC-DD-3.7] Commissioning Flow - Concurrent - Negative Scenario [DUT -
Commissioner] - REMOVED]
**** link:#_tc_dd_3_8_commissioning_flow_non_concurrent_negative_scenario_dut_commissioner_removed[8.3.8.
[TC-DD-3.8] Commissioning Flow - Non-concurrent - Negative Scenario [DUT
- Commissioner] - REMOVED]
**** link:#_tc_dd_3_9_commissioning_flow_custom_flow_2_dut_commissionee[8.3.9.
[TC-DD-3.9] Commissioning Flow - Custom Flow = 2 [DUT - Commissionee]]
**** link:#_tc_dd_3_10_commissioning_flow_custom_flow_2_dut_commissioner[8.3.10.
[TC-DD-3.10] Commissioning Flow - Custom Flow = 2 [DUT - Commissioner]]
**** link:#_tc_dd_3_11_commissioning_flow_0_standard_flow_qr_code_dut_commissioner[8.3.11.
[TC-DD-3.11] Commissioning Flow = 0 (Standard Flow) - QR Code [DUT -
Commissioner]]
**** link:#_tc_dd_3_12_commissioning_flow_1_user_intent_flow_qr_code_dut_commissioner[8.3.12.
[TC-DD-3.12] Commissioning Flow = 1 (User-Intent Flow) - QR Code [DUT -
Commissioner]]
**** link:#_tc_dd_3_13_commissioning_flow_2_custom_flow_qr_code_dut_commissioner[8.3.13.
[TC-DD-3.13] Commissioning Flow = 2 (Custom Flow) - QR Code [DUT -
Commissioner]]
**** link:#_tc_dd_3_14_commissioning_flow_qr_code_negative_scenario_dut_commissioner[8.3.14.
[TC-DD-3.14] Commissioning Flow - QR Code - Negative Scenario [DUT -
Commissioner]]
**** link:#_tc_dd_3_15_commissioning_flow_manual_pairing_code_dut_commissioner[8.3.15.
[TC-DD-3.15] Commissioning Flow - Manual Pairing Code [DUT -
Commissioner]]
**** link:#_tc_dd_3_16_commissioning_flow_11_digit_manual_pairing_code_negative_scenario_dut_commissioner[8.3.16.
[TC-DD-3.16] Commissioning Flow - 11-digit Manual Pairing Code -
Negative Scenario [DUT - Commissioner]]
**** link:#_tc_dd_3_17_commissioning_flow_21_digit_manual_pairing_code_negative_scenario_dut_commissioner[8.3.17.
[TC-DD-3.17] Commissioning Flow - 21-digit Manual Pairing Code -
Negative Scenario [DUT - Commissioner]]
**** link:#_tc_dd_3_18_commissioning_flow_commissioning_multiple_devices_dut_commissioner[8.3.18.
[TC-DD-3.18] Commissioning Flow - Commissioning Multiple Devices [DUT -
Commissioner]]
**** link:#_tc_dd_3_19_commissioning_flow_commission_unpair_and_re_commission_device_dut_commissionee[8.3.19.
[TC-DD-3.19] Commissioning Flow - Commission, Unpair and Re-commission
Device [DUT - Commissionee]]
**** link:#_tc_dd_3_20_commissioning_flow_commission_unpair_and_re_commission_device_dut_commissioner[8.3.20.
[TC-DD-3.20] Commissioning Flow - Commission, Unpair and Re-commission
Device [DUT - Commissioner]]
**** link:#_tc_dd_3_21_commissioning_flow_commission_multiple_endpoint_device_dut_commissioner[8.3.21.
[TC-DD-3.21] Commissioning Flow - Commission Multiple-Endpoint Device
[DUT - Commissioner]]
* link:#_basic_information_test_plan[*Basic Information Test Plan*]
** link:#_pics_definition_3[9. PICS Definition]
*** link:#_role_2[9.1. Role]
*** link:#_server[9.2. Server]
**** link:#_attributes[9.2.1. Attributes]
**** link:#_events[9.2.2. Events]
** link:#_pixit_definition[10. PIXIT Definition]
** link:#_test_case_list_2[11. Test Case List]
** link:#_test_cases_2[12. Test Cases]
*** link:#_generic_test_cases[12.1. Generic Test Cases]
**** link:#_tc_binfo_1_1_global_attributes_with_dut_as_server[12.1.1.
[TC-BINFO-1.1] Global Attributes with DUT as Server]
*** link:#_dut_as_server[12.2. DUT as Server]
**** link:#_tc_binfo_2_1_attributes_dut_server[12.2.1. [TC-BINFO-2.1]
Attributes [DUT-Server]]
**** link:#_tc_binfo_2_2_events_dut_server[12.2.2. [TC-BINFO-2.2] Events
[DUT-Server]]
**** link:#_tc_binfo_3_1_appearance_attribute_dut_as_server[12.2.3.
[TC-BINFO-3.1] Appearance Attribute DUT as Server]
* link:#_node_operational_credentials_test_plan[*Node Operational
Credentials Test Plan*]
** link:#_pics_definition_4[13. PICS Definition]
*** link:#_role_3[13.1. Role]
*** link:#_server_2[13.2. Server]
**** link:#_attributes_2[13.2.1. Attributes]
**** link:#_commands_received[13.2.2. Commands received]
**** link:#_commands_generated[13.2.3. Commands generated]
*** link:#_client[13.3. Client]
**** link:#_attributes_3[13.3.1. Attributes]
**** link:#_commands_received_2[13.3.2. Commands received]
**** link:#_commands_generated_2[13.3.3. Commands generated]
** link:#_test_case_list_3[14. Test Case List]
** link:#_test_cases_3[15. Test Cases]
*** link:#_generic_test_cases_2[15.1. Generic Test Cases]
**** link:#_tc_opcreds_1_2_global_attributes_with_dut_as_server[15.1.1.
[TC-OPCREDS-1.2] Global Attributes with DUT as Server]
*** link:#_dut_as_server_2[15.2. DUT as Server]
**** link:#_tc_opcreds_3_1_attribute_nocs_trustedrootcertificates_list_validation_dut_server[15.2.1.
[TC-OPCREDS-3.1] Attribute-NOCs, TrustedRootCertificates list validation
[DUT-Server]]
**** link:#_tc_opcreds_3_2_attribute_currentfabricindex_validation_dut_server[15.2.2.
[TC-OPCREDS-3.2] Attribute-CurrentFabricIndex validation [DUT-Server]]
**** link:#_tc_opcreds_3_4_updatenoc_error_condition_dut_server[15.2.3.
[TC-OPCREDS-3.4] UpdateNOC-Error Condition [DUT-Server]]
**** link:#_tc_opcreds_3_5_noc_check_for_updatenoc_dut_server[15.2.4.
[TC-OPCREDS-3.5] NOC Check for UpdateNOC [DUT-Server]]
**** link:#_tc_opcreds_3_6_last_fabric_removal_validation_dut_server[15.2.5.
[TC-OPCREDS-3.6] Last Fabric removal validation [DUT-Server]]
**** link:#_tc_opcreds_3_7_add_second_fabric_over_case_dut_server[15.2.6.
[TC-OPCREDS-3.7] Add Second Fabric over CASE [DUT-Server]]
*** link:#_dut_as_client[15.3. DUT as Client]
**** link:#_tc_opcreds_3_3_attribute_nocs_commands_dut_client[15.3.1.
[TC-OPCREDS-3.3] Attribute-NOCs, Commands [DUT-Client]]
* link:#_network_commissioning_test_plan[*Network Commissioning Test
Plan*]
** link:#_pics_definition_5[16. PICS Definition]
*** link:#_role_4[16.1. Role]
*** link:#_server_3[16.2. Server]
**** link:#_features[16.2.1. Features]
**** link:#_attributes_4[16.2.2. Attributes]
**** link:#_commands_received_3[16.2.3. Commands received]
**** link:#_commands_generated_3[16.2.4. Commands generated]
*** link:#_client_2[16.3. Client]
**** link:#_features_2[16.3.1. Features]
**** link:#_commands_generated_4[16.3.2. Commands generated]
** link:#_pixit_definition_2[17. PIXIT Definition]
** link:#_test_case_list_4[18. Test Case List]
** link:#_test_cases_4[19. Test Cases]
*** link:#_generic_test_cases_3[19.1. Generic Test Cases]
**** link:#_tc_cnet_1_3_global_attributes_with_dut_as_server[19.1.1.
[TC-CNET-1.3] Global Attributes with DUT as Server]
*** link:#_dut_as_server_3[19.2. DUT as Server]
**** link:#_tc_cnet_4_1_wi_fi_verification_for_attributes_check_dut_server[19.2.1.
[TC-CNET-4.1] [Wi-Fi] Verification for attributes check [DUT-Server]]
**** link:#_tc_cnet_4_2_thread_verification_for_attributes_check_dut_server[19.2.2.
[TC-CNET-4.2] [Thread] Verification for attributes check [DUT-Server]]
**** link:#_tc_cnet_4_3_ethernet_verification_for_attributes_check_dut_server[19.2.3.
[TC-CNET-4.3] [Ethernet] Verification for attributes check [DUT-Server]]
**** link:#_tc_cnet_4_4_wi_fi_verification_for_scannetworks_command_dut_server[19.2.4.
[TC-CNET-4.4] [Wi-Fi] Verification for ScanNetworks command
[DUT-Server]]
**** link:#_tc_cnet_4_5_wi_fi_failsafe_required_message_validation_dut_server[19.2.5.
[TC-CNET-4.5] [Wi-Fi] FAILSAFE_REQUIRED message Validation [DUT-Server]]
**** link:#_tc_cnet_4_6_thread_failsafe_required_message_validation_dut_server[19.2.6.
[TC-CNET-4.6] [Thread] FAILSAFE_REQUIRED message Validation
[DUT-Server]]
**** link:#_tc_cnet_4_9_wi_fi_verification_for_removenetwork_command_dut_server[19.2.7.
[TC-CNET-4.9] [Wi-Fi] Verification for RemoveNetwork Command
[DUT-Server]]
**** link:#_tc_cnet_4_10_thread_verification_for_removenetwork_command_dut_server[19.2.8.
[TC-CNET-4.10] [Thread] Verification for RemoveNetwork Command
[DUT-Server]]
**** link:#_tc_cnet_4_11_wi_fi_verification_for_connectnetwork_command_dut_server[19.2.9.
[TC-CNET-4.11] [Wi-Fi] Verification for ConnectNetwork Command
[DUT-Server]]
**** link:#_tc_cnet_4_12_thread_verification_for_connectnetwork_command_dut_server[19.2.10.
[TC-CNET-4.12] [Thread] Verification for ConnectNetwork Command
[DUT-Server]]
**** link:#_tc_cnet_4_13_wi_fi_verification_for_reordernetwork_command_dut_server[19.2.11.
[TC-CNET-4.13] [Wi-Fi] Verification for ReorderNetwork command
[DUT-Server]]
**** link:#_tc_cnet_4_14_thread_verification_for_reordernetwork_command_dut_server[19.2.12.
[TC-CNET-4.14] [Thread] Verification for ReorderNetwork command
[DUT-Server]]
**** link:#_tc_cnet_4_15_wi_fi_networkidnotfound_returned_in_lastnetworkingstatus_field_validation_dut_server[19.2.13.
[TC-CNET-4.15] [Wi-Fi] NetworkIDNotFound returned in
LastNetworkingStatus field validation [DUT-Server]]
**** link:#_tc_cnet_4_16_thread_networkidnotfound_returned_in_lastnetworkingstatus_field_validation_dut_server[19.2.14.
[TC-CNET-4.16] [Thread] NetworkIDNotFound returned in
LastNetworkingStatus field validation [DUT-Server]]
**** link:#_tc_cnet_4_22_thread_verification_for_scannetworks_command_dut_server[19.2.15.
[TC-CNET-4.22] [Thread] Verification for ScanNetworks command
[DUT-Server]]
*** link:#_dut_as_client_2[19.3. DUT as Client]
**** link:#_tc_cnet_4_20_wi_fi_verification_for_commands_check_dut_client[19.3.1.
[TC-CNET-4.20] [Wi-Fi] Verification for commands check [DUT-Client]]
**** link:#_tc_cnet_4_21_thread_verification_for_commands_check_dut_client[19.3.2.
[TC-CNET-4.21] [Thread] Verification for commands check [DUT-Client]]
* link:#_secure_channel_test_plan[*Secure Channel Test Plan*]
** link:#_pics_definition_6[20. PICS Definition]
*** link:#_server_4[20.1. Server]
**** link:#_commands_received_4[20.1.1. Commands received]
** link:#_test_case_list_5[21. Test Case List]
** link:#_test_cases_5[22. Test Cases]
*** link:#_matter_reliable_message_protocol_mrp_test_cases[22.1. Matter
Reliable Message Protocol (MRP) Test Cases]
**** link:#_tc_sc_1_1_mrp_max_message_size_removed[22.1.1. [TC-SC-1.1]
MRP Max Message Size - REMOVED]
**** link:#_tc_sc_1_2_mrp_message_flows_removed[22.1.2. [TC-SC-1.2] MRP
Message Flows - REMOVED]
**** link:#_tc_sc_1_3_mrp_retransmissions_removed[22.1.3. [TC-SC-1.3]
MRP Retransmissions - REMOVED]
**** link:#_tc_sc_1_4_mrp_message_counter_and_duplicate_messaging_removed[22.1.4.
[TC-SC-1.4] MRP message counter and duplicate messaging - REMOVED]
*** link:#_session_establishment[22.2. Session Establishment]
**** link:#_tc_sc_2_1_session_establishment_passcode_authenticated_session_establishment_pase_removed[22.2.1.
[TC-SC-2.1] Session Establishment - Passcode Authenticated Session
Establishment (PASE) - REMOVED]
**** link:#_tc_sc_2_2_bidirectional_communication_passcode_authenticated_session_establishment_pase_removed[22.2.2.
[TC-SC-2.2] Bidirectional Communication - Passcode Authenticated Session
Establishment (PASE) - REMOVED]
**** link:#_tc_sc_2_3_pase_error_handling_dut_respondercommissionee_removed[22.2.3.
[TC-SC-2.3] PASE Error Handling [DUT_Responder/Commissionee] - REMOVED]
**** link:#_tc_sc_2_4_pase_error_handling_dut_initiatorcommissioner_removed[22.2.4.
[TC-SC-2.4] PASE Error Handling [DUT_Initiator/Commissioner] - REMOVED]
*** link:#_certificate_authenticated_session_establishment_case_test_cases[22.3.
Certificate Authenticated Session Establishment (CASE) Test Cases]
**** link:#_tc_sc_3_1_session_establishment_removed[22.3.1. [TC-SC-3.1]
Session Establishment - REMOVED]
**** link:#_tc_sc_3_2_case_session_resumption_dut_responder[22.3.2.
[TC-SC-3.2] CASE Session Resumption [DUT_Responder]]
**** link:#_tc_sc_3_3_case_session_resumption_dut_initiator_removed[22.3.3.
[TC-SC-3.3] CASE Session Resumption [DUT_Initiator] - REMOVED]
**** link:#_tc_sc_3_4_case_error_handling_dut_responder_removed[22.3.4.
[TC-SC-3.4] CASE Error Handling [DUT_Responder] - REMOVED]
**** link:#_tc_sc_3_5_case_error_handling_dut_initiator_removed[22.3.5.
[TC-SC-3.5] CASE Error Handling [DUT_Initiator] - REMOVED]
**** link:#_tc_sc_3_6_case_resource_validation[22.3.6. [TC-SC-3.6] CASE
Resource validation]
*** link:#_discovery[22.4. Discovery]
**** link:#_tc_sc_4_1_commissionable_node_discovery_dut_as_commissionee[22.4.1.
[TC-SC-4.1] Commissionable Node Discovery [DUT as Commissionee]]
**** link:#_tc_sc_4_2_discovery_dut_as_commissioner[22.4.2. [TC-SC-4.2]
Discovery [DUT as Commissioner]]
**** link:#_tc_sc_4_3_discovery_dut_as_commissionee[22.4.3. [TC-SC-4.3]
Discovery [DUT as Commissionee]]
**** link:#_tc_sc_4_4_discovery_dut_as_controller[22.4.4. [TC-SC-4.4]
Discovery [DUT as Controller]]
**** link:#_tc_sc_4_5_discovery_dut_as_commissioneethread_removed[22.4.5.
[TC-SC-4.5] Discovery [DUT as Commissionee][Thread] - REMOVED]
**** link:#_tc_sc_4_6commissioner_discovery_dut_as_commissioner[22.4.6.
[TC-SC-4.6]Commissioner Discovery [DUT as Commissioner]]
**** link:#_tc_sc_4_7_commissioner_discovery_dut_as_commissionee[22.4.7.
[TC-SC-4.7] Commissioner Discovery [DUT as Commissionee]]
**** link:#_tc_sc_4_8_compressed_fabric_id_remains_the_same_for_nodes_commissioned_to_the_same_fabric_dut_as_commissioner[22.4.8.
[TC-SC-4.8] Compressed Fabric ID remains the same for Nodes commissioned
to the same fabric [DUT as Commissioner]]
**** link:#_tc_sc_4_9_operational_discovery_rio_support_dut_as_commissionee[22.4.9.
[TC-SC-4.9] Operational Discovery - RIO support [DUT as Commissionee]]
**** link:#_tc_sc_4_10_operational_discovery_sit_icd_node_dut_as_commissionee[22.4.10.
[TC-SC-4.10] Operational Discovery - SIT ICD Node [DUT as Commissionee]]
* link:#_group_communication[*Group Communication*]
** link:#_pics_definition_7[23. PICS Definition]
*** link:#_role_5[23.1. Role]
*** link:#_server_5[23.2. Server]
**** link:#_features_3[23.2.1. Features]
**** link:#_attributes_5[23.2.2. Attributes]
**** link:#_commands_received_5[23.2.3. Commands received]
*** link:#_client_3[23.3. Client]
**** link:#_attributes_6[23.3.1. Attributes]
**** link:#_commands_generated_5[23.3.2. Commands generated]
** link:#_pixit_definition_3[24. PIXIT Definition]
** link:#_test_case_list_6[25. Test Case List]
** link:#_test_cases_6[26. Test Cases]
*** link:#_generic_test_cases_4[26.1. Generic test cases]
**** link:#_tc_grpkey_1_1_global_attributes_with_dut_as_server[26.1.1.
[TC-GRPKEY-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut[26.2. Server as DUT]
*** link:#_dut_as_server_4[26.3. DUT as Server]
**** link:#_tc_grpkey_2_1_attributes_dut_server[26.3.1. [TC-GRPKEY-2.1]
Attributes [DUT-Server]]
**** link:#_tc_grpkey_2_2_primary_functionality_with_dut_as_server[26.3.2.
[TC-GRPKEY-2.2] Primary functionality with DUT as Server]
**** link:#_tc_sc_5_1_adding_member_to_a_group_th_as_admin_and_dut_as_group_member[26.3.3.
[TC-SC-5.1] Adding member to a group - TH as Admin and DUT as Group
Member]
**** link:#_tc_sc_5_2_receiving_a_group_message_th_to_dut[26.3.4.
[TC-SC-5.2] Receiving a group message - TH to DUT]
**** link:#_tc_sc_5_3_sending_a_group_message_dut_to_th[26.3.5.
[TC-SC-5.3] Sending a group message - DUT to TH]
**** link:#_tc_grpkey_5_4_verification_for_keysetreadresponse_command_for_cacheandsync[26.3.6.
[TC-GRPKEY-5.4] Verification for KeySetReadResponse Command for
CacheAndSync]
*** link:#_client_as_dut[26.4. Client as DUT]
**** link:#_tc_sc_6_1_adding_member_to_a_group_dut_as_admin_and_th_as_group_member_dut_client[26.4.1.
[TC-SC-6.1] Adding member to a group - DUT as Admin and TH as Group
Member [DUT-Client]]
* link:#_device_attestation_test_plan[*Device Attestation Test Plan*]
** link:#_pics_definition_8[27. PICS Definition]
** link:#_test_case_list_7[28. Test Case List]
** link:#_test_cases_7[29. Test Cases]
*** link:#_server_as_dut_2[29.1. Server as DUT]
**** link:#_tc_da_1_1_the_noc_shall_be_wiped_on_factory_reset_dut_commissionee[29.1.1.
[TC-DA-1.1] The NOC SHALL be wiped on Factory Reset [DUT -
Commissionee]]
**** link:#_tc_da_1_2_device_attestation_request_validation_dut_commissionee[29.1.2.
[TC-DA-1.2] Device Attestation Request Validation [DUT - Commissionee]]
**** link:#_tc_da_1_3_device_attestation_request_validation_dut_commissioner[29.1.3.
[TC-DA-1.3] Device Attestation Request Validation [DUT - Commissioner]]
**** link:#_tc_da_1_4_device_attestation_request_validation_error_scenario_dut_commissioner[29.1.4.
[TC-DA-1.4] Device Attestation Request Validation-Error Scenario
[DUT-Commissioner]]
**** link:#_tc_da_1_5_nocsr_procedure_validation_dut_commissionee[29.1.5.
[TC-DA-1.5] NOCSR Procedure Validation [DUT - Commissionee]]
**** link:#_tc_da_1_6_nocsr_procedure_validation_dut_commissioner[29.1.6.
[TC-DA-1.6] NOCSR Procedure Validation [DUT - Commissioner]]
**** link:#_tc_da_1_7_validate_certificatechainrequest_dut_commissionee[29.1.7.
[TC-DA-1.7] Validate CertificateChainRequest [DUT-Commissionee]]
**** link:#_tc_da_1_8_device_attestation_request_validation_success_scenario_dut_commissioner[29.1.8.
[TC-DA-1.8] Device Attestation Request Validation-Success Scenario
[DUT-Commissioner]]
* link:#_interaction_data_model_test_plan[*Interaction Data Model Test
Plan*]
** link:#_pics_definition_9[30. PICS Definition]
** link:#_test_case_list_8[31. Test Case List]
** link:#_test_cases_8[32. Test Cases]
*** link:#_invoke_transaction_test_cases[32.1. Invoke Transaction Test
Cases]
**** link:#_tc_idm_1_1_invoke_request_action_from_dut_to_th_dut_as_client[32.1.1.
[TC-IDM-1.1] Invoke Request Action from DUT to TH - [DUT as Client]]
**** link:#_tc_idm_1_2_invoke_response_action_from_dut_to_th_dut_as_server[32.1.2.
[TC-IDM-1.2] Invoke Response Action from DUT to TH - [DUT as Server]]
*** link:#_read_transaction_test_cases[32.2. Read Transaction Test
Cases]
**** link:#_tc_idm_2_1_read_request_action_from_dut_to_th_dut_as_client[32.2.1.
[TC-IDM-2.1] Read Request Action from DUT to TH. [DUT as Client]]
**** link:#_tc_idm_2_2_report_data_action_from_dut_to_th_dut_as_server[32.2.2.
[TC-IDM-2.2] Report Data Action from DUT to TH. [DUT as Server]]
*** link:#_write_transaction_test_cases[32.3. Write Transaction Test
Cases]
**** link:#_tc_idm_3_1_write_request_action_from_dut_to_th_dut_as_client[32.3.1.
[TC-IDM-3.1] Write Request Action from DUT to TH. [DUT as Client]]
**** link:#_tc_idm_3_2_write_response_action_from_dut_to_th_dut_as_server[32.3.2.
[TC-IDM-3.2] Write Response Action from DUT to TH. [DUT as Server]]
*** link:#_subscription_transaction_test_cases[32.4. Subscription
Transaction Test Cases]
**** link:#_tc_idm_4_1_subscriptionrequestmessage_from_dut_test_cases_dut_as_client[32.4.1.
[TC-IDM-4.1] SubscriptionRequestMessage from DUT test cases. [DUT as
Client]]
**** link:#_tc_idm_4_2_subscription_response_messages_from_dut_test_cases_dut_as_server[32.4.2.
[TC-IDM-4.2] Subscription Response Messages from DUT Test Cases. [DUT as
Server]]
**** link:#_tc_idm_4_3_report_data_messages_post_subscription_activation_from_dut_test_cases_dut_as_server[32.4.3.
[TC-IDM-4.3] Report Data Messages post Subscription Activation from DUT
Test Cases. [DUT as Server]]
**** link:#_tc_idm_4_4_persistent_subscription_test_cases_dut_as_server[32.4.4.
[TC-IDM-4.4] Persistent Subscription Test Cases. [DUT as Server]]
*** link:#_timed_request_action_test_cases[32.5. Timed Request Action
Test Cases]
**** link:#_tc_idm_5_1_timed_request_action_from_dut_to_th_dut_as_client[32.5.1.
[TC-IDM-5.1] Timed Request Action from DUT to TH. [DUT as Client]]
**** link:#_tc_idm_5_2_status_response_from_dut_in_response_to_a_timed_request_action_from_th[32.5.2.
[TC-IDM-5.2] Status Response from DUT in response to a Timed Request
Action from TH.]
*** link:#_events_test_cases[32.6. Events Test Cases]
**** link:#_tc_idm_6_1_events_read_interaction_from_th_to_dut_dut_as_server[32.6.1.
[TC-IDM-6.1] Events Read Interaction from TH to DUT. [DUT as Server]]
**** link:#_tc_idm_6_2_events_subscribe_interaction_from_th_to_dut_dut_as_server[32.6.2.
[TC-IDM-6.2] Events Subscribe Interaction from TH to DUT. [DUT as
Server]]
**** link:#_tc_idm_6_3_events_read_interaction_from_dut_to_th_dut_as_client[32.6.3.
[TC-IDM-6.3] Events Read Interaction from DUT to TH. [DUT as Client]]
**** link:#_tc_idm_6_4_events_subscribe_interaction_from_dut_to_th_dut_as_client[32.6.4.
[TC-IDM-6.4] Events Subscribe Interaction from DUT to TH. [DUT as
Client]]
**** link:#_tc_idm_7_1_multi_fabric_subscription_test_cases_dut_as_server[32.6.5.
[TC-IDM-7.1] Multi Fabric Subscription Test Cases. [DUT as Server]]
**** link:#_tc_idm_8_1_fabric_scoped_test_cases_dut_as_server[32.6.6.
[TC-IDM-8.1] Fabric scoped Test Cases. [DUT as Server]]
**** link:#_tc_idm_9_1_constraint_error_status_response_test_cases_dut_as_server_removed[32.6.7.
[TC-IDM-9.1] CONSTRAINT_ERROR status response test cases [DUT as Server]
- REMOVED]
**** link:#_tc_idm_10_1_cluster_requirements_global_attributes_dut_as_server[32.6.8.
[TC-IDM-10.1] Cluster requirements - Global attributes [DUT as Server]]
**** link:#_tc_idm_11_1_data_types_attribute_strings_dut_as_server_data_model[32.6.9.
[TC-IDM-11.1] Data types - attribute strings [DUT as Server] - data
model]
* link:#_administrator_commissioning_cluster_test_plan[*Administrator
Commissioning Cluster Test Plan*]
** link:#_pics_definition_10[33. PICS Definition]
*** link:#_role_6[33.1. Role]
*** link:#_server_6[33.2. Server]
**** link:#_features_4[33.2.1. Features]
**** link:#_commands_received_6[33.2.2. Commands received]
**** link:#_attributes_7[33.2.3. Attributes]
*** link:#_client_4[33.3. Client]
**** link:#_manual_controllable[33.3.1. Manual controllable]
**** link:#_commands_generated_6[33.3.2. Commands generated]
**** link:#_attributes_8[33.3.3. Attributes]
** link:#_pixit_definition_4[34. PIXIT Definition]
** link:#_test_case_list_9[35. Test Case List]
** link:#_test_cases_9[36. Test Cases]
*** link:#_multiple_fabrics_test_cases[36.1. Multiple Fabrics Test
Cases]
**** link:#_tc_cadmin_1_1_administrator_behavior_using_ecm_dut_commissioner[36.1.1.
[TC-CADMIN-1.1] Administrator Behavior using ECM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_2_administrator_behavior_using_bcm_dut_commissioner[36.1.2.
[TC-CADMIN-1.2] Administrator Behavior using BCM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_3_node_behavior_using_ecm_dut_commissionee[36.1.3.
[TC-CADMIN-1.3] Node Behavior using ECM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_4_node_behavior_using_bcm_dut_commissionee[36.1.4.
[TC-CADMIN-1.4] Node Behavior using BCM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_5_commissioning_window_handling_timeout_and_revocation_using_ecm_dut_commissionee[36.1.5.
[TC-CADMIN-1.5] Commissioning window handling timeout and revocation
using ECM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_6_commissioning_window_handling_timeout_and_revocation_using_bcm_dut_commissionee[36.1.6.
[TC-CADMIN-1.6] Commissioning window handling timeout and revocation
using BCM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_7_commissioning_window_handling_timeout_and_revocation_using_ecm_dut_commissioner[36.1.7.
[TC-CADMIN-1.7] Commissioning window handling timeout and revocation
using ECM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_8_commissioning_window_handling_timeout_and_revocation_using_bcm_dut_commissioner[36.1.8.
[TC-CADMIN-1.8] Commissioning window handling timeout and revocation
using BCM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_9_device_exit_commissioning_mode_after_20_failed_commission_attempts_ecm_dut_commissionee[36.1.9.
[TC-CADMIN-1.9] Device exit commissioning mode after 20 failed
commission attempts [ECM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_10_device_exit_commissioning_mode_after_20_failed_commission_attempts_bcm_dut_commissionee[36.1.10.
[TC-CADMIN-1.10] Device exit commissioning mode after 20 failed
commission attempts [BCM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_11_open_commissioning_window_on_dut_twice_using_ecm_then_bcm_dut_commissionee[36.1.11.
[TC-CADMIN-1.11] Open commissioning window on DUT twice using ECM then
BCM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_12_open_commissioning_window_on_dut_twice_using_ecm_then_bcm_dut_commissioner[36.1.12.
[TC-CADMIN-1.12] Open commissioning window on DUT twice using ECM then
BCM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_13_open_commissioning_window_twice_on_dut_using_bcm_then_ecm_dut_commissionee[36.1.13.
[TC-CADMIN-1.13] Open commissioning window twice on DUT using BCM then
ECM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_14_open_commissioning_window_twice_on_dut_using_bcm_then_ecm_dut_commissioner[36.1.14.
[TC-CADMIN-1.14] Open commissioning window twice on DUT using BCM then
ECM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_15_removing_fabrics_from_dut_and_fabric_index_enumeration_using_ecm_dut_commissionee[36.1.15.
[TC-CADMIN-1.15] Removing Fabrics from DUT and Fabric index enumeration
using ECM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_16_removing_fabrics_from_dut_and_fabric_index_enumeration_using_bcm_dut_commissionee[36.1.16.
[TC-CADMIN-1.16] Removing Fabrics from DUT and Fabric index enumeration
using BCM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_17_removing_fabrics_from_dut_and_fabric_index_enumeration_using_ecm_dut_commissioner[36.1.17.
[TC-CADMIN-1.17] Removing Fabrics from DUT and Fabric index enumeration
using ECM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_18_removing_fabrics_from_dut_and_fabric_index_enumeration_using_bcm_dut_commissioner[36.1.18.
[TC-CADMIN-1.18] Removing Fabrics from DUT and Fabric index enumeration
using BCM [DUT - Commissioner]]
**** link:#_tc_cadmin_1_19_max_number_of_commissioned_fabrics_and_supportedfabrics_rollover_using_ecm_dut_commissionee[36.1.19.
[TC-CADMIN-1.19] max number of Commissioned Fabrics and SupportedFabrics
rollover using ECM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_20_max_number_of_commissioned_fabrics_and_supportedfabrics_rollover_using_bcm_dut_commissionee[36.1.20.
[TC-CADMIN-1.20] max number of Commissioned Fabrics and SupportedFabrics
rollover using BCM [DUT - Commissionee]]
**** link:#_tc_cadmin_1_21_open_commissioning_window_durations_max_and_max1_bcm_dut_commissionee[36.1.21.
[TC-CADMIN-1.21] Open commissioning window - durations max and max+1
[BCM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_22_open_commissioning_window_durations_max_and_max1_ecm_dut_commissionee[36.1.22.
[TC-CADMIN-1.22] Open commissioning window - durations max and max+1
[ECM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_23_open_commissioning_window_durations_min_and_min_1_bcm_dut_commissionee[36.1.23.
[TC-CADMIN-1.23] Open commissioning window - durations min and min-1
[BCM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_24_open_commissioning_window_durations_min_and_min_1_ecm_dut_commissionee[36.1.24.
[TC-CADMIN-1.24] Open commissioning window - durations min and min-1
[ECM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_25_subscription_to_the_attributes_verify_subscription_response_ecm_dut_commissionee[36.1.25.
[TC-CADMIN-1.25] Subscription to the attributes - verify subscription
response [ECM] [DUT - Commissionee]]
**** link:#_tc_cadmin_1_26_subscription_to_the_attributes_verify_subscription_response_bcm_dut_commissionee[36.1.26.
[TC-CADMIN-1.26] Subscription to the attributes - verify subscription
response [BCM] [DUT - Commissionee]]
* link:#_bridge_test_plan[*Bridge Test Plan*]
** link:#_pics_definition_11[37. PICS Definition]
*** link:#_dut_server[37.1. DUT server]
*** link:#_dut_client[37.2. DUT client]
** link:#_test_case_list_10[38. Test Case List]
** link:#_test_cases_10[39. Test Cases]
*** link:#_bridge_test_cases[39.1. Bridge Test Cases]
**** link:#ref_TC-BR-1[39.1.1. [TC-BR-1] Basics of bridging (DUT
server)]
**** link:#ref_TC-BR-2[39.1.2. [TC-BR-2] Changing the set of bridged
devices (DUT server)]
**** link:#ref_TC-BR-3[39.1.3. [TC-BR-3] Changing name and state of a
bridged device (DUT server)]
**** link:#ref_TC-BR-4[39.1.4. [TC-BR-4] DUT client handling of bridges
(DUT client)]
* link:#_bulk_data_exchange_protocol_test_plan[*Bulk Data Exchange
Protocol Test Plan*]
** link:#_pics_definition_12[40. PICS Definition]
** link:#_test_case_list_11[41. Test Case List]
** link:#_test_cases_11[42. Test Cases]
*** link:#_transfer_management_test_cases[42.1. Transfer Management Test
Cases]
**** link:#_tc_bdx_1_1_sender_initiated_bdx_transfer_session_removed[42.1.1.
[TC-BDX-1.1] Sender Initiated BDX Transfer Session - REMOVED]
**** link:#_tc_bdx_1_2_receiver_initiated_bdx_transfer_session[42.1.2.
[TC-BDX-1.2] Receiver Initiated BDX Transfer Session]
**** link:#_tc_bdx_1_3_response_to_sender_initiated_bdx_transfer_session_removed[42.1.3.
[TC-BDX-1.3] Response to Sender Initiated BDX Transfer Session -
REMOVED]
**** link:#_tc_bdx_1_4_response_to_receiver_initiated_bdx_transfer_session[42.1.4.
[TC-BDX-1.4] Response to Receiver Initiated BDX Transfer Session]
**** link:#_tc_bdx_1_5_response_to_sender_initiated_bdx_transfer_session_negative_scenario_removed[42.1.5.
[TC-BDX-1.5] Response to Sender Initiated BDX Transfer Session -
Negative Scenario - REMOVED]
**** link:#_tc_bdx_1_6_response_to_receiver_initiated_bdx_transfer_session_negative_scenario_removed[42.1.6.
[TC-BDX-1.6] Response to Receiver Initiated BDX Transfer Session -
Negative Scenario - REMOVED]
*** link:#_data_transfer_test_cases[42.2. Data Transfer Test Cases]
**** link:#_tc_bdx_2_1_synchronous_file_sending[42.2.1. [TC-BDX-2.1]
Synchronous File Sending]
**** link:#_tc_bdx_2_2_synchronous_file_receiving[42.2.2. [TC-BDX-2.2]
Synchronous File Receiving]
**** link:#_tc_bdx_2_3_restart_synchronous_file_receiving_removed[42.2.3.
[TC-BDX-2.3] Restart Synchronous File Receiving - REMOVED]
**** link:#_tc_bdx_2_4_asynchronous_file_sending_removed[42.2.4.
[TC-BDX-2.4] Asynchronous File Sending - REMOVED]
**** link:#_tc_bdx_2_5_asynchronous_file_receiving_removed[42.2.5.
[TC-BDX-2.5] Asynchronous File Receiving - REMOVED]
* link:#_ota_software_update_test_plan[*OTA Software Update Test Plan*]
** link:#_pics_definition_13[43. PICS Definition]
** link:#_test_case_list_12[44. Test Case List]
** link:#_test_cases_12[45. Test Cases]
*** link:#_ota_provider_discovery[45.1. OTA Provider Discovery]
**** link:#_tc_su_1_1_invoke_announceotaprovider_from_admindut_to_ota_r[45.1.1.
[TC-SU-1.1] Invoke AnnounceOTAProvider from Admin(DUT) to OTA-R]
*** link:#_querying_the_ota_provider[45.2. Querying the OTA Provider]
**** link:#_tc_su_2_1_queryimage_command_from_dut_to_ota_p[45.2.1.
[TC-SU-2.1] QueryImage Command from DUT to OTA-P]
**** link:#_tc_su_2_2_handling_different_queryimageresponse_scenarios_on_requestor[45.2.2.
[TC-SU-2.2] Handling Different QueryImageResponse Scenarios on
Requestor]
*** link:#_transfer_of_software_update_images[45.3. Transfer of Software
Update Images]
**** link:#_tc_su_2_3_transfer_of_software_update_images_between_dut_and_thota_p[45.3.1.
[TC-SU-2.3] Transfer of Software Update Images between DUT and TH/OTA-P]
*** link:#_applying_a_software_update[45.4. Applying a Software Update]
**** link:#_tc_su_2_4_applyupdaterequest_command_from_dut_to_ota_p[45.4.1.
[TC-SU-2.4] ApplyUpdateRequest Command from DUT to OTA-P]
**** link:#_tc_su_2_5_handling_different_applyupdateresponse_scenarios_on_requestor[45.4.2.
[TC-SU-2.5] Handling Different ApplyUpdateResponse Scenarios on
Requestor]
**** link:#_tc_su_2_6_notifyupdateapplied_command_from_dut_to_ota_p[45.4.3.
[TC-SU-2.6] NotifyUpdateApplied Command from DUT to OTA-P]
*** link:#_requestor_cluster_events[45.5. Requestor Cluster Events]
**** link:#_tc_su_2_7_verifying_events_on_ota_rdut[45.5.1. [TC-SU-2.7]
Verifying Events on OTA-R(DUT)]
*** link:#_multiple_fabrics[45.6. Multiple Fabrics]
**** link:#_tc_su_2_8_ota_functionality_in_multi_fabric_scenario[45.6.1.
[TC-SU-2.8] OTA Functionality in Multi Fabric Scenario]
*** link:#_querying_the_ota_provider_2[45.7. Querying the OTA Provider]
**** link:#_tc_su_3_1_queryimageresponse_from_dut_to_ota_r[45.7.1.
[TC-SU-3.1] QueryImageResponse from DUT to OTA-R]
**** link:#_tc_su_3_2_handling_different_queryimageresponse_scenarios_on_provider[45.7.2.
[TC-SU-3.2] Handling Different QueryImageResponse Scenarios on Provider]
*** link:#_transfer_of_software_update_images_2[45.8. Transfer of
Software Update Images]
**** link:#_tc_su_3_3_transfer_of_software_update_images_between_dut_and_ota_r[45.8.1.
[TC-SU-3.3] Transfer of Software Update Images between DUT and OTA-R]
*** link:#_applying_a_software_update_2[45.9. Applying a Software
Update]
**** link:#_tc_su_3_4_handling_different_applyupdateresponse_scenarios_on_provider[45.9.1.
[TC-SU-3.4] Handling Different ApplyUpdateResponse Scenarios on
Provider]
*** link:#_requestor_cluster_attributes[45.10. Requestor Cluster
Attributes]
**** link:#_tc_su_4_1_verifying_cluster_attributes_on_ota_rdut[45.10.1.
[TC-SU-4.1] Verifying Cluster Attributes on OTA-R(DUT)]
**** link:#_tc_su_4_2_verifying_cluster_attributes_from_admindut[45.10.2.
[TC-SU-4.2] Verifying Cluster Attributes from Admin(DUT)]
* link:#_access_control_enforcement_test_plan[*Access Control
Enforcement Test Plan*]
** link:#_pics_definition_14[46. PICS Definition]
*** link:#_role_7[46.1. Role]
*** link:#_server_7[46.2. Server]
**** link:#_attributes_9[46.2.1. Attributes]
** link:#_pixit_definition_5[47. PIXIT Definition]
** link:#_test_case_list_13[48. Test Case List]
** link:#_test_cases_13[49. Test Cases]
*** link:#_cluster_attribute_test_cases[49.1. Cluster Attribute test
cases]
**** link:#_tc_ace_1_1_privileges[49.1.1. [TC-ACE-1.1] Privileges]
**** link:#_tc_ace_1_2_subscriptions[49.1.2. [TC-ACE-1.2] Subscriptions]
**** link:#_tc_ace_1_3_subjects[49.1.3. [TC-ACE-1.3] Subjects]
**** link:#_tc_ace_1_4_targets[49.1.4. [TC-ACE-1.4] Targets]
**** link:#_tc_ace_1_5_multi_fabric[49.1.5. [TC-ACE-1.5] Multi-fabric]
**** link:#_tc_ace_1_6_group_auth_mode[49.1.6. [TC-ACE-1.6] Group auth
mode]
* link:#_minimal_resource_requirements_test_plan[*Minimal Resource
Requirements Test Plan*]
** link:#_test_case_list_14[50. Test Case List]
** link:#_test_cases_14[51. Test Cases]
*** link:#_minimal_resource_requirements_test_cases[51.1. Minimal
Resource Requirements Test Cases]
**** link:#_tc_rr_1_1_minimal_resource_requirements_for_matter_node[51.1.1.
[TC-RR-1.1] Minimal Resource Requirements for Matter Node]
* link:#_system_model_test_plan[*System Model Test Plan*]
** link:#_pics_definition_15[52. PICS Definition]
** link:#_test_case_list_15[53. Test Case List]
** link:#_test_cases_15[54. Test Cases]
*** link:#_device_composition_tests[54.1. Device composition tests]
**** link:#_tc_sm_1_1_device_composition_root_node_dut_as_server[54.1.1.
[TC-SM-1.1] Device composition - Root Node [DUT as Server]]
**** link:#_tc_sm_1_2_device_composition_topology_dut_as_server[54.1.2.
[TC-SM-1.2] Device composition - Topology [DUT as Server]]
* link:#_device_types_test_plan[*Device Types Test Plan*]
** link:#_pics_definition_16[55. PICS Definition]
** link:#_test_case_list_16[56. Test Case List]
** link:#_test_cases_16[57. Test Cases]
*** link:#_device_composition_tests_2[57.1. Device composition tests]
**** link:#_tc_dt_1_1_base_device_type_dut_as_server[57.1.1. [TC-DT-1.1]
Base Device Type [DUT as Server]]

[[content]]
[[_notice_of_use_and_disclosure]]
== link:#_notice_of_use_and_disclosure[]Notice of Use and Disclosure

Copyright © Connectivity Standards Alliance (2021). All rights reserved.
This information within this document is the property of the
Connectivity Standards Alliance and its use and disclosure are
restricted.

Elements of Connectivity Standards Alliance specifications may be
subject to third party intellectual property rights, including without
limitation, patent, copyright or trademark rights (such a third party
may or may not be a member of the Connectivity Standards Alliance). The
Connectivity Standards Alliance is not responsible and shall not be held
responsible in any manner for identifying or failing to identify any or
all such third party intellectual property rights.

This document and the information contained herein are provided on an
"AS IS" basis and the Connectivity Standards Alliance DISCLAIMS ALL
WARRANTIES EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO (A) ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OF THIRD PARTIES (INCLUDING WITHOUT LIMITATION ANY INTELLECTUAL
PROPERTY RIGHTS INCLUDING PATENT, COPYRIGHT OR TRADEMARK RIGHTS) OR (B)
ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, TITLE OR NON-INFRINGEMENT. IN NO EVENT WILL THE CONNECTIVITY
STANDARDS ALLIANCE BE LIABLE FOR ANY LOSS OF PROFITS, LOSS OF BUSINESS,
LOSS OF USE OF DATA, INTERRUPTION OF BUSINESS, OR FOR ANY OTHER DIRECT,
INDIRECT, SPECIAL OR EXEMPLARY, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL
DAMAGES OF ANY KIND, IN CONTRACT OR IN TORT, IN CONNECTION WITH THIS
DOCUMENT OR THE INFORMATION CONTAINED HEREIN, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH LOSS OR DAMAGE.

All company, brand and product names may be trademarks that are the sole
property of their respective owners.

This legal notice must be included on all copies of this document that
are made.

Connectivity Standards Alliance +
508 Second Street, Suite 206 +
Davis, CA 95616, USA

[[_participants]]
== link:#_participants[]Participants

[width="100%",cols="25%,25%,25%,25%",]
|===
|Agner, Stefan |Alvarez, José |Ananthakrishnan, Krithika |Andreola,
Cristian

|Babu, Praveen |Balducci, Alex |Bansal, Chirag |Bartolome, Diego

|Bauer-Schwan, Stefan |Beach, Chris |Beck, Austin |Becker, Markus

|Berrios, Victor |Bhat, Vikram |Bodurka, Adam |Bultman, Rob

|C, Rajashree |Cao, Cindy |Carbonara, Amato |Carmel-Veilleux, Tennessee

|Caronello, Paolo |Chalmers, Andrew |Chen, Zedd |Chudinov, Anton

|Claes, Jan |Cullen, Sam |Dakalia, Abhinav |Decenzo, Chris

|Deshpande, Prachi |Ding, Li-An |Drake, Jeff |Dunham, Michael

|Freeman, Cecille |Fu, Kenneth |Futane, Virupaksha |Fyall, Ian

|Galgalikar, Sailee |Garg, Pankaj |Garikipati, Shyam |Gaul, Dan

|Gonyea, Liam |Guo, Jiacheng |Guo, Song |H. G., Pramod

|Harvey, Gene |Heide, Janus |Heo, Joonhaeng |Hernandez Palomares, Martin

|Honnakasturi, Priyanka |Hou, Winnie |Houtepen, Rob |Hsiao, Alvin

|Hsu, Sid |Hu, Yinyi |Hussien, Emad |Jandhyala, Chaitanya

|Johns, Jerry |Josefsen, René |Kamp, Twan |Kardous, Mathieu

|Katira, Utsav |Kaur, Navjot |Khayat, Joseph |Kim, Jeonghwan

|Kleszcz, Marcin |Kneip, Daniel |Knörzer, Clemens |Kommareddi, Naveen

|Kohr, John |Kong, Lingshan |Kontra, Andrew |Kovacic, Lazar

|Królik, Damian |KY, Suma |Langewouters, Thomas |Lauric, Petru

|Lazar, Alin |Lepage, Marc |Li, James |Li, Zeng

|Liang, Gerrard |Lim, Kean |Lissianoi, Sergei |Lv, Zhinan

|Lyall, Jim |Ma, Qiang |Maes, Timothy |Makdissi, Shadi

|Mamo, Fesseha |Matignon, Florent |McAtee, Maxwell |McClain, Sean

|Mégevand, Jonathan |Mehta, Manav |Mohan, Kvs |Møller, Mikael

|Moreno, Alvaro |N.K., Sethu |Nadathur, Anush |Nandyala, Ramakrishna

|Øbakke, Erik Eskjær |Ocasio, Eric |P, Ashwini |P, Aswathy

|Palagummi, Raju |Pan, Shaofeng |Parausanu, Dragos |Paugam, Luc

|Penven, Jean-Francois |Pérez, Agustin |Petersen, Brian |Powell, Ken

|Qixiang, Wang |R A, Manjunath |Rahman, Mostafizur |Rhees, Jon

|Rozendaal, Leo |Rupp, Michael |S, Kowsalyadevi |S, Sowmya

|Salaun, Jean-Yves |Samad, Abdul |Schulze Struchtrup, Sebastian
|Seenivasan, Suraj

|Selvam, Sankar |Sena, Joe |She, Chengqiang |Shi, Lucy

|Shin, Sungmok |Sivaram |Somasundaram |Son, Jae

|Szablowski, Michał |Szewczyk, Robert |Tache, Marius |Takebe, Yasuyuki

|Thangaraj, Karthik |Trayer, Mark |Turon, Martin |Vasiliev, Sergey

|Villasenor, Joshua |Wan, Lank |Wang, David |Wang, Haoran

|Wang, Yunhan |Westadt, Caleb |Yang, Carol |Zbarsky, Boris

|Zhang, Aimee |Zhang, Xili |Zhaoxuan, Zhai |Zhong, Zain
|===

[[_document_control]]
== link:#_document_control[]Document Control

The Matter Test Plan is made of different chapters from the
Specification.

*Main Test Plans*

[width="100%",cols="50%,50%",]
|===
|Device Discovery |link:./devicediscovery.adoc[Document #]

|Secure Channel |link:./securechannel.adoc[Document #]

|Device Attestation |link:./deviceattestation.adoc[Document #]

|Basic Information |link:./cluster/basic_information.adoc[Document #]

|Node Operational Credentials
|link:./cluster/node_operational_credentials.adoc[Document #]

|Network Commissioning
|link:./cluster/network_commissioning.adoc[Document #]

|Interaction Data Model |link:./interactiondatamodel.adoc[Document #]

|Multiple Fabrics |link:./multiplefabrics.adoc[Document #]

|Bridge |link:./bridge.adoc[Document #]

|OTA Software Update |link:./softwareupdate.adoc[Document #]

|Bulk Data Exchange Protocol |link:./bdx.adoc[Document #]

|Minimal Resource Requirements
|link:./minimal_resource_reqs.adoc[Document #]

|Access Control Enforcement
|link:./AccessControlEnforcement.adoc[Document #]
|===

*Cluster Test Plans*

[width="100%",cols="50%,50%",]
|===
|OnOff Cluster |link:./cluster/onoff.adoc[Document #]

|Relative Humidity Measurement Cluster
|link:./cluster/relativehumiditymeasurement.adoc[Document #]

|Temperature Measurement Cluster
|link:./cluster/temperaturemeasurement.adoc[Document #]

|Pump Configuration and Control Cluster
|link:./cluster/pump_configuration_and_control.adoc[Document #]

|Media Cluster Library |link:./cluster/media.adoc[Document #]

|Level Control Cluster |link:./cluster/levelcontrol.adoc[Document #]

|Color Control Cluster |link:./cluster/colorcontrol.adoc[Document #]

|Occupancy Sensing Cluster
|link:./cluster/occupancysensing.adoc[Document #]

|Window Covering Cluster |link:./cluster/window_covering.adoc[Document
#]

|On/Off Switch Configuration Cluster
|link:./cluster/onoffswitchconfiguration.adoc[Document #]

|Software Diagnostics Cluster
|link:./cluster/software_diagnostics.adoc[Document #]

|Ethernet Network Diagnostics Cluster
|link:./cluster/ethernet_diagnostics.adoc[Document #]

|Switch Cluster |link:./cluster/switch.adoc[Document #]

|Actions Cluster |link:./cluster/actions.adoc[Document #]

|Scenes Cluster |link:./cluster/scenes.adoc[Document #]

|Bridged Device Basic Information
|link:./cluster/bridged_device_basic_information.adoc[Document #]

|Temperature Control Cluster
|link:./cluster/TemperatureControl.adoc[Document #]

|Carbon Monoxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/carbon_monoxide_concentration_measurement_cluster.adoc[Document
#]

|Carbon Dioxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/carbon_dioxide_concentration_measurement_cluster.adoc[Document
#]

|Ethylene Concentration Measurement Cluster
|link:./cluster/concentration-measurement/ethylene_concentration_measurement_cluster.adoc[Document
#]

|Ethylene Oxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/ethylene_oxide_concentration_measurement_cluster.adoc[Document
#]

|Hydrogen Concentration Measurement Cluster
|link:./cluster/concentration-measurement/hydrogen_concentration_measurement_cluster.adoc[Document
#]

|Hydrogen Sulfide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/hydrogen_sulfide_concentration_measurement_cluster.adoc[Document
#]

|Nitric Oxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/nitric_oxide_concentration_measurement_cluster.adoc[Document
#]

|Nitrogen Dioxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/nitrogen_dioxide_concentration_measurement_cluster.adoc[Document
#]

|Oxygen Concentration Measurement Cluster
|link:./cluster/concentration-measurement/oxygen_concentration_measurement_cluster.adoc[Document
#]

|Ozone Concentration Measurement Cluster
|link:./cluster/concentration-measurement/ozone_concentration_measurement_cluster.adoc[Document
#]

|Sulfur Dioxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/sulfur_dioxide_concentration_measurement_cluster.adoc[Document
#]

|Dissolved Oxygen Concentration Measurement Cluster
|link:./cluster/concentration-measurement/dissolved_oxygen_concentration_measurement_cluster.adoc[Document
#]

|Bromate Concentration Measurement Cluster
|link:./cluster/concentration-measurement/bromate_concentration_measurement_cluster.adoc[Document
#]

|Chloramines Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chloramines_concentration_measurement_cluster.adoc[Document
#]

|Chlorine Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chlorine_concentration_measurement_cluster.adoc[Document
#]

|Fecal coliform & E. Coli Concentration Measurement Cluster
|link:./cluster/concentration-measurement/fecal_coliform_&_e__coli_concentration_measurement_cluster.adoc[Document
#]

|Fluoride Concentration Measurement Cluster
|link:./cluster/concentration-measurement/fluoride_concentration_measurement_cluster.adoc[Document
#]

|Haloacetic Acids Concentration Measurement Cluster
|link:./cluster/concentration-measurement/haloacetic_acids_concentration_measurement_cluster.adoc[Document
#]

|Total Trihalomethanes Concentration Measurement Cluster
|link:./cluster/concentration-measurement/total_trihalomethanes_concentration_measurement_cluster.adoc[Document
#]

|Total Coliform Bacteria Concentration Measurement Cluster
|link:./cluster/concentration-measurement/total_coliform_bacteria_concentration_measurement_cluster.adoc[Document
#]

|Turbidity Concentration Measurement Cluster
|link:./cluster/concentration-measurement/turbidity_concentration_measurement_cluster.adoc[Document
#]

|Copper Concentration Measurement Cluster
|link:./cluster/concentration-measurement/copper_concentration_measurement_cluster.adoc[Document
#]

|Lead Concentration Measurement Cluster
|link:./cluster/concentration-measurement/lead_concentration_measurement_cluster.adoc[Document
#]

|Manganese Concentration Measurement Cluster
|link:./cluster/concentration-measurement/manganese_concentration_measurement_cluster.adoc[Document
#]

|Sulfate Concentration Measurement Cluster
|link:./cluster/concentration-measurement/sulfate_concentration_measurement_cluster.adoc[Document
#]

|Bromodichloromethane Concentration Measurement Cluster
|link:./cluster/concentration-measurement/bromodichloromethane_concentration_measurement_cluster.adoc[Document
#]

|Bromoform Concentration Measurement Cluster
|link:./cluster/concentration-measurement/bromoform_concentration_measurement_cluster.adoc[Document
#]

|Chlorodibromomethane Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chlorodibromomethane_concentration_measurement_cluster.adoc[Document
#]

|Chloroform Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chloroform_concentration_measurement_cluster.adoc[Document
#]

|Sodium Concentration Measurement Cluster
|link:./cluster/concentration-measurement/sodium_concentration_measurement_cluster.adoc[Document
#]

|PM2.5 Concentration Measurement Cluster
|link:./cluster/concentration-measurement/pm2_5_concentration_measurement_cluster.adoc[Document
#]

|Formaldehyde Concentration Measurement Cluster
|link:./cluster/concentration-measurement/formaldehyde_concentration_measurement_cluster.adoc[Document
#]

|PM1 Concentration Measurement Cluster
|link:./cluster/concentration-measurement/pm1_concentration_measurement_cluster.adoc[Document
#]

|PM10 Concentration Measurement Cluster
|link:./cluster/concentration-measurement/pm10_concentration_measurement_cluster.adoc[Document
#]

|Total Volatile Organic Compounds Concentration Measurement Cluster
|link:./cluster/concentration-measurement/total_volatile_organic_compounds_concentration_measurement_cluster.adoc[Document
#]

|Radon Concentration Measurement Cluster
|link:./cluster/concentration-measurement/radon_concentration_measurement_cluster.adoc[Document
#]

|Laundry Washer Mode |link:./cluster/mode_laundry_washer.adoc[Document
#]

|Laundry Washer Controls Cluster
|link:./cluster/LaundryWasherControls.adoc[Document #]

|Fan Control Cluster |link:./cluster/FanControl.adoc[Document #]

|Time Synchronization |link:./cluster/time_synchronization.adoc[Document
#]

|Dishwasher Mode Cluster |link:./cluster/mode_dishwasher.adoc[Document
#]

|Dishwasher Alarm Cluster |link:./cluster/dishwasher_alarm.adoc[Document
#]

|Operational State Cluster
|link:./cluster/operationalstate.adoc[Document #]

|Air Quality Cluster |link:./cluster/air_quality.adoc[Document #]

|HEPA Filter Monitoring Cluster
|link:./cluster/resource-monitoring/hepa_filter_monitoring.adoc[Document
#]

|Activated Carbon Filter Monitoring Cluster
|link:./cluster/resource-monitoring/activated_carbon_filter_monitoring.adoc[Document
#]

|Ceramic Filter Monitoring Cluster
|link:./cluster/resource-monitoring/ceramic_filter_monitoring.adoc[Document
#]

|Electrostatic Filter Monitoring Cluster
|link:./cluster/resource-monitoring/electrostatic_filter_monitoring.adoc[Document
#]

|UV Filter Monitoring Cluster
|link:./cluster/resource-monitoring/uv_filter_monitoring.adoc[Document
#]

|Ionizing Filter Monitoring Cluster
|link:./cluster/resource-monitoring/ionizing_filter_monitoring.adoc[Document
#]

|Zeolite Filter Monitoring Cluster
|link:./cluster/resource-monitoring/zeolite_filter_monitoring.adoc[Document
#]

|Ozone Filter Monitoring Cluster
|link:./cluster/resource-monitoring/ozone_filter_monitoring.adoc[Document
#]

|Water Tank Monitoring Cluster
|link:./cluster/resource-monitoring/water_tank_monitoring.adoc[Document
#]

|Fuel Tank Monitoring Cluster
|link:./cluster/resource-monitoring/fuel_tank_monitoring.adoc[Document
#]

|Ink Cartridge Monitoring Cluster
|link:./cluster/resource-monitoring/ink_cartridge_monitoring.adoc[Document
#]

|Toner Cartridge Monitoring Cluster
|link:./cluster/resource-monitoring/toner_cartridge_monitoring.adoc[Document
#]

|Mode Select Cluster |link:./cluster/modeselect.adoc[Document #]

|RVC Run Mode Cluster |link:./cluster/mode_rvc_run.adoc[Document #]

|RVC Clean Mode Cluster |link:./cluster/mode_rvc_clean.adoc[Document #]

|ICD Management |link:./cluster/icdmanagement.adoc[Document #]

|Refrigerator Mode Cluster |link:./cluster/mode_ref_tcc.adoc[Document #]

|Refrigerator Alarm Cluster
|link:./cluster/refrigerator_alarm.adoc[Document #]

|RVC Operational State Cluster
|link:./cluster/rvcoperationalstate.adoc[Document #]

|Smoke and CO Alarm Cluster |link:./cluster/smco.adoc[Document #]
|===

[[_document_history]]
== link:#_document_history[]Document History

[width="100%",cols="15%,15%,70%",options="header",]
|===
|Version |Date |Description
|r01 |June 7, 2021 |Initial draft
|===

[[_introduction]]
== link:#_introduction[]**Introduction**

[[_introduction_2]]
== link:#_introduction_2[]1. Introduction

[[_scope]]
=== link:#_scope[]1.1. Scope

This test plan covers the tests for Matter 1.0.

[[_purpose]]
=== link:#_purpose[]1.2. Purpose

Describe the tests to be performed for supported Matter 1.0 features.

[[_prerequisites]]
=== link:#_prerequisites[]1.3. Prerequisites

A test plan may have prerequisites that should be met before the test
plan can be executed with the expected results. Examples of
prerequisites include dependency certifications and security
conformance.

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*Ref* |*Authority* |*Doc No.* |*Test Plan Name* |*Prerequisites*
|TBD |TBD |TBD |TBD |TBD
|===

[[_references]]
== link:#_references[]2. References

[[_matter_documents]]
=== link:#_matter_documents[]2.1. Matter Documents

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*Ref* |*Authority* |*Doc No.* |*Specification Name* |*Test Plan Name*
|[C1] |Connectivity Standards Alliance / Matter |Github-Latest |Matter
Specification - Section 4 |Secure Channel Test Plan

|[C1] |Connectivity Standards Alliance / Matter |Github-Latest |Matter
Specification - Section 5 |Device Discovery Test Plan

|[C1] |Connectivity Standards Alliance / Matter |Github-Latest |Matter
Specification - Section 6 |Device Attestation Test Plan

|[C1] |Connectivity Standards Alliance / Matter |Github-Latest |Matter
Specification - Section 11 |Device Management Test Plan

|[C1] |Connectivity Standards Alliance / Matter |Github-Latest |Matter
Specification - Section 12 |Multiple Administrators Test Plan

|[C1] |Connectivity Standards Alliance / Matter |Github-Latest |Matter
Specification - Section 9.12 |Bridge Test Plan
|===

[[_dependency_certification_documents]]
=== link:#_dependency_certification_documents[]2.2. Dependency Certification Documents

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Ref* |*Authority* |*Doc No.* |*Specification Name*
|TBD |TBD |TBD |TBD
|===

[[_definitions]]
== link:#_definitions[]3. Definitions

[[_acronyms]]
=== link:#_acronyms[]3.1. Acronyms

[width="100%",cols="50%,50%",options="header",]
|===
|*Acronym or Abbreviation* |*Description*
|PICS |Protocol Implementation Conformance Statement(s).
|PIXIT |Protocol Implementation eXtra Information for Testing
|DUT |Device under test
|PAKE |Password Authenticated Key Exchange
|PASE |Passcode Authenticated Session Establishment
|PBKDF |Password-Based Key Derivation Function
|MIC |Message integrity check
|CASE |Certificate Authenticated Session Establishment
|TLV |Tag Length Value
|TH |Test Harness
|CSR |Certificate Signing Request
|===

[[_glossary]]
=== link:#_glossary[]3.2. Glossary

[width="100%",cols="50%,50%",options="header",]
|===
|*Term* |*Description*
|Node |An addressable entity which supports the Matter protocol stack
and (once Commissioned) has its own operational Node ID and Operational
Credential. Example: Matter app(lication)s on a mobile phone are Nodes,
the mobile phone itself is a Device.

|Controller |A Role of a Node that has permissions to enable it to
control one or more Nodes

|Controlee |A Role of a Node that has permissions defined to enable it
to be controlled by one or more Nodes.
|===

[[_identificationsidentifiers]]
=== link:#_identificationsidentifiers[]3.3. Identifications/Identifiers

Explanation of test case IDs, failure IDs, any other UUIDs

[[_conformance_levels]]
=== link:#_conformance_levels[]3.4. Conformance Levels

Reference IETF RFC-2119

MUST This word, or the terms "REQUIRED" or "SHALL", mean that the
definition is an absolute requirement of the specification.

MUST NOT This phrase, or the phrase "SHALL NOT", mean that the
definition is an absolute prohibition of the specification.

SHOULD This word, or the adjective "RECOMMENDED", mean that there may
exist valid reasons in particular circumstances to ignore a particular
item, but the full implications must be understood and carefully weighed
before choosing a different course.

SHOULD NOT This phrase, or the phrase "NOT RECOMMENDED" mean that there
may exist valid reasons in particular circumstances when the particular
behavior is acceptable or even useful, but the full implications should
be understood and the case carefully weighed before implementing any
behavior described with this label.

[[_diagram_definitions]]
=== link:#_diagram_definitions[]3.5. Diagram Definitions

This section defines picture/symbol element meaning for diagrams used
later in this document.

image:images/template-3-5-1.png[template 3 5 1]

image:images/template-3-5-2.png[template 3 5 2]

[[_test_setup]]
== link:#_test_setup[]4. Test Setup

This section will define any required steps necessary to set up an
environment that will be used for subsequent execution of test cases
contained in this test plan. Examples include the usage of particular
certificates, internet/cloud connectivity setup.

Test harness setup will be covered in the test tools documentation.

[[_mcore_pics_definition]]
== link:#_mcore_pics_definition[]**MCORE PICS Definition**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|0.1 |26-Jun-2022 |`Jonathan Megevand` |Initial draft
|===

[[_pics_definition]]
=== link:#_pics_definition[]5. PICS Definition

This section covers a part of the MCORE related PICS items. MCORE PICS
can be found and used among several clusters test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_communicationtransport]]
==== link:#_communicationtransport[]5.1. Communication/Transport

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.COM.BLE |Does the device support communication over Bluetooth Low
Energy (BLE) ? |O |

|MCORE.COM.WIFI |Does the device support communication over Wi-Fi ? |O |

|MCORE.COM.ETH |Does the device support communication over Ethernet ? |O
|

|MCORE.COM.THR |Does the device support communication over Thread ? |O |

|MCORE.COM.WIRELESS |Does the device support Wi-Fi or Thread interfaces
communication ? |MCORE.COM.WIFI, MCORE.COM.THR |
|===

[[_role]]
==== link:#_role[]5.2. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.ROLE.COMMISSIONER |Does the device implement a Commissioner ? |O
|

|MCORE.ROLE.COMMISSIONEE |Does the device implement a Commissionee ? |O
|

|MCORE.ROLE.CONTROLLER |Does the device implement a Controller ? |O |
|===

[[_user_interface]]
==== link:#_user_interface[]5.3. User Interface

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.UI.FACTORYRESET |Does the device support the Factory Reset
Method? |O |
|===

[[_device_discovery_test_plan]]
== link:#_device_discovery_test_plan[]**Device Discovery Test Plan**

[[_pics_definition_2]]
=== link:#_pics_definition_2[]6. PICS Definition

This section covers the Device Discovery related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*
|MCORE.DD.CHIP_DEV |Does the commissionee device only function within a
Matter network? |O |

|MCORE.DD.DEV_LOCK |Is the commissionee device a lock device? |O |

|MCORE.DD.DEV_BARRIER |Is the commissionee device a barrier access
device? |O |

|MCORE.DD.IE |Does the commissionee device have a vendor specific
information element (IE)? |MCORE.DD.DISCOVERY_SOFTAP:O |This should only
be applicable for devices that support being discovered over Wi-Fi
Soft-AP commissioning (MCORE.COM.WIFI is mandatory if the device
supports MCORE.DD.IE).

|MCORE.DD.QR |Does the commissionee device or device packaging have a QR
code based onboarding payload? |MCORE.DD.CONCATENATED_QR_CODE:M |

|MCORE.DD.MANUAL_PC |Does the commissionee device or device packaging
have a Manual Pairing Code? |O |

|MCORE.DD.NFC |Does the commissionee device have a NFC tag containing
the onboarding payload? |O |MCORE.DD.QR and/or MCORE.DD.MANUAL_PC are
mandatory if this item is supported/true.

|MCORE.DD.PASSCODE |Does the commissionee device support dynamic
passcodes? |O |

|MCORE.DD.UI |Does the DUT support user interface? |O |

|MCORE.DD.COMM_DISCOVERY |Does the DUT support Commissioner Discovery?
|O |

|MCORE.DD.CONTROLLER |Is the DUT a Controller? |O |

|MCORE.DD.CONCATENATED_QR_CODE |Does the commissionee device’s
Onboarding Payload contain concatenated QR codes? |O |MCORE.DD.QR is
mandatory if this item is supported/true.

|MCORE.DD.CTRL_CONCATENATED_QR_CODE_1 |Does the commissioner support
scanning and processing concatenated QR codes?
|MCORE.DD.CTRL_CONCATENATED_QR_CODE_1_INORDER:M |

|MCORE.DD.CTRL_CONCATENATED_QR_CODE_1_INORDER |Does the commissioner
support processing devices in the order as indicated in the concatenated
QR codes? |O |MCORE.DD.CTRL_CONCATENATED_QR_CODE_1 is mandatory if this
item is supported/true

|MCORE.DD.CTRL_CONCATENATED_QR_CODE_2 |Does the commissioner support
indicating to user the need to commission devices one by one for
concatenated QR codes? |O |

|MCORE.DD.DISCOVERY_BLE |Does the commissioner support Discovery
Capability over BLE? |MCORE.DD.COMMISSIONER & MCORE.COM.BLE |

|MCORE.DD.DISCOVERY_IP |Does the commissioner support Discovery
Capability over IP Network? |MCORE.ROLE.COMMISSIONER:M |

|MCORE.DD.DISCOVERY_SOFTAP |Does the commissioner support Discovery
Capability over SoftAP? |O |

|MCORE.DD.STANDARD_COMM_FLOW |Does the DUT support Standard
Commissioning Flow? |MCORE.DD.11_MANUAL_PC:M |

|MCORE.DD.USER_INTENT_COMM_FLOW |Does the DUT support User-Intent
Commissioning Flow? |O |

|MCORE.DD.CUSTOM_COMM_FLOW |Does the DUT support Custom Commissioning
Flow? |O |

|MCORE.DD.MANUAL_PC_COMMISSIONING |Does the commissioner support
accepting a Manual Pairing Code for commissioning? |O |

|MCORE.DD.11_MANUAL_PC |Does the commissioner support accepting an
11-digit Manual Pairing Code for commissioning? |O
|MCORE.DD.STANDARD_COMM_FLOW is mandatory if MCORE.DD.11_MANUAL_PC is
supported/true.

|MCORE.DD.21_MANUAL_PC |Does the commissioner support accepting a
21-digit Manual Pairing Code for commissioning? |O
|MCORE.DD.USER_INTENT_COMM_FLOW and/or MCORE.DD.CUSTOM_COMM_FLOW are
mandatory if this item is supported/true.

|MCORE.DD.PHYSICAL_TAMPERING |Is commissionee device subject to physical
tampering (doorbell, camera, door lock, designed for outdoor usage)? |O
|

|MCORE.DD.SCAN_NFC |Does the commissioner support scanning NFC tags
containing the onboarding payload? |O |

|MCORE.DD.QR_COMMISSIONING |Does the commissioner support accepting a QR
code for commissioning? |O |

|MCORE.DD.SCAN_QR_CODE |Does the commissioner support scanning QR codes
containing the onboarding payload? |O |

|MCORE.DD.EXTENDED_DISCOVERY |Does the commissionee device support
Extended Discovery through DNS-SD advertisements when device is not in
commissioning mode? |O |

|MCORE.DD.COMMISSIONING_SUBTYPE_V |Does the commissionee device support
advertising the Vendor ID Commissioning Subtype in Commissionable Node
Discovery through DNS-SD advertisements? |O |

|MCORE.DD.COMMISSIONING_SUBTYPE_T |Does the commissionee device support
advertising the Device Type Commissioning Subtype in Commissionable Node
Discovery through DNS-SD advertisements? |O |

|MCORE.DD.TXT_KEY_VP |Does the commissionee device support TXT Key 'VP'
(Vendor ID / Product ID) in it’s DNS-SD TXT Records for Commissionable
Node Discovery? |O |

|MCORE.DD.TXT_KEY_DT |Does the commissionee device support TXT Key 'DT'
(Device Type) in it’s DNS-SD TXT Records for Commissionable Node
Discovery? |O |

|MCORE.DD.TXT_KEY_DN |Does the commissionee device support TXT Key 'DN'
(Device Name) in it’s DNS-SD TXT Records for Commissionable Node
Discovery? |O |

|MCORE.DD.TXT_KEY_RI |Does the commissionee device support TXT Key 'RI'
(Rotating Identifier) in it’s DNS-SD TXT Records for Commissionable Node
Discovery? |O |

|MCORE.DD.TXT_KEY_PH |Does the commissionee device support TXT Key 'PH'
(Pairing Hint) in it’s DNS-SD TXT Records for Commissionable Node
Discovery? |O |If MCORE.DD.EXTENDED_DISCOVERY is true, then this record
is required when not in Commissioning Mode (CM=0).

|MCORE.DD.TXT_KEY_PI |Does the commissionee device support TXT Key 'PI'
(Pairing Instruction) in it’s DNS-SD TXT Records for Commissionable Node
Discovery? |O |
|===

[[_test_case_list]]
=== link:#_test_case_list[]7. Test Case List

[width="100%",cols="50%,50%",options="header",]
|===
|*TC UUID* |*Test Case Name*
|TC-DD-1.1 |QR Code Onboarding Payload Verification [DUT - Commissionee]

|TC-DD-1.2 |Manual Pairing Code Payload Verification [DUT -
Commissionee]

|TC-DD-1.3 |NFC Onboarding Payload Verification [DUT - Commissionee] -
REMOVED

|TC-DD-1.4 |Concatenation - QR Code Onboarding Payload Verification [DUT
- Commissionee] - REMOVED

|TC-DD-1.5 |NFC Rules of Advertisement and Onboarding [DUT -
Commissionee] - REMOVED

|TC-DD-1.6 |QR Code Format and Label [DUT - Commissionee]

|TC-DD-1.7 |Setup Code Format and Label [DUT - Commissionee]

|TC-DD-1.8 |QR Code Onboarding Payload Verification [DUT - Commissioner]

|TC-DD-1.9 |Manual Pairing Code Payload Verification [DUT -
Commissioner]

|TC-DD-1.10 |NFC Onboarding Payload Verification [DUT - Commissioner] -
REMOVED

|TC-DD-1.11 |Concatenation - QR Code Onboarding Payload Verification
[DUT - Commissioner] - REMOVED

|TC-DD-1.12 |Onboarding Payload Verification - Custom Flow = 0 [DUT -
Commissionee]

|TC-DD-1.13 |Onboarding Payload Verification - Custom Flow = 1 [DUT -
Commissionee]

|TC-DD-1.14 |Onboarding Payload Verification - Custom Flow = 2 [DUT -
Commissionee]

|TC-DD-1.15 |Onboarding Payload Verification - Unique Discriminator and
Passcode Values [DUT - Commissionee]

|TC-DD-2.1 |Announcement by Device Verification [DUT - Commissionee]

|TC-DD-2.2 |Discovery by Commissioner Verification [DUT - Commissioner]

|TC-DD-3.1 |Commissioning Flow - Concurrent [DUT - Commissionee]

|TC-DD-3.2 |Commissioning Flow - Non-concurrent [DUT - Commissionee] -
REMOVED

|TC-DD-3.3 |User Directed Commissioning [DUT - Commissionee]

|TC-DD-3.4 |User Directed Commissioning [DUT - Commissioner]

|TC-DD-3.5 |Commissioning Flow - Concurrent [DUT - Commissioner]

|TC-DD-3.6 |Commissioning Flow - Non-concurrent [DUT - Commissioner] -
REMOVED

|TC-DD-3.7 |Commissioning Flow - Concurrent - Negative Scenario [DUT -
Commissioner] - REMOVED

|TC-DD-3.8 |Commissioning Flow - Non-concurrent - Negative Scenario [DUT
- Commissioner] - REMOVED

|TC-DD-3.9 |Commissioning Flow - Custom Flow = 2 [DUT - Commissionee]

|TC-DD-3.10 |Commissioning Flow - Custom Flow = 2 [DUT - Commissioner]

|TC-DD-3.11 |Commissioning Flow = 0 (Standard Flow) - QR Code [DUT -
Commissioner]

|TC-DD-3.12 |Commissioning Flow = 1 (User-Intent Flow) - QR Code [DUT -
Commissioner]

|TC-DD-3.13 |Commissioning Flow = 2 (Custom Flow) - QR Code [DUT -
Commissioner]

|TC-DD-3.14 |Commissioning Flow - QR Code - Negative Scenario [DUT -
Commissioner]

|TC-DD-3.15 |Commissioning Flow - Manual Pairing Code [DUT -
Commissioner]

|TC-DD-3.16 |Commissioning Flow - 11-digit Manual Pairing Code -
Negative Scenario [DUT - Commissioner]

|TC-DD-3.17 |Commissioning Flow - 21-digit Manual Pairing Code -
Negative Scenario [DUT - Commissioner]

|TC-DD-3.18 |Commissioning Flow - Commissioning Multiple Devices [DUT -
Commissioner]

|TC-DD-3.19 |Commissioning Flow - Commission, Unpair and Re-commission
Device [DUT - Commissionee]

|TC-DD-3.20 |Commissioning Flow - Commission, Unpair and Re-commission
Device [DUT - Commissioner]

|TC-DD-3.21 |Commissioning Flow - Commission Multiple-Endpoint Device
[DUT - Commissioner]
|===

[[_test_cases]]
=== link:#_test_cases[]8. Test Cases

'''''

[[_onboarding_payload_test_cases]]
==== link:#_onboarding_payload_test_cases[]8.1. *Onboarding Payload Test Cases*

'''''

[[_tc_dd_1_1_qr_code_onboarding_payload_verification_dut_commissionee]]
===== link:#_tc_dd_1_1_qr_code_onboarding_payload_verification_dut_commissionee[]8.1.1. [TC-DD-1.1] QR Code Onboarding Payload Verification [DUT - Commissionee]

[[_category]]
====== link:#_category[]Category

Functional Conformance.

[[_purpose_2]]
====== link:#_purpose_2[]Purpose

This test case verifies that the onboarding QR code contains the
necessary information to onboard the device onto the Matter network.

[[_pics]]
====== link:#_pics[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.QR

[[_preconditions]]
====== link:#_preconditions[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.3 |QR Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).
|
|===

[[_required_devices]]
====== link:#_required_devices[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a QR code reader device that can read and decode
a QR code.

|2 |DUT |DUT as Commissionee device with the QR code printed on it or
contained in additional provided materials.
|===

[[_test_procedure]]
====== link:#_test_procedure[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Scan the DUT’s QR code using a QR code reader |Verify the QR
code is scanned successfully.

|2.a |5.1.3.1 Table 34 | |Verify the QR code payload version |Verify the
QR code payload version is '000'.

|2.b |5.1.3.1 Table 34 | |Verify Vendor ID and Product ID |Verify Vendor
ID and Product ID match the values submitted by manufacturer in
Distributed Compliance Ledger

|2.c |5.1.3.1 Table 34 | |Verify the Custom Flow bit |Verify the Custom
Flow bit has one of the following values: 0, 1 or 2

|2.d |5.1.3.1 Table 34 | |Verify 8-bit Discovery Capabilities bit mask
|Verify the onboarding payload contains an 8-bit Discovery Capabilities
bit mask describing the transports which can be used for commissioning
the DUT.

|2.e |5.1.3.1 Table 34 | |Verify the 12-bit discriminator bit mask
|Verify the 12-bit discriminator matches the value which a device
advertises during commissioning.

|2.f |5.1.3.1 Table 34 | |Verify the onboarding payload contains a
27-bit Passcode |Verify the 27-bit unsigned integer encodes an 8-digit
decimal numeric value and shall be a value between 0x0000001 to
0x5f5e0fe (00000001 to 99999998)

|2.g |5.1.7.1 | |Verify passcode is valid a|
Verify passcode does not use any trivial values: 00000000, 11111111,
22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888,
99999999, 12345678, 87654321

Verify Passcode is not derived from public information as serial number,
manufacturer date, MAC address, region of origin etc.

|2.h |5.1.3.1 | |Verify QR code prefix |Verify QR code prefix is "MT:"

|3 |5.1.3.1 Table 34 | |Verify the packed binary data structure |Verify
the packed binary data structure is padded with '0' bits at the end of
the structure to the nearest byte boundary.
|===

[[_notestesting_considerations]]
====== link:#_notestesting_considerations[]Notes/Testing considerations

'''''

[[_tc_dd_1_2_manual_pairing_code_payload_verification_dut_commissionee]]
===== link:#_tc_dd_1_2_manual_pairing_code_payload_verification_dut_commissionee[]8.1.2. [TC-DD-1.2] Manual Pairing Code Payload Verification [DUT - Commissionee]

[[_category_2]]
====== link:#_category_2[]Category

Functional Conformance.

[[_purpose_3]]
====== link:#_purpose_3[]Purpose

This test case verifies that the Manual Pairing Code contains the
necessary information to onboard the device onto the Matter network.

[[_pics_2]]
====== link:#_pics_2[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.MANUAL_PC

[[_preconditions_2]]
====== link:#_preconditions_2[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.4.1 |Manual Pairing Code is printed on the Commissionee device
or in additional provided materials (ex: manual, companion app, web
service). |
|===

[[_required_devices_2]]
====== link:#_required_devices_2[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Checksum script used to validate the check
digit using the Verhoeff algorithm

|2 |DUT |DUT as Commissionee device with the Manual Pairing Code printed
on it or contained in additional provided materials.
|===

[[_test_procedure_2]]
====== link:#_test_procedure_2[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.1.4.1 Table 38 | |Verify the first digit of the Manual Pairing
Code for the DUT a|
The first digit must be between 0 and 7. If the digit is between 0 and
3, the code length must be 11 digits (VID_PID flag not set).

If the digit is between 4 and 7, the code length must be 21 digits
(VID_PID flag set)

|2 |5.1.4.1 Table 38 | |If the Manual Pairing Code is 11 digits/the
VID_PID flag is not set, verify the encoded elements. |Digits 2 through
6 must be between 00000 and 65535 Digits 7 through 10 must be between
0000 and 8191

|2.b |5.1.4.1 - Table 39 | |If the Manual Pairing Code is 21 digits/the
VID_PID flag is set, verify the encoded elements. |Digits 2 through 6
must be between 00000 and 65535. Digits 7 through 10 must be between
0000 and 8191. Digits 11 through 15 must be between 00000 and 65535.
Digits 16 through 20 must be between 00000 and 65535.

|3 |5.1.4.1 Check Digit | |Verify the Check Digit (last digit of the
Manual Pairing Code) by entering the preceding digits into the checksum
script/Test Harness |Verify the final digit, the Check Digit, of the
Manual Pairing Code printed on the DUT matches the generated digit by
the script/Test Harness.
|===

[[_notestesting_considerations_2]]
====== link:#_notestesting_considerations_2[]Notes/Testing considerations

'''''

[[_tc_dd_1_3_nfc_onboarding_payload_verification_dut_commissionee_removed]]
===== link:#_tc_dd_1_3_nfc_onboarding_payload_verification_dut_commissionee_removed[]8.1.3. [TC-DD-1.3] NFC Onboarding Payload Verification [DUT - Commissionee] - REMOVED

[[_category_3]]
====== link:#_category_3[]Category

Functional Conformance.

[[_purpose_4]]
====== link:#_purpose_4[]Purpose

This test case verifies that the NFC tag’s onboarding payload contains
the necessary information to onboard the device onto the Matter network.

[[_pics_3]]
====== link:#_pics_3[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.NFC

[[_preconditions_3]]
====== link:#_preconditions_3[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.8 |NFC Tag is on the device a|
- The data contained in the NFC tag SHALL be the same as specified in QR
Code Format.

- The NFC tag SHALL be one of the types as defined by NFC Forum.

- The NFC tag SHALL use the NFC Data Exchange Format (NDEF) as defined
by NFC NDEF 1.0.

- The NFC tag SHALL use NDEF messages as defined by NFC RTD 1.0.

- The Onboarding Payload for the NFC tag SHALL use NDEF URI Record Type
Definition as defined by NFC RTD URI 1.0 and as specified in the Table
41.

|===

[[_required_devices_3]]
====== link:#_required_devices_3[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as an NFC code reader device that can read and
decode a NFC code

|2 |DUT |DUT as Commissionee device with the NFC tag containing an
onboarding payload
|===

[[_test_procedure_3]]
====== link:#_test_procedure_3[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Power up the DUT and put the DUT in pairing mode |

|2 | | |Bring the NFC code reader close to the DUT |

|3.a |5.1.3.1 Table 33/34 | |Verify the NFC’s onboarding payload code
version |Verify the NFC’s onboarding payload code version is '000'.

|3.b |5.1.3.1 Table 34/35 | |Verify 8-bit Discovery Capabilities bit
mask |Verify the onboarding payload contains an 8-bit Discovery
Capabilities bit mask describing the transports which can be used for
commissioning the DUT. Refer to spec 5.1.3 Table 35 for specifics of the
bit mask.

|3.c | | |Verify the 12-bit discriminator bit mask |Verify the 12-bit
discriminator matches the value which a device advertises during
commissioning.

|3.d | | |Verify the onboarding payload contains a 27-bit Passcode
|Verify the 27-bit unsigned integer encodes an 8-digit decimal numeric
value and shall be a value between 0x0000001 to 0x5f5e0fe (00000001 to
99999998)

|3.e | | |Verify passcode is valid a|
Verify passcode does not use any trivial values: 00000000, 11111111,
22222222, 33333333, 44444444, 55555555, 66666666, 77777777, 88888888,
99999999, 12345678, 87654321

Verify Passcode is not derived from public information as serial number,
manufacturer date, MAC address, region of origin etc.

|3.f | | |Verify NFC’s onboarding payload code prefix |Verify NFC’s
onboarding payload code prefix is "MT:"

|3.g | | |Verify Vendor ID and Product ID |Verify Vendor ID and Product
ID match the values submitted by manufacturer in Distributed Compliance
Ledger

|4 |5.1.3 Table 33 | |Verify the packed binary data structure |Verify
the packed binary data structure is padded with '0' bits at the end of
the structure to the nearest byte boundary.

|5 |5.1.3 | |Verify Custom payload support |Verify the custom payload is
a 2 bit field and the Values supported are 0, 1 and 2.
|===

[[_notestesting_considerations_3]]
====== link:#_notestesting_considerations_3[]Notes/Testing considerations

'''''

[[_tc_dd_1_4_concatenation_qr_code_onboarding_payload_verification_dut_commissionee_removed]]
===== link:#_tc_dd_1_4_concatenation_qr_code_onboarding_payload_verification_dut_commissionee_removed[]8.1.4. [TC-DD-1.4] Concatenation - QR Code Onboarding Payload Verification [DUT - Commissionee] - REMOVED

[[_category_4]]
====== link:#_category_4[]Category

Physical Conformance, Conformance

[[_purpose_5]]
====== link:#_purpose_5[]Purpose

This test case verifies that the onboarding QR code contains information
on the onboarding of multiple DUT.

[[_pics_4]]
====== link:#_pics_4[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.CONCATENATED_QR_CODE

[[_required_devices_4]]
====== link:#_required_devices_4[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a QR code reader device that can read and decode
a QR code

|2 |DUT |DUT as Commissionee device with the QR code printed on it or
contained in additional provided materials.
|===

[[_test_setup_2]]
====== link:#_test_setup_2[]Test Setup

The DUT may include in its packaging a combined QR code containing a
concatenation of all the devices that will be available for
commissioning.

[[_test_procedure_4]]
====== link:#_test_procedure_4[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.1.6 | |Scan larger QR code that will support the commissioning of
all the DUTs in the packaging using the QR code scanner a|
Verify that each DUT onboarding payload is delimited with a * depending
on the number of DUTs that will be onboarded.

Example:
MT:<onboarding-base-38-content_bulb1>*<onboarding-base-38-content_bulb2>*<onboarding-base-38-content_bulb3>*<onboarding-base-38-content_bulb4>

|===

[[_notestesting_considerations_4]]
====== link:#_notestesting_considerations_4[]Notes/Testing considerations

'''''

[[_tc_dd_1_5_nfc_rules_of_advertisement_and_onboarding_dut_commissionee_removed]]
===== link:#_tc_dd_1_5_nfc_rules_of_advertisement_and_onboarding_dut_commissionee_removed[]8.1.5. [TC-DD-1.5] NFC Rules of Advertisement and Onboarding [DUT - Commissionee] - REMOVED

[[_category_5]]
====== link:#_category_5[]Category

Conformance - protocol and device setup.

[[_purpose_6]]
====== link:#_purpose_6[]Purpose

This test case verifies that the NFC Tag setup experience follows
guidance in section 5.1.8

[[_pics_5]]
====== link:#_pics_5[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.NFC

[[_preconditions_4]]
====== link:#_preconditions_4[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.7 a|
NFC Spec Requirements: NFC tags SHALL use the NFC Data Exchange Format
(NDEF) as defined by NFC ForumTM in [NDEF 1.0 NFCForum-TS-NDEF 1.0]

An NDEF message is defined as a group of individual NDEF records as
defined by NFC ForumTM in NFC Record Type Definition (RTD) RTD 1.0
[NFCForum-TS-RTD 1.0]

Onboarding Payload for NFC tags SHALL use NDEF URI Record Type
Definition as defined by NFC ForumTM in URI Record Type Definition
RTD-URI 1.0 [NFCForum-TS-RTD URI 1.0]. The URI for defined in section
3.3 Format

|
|===

[[_required_devices_5]]
====== link:#_required_devices_5[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as an NFC scanner device that can read and decode a
NFC

|2 |DUT |DUT as Commissionee device with the NFC tag containing an
onboarding payload
|===

[[_device_topology]]
====== link:#_device_topology[]Device Topology

Diagram of device communication and, if applicable, respective ranges.

[[_test_setup_3]]
====== link:#_test_setup_3[]Test Setup

This will describe how to set up for testing.

[[_test_procedure_5]]
====== link:#_test_procedure_5[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.1.7 | |Keep the DUT in packaging and bring in TH NFC scanner close
to the DUT packaging. |Bring in the TH NFC scanner close to the DUT
packaging and verify the DUT’s NFC tag containing Onboarding Payload is
not scannable and readable

|2.a |5.1.7 | |Unpack DUT from its packaging, make sure DUT is not
powered on and do not put the DUT in pairing mode. Bring in TH NFC
scanner close to the DUT’s NFC tag |Verify that the programmable tag
does not advertise the Onboarding Payload and cannot be modified over
the air.

|2.b |13.3 |MCORE.DD.PHYSICAL_TAMPERING |Power on DUT and do not put the
DUT in pairing mode. Bring in TH NFC scanner close to the DUT’s NFC tag
|Verify programmable tag when not in pairing mode, does not advertise
the Onboarding Payload and cannot be modified over the air.

|2.c |13.3 |MCORE.DD.PHYSICAL_TAMPERING |DUT must have an explicit
trigger of the the NFC pairing mode |Verify the DUT has an explicit
trigger (a physical action that enables the NFC pairing flow)

|2.d |13.3 |MCORE.DD.PHYSICAL_TAMPERING |Power on DUT and put the DUT in
pairing mode. Bring in TH NFC scanner close to NFC tag |Verify the
complete onboarding payload is presented

|2.e |5.1.7 |!(MCORE.DD.PHYSICAL_TAMPERING) |Power on DUT. Bring in NFC
scanner close to NFC tag |Verify the complete onboarding payload is
presented

|2.f |5.1.7 | |Wait for the pairing mode to expire on device |Verify the
DUT terminates the advertising upon termination of pairing mode.

|3 |5.1.5 | |For Read only Tags, try to write using NFC tool a payload
to DUT |Verify it is rejected and payload can’t be written to tag

|4.a |5.1.5 | |For Programmable Tag, NFC tag must be read only OTA. Try
to write a payload to DUT using NFC tool |Verify the write is rejected
and payload can’t be written to tag

|4.b |5.1.5 | |Optional — For Programmable Tag, NFC tag may be
reconfigured using wired means |Verify payload can be written through
wired means

|5 |5.1.5 | |Using TH NFC scanner - read NFC tag Reader type |Verify the
NFC tag on a device is Type 2 or greater
|===

[[_notestesting_considerations_5]]
====== link:#_notestesting_considerations_5[]Notes/Testing considerations

'''''

[[_tc_dd_1_6_qr_code_format_and_label_dut_commissionee]]
===== link:#_tc_dd_1_6_qr_code_format_and_label_dut_commissionee[]8.1.6. [TC-DD-1.6] QR Code Format and Label [DUT - Commissionee]

[[_category_6]]
====== link:#_category_6[]Category

Physical Conformance

[[_purpose_7]]
====== link:#_purpose_7[]Purpose

This test case verifies that the onboarding QR code is of scannable
size.

[[_pics_6]]
====== link:#_pics_6[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.QR

[[_required_devices_6]]
====== link:#_required_devices_6[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a QR code reader device that can read and decode
a QR code.

|2 |DUT |DUT as Commissionee device with the QR code printed on it or
contained in additional provided materials.
|===

[[_test_setup_4]]
====== link:#_test_setup_4[]Test Setup

Final label of DUT is ready to be scanned

[[_test_procedure_6]]
====== link:#_test_procedure_6[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.1.3.2 | |Scan the DUT’s QR code using the TH QR code reader
|Verify the QR code gets scanned successfully. Verify The QR code must
be of sufficient size and contrast respective to surface material as to
be readable with standard readers such as smartphones in normal lighting
conditions. Refer to spec 5.1.3.3 _“Example”_

|2 |5.1.3.2 | |Verify QR code version |QR code version must be of
Version 1 or higher.
|===

[[_notestesting_considerations_6]]
====== link:#_notestesting_considerations_6[]Notes/Testing considerations

'''''

[[_tc_dd_1_7_setup_code_format_and_label_dut_commissionee]]
===== link:#_tc_dd_1_7_setup_code_format_and_label_dut_commissionee[]8.1.7. [TC-DD-1.7] Setup Code Format and Label [DUT - Commissionee]

[[_category_7]]
====== link:#_category_7[]Category

Physical Conformance

[[_purpose_8]]
====== link:#_purpose_8[]Purpose

This test case verifies that the Manual Pairing Code size meets the
minimum requirements.

[[_pics_7]]
====== link:#_pics_7[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.MANUAL_PC

[[_preconditions_5]]
====== link:#_preconditions_5[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.4.2 |Manual Pairing Code is printed on the Commissionee device
or in additional provided materials (ex: manual, companion app, web
service). |
|===

[[_required_devices_7]]
====== link:#_required_devices_7[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |Ruler/Measuring Device |Used to validate the size of the Manual
Pairing Code

|2 |DUT |DUT as Commissionee device with the Manual Pairing Code printed
on it or contained in additional provided materials.
|===

[[_test_setup_5]]
====== link:#_test_setup_5[]Test Setup

Final label of DUT is ready to be scanned

[[_test_procedure_7]]
====== link:#_test_procedure_7[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.1.4, 1.6.1, 5.7.4 | |Verify using instruments a|
The Manual Pairing Code shall meet the following requirements:

- Printed using a minimum font size of 6 points, typically producing a
typeface height of 2.1 mm (6/72 inches)

- Include dashes between the groups of Manual Pairing Code digits with
the following spacing:

- For 11 or 21-digit codes, the first row spacing is 4-3-4 (First Row:
"1234-567-8901")

- For 21-digit codes, the second row spacing is 4-3-2-1 (Second
Row:"9876-543-21-0")

|===

[[_notestesting_considerations_7]]
====== link:#_notestesting_considerations_7[]Notes/Testing considerations

'''''

[[_tc_dd_1_8_qr_code_onboarding_payload_verification_dut_commissioner]]
===== link:#_tc_dd_1_8_qr_code_onboarding_payload_verification_dut_commissioner[]8.1.8. [TC-DD-1.8] QR Code Onboarding Payload Verification [DUT - Commissioner]

[[_category_8]]
====== link:#_category_8[]Category

Functional Conformance.

[[_purpose_9]]
====== link:#_purpose_9[]Purpose

This test case verifies that the Commissioner is able to scan and parse
the QR code to onboard the device onto the Matter network.

[[_pics_8]]
====== link:#_pics_8[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING

[[_preconditions_6]]
====== link:#_preconditions_6[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.3, 5.1.5 a|
QR Code is printed on the Commissionee device or in additional provided
materials (ex: manual, companion app, web service). Device also has
additional TLV data with a non-zero length appended to the end of the QR
code.

An example onboarding QR code could be
"MT:-24J029Q00KA064IJ3P0IXZB0DK5N1K8SQ1RYCU1-A40" (following 5.1.3 "QR
Code", Table 34 "Packed Binary Data Structure for Onboarding Payload")
which includes:

- 3-bit Version String=000

- 16-bit Vendor ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier")

- 16-bit Product ID=0x8001 (as defined in section 2.5.3. "Product
Identifier")

- 2-bit Custom Flow=10 (Custom Commissioning Flow = 2)

- 8-bit Discovery Capabilities Bitmask=00000100 (OnNetwork)

- 12-bit Discriminator=0xF00

- 27-bit Passcode=20202021

- 4-bit Padding=0000

- TLV Data=0x152C000A3132333435363738393018 included (as defined in
section 5.1.3.1. "Payload", subsection "TLV Data")

|
|===

[[_required_devices_8]]
====== link:#_required_devices_8[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device that can read and decode a QR
code.

|2 |TH |Test Harness as a Commissionee device with the QR code printed
on it or contained in additional provided materials.
|===

[[_test_procedure_8]]
====== link:#_test_procedure_8[]Test Procedure

[width="100%",cols="10%,10%,15%,50%,15%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MCORE.DD.SCAN_QR_CODE |Scan the TH Device’s QR code using DUT
|Verify the QR code has been scanned successfully.

|2 | | |Using the DUT, parse the TH’s QR code to onboard the TH Device
onto the Matter network. |Verify the TH’s QR code was parsed
successfully by the DUT

|3.a | |MCORE.DD.SCAN_QR_CODE a|
Scan the TH Device’s QR code (that includes the additional TLV data)
using DUT.

Using the example provided above, the payload would be
"MT:-24J029Q00KA064IJ3P0IXZB0DK5N1K8SQ1RYCU1-A40".

|Verify the QR code has been scanned successfully.

|3.b | | |Using the DUT, parse the TH’s QR code to onboard the TH Device
onto the Matter network. |Verify the TH’s QR code with the appended TLV
data was parsed successfully by the DUT (where the DUT may ignore the
TLV contents)

|4.a | |MCORE.DD.SCAN_QR_CODE |Scan the TH Device’s QR code (that
includes the additional large TLV data) using DUT. |Verify the QR code
has been scanned successfully.

|4.b | | |Using the DUT, parse the TH’s QR code to onboard the TH Device
onto the Matter network. |Verify the TH’s QR code with the appended TLV
data was parsed successfully by the DUT (where the DUT may ignore the
TLV contents)
|===

[[_notestesting_considerations_8]]
====== link:#_notestesting_considerations_8[]Notes/Testing considerations

'''''

[[_tc_dd_1_9_manual_pairing_code_payload_verification_dut_commissioner]]
===== link:#_tc_dd_1_9_manual_pairing_code_payload_verification_dut_commissioner[]8.1.9. [TC-DD-1.9] Manual Pairing Code Payload Verification [DUT - Commissioner]

[[_category_9]]
====== link:#_category_9[]Category

Functional Conformance.

[[_purpose_10]]
====== link:#_purpose_10[]Purpose

This test case verifies that the Manual Pairing Code can be provided to
the Commissioner and parsed to onboard the device onto the Matter
network.

[[_pics_9]]
====== link:#_pics_9[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.MANUAL_PC_COMMISSIONING

[[_preconditions_7]]
====== link:#_preconditions_7[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.4.1 |Manual Pairing Code is printed on the Commissionee device
or in additional provided materials (ex: manual, companion app, web
service). |
|===

[[_required_devices_9]]
====== link:#_required_devices_9[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device that can read and decode a Manual
Pairing Code.

|2 |TH |Test Harness as a device used to validate the check digit using
the Verhoeff algorithm
|===

[[_test_procedure_9]]
====== link:#_test_procedure_9[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.1.4.1 | |Provide the 11-digit/21-digit Manual Pairing Code from
the TH Device in text, speech or any format supported by DUT |Verify
that the Manual Pairing Code can be provided to DUT and parsed to
onboard the device onto the Matter network.
|===

[[_notestesting_considerations_9]]
====== link:#_notestesting_considerations_9[]Notes/Testing considerations

'''''

[[_tc_dd_1_10_nfc_onboarding_payload_verification_dut_commissioner_removed]]
===== link:#_tc_dd_1_10_nfc_onboarding_payload_verification_dut_commissioner_removed[]8.1.10. [TC-DD-1.10] NFC Onboarding Payload Verification [DUT - Commissioner] - REMOVED

[[_category_10]]
====== link:#_category_10[]Category

Functional Conformance.

[[_purpose_11]]
====== link:#_purpose_11[]Purpose

This test case verifies that the Commissioner is able to read and decode
the NFC code to onboard the device onto the Matter network.

[[_pics_10]]
====== link:#_pics_10[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.SCAN_NFC

[[_preconditions_8]]
====== link:#_preconditions_8[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.8 a|
NFC tag follows guidelines set in section 5.1.8 of spec.

An example onboarding payload could be "MT:-24J029Q00KA0648G00"
(following Table 34 "Packed Binary Data Structure for Onboarding
Payload") which includes:

- 3-bit Version String=000

- 16-bit Vendor ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier")

- 16-bit Product ID=0x8001 (as defined in section 2.5.3. "Product
Identifier")

- 2-bit Custom Flow=10 (Custom Commissioning Flow = 2)

- 8-bit Discovery Capabilities Bitmask=00000100 (OnNetwork)

- 12-bit Discriminator=0xF00

- 27-bit Passcode=20202021

- 4-bit Padding=0000

- no variable-length TLV Data included (as defined in section 5.1.3.1.
"Payload", subsection "TLV Data")

|
|===

[[_required_devices_10]]
====== link:#_required_devices_10[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device that can read and decode an NFC
tag containing an Onboarding Payload.

|2 |TH |Test Harness as a Commissionee device with NFC tag/ Reference
NFC tag
|===

[[_test_procedure_10]]
====== link:#_test_procedure_10[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Power up the TH Device and put the TH Device in commissioning
mode |TH is in a state to be commissioned by the DUT Commissioner

|2 | | |Bring the DUT close to the NFC tag for the TH Device |Verify the
DUT is able to read and decode the NFC tag’s onboarding payload
successfully to onboard the TH Device onto the Matter network.
|===

[[_notestesting_considerations_10]]
====== link:#_notestesting_considerations_10[]Notes/Testing considerations

'''''

[[_tc_dd_1_11_concatenation_qr_code_onboarding_payload_verification_dut_commissioner_removed]]
===== link:#_tc_dd_1_11_concatenation_qr_code_onboarding_payload_verification_dut_commissioner_removed[]8.1.11. [TC-DD-1.11] Concatenation - QR Code Onboarding Payload Verification [DUT - Commissioner] - REMOVED

[[_category_11]]
====== link:#_category_11[]Category

Physical Conformance, Conformance

[[_purpose_12]]
====== link:#_purpose_12[]Purpose

This test case verifies that the onboarding QR code contains information
on the onboarding of multiple DUT.

This test case verifies that the Commissioner is able to scan and parse
a concatenated QR code to onboard multiple devices in order onto the
Matter network.

[[_pics_11]]
====== link:#_pics_11[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING

[[_required_devices_11]]
====== link:#_required_devices_11[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device that can read and decode a QR
code.

|2 |TH |Test Harness as Multiple Devices that are Commissionees with a
concatenated QR code
|===

[[_test_procedure_11]]
====== link:#_test_procedure_11[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.1.6 |MCORE.DD.CTRL_CONCATENATED_QR_CODE_1 |Scan QR code using
concatenation (which supports the commissioning of all the TH devices)
|Verify the DUT is able to scan and parse the concatenated QR code
successfully

|2 |5.1.6 |MCORE.DD.CTRL_CONCATENATED_QR_CODE_1_INORDER | a|
Verify the DUT follows the correct order of onboarding the TH devices
which must be from first to last starting from left to right.

Example:
MT:<onboarding-base-38-content_bulb1>*<onboarding-base-38-content_bulb2>*<onboarding-base-38-content_bulb3>*<onboarding-base-38-content_bulb4>

content_bulb1 gets onboarded first, content_bulb2 gets onboarded second
and so forth.

|3 |5.1.6 |!(MCORE.DD.CTRL_CONCATENATED_QR_CODE_1) &
MCORE.DD.CTRL_CONCATENATED_QR_CODE_2 | |Verify the DUT indicates to the
user the need to commission TH devices one by one by scanning their
individual QR codes.

|4 |5.1.6 |!(MCORE.DD.CTRL_CONCATENATED_QR_CODE_1) &
!(MCORE.DD.CTRL_CONCATENATED_QR_CODE_2) | |Verify the DUT does NOT
indicate to the user the need to commission TH devices one by one by
scanning their individual QR codes, but instead warns the user (in a way
described by the provider of the DUT) that the QR code cannot be
processed.

|5 |5.1.6 | |Scan QR code using concatenation (which supports the
commissioning of all the TH devices) |Verify the DUT recognizes the *
separator from the QR code as an indication concatenation is used by
parsing the QR code successfully as multiple TH QR codes.
|===

[[_notestesting_considerations_11]]
====== link:#_notestesting_considerations_11[]Notes/Testing considerations

'''''

[[_tc_dd_1_12_onboarding_payload_verification_custom_flow_0_dut_commissionee]]
===== link:#_tc_dd_1_12_onboarding_payload_verification_custom_flow_0_dut_commissionee[]8.1.12. [TC-DD-1.12] Onboarding Payload Verification - Custom Flow = 0 [DUT - Commissionee]

[[_category_12]]
====== link:#_category_12[]Category

Functional Conformance.

[[_purpose_13]]
====== link:#_purpose_13[]Purpose

This test case verifies that the interactions defined by the Custom Flow
field are reflected by the DUT supporting Standard Commissioning Flow

[[_pics_12]]
====== link:#_pics_12[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.QR
* MCORE.DD.STANDARD_COMM_FLOW

[[_preconditions_9]]
====== link:#_preconditions_9[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.3 |QR Code/ Manual Pairing Code is printed on the Commissionee
device or in additional provided materials (ex: manual, companion app,
web service). |
|===

[[_required_devices_12]]
====== link:#_required_devices_12[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a QR code reader device that can read and decode
a QR code.

|2 |DUT |DUT as Commissionee device with the QR code printed on it or
contained in additional provided materials. DUT supports Standard
Commissioning Flow.
|===

[[_test_procedure_12]]
====== link:#_test_procedure_12[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.1.3 | |Scan the DUT’s QR code using the TH. |Verify the QR code is
scanned successfully and that the TH parses QR code.

|2 |5.7.1 | |Reboot the DUT device. |Upon power up, verify the DUT
Commissionee is advertising to be commissioned to a Matter network.
|===

[[_notestesting_considerations_12]]
====== link:#_notestesting_considerations_12[]Notes/Testing considerations

'''''

[[_tc_dd_1_13_onboarding_payload_verification_custom_flow_1_dut_commissionee]]
===== link:#_tc_dd_1_13_onboarding_payload_verification_custom_flow_1_dut_commissionee[]8.1.13. [TC-DD-1.13] Onboarding Payload Verification - Custom Flow = 1 [DUT - Commissionee]

[[_category_13]]
====== link:#_category_13[]Category

Functional Conformance.

[[_purpose_14]]
====== link:#_purpose_14[]Purpose

This test case verifies that the interactions defined by the Custom Flow
field are reflected by the DUT supporting User-Intent Commissioning Flow

[[_pics_13]]
====== link:#_pics_13[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.QR
* MCORE.DD.USER_INTENT_COMM_FLOW

[[_preconditions_10]]
====== link:#_preconditions_10[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.3 |QR Code/ Manual Pairing Code is printed on the Commissionee
device or in additional provided materials (ex: manual, companion app,
web service). |
|===

[[_required_devices_13]]
====== link:#_required_devices_13[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a QR code reader device that can read and decode
a QR code.

|2 |DUT |DUT as Commissionee device with the QR code printed on it or
contained in additional provided materials. DUT supports User-Intent
Commissioning Flow.
|===

[[_test_procedure_13]]
====== link:#_test_procedure_13[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Power on the DUT device. |Verify DUT Commissionee is NOT in
commissioning mode. User has a QR code to pass into DUT.

|2 |5.1.3 | |Scan the DUT’s QR code from the previous step using the TH.
|Verify the QR code is scanned successfully and that the TH parses QR
code.

|3 |5.7.2 | |Follow any DUT-specific steps for putting the DUT
Commissionee into commissioning mode |Verify the DUT Commissionee is
advertising to be commissioned to a Matter network.
|===

[[_notestesting_considerations_13]]
====== link:#_notestesting_considerations_13[]Notes/Testing considerations

'''''

[[_tc_dd_1_14_onboarding_payload_verification_custom_flow_2_dut_commissionee]]
===== link:#_tc_dd_1_14_onboarding_payload_verification_custom_flow_2_dut_commissionee[]8.1.14. [TC-DD-1.14] Onboarding Payload Verification - Custom Flow = 2 [DUT - Commissionee]

[[_category_14]]
====== link:#_category_14[]Category

Functional Conformance.

[[_purpose_15]]
====== link:#_purpose_15[]Purpose

This test case verifies that the interactions defined by the Custom Flow
field are reflected by the DUT supporting Custom Commissioning Flow

[[_pics_14]]
====== link:#_pics_14[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.QR
* MCORE.DD.CUSTOM_COMM_FLOW

[[_preconditions_11]]
====== link:#_preconditions_11[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1.3 |QR Code/ Manual Pairing Code is printed on the Commissionee
device or in additional provided materials (ex: manual, companion app,
web service). |
|===

[[_required_devices_14]]
====== link:#_required_devices_14[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a QR code reader device that can read and decode
a QR code.

|2 |DUT |DUT as Commissionee device with the QR code printed on it or
contained in additional provided materials. DUT supports Custom
Commissioning Flow.
|===

[[_test_procedure_14]]
====== link:#_test_procedure_14[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Power on the DUT device. |Verify DUT Commissionee is NOT in
commissioning mode. User has a QR code to pass into DUT.

|2 |5.1.3 | |Scan the DUT’s QR code from the previous step using the TH.
|Verify the QR code is scanned successfully and that the TH parses QR
code.

|3 |5.7.3 | |Follow any DUT-specific steps, guided by a service provided
by the DUT’s manufacturer for initial device setup, then place the DUT
Commissionee into commissioning mode. |Verify the DUT Commissionee is
advertising to be commissioned to a Matter network.
|===

[[_notestesting_considerations_14]]
====== link:#_notestesting_considerations_14[]Notes/Testing considerations

'''''

[[_tc_dd_1_15_onboarding_payload_verification_unique_discriminator_and_passcode_values_dut_commissionee]]
===== link:#_tc_dd_1_15_onboarding_payload_verification_unique_discriminator_and_passcode_values_dut_commissionee[]8.1.15. [TC-DD-1.15] Onboarding Payload Verification - Unique Discriminator and Passcode Values [DUT - Commissionee]

[[_category_15]]
====== link:#_category_15[]Category

Functional Conformance.

[[_purpose_16]]
====== link:#_purpose_16[]Purpose

This test case verifies that the Discriminator and Passcode values are
unique across two different hardware units of the same product coming
for certification testing.

[[_pics_15]]
====== link:#_pics_15[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_12]]
====== link:#_preconditions_12[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.1 |Onboarding payload is printed on the device or in additional
provided materials (ex: manual, companion app, web service) through a QR
Code, a Manual Pairing Code or as content in an NFC tag. |
|===

[[_required_devices_15]]
====== link:#_required_devices_15[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as an Onboarding payload reader - A device that can
read and decode an Onboarding payload. (ex: Scanning a QR code,
accepting a Manual Pairing Code, or scanning an NFC tag)

|2 |DUT1 |DUT 1 as a Commissionee device with the Onboarding payload
printed on the device or in additional provided materials (ex: manual)
through a QR Code, a manually entered code or as content in an NFC tag.

|3 |DUT2 |DUT 2 as a Commissionee device with the Onboarding payload
printed on the device or in additional provided materials (ex: manual)
through a QR Code, a manually entered code or as content in an NFC tag.
|===

[[_test_procedure_15]]
====== link:#_test_procedure_15[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a | | |Using the TH Onboarding payload reader, scan or read the
Onboarding payload from DUT1 |Verify the Onboarding payload is scanned
successfully.

|1.b |5.7.1 | |Using the TH, parse the Onboarding payload from previous
step and verify that the Discriminator and Passcode for DUT1 are
present. |Note down the Discriminator and Passcode values of the parsed
payload.

|2.a | | |Using the TH Onboarding payload reader, scan or read the
Onboarding payload from DUT2 |Verify the Onboarding payload is scanned
successfully.

|2.b |5.7.1 | |Using the TH, parse the Onboarding payload from previous
step and verify that the Discriminator and Passcode for DUT2 are
present. |Note down the Discriminator and Passcode values of the parsed
payload.

|3 |5.1.1.5 | |Compare the Discriminator values for DUT1 (Step 1.b) and
DUT2 (Step 2.b) |Verify that DUT1’s Discriminator value is different
than DUT2’s Discriminator value.

|4 |5.1.1.6 | |Compare the Passcode values for DUT1 (Step 1.b) and DUT2
(Step 2.b) |Verify that DUT1’s Passcode value is different than DUT2’s
Passcode value.
|===

[[_notestesting_considerations_15]]
====== link:#_notestesting_considerations_15[]Notes/Testing considerations

'''''

[[_pre_commissioning_discovery_test_cases]]
==== link:#_pre_commissioning_discovery_test_cases[]8.2. *Pre-Commissioning Discovery Test Cases*

'''''

[[_tc_dd_2_1_announcement_by_device_verification_dut_commissionee]]
===== link:#_tc_dd_2_1_announcement_by_device_verification_dut_commissionee[]8.2.1. [TC-DD-2.1] Announcement by Device Verification [DUT - Commissionee]

[[_category_16]]
====== link:#_category_16[]Category

Functional Conformance.

[[_purpose_17]]
====== link:#_purpose_17[]Purpose

The purpose of this test case is to verify if the DUT properly announces
its uncommissioned state to allow a Matter Commissioner to discover the
DUT to be commissioned.

[[_pics_16]]
====== link:#_pics_16[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_13]]
====== link:#_preconditions_13[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |The DUT is switched on and the DUT is transport-connected (BLE,
Wi-Fi or Ethernet) |
|===

[[_required_devices_16]]
====== link:#_required_devices_16[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Matter Commissioner that is already joined in
a Matter network

|2 |DUT |DUT as a Commissionee device that is in an uncommissioned state
|===

[[_test_procedure_16]]
====== link:#_test_procedure_16[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.4.2.1 | a|
If TH is aware of the DUT’s Discovery Capability Bitmask, it SHALL
initiate Device Discovery in any order of priority on all the networking
technologies that are supported by both the TH and the DUT

If TH is unaware of the DUT’s Discovery Capability Bitmask, it SHALL
initiate Device Discovery in any order on all the networking
technologies it supports out of Wi-Fi Soft-AP, BLE, and on IP network
discovery.

|DUT selects a transport in any order of priority.

|2 |5.4.2.2 a|
MCORE.DD.CHIP_DEV |

!(MCORE.DD.CHIP_DEV) |

MCORE.DD.DEV_LOCK |

MCORE.DD.DEV_BARRIER

a|
If (MCORE.DD.CHIP_DEV) then

If !(MCORE.DD.CHIP_DEV) then

If (MCORE.DD.DEV_LOCK) then

If (MCORE.DD.DEV_BARRIER) then

a|
DUT starts announcing automatically

DUT does not start announcing

DUT does not start announcing

DUT does not start announcing

|3 |5.4.2.5 |MCORE.COM.BLE |DUT begins sending ADVs. TH does not respond
to these DUT ADVs so that the DUT can keep sending ADVs a|
The following Advertising PDU payload fields shall comply with section
5.4.2.5.6. "Advertising Data". DUT contains in the ADV:

12-bit "Discriminator" field (Byte 8-9, Bits[11:0])

DUT may contain in the ADV:

16-bit "Vendor ID" field (Byte 10-11, Set to 0, if elided)

16-bit "Product ID" field (Byte 12-13, Set to 0, if elided)

Variable length "Extended Data" field (Byte 14, Bit[0], Set to 0, if
elided)

|4 |5.4.2.5 |MCORE.COM.BLE |TH does not respond to DUT and DUT keeps
sending ADVs |The ADV contains a GAP peripheral and uses the GAP General
Discoverable mode

|5 |5.4.2.5 |MCORE.COM.BLE |TH does not respond to DUT and DUT keeps
sending ADVs a|
Between T0 and 30s, DUT should send ADVs each 20ms to 60ms

Between 30s and 15min, DUT should send ADVs each 150ms to 1200ms

|6 |5.4.2.5 |MCORE.COM.BLE |TH does not respond to DUT. User power
cycles the DUT |DUT restarts the ADV sending process upon reboot and
uses a new address (the previous address must be stored by TH in the
previous step).

|7 |5.4.2.5 |MCORE.COM.BLE |TH does not respond to DUT and DUT keeps
sending ADVs. TH waits at least 15 minutes |DUT stops sending ADV no
later than 15 minutes and no sooner than 3 minutes.

|8 |5.4.2.6 |MCORE.COM.WIFI |TH scans and finds the DUT SSID |DUT SSID
is not hidden and has the format: MATTER-ddd-vvvv-pppp

|9 |5.4.2.6 |MCORE.COM.WIFI a|
TH scans and finds the DUT SSID

TH sends to DUT a 1st power cycle command (or reset manually)

TH sends to DUT a 2nd power cycle command (or reset manually)

a|
DUT BSSID is random on each boot. DUT BSSID has the value X

After 1st power cycle, DUT BSSID is random with respect X (is not X,
X+1, X-1, X*2, X/2, etc.)

After 2nd power cycle, DUT BSSID is random with respect X (is not X,
X+1, X-1, X*2, X/2, etc.)

DUT bcast bit is set.

DUT locally-administered bit is set.

|10 |5.4.2.6 |MCORE.COM.WIFI & MCORE.DD.IE |TH scans and finds the DUT
SSID a|
DUT IE is carried in the Wi-Fi Soft-AP Beacon and Probe response frames

AND

DUT includes in that IE the following fields:

0x00 (Reserved)

0x01 (Device State)

0x02 (Device Information)

0x03 (Rotating Device Id)

0x04 - 0xFF (Reserved)

|11 |5.4.2.1, 4.3.1.5., 4.3.1.7., 4.3.1.11. | |TH and DUT are connected
to the same network through vendor-unique means or by commissioning the
DUT onto the Matter network and opening a commissioning window. The DUT
is sending mandatory Commissionable Node Discovery service records over
DNS-SD. a|
DUT is able to be discovered over DNS-SD.

For each of the following required TXT record keys for DNS-SD based
discovery, validate that the DUT’s TXT records contain a valid key/value
pair corresponding to the rules for each TXT key listed:

D: Full 12-bit discriminator for the Commissionable Node (Spec.
4.3.1.5.). The discriminator value SHALL be encoded as a variable-length
decimal number in ASCII text, with up to four digits, omitting any
leading zeroes. For example, value D=840 would indicate that this
Commissionable Node has a decimal long discriminator=840.

CM: Commissioning Mode, The absence of key CM SHALL imply a value of 0
(CM=0). CM=0 SHALL indicate that the publisher is not currently in
Commissioning Mode. CM=1 SHALL indicate that the publisher is currently
in Commissioning Mode and requires use of a passcode for commissioning
provided by the Commissionee CM=2 SHALL indicate that the publisher is
currently in Commissioning Mode and requires use of a dynamically
generated passcode for commissioning corresponding to the verifier that
was passed to the device using the Open Commissioning Window command.

|12.a |4.3.1.6. |MCORE.DD.TXT_KEY_VP |TH and DUT are connected to the
same network and the DUT is sending optional Commissionable Node
Discovery service records over DNS-SD. a|
Validate that the following TXT key record is compliant:

VP: Vendor ID and Product ID (Spec 4.3.1.6.) SHALL both be expressed as
variable-length decimal numbers, encoded as ASCII text, omitting any
leading zeroes, and of maximum length of 5 characters each to fit their
16-bit numerical range. For example, If the Product ID is present, it
SHALL be separated from the Vendor ID using a '' character. If the VP
key is present without a Product ID, the value SHALL contain only the
Vendor ID alone, with no '' character.

For example, (1) VP=123 gives Vendor ID. (2) VP=123+456 gives Vendor
ID=123 + Product ID=456.

|12.b |4.3.1.8. |MCORE.DD.TXT_KEY_DT |TH and DUT are connected to the
same network and the DUT is sending optional Commissionable Node
Discovery service records over DNS-SD. a|
Validate that the following TXT key record is compliant:

DT: Device Type (Spec 4.3.1.8.) MAY provide the publisher’s primary
device type (see Section 11.22.5.3, “DeviceTypeID”). In case the device
combines multiple device types, the manufacturer SHOULD choose the
device type identifier of the primary function of the device for which
the device wishes to be discoverable. If present, it SHALL be encoded as
a variable-length decimal number in ASCII text, omitting any leading
zeroes.

For example, the DT=10 key/value pair would indicate that the primary
device type is 10 (0x000a), which is the device type identifier for a
Door Lock.

|12.c |4.3.1.9. |MCORE.DD.TXT_KEY_DN |TH and DUT are connected to the
same network and the DUT is sending optional Commissionable Node
Discovery service records over DNS-SD. a|
Validate that the following TXT key record is compliant:

DN: Device Name (Spec 4.3.1.9.) MAY provide a device advertisement name.
If present, it SHALL be encoded as a valid UTF-8 string with a maximum
length of 32 bytes (matching the maximum length of the NodeLabel string
in the Basic Information Cluster).

For example, the DN=Living Room key/value pair indicates that the
advertisement name specified by the user is 'Living Room'.

|12.d |4.3.1.10. |MCORE.DD.TXT_KEY_RI |TH and DUT are connected to the
same network and the DUT is sending optional Commissionable Node
Discovery service records over DNS-SD. a|
Validate that the following TXT key record is compliant:

RI: Rotating Identifier (Spec 4.3.1.10.) MAY provide a Rotating Device
Identifier. If present, the value associated with the RI key SHALL
contain the octets of the Rotating Device Identifier octet string
encoded as the concatenation of each octet’s value as a 2-digit
uppercase hexadecimal number. The resulting ASCII string SHALL NOT be
longer than 100 characters, which implies a Rotating Device Identifier
of at most 50 octets.

|12.e |4.3.1.11. |MCORE.DD.TXT_KEY_PH |TH and DUT are connected to the
same network and the DUT is sending optional Commissionable Node
Discovery service records over DNS-SD. a|
Validate that the following TXT key record is compliant:

PH: Pairing Hint (Spec 4.3.1.11.) MAY provide a pairing hint. If
present, it SHALL be encoded as a variable-length decimal number in
ASCII text, omitting any leading zeroes. The pairing hint represents a
base-10 numeric value for a bitmap of methods supported by the
Commissionee in its current state for putting it in Commissioning Mode.

For example, the PH=5 key/value pair represents a hint value with bits 0
and 2 are set.

For the Pairing Hint TXT key, verify the following bits are set
according to the requirement listed for the bit:

Bit 0: This bit SHALL be set to 1 for devices using Standard
Commissioning Flow , and set to 0 otherwise.

Bit 1: This SHALL be set to 1 for devices requiring Custom Commissioning
Flow before they can be available for Commissioning by any Commissioner.

Bits 8, 10, 12, 15, 17, 19: If the following bits are set to 1 in the
PH, verify that the PI key is set with a value N representing a value
the PH key needs to indicate action for the user to take (i.e. PH Bit 8:
hold reset button for N seconds, PH Bit 12: press reset button N times)

If the DUT=Commissionee has enabled Extended Discovery, then the PH
record is required when not in Commissioning Mode (CM=0).

|12.f |4.3.1.12. |MCORE.DD.TXT_KEY_PI |TH and DUT are connected to the
same network and the DUT is sending optional Commissionable Node
Discovery service records over DNS-SD. a|
Validate that the following TXT key record is compliant:

PI: Pairing Instruction (Spec 4.3.1.12.) MAY give the pairing
instruction. If present, the value SHALL be encoded as a valid UTF-8
string with a maximum length of 128 bytes. The meaning of this key is
dependent upon the PH key value, see Table 6, “Pairing Hint Values”.
This key/value pair SHALL only be returned in the DNS-SD TXT record if
the PH bitmap value has a bit set which has PI Dependency = True, see
Table 6, “Pairing Hint Values”. The PH key SHALL NOT have more than one
bit set which has a dependency on the PI key (PI Dependency = True) to
avoid ambiguity in PI key usage.

For example, given PH=256, bit 8 is set which indicates "Press Reset
Button for N seconds". Therefore, a value of PI=10 would indicate that N
is 10 in that context.

|13 |4.3.1.2., 4.3.1.3. |MCORE.DD.EXTENDED_DISCOVERY |Place the DUT
device into a non-commissionable state a|
Verify DUT is not able to be commissioned over DNS-SD.

Verify that Commissioning Subtype='_CM' is NOT being published in the
DUT’s Commissionable Node Discovery service record over DNS-SD.

|14.a |4.3.1.3. | |TH and DUT are connected to the same network and the
DUT is sending a Commissionable Node Discovery service record over
DNS-SD. |DUT is able to be discovered over DNS-SD.

|14.b |4.3.1.3. | |Mandatory Commissioning Subtypes: Send a browse
request for '_services._dns-sd._udp' using a DNS-SD records command-line
test tool (i.e. 'dns-sd -B _services._dns-sd._udp' or 'avahi-browse
_services._dns-sd._udp -r') a|
Verify each of the following Commissioning Subtypes, published in the
DUT’s Commissionable Node Discovery service record over DNS-SD, matches
one of the following valid subtypes:

{empty}1. _L<dddd>, where <dddd> provides the full 12-bit discriminator,
encoded as a variable-length decimal number in ASCII text, omitting any
leading zeroes.

{empty}2. _S<dd>, where <dd> provides the upper 4 bits of the
discriminator, encoded as a variable-length decimal number in ASCII
text, omitting any leading zeroes.

{empty}3. _CM, which represents "currently in Commissioning Mode" (due
to any method, for example, a factory new device that has just been put
into commissioning mode by the user, or an already- commissioned device
which has just received the Open Commissioning Window command).

|14.c |4.3.1.3. |MCORE.DD.COMMISSIONING_SUBTYPE_V |
MCORE.DD.COMMISSIONING_SUBTYPE_T |Optional Commissioning Subtypes: Send
a browse request for '_services._dns-sd._udp' using a DNS-SD records
command-line test tool (i.e. 'dns-sd -B _services._dns-sd._udp' or
'avahi-browse _services._dns-sd._udp -r') a|
Verify each of the following Commissioning Subtypes, published in the
DUT’s Commissionable Node Discovery service record over DNS-SD, matches
one of the following valid subtypes:

{empty}1. _V<ddddd>, where <ddddd> provides the 16-bit Vendor ID,
encoded as a variable-length decimal number in ASCII text, omitting any
leading zeroes.

{empty}2. _T<ddd>, where <ddd> provides the device type identifier for
the device, encoded as a variable- length decimal number in ASCII
(UTF-8) text, omitting any leading zeroes. In case the device combines
multiple device types, the manufacturer SHOULD choose the device type
identifier of the primary function of the device for which the device
wishes to be discoverable.

|15.a |4.3.1 | |Place the DUT device into Commissioning mode |DUT is
able to be discovered over DNS-SD.

|15.b |4.3.1.3., 4.3.1.13. | |Send a browse request for '_matterc._udp'
using a DNS-SD records command-line test tool (i.e. 'dns-sd -B
_matterc._udp' or 'avahi-browse _matterc._udp -r') |DUT responds to the
'_matterc._udp' browse request from the TH. Verify TH is able to read
the Matter pointer records for the DUT
|===

[[_notestesting_considerations_16]]
====== link:#_notestesting_considerations_16[]Notes/Testing considerations

Test Steps 8, 9, 10: Out of Scope for V1.0 as they use Wi-Fi Soft-AP
commissioning.

'''''

[[_tc_dd_2_2_discovery_by_commissioner_verification_dut_commissioner]]
===== link:#_tc_dd_2_2_discovery_by_commissioner_verification_dut_commissioner[]8.2.2. [TC-DD-2.2] Discovery by Commissioner Verification [DUT - Commissioner]

[[_category_17]]
====== link:#_category_17[]Category

Functional Conformance.

[[_purpose_18]]
====== link:#_purpose_18[]Purpose

The purpose of the test case is to verify that a device acting as
Commissioner is able to properly discover an uncommissioned matter
device that wants to join the network using all discovery transport
technologies specified.

[[_pics_17]]
====== link:#_pics_17[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_14]]
====== link:#_preconditions_14[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.4.3. Discovery by Commissioner |DUT supports BLE (central role),
Wi-Fi and IP connectivity |Wi-Fi certified n client

|2 | |Test Harness must support all discovery transport technologies as
the DUT (i.e. BLE, Wi-Fi and IP connectivity) |
|===

[[_required_devices_17]]
====== link:#_required_devices_17[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Commissionee device acting as a joiner that
supports all discovery transports (i.e. BLE, Wi-Fi and IP connectivity)

|2 |DUT |DUT as Commissioner device that is joined already in a Matter
network
|===

[[_test_procedure_17]]
====== link:#_test_procedure_17[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a |TH |5.4.3.1 |MCORE.DD.DISCOVERY_BLE |TH starts matter announcement
procedure using BLE transport |TH must start sending BLE advertisements.

|1.b |DUT |5.4.3.1 |MCORE.DD.DISCOVERY_BLE |DUT starts BLE scan across
all three advertising channels with a sufficient dwell time, interval,
and overall duration of scan a|
DUT must find TH and provide onboarding data to for validation.

Pass Criteria: DUT is able to report the Onboarding payload as set on TH

|2.a |DUT |5.4.3.1 |MCORE.DD.DISCOVERY_BLE |DUT starts scan in
background using BLE transport |

|2.b |TH |5.4.3.1 |MCORE.DD.DISCOVERY_BLE |TH starts matter announcement
using BLE transport |TH must start sending BLE advertisements.

|2.c |DUT |5.4.3.1 |MCORE.DD.DISCOVERY_BLE | a|
DUT must find TH and provide onboarding data for validation.

Pass Criteria: DUT is able to report the Onboarding payload as set on TH

|3.a |TH |5.4.3.2 |MCORE.DD.DISCOVERY_SOFTAP |TH starts SoftAP and begin
matter announcement procedure |TH must start SoftAP using Wi-Fi
transport

|3.b |DUT |5.4.3.2 |MCORE.DD.DISCOVERY_SOFTAP |DUT starts Wi-Fi scan of
all 2.4 GHz Wi-Fi channels allowed per its operational regulatory domain
(channels 1, 6, and 11 are preferred) a|
DUT must find TH and provide onboarding data for validation.

Pass Criteria: DUT is able to report the Onboarding payload as set on TH

|4.a |DUT |5.4.3.2 |MCORE.DD.DISCOVERY_SOFTAP |DUT scans using Wi-Fi in
background |

|4.b |TH |5.4.3.2 |MCORE.DD.DISCOVERY_SOFTAP |TH starts SoftAP and begin
matter announcement procedure |TH must start SoftAP using Wi-Fi
transport

|4.c |DUT |5.4.3.2 |MCORE.DD.DISCOVERY_SOFTAP | a|
DUT must find TH and provide onboarding data for validation.

Pass Criteria: DUT is able to report the Onboarding payload as set on TH

|5 |DUT |5.4.3.3 | |With DUT and TH connected to the same network over
IP, DUT performs service discovery using DNS-SD a|
DUT must find TH and provide onboarding data for validation.

Pass Criteria: DUT is able to report the Onboarding payload as set on TH

|===

[[_notestesting_considerations_17]]
====== link:#_notestesting_considerations_17[]Notes/Testing considerations

Test Steps 3.a/b, 4.a/b/c: Out of Scope for V1.0 as they use Wi-Fi
Soft-AP commissioning.

'''''

[[_commissioning_flows_test_cases]]
==== link:#_commissioning_flows_test_cases[]8.3. *Commissioning Flows Test Cases*

'''''

[[_tc_dd_3_1_commissioning_flow_concurrent_dut_commissionee]]
===== link:#_tc_dd_3_1_commissioning_flow_concurrent_dut_commissionee[]8.3.1. [TC-DD-3.1] Commissioning Flow - Concurrent [DUT - Commissionee]

[[_category_18]]
====== link:#_category_18[]Category

End to End Conformance.

[[_purpose_19]]
====== link:#_purpose_19[]Purpose

The purpose of the following test cases is to verify the End to End
Concurrent Commissioning Flow of a device that is commissioned into a
Matter network.

[[_pics_18]]
====== link:#_pics_18[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_15]]
====== link:#_preconditions_15[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |Commissioner is on a network. |The network can either be
IP-based(Ethernet or Wi-Fi) or Thread. Commissioner can either be a
Matter device which is already on a network or the test harness
connected to the network.
|===

[[_required_devices_18]]
====== link:#_required_devices_18[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Commissioner can either be a Matter device
which is already on a network or the test harness connected to the
network.

|2 |DUT |DUT as Commissionee device that is connected to an operational
network(i.e. BLE, Wi-Fi, or Ethernet) and is prepared for commissioning
|===

[[_test_procedure_18]]
====== link:#_test_procedure_18[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |5.5 - 2 | |Commissioner and Commissionee discover each other and
connect via the discovery mode applicable for the DUT. |Commissioner and
Commissionee can discover each other and connect to each other by
establishing a commissioning channel between each other.

|2 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|3 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |DUT arms the Fail-safe timer with success

|4 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |DUT sets the regulatory
values configured by the Commissioner

|5 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |DUT generate a new
operational key pair

|6 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |DUT is able to install Trusted Root
Certificate if needed

|7 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on DUT if needed |DUT configures the ACL with success

|8 |DUT |5.5 - 11 | |Commissioner configures operational network on DUT
if DUT both supports and requires |DUT configure the correct operational
network credentials

|9 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |DUT successfully connect
to operational network

|10 |TH |5.5 - 13 | |Commissioner starts discovery of DUT using
Operational Discovery |

|11 |DUT |5.5 - 14 | |Commissioner opens a CASE session with DUT over
operational network |DUT is able to open the CASE session with TH

|12 |DUT |5.5 - 15 | |Commissioner sends CommissioningComplete command
|DUT responds with success at CommissioningComplete command sent by TH

|13 | |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |
|===

[[_notestesting_considerations_18]]
====== link:#_notestesting_considerations_18[]Notes/Testing considerations

'''''

[[_tc_dd_3_2_commissioning_flow_non_concurrent_dut_commissionee_removed]]
===== link:#_tc_dd_3_2_commissioning_flow_non_concurrent_dut_commissionee_removed[]8.3.2. [TC-DD-3.2] Commissioning Flow - Non-concurrent [DUT - Commissionee] - REMOVED

[[_category_19]]
====== link:#_category_19[]Category

End to End Conformance.

[[_purpose_20]]
====== link:#_purpose_20[]Purpose

The purpose of the following test cases is to verify the End to End
Non-Concurrent Commissioning Flow of a device that is commissioned into
a Matter network.

[[_pics_19]]
====== link:#_pics_19[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_16]]
====== link:#_preconditions_16[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |Commissioner is on a network. |The network can either be
IP-based(Ethernet or Wi-Fi) or Thread. Commissioner can either be a
Matter device which is already on a network or the test harness
connected to the network.
|===

[[_required_devices_19]]
====== link:#_required_devices_19[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Commissioner can either be a Matter device
which is already on a network or the test harness connected to the
network.

|2 |DUT |DUT as Commissionee device that is not connected to an
operational network(i.e. BLE, Wi-Fi, or Ethernet) and is prepared for
commissioning
|===

[[_test_procedure_19]]
====== link:#_test_procedure_19[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |5.5 - 2 | |Commissioner and Commissionee discover each other and
connect via the discovery mode applicable for the DUT. |Commissioner and
Commissionee can discover each other and connect to each other.

|2 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|3 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |DUT arms the Fail-safe timer with success

|4 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |DUT sets the values
configured by the Commissioner

|5 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |DUT generates a new
operational key pair

|6 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |DUT is able to install Trusted Root
Certificate if needed

|7 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on DUT if needed |DUT configures the ACL with success

|8 |DUT |5.5 - 11 | |Commissioner configures operational network on DUT
if DUT both supports and requires |DUT configures the correct
operational network credentials

|9 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |DUT successfully connects
to operational network

|10 | |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |

|11 |TH |5.5 - 13 | |Commissioner starts discovery of DUT using
Operational Discovery |

|12 |DUT |5.5 - 14 | |Commissioner opens a CASE session with DUT over
operational network |DUT is able to open the CASE session with TH

|13 |DUT |5.5 - 15 | |Commissioner sends CommissioningComplete command
|DUT respond with success at CommissioningComplete command sent by TH
|===

[[_notestesting_considerations_19]]
====== link:#_notestesting_considerations_19[]Notes/Testing considerations

'''''

[[_tc_dd_3_3_user_directed_commissioning_dut_commissionee]]
===== link:#_tc_dd_3_3_user_directed_commissioning_dut_commissionee[]8.3.3. [TC-DD-3.3] User Directed Commissioning [DUT - Commissionee]

[[_category_20]]
====== link:#_category_20[]Category

Functional Conformance.

[[_purpose_21]]
====== link:#_purpose_21[]Purpose

This test case verifies that a Commissionee is able to initiate the
commissioning procedure using User Directed Commissioning.

[[_pics_20]]
====== link:#_pics_20[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.UI
* MCORE.DD.COMM_DISCOVERY

[[_preconditions_17]]
====== link:#_preconditions_17[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |User must indicate the intention for commissioning using a
display or other UI elements.

|2 | | |TH is not advertising Commissioner Discovery Service at start
|===

[[_required_devices_20]]
====== link:#_required_devices_20[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Matter Commissioner that supports Commissioner
Discovery and is already in network

|2 |DUT |DUT as a Commissionee device that is in an uncommissioned
state, supports Commissioner Discovery and has UI
|===

[[_test_procedure_20]]
====== link:#_test_procedure_20[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.3 | |DUT starts scanning for available commissioners using
Commissioner Discovery |DUT should make 4 retries and each retry should
be delayed by 100ms from the previous transmission

|2 |TH |5.3 | |TH is instructed to advertise Commissioner Discovery
service |

|3 |DUT |5.3 | |DUT starts scanning for available commissioners using
Commissioner Discovery |DUT must find the TH Commissioner Discovery
DNS-SD service

|4 |DUT |5.3 | |DUT is instructed to start the commissioning procedure
with the TH found at Step 3 |DUT should send an Identification
Declaration message to selected Commissioner

|5 |TH |5.3 | |TH verifies the Identification Declaration message a|
Identification Declaration message should have:

- protocol ID 0x0003

- protocol opcode 0x00

- Session ID field must be set to 0

- Session Type bits from Security Flags and Session ID must be set to 0

- S bit and DSIZ bits from Message Flags must be set to 0

- R bit from Exchange Flags must be set to 0

- I bit from Exchange Flags must be set to 1

- Content should be the DUT DNS-SD service instance name

|6 |TH |5.3 | |TH starts the commissioning procedure with DUT
|Commissioning procedure ends with success
|===

[[_notestesting_considerations_20]]
====== link:#_notestesting_considerations_20[]Notes/Testing considerations

Test Steps 4, 5: Out of Scope for V1.0

'''''

[[_tc_dd_3_4_user_directed_commissioning_dut_commissioner]]
===== link:#_tc_dd_3_4_user_directed_commissioning_dut_commissioner[]8.3.4. [TC-DD-3.4] User Directed Commissioning [DUT - Commissioner]

[[_category_21]]
====== link:#_category_21[]Category

Functional Conformance.

[[_purpose_22]]
====== link:#_purpose_22[]Purpose

This test case verifies that a Commissioner is able to handle the
commissioning procedure initiated by a commissionee using User Directed
Commissioning.

[[_pics_21]]
====== link:#_pics_21[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.UI
* MCORE.DD.COMM_DISCOVERY

[[_preconditions_18]]
====== link:#_preconditions_18[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |User must indicate the intention for commissioning using a
display or other UI elements.
|===

[[_required_devices_21]]
====== link:#_required_devices_21[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Matter Commissioner that supports Commissioner
Discovery and is already in network

|2 |TH |Test Harness as a Commissionee device that is in an
uncommissioned state and supports Commissioner Discovery
|===

[[_test_procedure_21]]
====== link:#_test_procedure_21[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.3 | |DUT is instructed to advertise Commissioner Discovery
service |

|2 |TH |5.3 | |TH starts scanning for available commissioners using
Commissioner Discovery |TH must find the DUT Commissioner Discovery
DNS-SD advertising using service type _matterd._udp

|3 |TH |5.3 | |TH is instructed to start the commissioning procedure
with the DUT found at Step 2 |TH should send an Identification
Declaration message to DUT

|4 |DUT |5.3 | |DUT verifies the Identification Declaration message a|
Identification Declaration message should have:

- protocol ID 0x0003

- protocol opcode 0x00

- Session ID field must be set to 0

- Session Type bits from Security Flags and Session ID must be set to 0

- S bit and DSIZ bits from Message Flags must be set to 0

- R bit from Exchange Flags must be set to 0

- I bit from Exchange Flags must be set to 1

- Content should be the DUT DNS-SD service instance name

|5 |DUT |5.3 | |By any means, DUT prompts user for onboarding payload
|DUT must request onboarding payload

|6 |DUT |5.3 | |DUT starts the commissioning procedure with TH
|Commissioning procedure ends with success
|===

[[_notestesting_considerations_21]]
====== link:#_notestesting_considerations_21[]Notes/Testing considerations

Test Steps 3, 4: Out of Scope for V1.0

'''''

[[_tc_dd_3_5_commissioning_flow_concurrent_dut_commissioner]]
===== link:#_tc_dd_3_5_commissioning_flow_concurrent_dut_commissioner[]8.3.5. [TC-DD-3.5] Commissioning Flow - Concurrent [DUT - Commissioner]

[[_category_22]]
====== link:#_category_22[]Category

End to End Conformance.

[[_purpose_23]]
====== link:#_purpose_23[]Purpose

The purpose of the following test cases is to verify the End to End
Concurrent Commissioning Flow of commissioner that can discover and
commission a device in the Matter network.

[[_pics_22]]
====== link:#_pics_22[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_19]]
====== link:#_preconditions_19[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |Commissioner is on a network. |The network can either be Wi-Fi
or Thread.

|2 |5.5 |Commissionee can either be a Matter device which is already on
a network or the test harness connected to the network. |
|===

[[_required_devices_22]]
====== link:#_required_devices_22[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a device that has Commissioner role

|2 |TH |Test Harness as a Commissionee device that is connected to an
operational network(i.e. BLE, Wi-Fi, or Ethernet) and is prepared for
commissioning
|===

[[_test_procedure_22]]
====== link:#_test_procedure_22[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.5 - 1 | |Commissioner has regulatory and fabric information
available and has accurate date, time and timezone |Check time, date and
timezone on DUT

|2 | |5.5 - 2, 5.4.3.3, 5.4.2.1 |MCORE.DD.DISCOVERY_IP a|
Commissioner and Commissionee discover each other and connect via the
discovery mode applicable for the DUT.

If (MCORE.DD.DISCOVERY_IP), TH device is advertising over IP Network
using DNS-based Service Discovery (DNS-SD)

|Commissioner and Commissionee can discover each other and connect to
each other.

|3 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|4 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |TH arm the Fail-safe timer with success

|5 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |TH set the values
configured by the Commissioner

|6 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |TH generate a new
operational key pair

|7 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |TH is able to install Trusted Root
Certificate if needed

|8 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on TH if needed |TH configure the ACL with success

|9 |DUT |5.5 - 11 | |Commissioner configures operational network on TH
if TH both supports and requires |TH configure the correct operational
network credentials

|10 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |TH successfully connect to
operational network

|12 |DUT |5.5 - 13 | |Commissioner starts discovery of TH using
Operational Discovery |

|13 |DUT |5.5 - 14 | |Commissioner opens a CASE session with TH over
operational network |TH is able to open the CASE session with DUT

|14 |DUT |5.5 - 15 | |Commissioner sends CommissioningComplete command
|TH respond with success at CommissioningComplete command sent by DUT

|15 | |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |
|===

[[_notestesting_considerations_22]]
====== link:#_notestesting_considerations_22[]Notes/Testing considerations

'''''

[[_tc_dd_3_6_commissioning_flow_non_concurrent_dut_commissioner_removed]]
===== link:#_tc_dd_3_6_commissioning_flow_non_concurrent_dut_commissioner_removed[]8.3.6. [TC-DD-3.6] Commissioning Flow - Non-concurrent [DUT - Commissioner] - REMOVED

[[_category_23]]
====== link:#_category_23[]Category

End to End Conformance.

[[_purpose_24]]
====== link:#_purpose_24[]Purpose

The purpose of the following test cases is to verify the End to End
Non-Concurrent Commissioning Flow of commissioner that can commission a
device in the Matter network.

[[_pics_23]]
====== link:#_pics_23[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_20]]
====== link:#_preconditions_20[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |Commissioner is on a network. |The network can either be Wi-Fi
or Thread.

|2 |5.5 |Commissionee is not connected to an operational network |
|===

[[_required_devices_23]]
====== link:#_required_devices_23[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a device that has Commissioner role

|2 |TH |Test Harness as a Commissionee device that is not connected to
an operational network(i.e. BLE, Wi-Fi, or Ethernet) and is prepared for
commissioning
|===

[[_test_procedure_23]]
====== link:#_test_procedure_23[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.5 - 1 | |Commissioner has regulatory and fabric information
available and has accurate date, time and timezone |Check time, date and
timezone on DUT

|2 | |5.5 - 2 | |Commissioner and Commissionee discover each other and
connect via the discovery mode applicable for the DUT. |Commissioner and
Commissionee can discover each other and connect to each other.

|3 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|4 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |TH arm the Fail-safe timer with success

|5 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |TH set the values
configured by the Commissioner

|6 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |TH generate a new
operational key pair

|7 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |TH is able to install Trusted Root
Certificate if needed

|8 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on TH if needed |TH configure the ACL with success

|9 |DUT |5.5 - 11 | |Commissioner configures operational network on TH
if TH both supports and requires |TH configure the correct operational
network credentials

|10 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |TH successfully connect to
operational network

|11 |DUT |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |

|12 |DUT |5.5 - 13 | |Commissioner starts discovery of TH using
Operational Discovery |

|13 |DUT |5.5 - 14 | |Commissioner opens a CASE session with TH over
operational network |TH is able to open the CASE session with DUT

|14 |DUT |5.5 - 15 | |Commissioner sends CommissioningComplete command
|TH respond with success at CommissioningComplete command sent by DUT
|===

[[_notestesting_considerations_23]]
====== link:#_notestesting_considerations_23[]Notes/Testing considerations

'''''

[[_tc_dd_3_7_commissioning_flow_concurrent_negative_scenario_dut_commissioner_removed]]
===== link:#_tc_dd_3_7_commissioning_flow_concurrent_negative_scenario_dut_commissioner_removed[]8.3.7. [TC-DD-3.7] Commissioning Flow - Concurrent - Negative Scenario [DUT - Commissioner] - REMOVED

[[_category_24]]
====== link:#_category_24[]Category

End to End Conformance.

[[_purpose_25]]
====== link:#_purpose_25[]Purpose

The purpose of the following test cases is to verify the End to End
Concurrent Commissioning Flow of commissioner that can commission a
device in the Matter network.

[[_pics_24]]
====== link:#_pics_24[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_21]]
====== link:#_preconditions_21[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |Commissioner is on a network. |The network can either be Wi-Fi
or Thread.

|2 |5.5 |Commissionee can either be a Matter device which is already on
a network or the test harness connected to the network. |
|===

[[_required_devices_24]]
====== link:#_required_devices_24[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Matter Commissioner device

|2 |TH |Test Harness as a Commissionee device that is connected to an
operational network(i.e. BLE, Wi-Fi, or Ethernet) and is prepared for
commissioning
|===

[[_test_procedure_24]]
====== link:#_test_procedure_24[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.5 - 1 | |Commissioner has regulatory and fabric information
available and has accurate date, time and timezone |Check time, date and
timezone on DUT

|2 | |5.5 - 2 | |Commissioner and Commissionee discover each other and
connect via the discovery mode applicable for the DUT. |Commissioner and
Commissionee can discover each other and connect to each other.

|3 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|4 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |TH arm the Fail-safe timer with success

|5 |TH |5.5.1 | |Reboot TH and prepare for commissioning |

|6 |DUT |5.5.1 | |Commissioner should return to step 2 |Commissioner and
Commissionee can discover each other and connect to each other.

|7 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|8 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |TH arm the Fail-safe timer with success

|9 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |TH set the values
configured by the Commissioner

|10 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |TH generate a new
operational key pair

|11 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |TH is able to install Trusted Root
Certificate if needed

|12 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on TH if needed |TH configure the ACL with success

|13 |DUT |5.5 - 11 | |Commissioner configures operational network on TH
if TH both supports and requires |TH configure the correct operational
network credentials

|14 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |TH successfully connect to
operational network

|15 |TH |5.5.1 | |Reboot TH |

|16 |DUT |5.5.1 | |Commissioner should return to the same state as step
13 to continue commissioning (i.e. Commissioner configure operational
network on TH if TH both supports and requires) |Commissioner configure
operational network on TH if needed

|17 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |TH successfully connect to
operational network

|18 |DUT |5.5 - 13 | |Commissioner starts discovery of TH using
Operational Discovery |

|19 |DUT |5.5 - 14 | |Commissioner opens a CASE session with TH over
operational network |TH is able to open the CASE session with DUT

|20 |DUT |5.5 - 15 | |Commissioner sends CommissioningComplete command
|TH respond with success at CommissioningComplete command sent by DUT

|21 | |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |
|===

[[_notestesting_considerations_24]]
====== link:#_notestesting_considerations_24[]Notes/Testing considerations

'''''

[[_tc_dd_3_8_commissioning_flow_non_concurrent_negative_scenario_dut_commissioner_removed]]
===== link:#_tc_dd_3_8_commissioning_flow_non_concurrent_negative_scenario_dut_commissioner_removed[]8.3.8. [TC-DD-3.8] Commissioning Flow - Non-concurrent - Negative Scenario [DUT - Commissioner] - REMOVED

[[_category_25]]
====== link:#_category_25[]Category

End to End Conformance.

[[_purpose_26]]
====== link:#_purpose_26[]Purpose

The purpose of the following test cases is to verify the End to End
Non-Concurrent Commissioning Flow of commissioner that can commission a
device in the Matter network.

[[_pics_25]]
====== link:#_pics_25[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_22]]
====== link:#_preconditions_22[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |Commissioner is on a network. |The network can either be Wi-Fi
or Thread.

|2 |5.5 |Commissionee is not connected to an operational network |
|===

[[_required_devices_25]]
====== link:#_required_devices_25[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Matter Commissioner device

|2 |TH |Test Harness as a Commissionee device that is not connected to
an operational network(i.e. BLE, Wi-Fi, or Ethernet) and is prepared for
commissioning
|===

[[_test_procedure_25]]
====== link:#_test_procedure_25[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.5 - 1 | |Commissioner has regulatory and fabric information
available and has accurate date, time and timezone |Check time, date and
timezone on DUT

|2 | |5.5 - 2 | |Commissioner and Commissionee discover each other and
connect via the discovery mode applicable for the DUT. |Commissioner and
Commissionee can discover each other and connect to each other.

|3 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|4 |DUT |5.5 - 4 | |Commissioner SHALL re-arm Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |TH arm the Fail-safe timer with success

|5 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |TH set the values
configured by the Commissioner

|6 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |TH generate a new
operational key pair

|7 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |TH is able to install Trusted Root
Certificate if needed

|8 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on TH if needed |TH configure the ACL with success

|9 |DUT |5.5 - 11 | |Commissioner configures operational network on TH
if TH both supports and requires |TH configure the correct operational
network credentials

|10 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |TH successfully connect to
operational network

|11 |DUT |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |

|12 |TH |5.5.1 | |Reboot TH and prepare for commissioning |Commissioner
should go to step 2. Commissioner and Commissionee should discover and
connect to each other.

|13 |DUT |5.5 - 3 | |Establish encryption keys with Password
Authenticated Session Establishment on the commissioning channel |DUT is
able to establish encryption keys using PASE

|14 |DUT |5.5 - 3 | |Commissioner re-arms Fail-safe timer on
Commissionee within 60s (the autonomously Fail-safe timer length set by
Commissionee) |TH arm the Fail-safe timer with success

|15 |DUT |5.5 - 5 |MCORE.COM.WIRELESS |Commissioner SHALL configure
regulatory information in the Commissionee. |TH set the values
configured by the Commissioner

|16 |DUT |5.5 - 8 | |Commissioner requests operational CSR from
Commissionee with OperationalCSRRequest command |TH generate a new
operational key pair

|17 |DUT |5.5 - 9 | |Commissioner configures operational credentials on
DUT if not previously installed |TH is able to install Trusted Root
Certificate if needed

|18 |DUT |5.5 - 10 | |Commissioner configures itself as administrator in
ACL on TH if needed |TH configure the ACL with success

|19 |DUT |5.5 - 11 | |Commissioner configures operational network on TH
if TH both supports and requires |TH configure the correct operational
network credentials

|20 |DUT |5.5 - 12 | |Commissioner instructs Commissionee to connect to
operational network if not already connected |TH successfully connect to
operational network

|21 |DUT |5.5 | |Commissioning channel between the Commissioner and
Commissionee is terminated. |

|22 |DUT |5.5 - 13 | |Commissioner starts discovery of TH using
Operational Discovery |

|23 |DUT |5.5 - 14 | |Commissioner opens a CASE session with TH over
operational network |TH is able to open the CASE session with DUT

|24 |DUT |5.5 - 15 | |Commissioner sends CommissioningComplete command
|TH respond with success at CommissioningComplete command sent by DUT
|===

[[_notestesting_considerations_25]]
====== link:#_notestesting_considerations_25[]Notes/Testing considerations

'''''

[[_tc_dd_3_9_commissioning_flow_custom_flow_2_dut_commissionee]]
===== link:#_tc_dd_3_9_commissioning_flow_custom_flow_2_dut_commissionee[]8.3.9. [TC-DD-3.9] Commissioning Flow - Custom Flow = 2 [DUT - Commissionee]

[[_category_26]]
====== link:#_category_26[]Category

End to End Conformance.

[[_purpose_27]]
====== link:#_purpose_27[]Purpose

The purpose of this test case is to verify if a device that is not a
commissioner and has a custom commissioning flow is able to complete the
commissioning procedure with success.

[[_pics_26]]
====== link:#_pics_26[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.CUSTOM_COMM_FLOW

[[_preconditions_23]]
====== link:#_preconditions_23[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Commissioner is on an operational network and has accurate date,
time, timezone, regulatory, and fabric information available. |
|===

[[_required_devices_26]]
====== link:#_required_devices_26[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as a Commissioner device acting as the Matter
commissioner.

|2 |DUT |DUT as a Commissionee device acting as a commissionee to join a
Matter network that has a custom commissioning flow.
|===

[[_device_topology_2]]
====== link:#_device_topology_2[]Device Topology

Commissioner (TH) ←→ DUT

[[_test_procedure_26]]
====== link:#_test_procedure_26[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |TH |5.7.3 | |TH receives Onboarding Payload from the DUT |Custom
Flow field from Onboarding Payload must be set to value 2.

|2 |TH |5.7.3 | |Follow any custom steps, guided by a service provided
by the DUT’s manufacturer for initial device setup, then place the DUT
Commissionee into commissioning mode. |Verify the DUT Commissionee is
advertising to be commissioned to a Matter network.

|3 |TH |5.7.3 | |DUT is commissioned by the TH |The commissioning
procedure ends with success
|===

[[_notestesting_considerations_26]]
====== link:#_notestesting_considerations_26[]Notes/Testing considerations

'''''

[[_tc_dd_3_10_commissioning_flow_custom_flow_2_dut_commissioner]]
===== link:#_tc_dd_3_10_commissioning_flow_custom_flow_2_dut_commissioner[]8.3.10. [TC-DD-3.10] Commissioning Flow - Custom Flow = 2 [DUT - Commissioner]

[[_category_27]]
====== link:#_category_27[]Category

End to End Conformance.

[[_purpose_28]]
====== link:#_purpose_28[]Purpose

The purpose of this test case is to verify if a node that acts as a
commissioner is able to properly use custom commissioning data that a
commissionee may require in order to complete the commissioning
procedure with success.

[[_pics_27]]
====== link:#_pics_27[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.CUSTOM_COMM_FLOW

[[_preconditions_24]]
====== link:#_preconditions_24[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |
|===

[[_required_devices_27]]
====== link:#_required_devices_27[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness Commissionee device acting as a commissionee to
join a Matter network that has a custom commissioning flow.
|===

[[_device_topology_3]]
====== link:#_device_topology_3[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_27]]
====== link:#_test_procedure_27[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.7.3 | |DUT receives Onboarding Payload from the TH with
Custom Flow field set to value 2 |DUT is triggered to enter the Custom
Commissioning Flow

|2 |TH |5.7.3 | |User follows any TH-specific steps to place the TH
Commissionee into commissioning mode. |Verify the TH Commissionee is
advertising to be commissioned to a Matter network.

|3 |DUT |5.7.3 | |DUT commissions TH |Commissioning of TH ends with
success
|===

[[_notestesting_considerations_27]]
====== link:#_notestesting_considerations_27[]Notes/Testing considerations

'''''

[[_tc_dd_3_11_commissioning_flow_0_standard_flow_qr_code_dut_commissioner]]
===== link:#_tc_dd_3_11_commissioning_flow_0_standard_flow_qr_code_dut_commissioner[]8.3.11. [TC-DD-3.11] Commissioning Flow = 0 (Standard Flow) - QR Code [DUT - Commissioner]

[[_category_28]]
====== link:#_category_28[]Category

End to End Conformance.

[[_purpose_29]]
====== link:#_purpose_29[]Purpose

This test case verifies that the Commissioner can scan a device
onboarding QR code, successfully parse the QR code and successfully
complete the commissioning procedure using Standard commissioning flow.

[[_pics_28]]
====== link:#_pics_28[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING
* MCORE.DD.STANDARD_COMM_FLOW

[[_preconditions_25]]
====== link:#_preconditions_25[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 a|
QR Code is printed on the Commissionee device or in additional provided
materials (ex: manual, companion app, web service).

An example onboarding QR code could be "MT:-24J029Q00KA0648G00"
(following 5.1.3 "QR Code", Table 34 "Packed Binary Data Structure for
Onboarding Payload") which includes:

- 3-bit Version String=000

- 16-bit Vendor ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier")

- 16-bit Product ID=0x8001 (as defined in section 2.5.3. "Product
Identifier")

- 2-bit Custom Flow=10 (Custom Commissioning Flow = 2)

- 8-bit Discovery Capabilities Bitmask=00000100 (OnNetwork)

- 12-bit Discriminator=0xF00

- 27-bit Passcode=20202021

- 4-bit Padding=0000

- no variable-length TLV Data included (as defined in section 5.1.3.1.
"Payload", subsection "TLV Data")

|
|===

[[_required_devices_28]]
====== link:#_required_devices_28[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_4]]
====== link:#_device_topology_4[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_28]]
====== link:#_test_procedure_28[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a |DUT |5.7.1 |MCORE.DD.DISCOVERY_BLE |Standard Commissioning Flow:
Use a Commissionee with a QR code that has the Custom Flow field set to
0 and supports BLE for its Discovery Capability. Ensure the Version bit
string follows the current Matter spec. documentation. |User has a QR
code to pass into DUT

|1.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|1.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_BLE |Using the DUT, parse the TH’s
QR code and follow any steps needed for the Commissioner/Commissionee to
complete the commissioning process using BLE |DUT parses QR code and DUT
commissions TH to the Matter network

|2.a |DUT |5.7.1 |MCORE.DD.DISCOVERY_IP |Standard Commissioning Flow:
Use a Commissionee with a QR code that has the Custom Flow field set to
0, supports IP Network for its Discovery Capability and is already on
the same IP network as the DUT commissioner. Ensure the Version bit
string follows the current Matter spec. documentation. |User has a QR
code to pass into DUT

|2.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|2.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_IP |Using the DUT, parse the TH’s
QR code and follow any steps needed for the Commissioner/Commissionee to
complete the commissioning process using IP Network |DUT parses QR code
and DUT commissions TH to the Matter network

|3.a |DUT |5.7.1 |MCORE.DD.DISCOVERY_SOFTAP |Standard Commissioning
Flow: Use a Commissionee with a QR code that has the Custom Flow field
set to 0 and supports SoftAP for its Discovery Capability. Ensure the
Version bit string follows the current Matter spec. documentation. |User
has a QR code to pass into DUT

|3.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|3.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_SOFTAP |Using the DUT, parse the
TH’s QR code and follow any steps needed for the
Commissioner/Commissionee to complete the commissioning process using
SoftAP |DUT parses QR code and DUT commissions TH to the Matter network
|===

[[_notestesting_considerations_28]]
====== link:#_notestesting_considerations_28[]Notes/Testing considerations

Test Steps 3.a, 3.b, 3.c: Out of Scope for V1.0 as they use Wi-Fi
Soft-AP Commissioning.

'''''

[[_tc_dd_3_12_commissioning_flow_1_user_intent_flow_qr_code_dut_commissioner]]
===== link:#_tc_dd_3_12_commissioning_flow_1_user_intent_flow_qr_code_dut_commissioner[]8.3.12. [TC-DD-3.12] Commissioning Flow = 1 (User-Intent Flow) - QR Code [DUT - Commissioner]

[[_category_29]]
====== link:#_category_29[]Category

End to End Conformance.

[[_purpose_30]]
====== link:#_purpose_30[]Purpose

This test case verifies that the Commissioner can scan a device
onboarding QR code, successfully parse the QR code and successfully
complete the commissioning procedure using User-Intent commissioning
flow.

[[_pics_29]]
====== link:#_pics_29[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING
* MCORE.DD.USER_INTENT_COMM_FLOW

[[_preconditions_26]]
====== link:#_preconditions_26[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 a|
QR Code is printed on the Commissionee device or in additional provided
materials (ex: manual, companion app, web service).

An example onboarding QR code could be "MT:-24J029Q00KA0648G00"
(following 5.1.3 "QR Code", Table 34 "Packed Binary Data Structure for
Onboarding Payload") which includes:

- 3-bit Version String=000

- 16-bit Vendor ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier")

- 16-bit Product ID=0x8001 (as defined in section 2.5.3. "Product
Identifier")

- 2-bit Custom Flow=10 (Custom Commissioning Flow = 2)

- 8-bit Discovery Capabilities Bitmask=00000100 (OnNetwork)

- 12-bit Discriminator=0xF00

- 27-bit Passcode=20202021

- 4-bit Padding=0000

- no variable-length TLV Data included (as defined in section 5.1.3.1.
"Payload", subsection "TLV Data")

|
|===

[[_required_devices_29]]
====== link:#_required_devices_29[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_5]]
====== link:#_device_topology_5[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_29]]
====== link:#_test_procedure_29[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a |DUT |5.7.2 |MCORE.DD.DISCOVERY_BLE |User-Intent Commissioning
Flow: Use a Commissionee with a QR code that has the Custom Flow field
set to 1 and supports BLE for its Discovery Capability. Commissionee is
NOT in commissioning mode. Ensure the Version bit string follows the
current Matter spec. documentation. |User has a QR code to pass into
DUT.

|1.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|1.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_BLE |DUT parses QR code. |Verify
DUT has parsed the QR code. Verify TH has not been commissioned to the
Matter network.

|1.d |DUT |5.1.3 |MCORE.DD.DISCOVERY_BLE |User should follow any
TH-specific steps for putting the TH Commissionee device into
commissioning mode and to complete the commissioning process using BLE.
|DUT commissions TH to the Matter network.

|2.a |DUT |5.7.2 |MCORE.DD.DISCOVERY_IP |User-Intent Commissioning Flow:
Use a Commissionee with a QR code that has the Custom Flow field set to
1 and supports IP Network for its Discovery Capability. Commissionee is
NOT in commissioning mode. Ensure the Version bit string follows the
current Matter spec. documentation. |User has a QR code to pass into
DUT.

|2.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|2.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_IP |DUT parses QR code. |Verify DUT
has parsed the QR code. Verify TH has not been commissioned to the
Matter network.

|2.d |DUT |5.1.3 |MCORE.DD.DISCOVERY_IP |User should follow any
TH-specific steps for putting the TH Commissionee device into
commissioning mode and to complete the commissioning process using IP
Network. |DUT commissions TH to the Matter network.

|3.a |DUT |5.7.2 |MCORE.DD.DISCOVERY_SOFTAP |User-Intent Commissioning
Flow: Use a Commissionee with a QR code that has the Custom Flow field
set to 1 and supports SoftAP for its Discovery Capability. Commissionee
is NOT in commissioning mode. Ensure the Version bit string follows the
current Matter spec. documentation. |User has a QR code to pass into
DUT.

|3.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|3.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_SOFTAP |DUT parses QR code. |Verify
DUT has parsed the QR code. Verify TH has not been commissioned to the
Matter network.

|3.d |DUT |5.1.3 |MCORE.DD.DISCOVERY_SOFTAP |User should follow any
TH-specific steps for putting the TH Commissionee device into
commissioning mode and to complete the commissioning process using
SoftAP. |DUT commissions TH to the Matter network.
|===

[[_notestesting_considerations_29]]
====== link:#_notestesting_considerations_29[]Notes/Testing considerations

Test Steps 3.a, 3.b, 3.c, 3.d: Out of Scope for V1.0 as they use Soft-AP
Commissioning.

'''''

[[_tc_dd_3_13_commissioning_flow_2_custom_flow_qr_code_dut_commissioner]]
===== link:#_tc_dd_3_13_commissioning_flow_2_custom_flow_qr_code_dut_commissioner[]8.3.13. [TC-DD-3.13] Commissioning Flow = 2 (Custom Flow) - QR Code [DUT - Commissioner]

[[_category_30]]
====== link:#_category_30[]Category

End to End Conformance.

[[_purpose_31]]
====== link:#_purpose_31[]Purpose

This test case verifies that the Commissioner can scan a device
onboarding QR code, successfully parse the QR code and successfully
complete the commissioning procedure using Custom commissioning flow.

[[_pics_30]]
====== link:#_pics_30[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING
* MCORE.DD.CUSTOM_COMM_FLOW

[[_preconditions_27]]
====== link:#_preconditions_27[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 a|
QR Code is printed on the Commissionee device or in additional provided
materials (ex: manual, companion app, web service).

An example onboarding QR code could be "MT:-24J029Q00KA0648G00"
(following 5.1.3 "QR Code", Table 34 "Packed Binary Data Structure for
Onboarding Payload") which includes:

- 3-bit Version String=000

- 16-bit Vendor ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier")

- 16-bit Product ID=0x8001 (as defined in section 2.5.3. "Product
Identifier")

- 2-bit Custom Flow=10 (Custom Commissioning Flow = 2)

- 8-bit Discovery Capabilities Bitmask=00000100 (OnNetwork)

- 12-bit Discriminator=0xF00

- 27-bit Passcode=20202021

- 4-bit Padding=0000

- no variable-length TLV Data included (as defined in section 5.1.3.1.
"Payload", subsection "TLV Data")

|
|===

[[_required_devices_30]]
====== link:#_required_devices_30[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_6]]
====== link:#_device_topology_6[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_30]]
====== link:#_test_procedure_30[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a |DUT |5.7.3 |MCORE.DD.DISCOVERY_BLE |Custom Commissioning Flow: Use
a Commissionee with a QR code that has the Custom Flow field set to 2
and supports BLE for its Discovery Capability. Commissionee is NOT in
commissioning mode. Ensure the Version bit string follows the current
Matter spec. documentation. |User has a QR code to pass into DUT.

|1.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|1.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_BLE |DUT parses QR code. |Verify
DUT has parsed the QR code. Verify TH has not been commissioned to the
Matter network.

|1.d |DUT |5.7.3 |MCORE.DD.DISCOVERY_BLE |User should follow any
TH-specific steps, unless the DUT has alternative means to guide the
user to successful commissioning, for putting the TH Commissionee into
commissioning mode, for triggering the DUT Commissioner for
commissioning, and for completing the commissioning process using BLE.
|DUT commissions TH to the Matter network.

|2.a |DUT |5.7.3 |MCORE.DD.DISCOVERY_IP |Custom Commissioning Flow: Use
a Commissionee with a QR code that has the Custom Flow field set to 2
and supports IP Network for its Discovery Capability. Commissionee is
NOT in commissioning mode. Ensure the Version bit string follows the
current Matter spec. documentation. |User has a QR code to pass into
DUT.

|2.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|2.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_IP |DUT parses QR code. |Verify DUT
has parsed the QR code. Verify TH has not been commissioned to the
Matter network.

|2.d |DUT |5.7.3 |MCORE.DD.DISCOVERY_IP |User should follow any
TH-specific steps, unless the DUT has alternative means to guide the
user to successful commissioning, for putting the TH Commissionee into
commissioning mode, for triggering the DUT Commissioner for
commissioning, and for completing the commissioning process using IP
Network. |DUT commissions TH to the Matter network.

|3.a |DUT |5.7.3 |MCORE.DD.DISCOVERY_SOFTAP |Custom Commissioning Flow:
Use a Commissionee with a QR code that has the Custom Flow field set to
2 and supports SoftAP for its Discovery Capability. Commissionee is NOT
in commissioning mode. Ensure the Version bit string follows the current
Matter spec. documentation. |User has a QR code to pass into DUT.

|3.b |DUT |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan the QR code from the
previous step using the DUT. |Verify the QR code has been scanned
successfully.

|3.c |DUT |5.1.3 |MCORE.DD.DISCOVERY_SOFTAP |DUT parses QR code. |Verify
DUT has parsed the QR code. Verify TH has not been commissioned to the
Matter network.

|3.d |DUT |5.7.3 |MCORE.DD.DISCOVERY_SOFTAP |User should follow any
TH-specific steps, unless the DUT has alternative means to guide the
user to successful commissioning, for putting the TH Commissionee into
commissioning mode, for triggering the DUT Commissioner for
commissioning, and for completing the commissioning process using
SoftAP. |DUT commissions TH to the Matter network.
|===

[[_notestesting_considerations_30]]
====== link:#_notestesting_considerations_30[]Notes/Testing considerations

Test Steps 3.a, 3.b, 3.c, 3.d: Out of Scope for V1.0 as they use Soft-AP
Commissioning.

'''''

[[_tc_dd_3_14_commissioning_flow_qr_code_negative_scenario_dut_commissioner]]
===== link:#_tc_dd_3_14_commissioning_flow_qr_code_negative_scenario_dut_commissioner[]8.3.14. [TC-DD-3.14] Commissioning Flow - QR Code - Negative Scenario [DUT - Commissioner]

[[_category_31]]
====== link:#_category_31[]Category

End to End Conformance.

[[_purpose_32]]
====== link:#_purpose_32[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can scan a device onboarding QR code, successfully
parse the QR code and prevent the commissioning of any devices when
scanning an invalid QR code.

[[_pics_31]]
====== link:#_pics_31[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING

[[_preconditions_28]]
====== link:#_preconditions_28[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 a|
QR Code is printed on the Commissionee device or in additional provided
materials (ex: manual, companion app, web service).

An example onboarding QR code could be "MT:-24J029Q00KA0648G00"
(following 5.1.3 "QR Code", Table 34 "Packed Binary Data Structure for
Onboarding Payload") which includes:

- 3-bit Version String=000

- 16-bit Vendor ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier")

- 16-bit Product ID=0x8001 (as defined in section 2.5.3. "Product
Identifier")

- 2-bit Custom Flow=10 (Custom Commissioning Flow = 2)

- 8-bit Discovery Capabilities Bitmask=00000100 (OnNetwork)

- 12-bit Discriminator=0xF00

- 27-bit Passcode=20202021

- 4-bit Padding=0000

- no variable-length TLV Data included (as defined in section 5.1.3.1.
"Payload", subsection "TLV Data")

|
|===

[[_required_devices_31]]
====== link:#_required_devices_31[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_7]]
====== link:#_device_topology_7[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_31]]
====== link:#_test_procedure_31[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.7.4 | |Locate and scan/read the Commissionee’s QR code using
DUT |Verify the DUT is able to scan/read the QR code

|2.a |DUT |5.1.3 | |Version String: Using the QR code from Step 1,
generate a new QR code but substituting out the current Version String
with an invalid Version String (i.e. '010' or any non-zero 3-bit value)
|User has a QR code generated to pass into DUT. Using the example
provided above, the payload would be "MT:034J029Q00KA0648G00".

|2.b |DUT |5.1.3 | |Scan/read the QR code, generated in the previous
step, using the DUT |DUT parses QR code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|3.a |DUT |5.1.3 |MCORE.DD.DISCOVERY_BLE |Using the QR code from Step 1,
ensure the TH’s Discovery Capability bit string is NOT set to BLE for
discovery (i.e. set to OnNetwork discovery capability) |User has a QR
code generated to pass into DUT. Using the example provided above, the
payload would be "MT:-24J029Q00KA0648G00".

|3.b |DUT |5.1.3 |MCORE.DD.DISCOVERY_BLE |Scan/read the QR code of the
TH device using the DUT |If TH Commissionee’s Discovery Capabilities do
not support BLE, ensure that the DUT commissions the TH onto the Matter
network over a capability that is NOT BLE. In this example, over
OnNetwork.

|4.a |DUT |5.1.7.1 | |Passcode: Using the QR code from Step 1, generate
a new QR code using all the same Onboarding Payload components except
for the Passcode. For each passcode in the following list, set the
Passcode component to one of the invalid Passcodes and generate a new QR
code using all the same Onboarding Payload components and one Passcode
from the list: 00000000, 11111111, 22222222, 33333333, 44444444,
55555555, 66666666, 77777777, 88888888, 99999999, 12345678, 87654321 a|
User has 12 QR codes (one for each passcode in the list of invalid
passcodes) generated to pass into DUT

Using the example provided above, the payloads would be:
"MT:-24J029Q00OC0000000" (00000000), "MT:-24J029Q00KMSP0Z800"
(11111111), "MT:-24J029Q00GWID1WH00" (22222222),
"MT:-24J029Q00C4912TQ00" (33333333), "MT:-24J029Q008E.Q2QZ00"
(44444444), "MT:-24J029Q004ORE3N610" (55555555),
"MT:-24J029Q000YH24KF10" (66666666), "MT:-24J029Q00Y58S4HO10"
(77777777), "MT:-24J029Q00UF-F5EX10" (88888888),
"MT:-24J029Q00QPQ36B420" (99999999), "MT:-24J029Q004QG46Y900"
(12345678), "MT:-24J029Q00YX018EW10" (87654321)

|4.b |DUT |5.1.3 | |Scan each of the generated QR codes from the
previous step using DUT |DUT parses QR code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|5.a |DUT |5.1.3 | |Prefix: Using the QR code from Step 1, generate a
new QR code but substituting out the current Prefix with an invalid
Prefix that is not 'MT:' (i.e. Prefix='AB:') |User has a QR code
generated to pass into DUT. Using the example provided above, the
payload would be "AB:-24J029Q00KA0648G00".

|5.b |DUT |5.1.3 | |Scan/read the QR code, generated in the previous
step, using the DUT |DUT commissioner does not react successfully to
scanning the QR code and DUT terminates the commissioning process in a
DUT-specific manner according to the DUT manufacturer’s instructions.
|===

[[_notestesting_considerations_31]]
====== link:#_notestesting_considerations_31[]Notes/Testing considerations

'''''

[[_tc_dd_3_15_commissioning_flow_manual_pairing_code_dut_commissioner]]
===== link:#_tc_dd_3_15_commissioning_flow_manual_pairing_code_dut_commissioner[]8.3.15. [TC-DD-3.15] Commissioning Flow - Manual Pairing Code [DUT - Commissioner]

[[_category_32]]
====== link:#_category_32[]Category

End to End Conformance.

[[_purpose_33]]
====== link:#_purpose_33[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can use a Manual Pairing Code, successfully parse the
Manual Pairing Code and complete the commissioning procedure with
success.

[[_pics_32]]
====== link:#_pics_32[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.MANUAL_PC_COMMISSIONING

[[_preconditions_29]]
====== link:#_preconditions_29[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.4.2 a|
Manual Pairing Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).

An example onboarding payload could be "34970112332" (11-digit) or could
be "749701123365521327694" (21-digit) (following 5.1.4. Table 37.
"Manual Pairing Code Elements") which each include:

- 1-bit VID_PID_PRESENT = 0 (11-digit) or = 1 (21-digit)

- 1-bit VERSION=0

- 4-bit SHORT DISCRIMINATOR=0xF00 (4 Most-significant bits of the
12-bits Discriminator value)

- 27-bit PASSCODE=20202021 (see section 5.1.6. Generation of the
Passcode)

- 16-bit VENDOR_ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier", for 21-digit Manual Pairing Code only)

- 16-bit PRODUCT_ID=0x8001 (as defined in section 2.5.3. "Product
Identifier", present if and only if VID is present)

- A generated CHECK_DIGIT (see section 5.1.4. Manual Pairing Code,
subsection "Check Digit")

|
|===

[[_required_devices_32]]
====== link:#_required_devices_32[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_8]]
====== link:#_device_topology_8[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_32]]
====== link:#_test_procedure_32[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a |DUT |5.1.4.1 |MCORE.DD.11_MANUAL_PC a|
Verify the TH’s 11-digit Manual Pairing Code meets the following
criteria:

- VERSION bit string string up to date with the current Matter spec.
documentation

- VID_PID_PRESENT bit string set to 0

|User has the TH’s 11-digit Manual Pairing Code to pass into DUT.

|1.b |DUT |5.1.4.1 |MCORE.DD.11_MANUAL_PC |Provide the Manual Pairing
Code, generated in the previous step, to the DUT in any format supported
by the DUT. Follow any steps needed for the Commissioner/Commissionee to
complete the commissioning process. |DUT parses Manual Pairing Code and
DUT commissions TH to the Matter network

|2.a |DUT |5.1.4.1 |MCORE.DD.21_MANUAL_PC a|
Verify the TH’s 21-digit Manual Pairing Code meets the following
criteria:

- A VERSION bit string string up-to-date with the current Matter spec.
documentation

- A VID_PID_PRESENT bit string set to 1

- A VENDOR_ID present (as defined in section 2.5.2. "Vendor Identifier")

- A PRODUCT_ID present (as defined in section 2.5.3. "Product
Identifier")

|User has a Manual Pairing Code to pass into DUT

|2.b |DUT |5.1.4.1 |MCORE.DD.21_MANUAL_PC |Provide the Manual Pairing
Code, generated in the previous step, to the DUT in any format supported
by the DUT. Follow any steps needed for the Commissioner/Commissionee to
complete the commissioning process. |DUT parses Manual Pairing Code and
DUT commissions TH to the Matter network
|===

[[_notestesting_considerations_32]]
====== link:#_notestesting_considerations_32[]Notes/Testing considerations

'''''

[[_tc_dd_3_16_commissioning_flow_11_digit_manual_pairing_code_negative_scenario_dut_commissioner]]
===== link:#_tc_dd_3_16_commissioning_flow_11_digit_manual_pairing_code_negative_scenario_dut_commissioner[]8.3.16. [TC-DD-3.16] Commissioning Flow - 11-digit Manual Pairing Code - Negative Scenario [DUT - Commissioner]

[[_category_33]]
====== link:#_category_33[]Category

End to End Conformance.

[[_purpose_34]]
====== link:#_purpose_34[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can take an 11-digit Manual Pairing Code, successfully
parse the Manual Pairing Code and prevent the commissioning of any
devices when the Manual Pairing Code is invalid.

[[_pics_33]]
====== link:#_pics_33[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.11_MANUAL_PC

[[_preconditions_30]]
====== link:#_preconditions_30[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.4.2 a|
11-digit Manual Pairing Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).

An example onboarding payload could be "34970112332" (following 5.1.4.
Table 37. "Manual Pairing Code Elements") which each include:

- 1-bit VID_PID_PRESENT = 0 (11-digit only)

- 1-bit VERSION=0

- 4-bit SHORT DISCRIMINATOR=0xF00 (4 Most-significant bits of the
12-bits Discriminator value)

- 27-bit PASSCODE=20202021 (see section 5.1.6. Generation of the
Passcode)

- 16-bit VENDOR_ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier", for 21-digit Manual Pairing Code only)

- 16-bit PRODUCT_ID=0x8001 (as defined in section 2.5.3. "Product
Identifier", present if and only if VID is present)

- A generated CHECK_DIGIT (see section 5.1.4. Manual Pairing Code,
subsection "Check Digit")

|
|===

[[_required_devices_33]]
====== link:#_required_devices_33[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_9]]
====== link:#_device_topology_9[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_33]]
====== link:#_test_procedure_33[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.7.4 | |Provide the 11-digit Manual Pairing Code from the
Commissionee to the DUT in any format supported by DUT |Verify that the
Manual Pairing Code can be provided to DUT

|2.a |DUT |5.1.4.1 | |VERSION: Using the manual code from Step 1,
generate a new manual code but substituting out the current VERSION with
an invalid VERSION: 2 |User has a manual code generated to pass into
DUT. The generated Manual Pairing Code follows all guidelines laid out
in the Preconditions #2, above, with special attention to the
CHECK_DIGIT using the Verhoeff algorithm. Using the example provided
above, the payload would be "84970112331".

|2.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|3.a |DUT |5.1.4.1 | |VID_PID_PRESENT: Using the manual code from Step
1, generate a new manual code but substituting out the current
VID_PID_PRESENT with an invalid VID_PID_PRESENT set to 1 |User has a
manual code generated to pass into DUT. The generated Manual Pairing
Code follows all guidelines laid out in the Preconditions #2, above,
with special attention to the CHECK_DIGIT using the Verhoeff algorithm.
Using the example provided above, the payload would be "74970112334".

|3.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|4.a |DUT |5.1.4.1 | |SHORT DISCRIMINATOR: Using the manual code from
Step 1, generate a new manual code but substituting out the current
SHORT DISCRIMINATOR string with a discriminator value that makes the
generated manual code differ from Step 1’s manual code (i.e. Choose a
discriminator value that changes any of the 4 most-significant bits of
Step 1’s 12-bit discriminator value and adheres to rules of section
5.1.1.5. "Discriminator value") |User has a manual code generated to
pass into DUT. The generated Manual Pairing Code follows all guidelines
laid out in the Preconditions #2, above, with special attention to the
CHECK_DIGIT using the Verhoeff algorithm. Using the example provided
above, for a SHORT DISCRIMINATOR=0xE00, the payload would be
"33331712336".

|4.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|5.a |DUT |5.1.7.1 | |Passcode: Using the manual code from Step 1,
generate a new manual code using all the same Onboarding Payload
components except for the Passcode. For each Passcode in the following
list, set the Passcode component to one of the invalid Passcode and
generate a new manual code using all the same Onboarding Payload
components and one Passcode from the list: 00000000, 11111111, 22222222,
33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999,
12345678, 87654321 a|
User has 12 manual codes (one for each passcode in the list of invalid
passcodes) generated to pass into DUT. The generated Manual Pairing Code
follows all guidelines laid out in the Preconditions #2, above, with
special attention to the CHECK_DIGIT using the Verhoeff algorithm.

Using the example provided above, the payloads would be: "34915200008"
(00000000), "35191106788" (11111111), "35467013565" (22222222),
"35742920344" (33333333), "36018827124" (44444444), "36294733900"
(55555555), "34932240691" (66666666), "35208147474" (77777777),
"35484054250" (88888888), "35759961037" (99999999), "35767807533"
(12345678), "36545753496" (87654321)

|5.b |DUT |5.7.4 | |Provide each of the Manual Pairing Codes, generated
in the previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|6.a |DUT |5.1.4.1 | |CHECK_DIGIT: Using the manual code from Step 1,
generate a new manual code but substituting out the current CHECK_DIGIT
with an invalid CHECK_DIGIT (i.e. Any different CHECK_DIGIT than the
commissionee’s CHECK_DIGIT while following Table 38. Encoding Method
without Vendor and Product ID’s (VID_PID_Present == 0)) |User has a
manual code generated to pass into DUT. The generated Manual Pairing
Code follows all guidelines laid out in the Preconditions #2, above,
with special attention to the CHECK_DIGIT using the Verhoeff algorithm.
Using the example provided above, the payload would be "34970112331".

|6.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.
|===

[[_notestesting_considerations_33]]
====== link:#_notestesting_considerations_33[]Notes/Testing considerations

'''''

[[_tc_dd_3_17_commissioning_flow_21_digit_manual_pairing_code_negative_scenario_dut_commissioner]]
===== link:#_tc_dd_3_17_commissioning_flow_21_digit_manual_pairing_code_negative_scenario_dut_commissioner[]8.3.17. [TC-DD-3.17] Commissioning Flow - 21-digit Manual Pairing Code - Negative Scenario [DUT - Commissioner]

[[_category_34]]
====== link:#_category_34[]Category

End to End Conformance.

[[_purpose_35]]
====== link:#_purpose_35[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can take a 21-digit Manual Pairing Code, successfully
parse the Manual Pairing Code and prevent the commissioning of any
devices when the Manual Pairing Code is invalid.

[[_pics_34]]
====== link:#_pics_34[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.21_MANUAL_PC

[[_preconditions_31]]
====== link:#_preconditions_31[]Preconditions

[width="100%",cols="10%,10%,60%,20%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.4.2 a|
21-digit Manual Pairing Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).

An example onboarding payload could be "749701123365521327694"
(21-digit) (following 5.1.4. Table 37. "Manual Pairing Code Elements")
which each include:

- 1-bit VID_PID_PRESENT = 1 (21-digit only)

- 1-bit VERSION=0

- 4-bit SHORT DISCRIMINATOR=0xF00 (4 Most-significant bits of the
12-bits Discriminator value)

- 27-bit PASSCODE=20202021 (see section 5.1.6. Generation of the
Passcode)

- 16-bit VENDOR_ID=0xFFF1 (as defined in section 2.5.2. "Vendor
Identifier", for 21-digit Manual Pairing Code only)

- 16-bit PRODUCT_ID=0x8001 (as defined in section 2.5.3. "Product
Identifier", present if and only if VID is present)

- A generated CHECK_DIGIT (see section 5.1.4. Manual Pairing Code,
subsection "Check Digit")

|
|===

[[_required_devices_34]]
====== link:#_required_devices_34[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device acting as a commissionee
to join a Matter network.
|===

[[_device_topology_10]]
====== link:#_device_topology_10[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_34]]
====== link:#_test_procedure_34[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |DUT |5.7.4 | |Provide the 21-digit Manual Pairing Code from the
Commissionee to the DUT in any format supported by DUT |Verify that the
Manual Pairing Code can be provided to DUT

|2.a |DUT |5.1.4.1 | |VERSION: Using the manual code from Step 1,
generate a new manual code but substituting out the current VERSION with
an invalid VERSION: 2 |User has a manual code generated to pass into
DUT. The generated Manual Pairing Code follows all guidelines laid out
in the Preconditions #2, above, with special attention to the
CHECK_DIGIT using the Verhoeff algorithm. Using the example provided
above, the payload would be "849701123365521327693".

|2.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|3.a |DUT |5.1.4.1 | |VID_PID_PRESENT: Using the manual code from Step
1, generate a new manual code but substituting out the current
VID_PID_PRESENT with an invalid VID_PID_PRESENT set to 0 |User has a
manual code generated to pass into DUT. The generated Manual Pairing
Code follows all guidelines laid out in the Preconditions #2, above,
with special attention to the CHECK_DIGIT using the Verhoeff algorithm.
Using the example provided above, the payload would be
"349701123365521327696".

|3.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|4.a |DUT |5.1.4.1 | |SHORT DISCRIMINATOR: Using the manual code from
Step 1, generate a new manual code but substituting out the current
SHORT DISCRIMINATOR string with a discriminator value that makes the
generated manual code differ from Step 1’s manual code (i.e. Choose a
discriminator value that changes any of the 4 most-significant bits of
Step 1’s 12-bit discriminator value and adheres to rules of section
5.1.1.5. "Discriminator value") |User has a manual code generated to
pass into DUT. The generated Manual Pairing Code follows all guidelines
laid out in the Preconditions #2, above, with special attention to the
CHECK_DIGIT using the Verhoeff algorithm. Using the example provided
above, for a SHORT DISCRIMINATOR=0xE00, the payload would be
"733317123365521327692".

|4.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|5.a |DUT |5.1.7.1 | |Passcode: Using the manual code from Step 1,
generate a new manual code using all the same Onboarding Payload
components except for the Passcode. For each Passcode in the following
list, set the Passcode component to one of the invalid Passcode and
generate a new manual code using all the same Onboarding Payload
components and one Passcode from the list: 00000000, 11111111, 22222222,
33333333, 44444444, 55555555, 66666666, 77777777, 88888888, 99999999,
12345678, 87654321 a|
User has 12 manual codes (one for each passcode in the list of invalid
passcodes) generated to pass into DUT. The generated Manual Pairing Code
follows all guidelines laid out in the Preconditions #2, above, with
special attention to the CHECK_DIGIT using the Verhoeff algorithm.

Using the example provided above, the payloads would be:
"749152000065521327698" (00000000), "751911067865521327698" (11111111),
"754670135665521327694" (22222222), "757429203465521327699" (33333333),
"760188271265521327697" (44444444), "762947339065521327695" (55555555),
"749322406965521327695" (66666666), "752081474765521327697" (77777777),
"754840542565521327693" (88888888), "757599610365521327695" (99999999),
"757678075365521327695" (12345678), "765457534965521327696" (87654321)

|5.b |DUT |5.7.4 | |Provide each of the Manual Pairing Codes, generated
in the previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|6.a |DUT |5.1.4.1 | |VENDOR_ID: Using the manual code from Step 1,
generate a new manual code using all the same Onboarding Payload
components except for the VENDOR_ID. For each VENDOR_ID in the following
list, set the VENDOR_ID component to one of the invalid Test VENDOR_IDs
and generate a new manual code using all the same Onboarding Payload
components and one Test VENDOR_ID from the list: 0xFFF1, 0xFFF2, 0xFFF3,
0xFFF4 a|
User has 4 manual codes (one for each VENDOR_ID in the list of invalid
VENDOR_IDs) generated to pass into DUT. The generated Manual Pairing
Codes follows all guidelines laid out in the Preconditions #2, above,
with special attention to the CHECK_DIGIT using the Verhoeff algorithm.

Using the example provided above, the payloads would be :

"749701123365521327694" (0xFFF1), "749701123365522327692" (0xFFF2),
"749701123365523327697" (0xFFF3), "749701123365524327693" (0xFFF4),

|6.b |DUT |5.7.4 | |Provide each of the Manual Pairing Codes, generated
in the previous step, to the DUT in any format supported by the DUT |If
the TH’s Vendor ID is an invalid Test Vendor ID, DUT attempts to parse
the Manual Pairing Code and DUT terminates the commissioning process in
a DUT-specific manner according to the DUT manufacturer’s instructions,
unless the user is made fully aware of the security risks of providing
an uncertified device with operational and networking credentials.

|7.a |DUT |5.1.4.1 | |PRODUCT_ID: Using the manual code from Step 1,
generate a new manual code but substituting out the current PRODUCT_ID
with an invalid PRODUCT_ID of 0x0000(i.e. While following section 2.5.3.
"Product Identifier") |User has a manual code generated to pass into
DUT. The generated Manual Pairing Code follows all guidelines laid out
in the Preconditions #2, above, with special attention to the
CHECK_DIGIT using the Verhoeff algorithm. Using the example provided
above, the payload would be "749701123365521000006".

|7.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.

|8.a |DUT |5.1.4.1 | |Check Digit: Using the manual code from Step 1,
generate a new manual code but substituting out the current CHECK_DIGIT
with an invalid CHECK_DIGIT (i.e. Any different CHECK_DIGIT than the
commissionee’s CHECK_DIGIT while following Table 39. Encoding Method
with Vendor and Product ID’s included (VID_PID_Present == 1)) |User has
a manual code generated to pass into DUT. The generated Manual Pairing
Code follows all guidelines laid out in the Preconditions #2, above,
with special attention to the CHECK_DIGIT using the Verhoeff algorithm.
Using the example provided above, the payload would be
"749701123365521327693".

|8.b |DUT |5.7.4 | |Provide the Manual Pairing Code, generated in the
previous step, to the DUT in any format supported by the DUT |DUT
attempts to parse the Manual Pairing Code and DUT terminates the
commissioning process in a DUT-specific manner according to the DUT
manufacturer’s instructions.
|===

[[_notestesting_considerations_34]]
====== link:#_notestesting_considerations_34[]Notes/Testing considerations

'''''

[[_tc_dd_3_18_commissioning_flow_commissioning_multiple_devices_dut_commissioner]]
===== link:#_tc_dd_3_18_commissioning_flow_commissioning_multiple_devices_dut_commissioner[]8.3.18. [TC-DD-3.18] Commissioning Flow - Commissioning Multiple Devices [DUT - Commissioner]

[[_category_35]]
====== link:#_category_35[]Category

End to End Conformance.

[[_purpose_36]]
====== link:#_purpose_36[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can successfully commission multiple devices onto a
Matter network.

[[_pics_35]]
====== link:#_pics_35[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING

[[_preconditions_32]]
====== link:#_preconditions_32[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 |QR Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).
|
|===

[[_required_devices_35]]
====== link:#_required_devices_35[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH1 |Test Harness 1 as a Commissionee device with its Onboarding
payload QR code printed on the device or in additional provided
materials (ex: manual)

|3 |TH2 |Test Harness 2 as a Commissionee device with its Onboarding
payload QR code printed on the device or in additional provided
materials (ex: manual)
|===

[[_device_topology_11]]
====== link:#_device_topology_11[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_35]]
====== link:#_test_procedure_35[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1.a | | | |Place TH1 into commissioning mode using the TH
manufacturer’s means to be discovered by a commissioner |Verify that TH1
is advertising and able to be discovered by a commissioner.

|1.b | | | |Place TH2 into commissioning mode using the TH
manufacturer’s means to be discovered by a commissioner |Verify that TH2
is advertising and able to be discovered by a commissioner.

|2.a | |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan TH1’s QR code using the DUT
Commissioner. |Verify the QR code has been scanned successfully.

|2.b | |5.1.3 | |DUT parses TH1’s QR code. Follow any steps needed for
the Commissioner/Commissionee to complete the commissioning process over
the TH Commissionee’s method of device discovery a|
DUT parses TH1’s QR code and DUT commissions TH1 onto the Matter
network.

- Verify that only TH1 has been commissioned onto the Matter network and
that TH2 has not been commissioned.

|3.a | |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan TH2’s QR code using the DUT
Commissioner. |Verify the QR code has been scanned successfully.

|3.b | |5.1.3 | |DUT parses TH2’s QR code. Follow any steps needed for
the Commissioner/Commissionee to complete the commissioning process over
the TH Commissionee’s method of device discovery a|
DUT parses TH2’s QR code and DUT commissions TH2 onto the Matter
network.

- Verify that only TH2 has been commissioned onto the Matter network in
this step.

|4.a | | | |Verify the Commissioner can still interact with TH1 (ex:
Read any cluster’s attribute from TH1) |Verify TH1 remains commissioned
onto the Matter network.

|4.b | | | |Verify the Commissioner can still interact with TH2 (ex:
Read any cluster’s attribute from TH2) |Verify TH2 remains commissioned
onto the Matter network.
|===

[[_notestesting_considerations_35]]
====== link:#_notestesting_considerations_35[]Notes/Testing considerations

'''''

[[_tc_dd_3_19_commissioning_flow_commission_unpair_and_re_commission_device_dut_commissionee]]
===== link:#_tc_dd_3_19_commissioning_flow_commission_unpair_and_re_commission_device_dut_commissionee[]8.3.19. [TC-DD-3.19] Commissioning Flow - Commission, Unpair and Re-commission Device [DUT - Commissionee]

[[_category_36]]
====== link:#_category_36[]Category

End to End Conformance.

[[_purpose_37]]
====== link:#_purpose_37[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissionee can successfully be commissioned onto a Matter network,
unpaired from that Matter network and re-commissioned back onto a Matter
network.

[[_pics_36]]
====== link:#_pics_36[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.QR

[[_preconditions_33]]
====== link:#_preconditions_33[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |Commissioner is on an operational network and has accurate date,
time, timezone, regulatory, and fabric information available. |

|2 |5.1.3 |QR Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).
|
|===

[[_required_devices_36]]
====== link:#_required_devices_36[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissionee device with its Onboarding payload QR
code printed on the device or in additional provided materials (ex:
manual)

|2 |TH |Test Harness as a Commissioner device acting as the Matter
commissioner.
|===

[[_device_topology_12]]
====== link:#_device_topology_12[]Device Topology

DUT ←→ Commissioner

[[_test_procedure_36]]
====== link:#_test_procedure_36[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | | |Place DUT into commissioning mode using the DUT’s
manufacturer’s means to be discovered by the TH Commissioner |Verify
that the DUT is advertising and able to be discovered by a commissioner.

|2 | |5.1.3 | |Scan DUT’s QR code using the TH Commissioner. Follow any
steps needed for the Commissioner/Commissionee to complete the
commissioning process over the DUT Commissionee’s method of device
discovery a|
TH parses DUT’s QR code and TH commissions DUT to the Matter network.

- Verify that the DUT has been commissioned onto the Matter network.

|3 | | | |Using TH Commissioner, unpair the DUT Commissionee from the
Matter network. |Verify the DUT is no longer on the Matter network.

|4 | | | |Place DUT Commissionee back into commissioning mode using the
DUT manufacturer’s means to be discovered by the TH Commissioner |Verify
that the DUT is advertising and able to be discovered by a commissioner.

|5 | |5.1.3 | |Scan DUT’s QR code using the TH Commissioner. Follow any
steps needed for the Commissioner/Commissionee to complete the
commissioning process over the DUT Commissionee’s method of device
discovery a|
TH parses DUT’s QR code and TH commissions DUT to the Matter network.

- Verify that the DUT has been commissioned onto the Matter network.

|===

[[_notestesting_considerations_36]]
====== link:#_notestesting_considerations_36[]Notes/Testing considerations

'''''

[[_tc_dd_3_20_commissioning_flow_commission_unpair_and_re_commission_device_dut_commissioner]]
===== link:#_tc_dd_3_20_commissioning_flow_commission_unpair_and_re_commission_device_dut_commissioner[]8.3.20. [TC-DD-3.20] Commissioning Flow - Commission, Unpair and Re-commission Device [DUT - Commissioner]

[[_category_37]]
====== link:#_category_37[]Category

End to End Conformance.

[[_purpose_38]]
====== link:#_purpose_38[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can successfully commission a device onto a Matter
network, unpair the device from the Matter network and re-commission the
device onto a Matter network.

[[_pics_37]]
====== link:#_pics_37[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING

[[_preconditions_34]]
====== link:#_preconditions_34[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 |QR Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).
|
|===

[[_required_devices_37]]
====== link:#_required_devices_37[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee device with its Onboarding
payload QR code printed on the device or in additional provided
materials (ex: manual)
|===

[[_device_topology_13]]
====== link:#_device_topology_13[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_37]]
====== link:#_test_procedure_37[]Test Procedure

[width="100%",cols="10%,5%,5%,20%,30%,30%",options="header",]
|===
|*#* |*Device* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | | |Place TH into commissioning mode using the TH manufacturer’s
means to be discovered by the DUT Commissioner |Verify that the TH is
advertising and able to be discovered by a commissioner.

|2.a | |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan TH’s QR code using the DUT
Commissioner. |Verify the QR code has been scanned successfully.

|2.b | |5.1.3 | |DUT parses TH’s QR code. Follow any steps needed for
the Commissioner/Commissionee to complete the commissioning process over
the TH Commissionee’s method of device discovery a|
DUT parses TH’s QR code and DUT commissions TH to the Matter network.

- Verify that the TH has been commissioned onto the Matter network.

|3 | | | |Using DUT Commissioner, unpair the TH Commissionee from the
Matter network. |Verify the TH is no longer on the Matter network.

|4 | | | |Place TH Commissionee back into commissioning mode using the
TH manufacturer’s means to be discovered by the DUT Commissioner |Verify
that the TH is advertising and able to be discovered by a commissioner.

|5.a | |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan TH’s QR code using the DUT
Commissioner. |Verify the QR code has been scanned successfully.

|5.b | |5.1.3 | |DUT parses TH’s QR code. Follow any steps needed for
the Commissioner/Commissionee to complete the commissioning process over
the TH Commissionee’s method of device discovery a|
DUT parses TH’s QR code and DUT commissions TH to the Matter network.

- Verify that the TH has been commissioned onto the Matter network.

|===

[[_notestesting_considerations_37]]
====== link:#_notestesting_considerations_37[]Notes/Testing considerations

'''''

[[_tc_dd_3_21_commissioning_flow_commission_multiple_endpoint_device_dut_commissioner]]
===== link:#_tc_dd_3_21_commissioning_flow_commission_multiple_endpoint_device_dut_commissioner[]8.3.21. [TC-DD-3.21] Commissioning Flow - Commission Multiple-Endpoint Device [DUT - Commissioner]

[[_category_38]]
====== link:#_category_38[]Category

End to End Conformance.

[[_purpose_39]]
====== link:#_purpose_39[]Purpose

This test case verifies End to End Commissioning Flows and ensures that
the Commissioner can successfully commission a device with multiple
endpoints onto a Matter network.

[[_pics_38]]
====== link:#_pics_38[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.QR_COMMISSIONING

[[_preconditions_35]]
====== link:#_preconditions_35[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is on an operational network and has accurate date, time,
timezone, regulatory, and fabric information available. |

|2 |5.1.3 |QR Code is printed on the Commissionee device or in
additional provided materials (ex: manual, companion app, web service).
|
|===

[[_required_devices_38]]
====== link:#_required_devices_38[]Required Devices

[width="100%",cols="15%,15%,70%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as a Commissioner device acting as the Matter commissioner.

|2 |TH |Test Harness as a Commissionee with its Onboarding payload QR
code printed on the device or in additional provided materials (ex:
manual). Commissionee implements the On/Off light device type on at
least 2 (non-zero) endpoints. For example, TH implements the On/Off
light device type on endpoints 2 and 4.
|===

[[_device_topology_14]]
====== link:#_device_topology_14[]Device Topology

DUT ←→ Commissionee

[[_test_procedure_38]]
====== link:#_test_procedure_38[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Place TH into commissioning mode using the TH manufacturer’s
means to be discovered by the DUT Commissioner |Verify that the TH is
advertising and able to be discovered by the DUT commissioner.

|2.a |5.1.3 |MCORE.DD.SCAN_QR_CODE |Scan TH’s QR code using the DUT
Commissioner. |Verify the QR code has been scanned successfully.

|2.b |5.1.3 | |DUT parses TH’s QR code. Follow any steps needed for the
Commissioner/Commissionee to complete the commissioning process over the
TH Commissionee’s method of device discovery a|
DUT parses TH’s QR code and DUT commissions TH to the Matter network.

- Verify that the TH has been commissioned onto the Matter network.

|3 | | |For each TH Endpoint that implements the On/Off light device,
verify that the DUT acknowledges the existence of the Endpoint through
DUT issuing an On command to the respective Endpoint (e.g. through some
user action to trigger such command). |TH verifies that the DUT has
successfully sent the On command to each of the endpoints which expose
an On/Off light device type.
|===

[[_notestesting_considerations_38]]
====== link:#_notestesting_considerations_38[]Notes/Testing considerations

'''''

[[_basic_information_test_plan]]
== link:#_basic_information_test_plan[]**Basic Information Test Plan**

[[_pics_definition_3]]
=== link:#_pics_definition_3[]9. PICS Definition

This section covers the Device Management related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_2]]
==== link:#_role_2[]9.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BINFO.S |Does the device implement the Basic Information Cluster as a
server? |M |
|===

[[_server]]
==== link:#_server[]9.2. Server

[[_attributes]]
===== link:#_attributes[]9.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BINFO.S.A0000(DataModelRevision) |Does the DUT(server) support the
DataModelRevision attribute? |M |

|BINFO.S.A0001(VendorName) |Does the DUT(server) support the VendorName
attribute? |M |

|BINFO.S.A0002(VendorID) |Does the DUT(server) support the VendorID
attribute? |M |

|BINFO.S.A0003(ProductName) |Does the DUT(server) support the
ProductName attribute? |M |

|BINFO.S.A0004(ProductID) |Does the DUT(server) support the ProductID
attribute? |M |

|BINFO.S.A0005(NodeLabel) |Does the DUT(server) support the NodeLabel
attribute? |M |

|BINFO.S.A0006(Location) |Does the DUT(server) support the Location
attribute? |M |

|BINFO.S.A0007(HardwareVersion) |Does the DUT(server) support the
HardwareVersion attribute? |M |

|BINFO.S.A0008(HardwareVersionString) |Does the DUT(server) support the
HardwareVersionString attribute? |M |

|BINFO.S.A0009(SoftwareVersion) |Does the DUT(server) support the
SoftwareVersion attribute? |M |

|BINFO.S.A000a(SoftwareVersionString) |Does the DUT(server) support the
SoftwareVersionString attribute? |M |

|BINFO.S.A000b(ManufacturingDate) |Does the DUT(server) support the
ManufacturingDate attribute? |O |

|BINFO.S.A000c(PartNumber) |Does the DUT(server) support the PartNumber
attribute? |O |

|BINFO.S.A000d(ProductURL) |Does the DUT(server) support the ProductURL
attribute? |O |

|BINFO.S.A000e(ProductLabel) |Does the DUT(server) support the
ProductLabel attribute? |O |

|BINFO.S.A000f(SerialNumber) |Does the DUT(server) support the
SerialNumber attribute? |O |

|BINFO.S.A0010(LocalConfigDisabled) |Does the DUT(server) support the
LocalConfigDisabled attribute? |O |

|BINFO.S.A0011(Reachable) |Does the DUT(server) support the Reachable
attribute? |O |

|BINFO.S.A0012(UniqueID) |Does the DUT(server) support the UniqueID
attribute? |O |

|BINFO.S.A0013(CapabilityMinima) |Does the DUT(server) support the
CapabilityMinima attribute? |M |

|BINFO.S.A0014(ProductAppearance) |Does the DUT(server) support the
ProductAppearance attribute? |O |
|===

[[_events]]
===== link:#_events[]9.2.2. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BINFO.S.E00(StartUp) |Does the DUT(server) support the StartUp event?
|M |

|BINFO.S.E01(ShutDown) |Does the DUT(server) support the ShutDown event?
|O |

|BINFO.S.E02(Leave) |Does the DUT(server) support the Leave event? |O |

|BINFO.S.E03(ReachableChanged) |Does the DUT(server) support the
ReachableChanged event? |BINFO.S.A0011(Reachable) |
|===

[[_pixit_definition]]
=== link:#_pixit_definition[]10. PIXIT Definition

This section covers the Basic Information Cluster’s Test Plan related
PIXIT items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.BINFO.PrimaryColor |ProductAppearance.PrimaryColor should reflect
the product’s color |BINFO.S.A0014(ProductAppearance) |

|PIXIT.BINFO.Finish |ProductAppearance.Finish should reflect the
product’s finish |BINFO.S.A0014(ProductAppearance) |
|===

[[_test_case_list_2]]
=== link:#_test_case_list_2[]11. Test Case List

[width="100%",cols="20%,80%",]
|===
|*TC UUID* |*Test Case Name*
|TC-BINFO-1.1 |Global Attributes with DUT as Server
|TC-BINFO-2.1 |Attributes [DUT-Server]
|TC-BINFO-2.2 |Events [DUT-Server]
|TC-BINFO-3.1 |Appearance Attribute DUT as Server
|===

[[_test_cases_2]]
=== link:#_test_cases_2[]12. Test Cases

'''''

[[_generic_test_cases]]
==== link:#_generic_test_cases[]12.1. Generic Test Cases

'''''

[[_tc_binfo_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_binfo_1_1_global_attributes_with_dut_as_server[]12.1.1. [TC-BINFO-1.1] Global Attributes with DUT as Server

[[_category_39]]
====== link:#_category_39[]Category

Functional conformance.

[[_purpose_40]]
====== link:#_purpose_40[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_39]]
====== link:#_pics_39[]PICS

* BINFO.S

[[_required_devices_39]]
====== link:#_required_devices_39[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_39]]
====== link:#_test_procedure_39[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008,
0x0009, 0x000a, 0x0013, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x000b: SHALL be included if and only if
BINFO.S.A000b(ManufacturingDate)

- 0x000c: SHALL be included if and only if BINFO.S.A000c(PartNumber)

- 0x000d: SHALL be included if and only if BINFO.S.A000d(ProductURL)

- 0x000e: SHALL be included if and only if BINFO.S.A000e(ProductLabel)

- 0x000f: SHALL be included if and only if BINFO.S.A000f(SerialNumber)

- 0x0010: SHALL be included if and only if
BINFO.S.A0010(LocalConfigDisabled)

- 0x0011: SHALL be included if and only if BINFO.S.A0011(Reachable)

- 0x0012: SHALL be included if and only if BINFO.S.A0012(UniqueID)

- 0x0014: SHALL be included if and only if
BINFO.S.A0014(ProductAppearance)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list SHALL include all the mandatory entries: +
0x00.

The list MAY include these optional entries: +
- 0x01: SHALL be included if and only if BINFO.S.E01(ShutDown)

- 0x02: SHALL be included if and only if BINFO.S.E02(Leave)

The list include entries based on attribute support: +
- 0x03: SHALL be included if and only if BINFO.S.A0011(Reachable)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_39]]
====== link:#_notestesting_considerations_39[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_dut_as_server]]
==== link:#_dut_as_server[]12.2. DUT as Server

'''''

[[_tc_binfo_2_1_attributes_dut_server]]
===== link:#_tc_binfo_2_1_attributes_dut_server[]12.2.1. [TC-BINFO-2.1] Attributes [DUT-Server]

[[_category_40]]
====== link:#_category_40[]Category

Functional conformance

[[_purpose_41]]
====== link:#_purpose_41[]Purpose

Verify if all the server attributes have been implemented correctly on
the DUT.

[[_pics_40]]
====== link:#_pics_40[]PICS

* BINFO.S

[[_precondition]]
====== link:#_precondition[]Precondition

[width="100%",cols="10%,14%,38%,38%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Commission DUT to TH |
|===

[[_required_devices_40]]
====== link:#_required_devices_40[]Required Devices

[width="100%",cols="9%,30%,61%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness that will query/modify for Basic Information
cluster attributes.

|2 |DUT |DUT which will be queried.
|===

[[_device_topology_15]]
====== link:#_device_topology_15[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_6]]
====== link:#_test_setup_6[]Test Setup

This will describe how to set up for testing.

[[_test_procedure_40]]
====== link:#_test_procedure_40[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.17.7.8 | |During Commissioning, TH Saves the CountryCode
Information from SetRegulatoryConfig command |

|2 |11.1.6.1-0, 7.18.1.3 |BINFO.S.A0000(DataModelRevision) |After
Commissioning, TH reads DataModelRevision from the DUT. |Verify that the
value is in the range of 0 to 65534

|3 | |BINFO.S.A0000(DataModelRevision) |TH writes DataModelRevision as
"0x1124" |Verify DUT responds with UNSUPPORTED_WRITE

|4 | |BINFO.S.A0000(DataModelRevision) |TH reads DataModelRevision from
the DUT |Verify that the DataModelRevision remains unchanged

|5 |11.1.6.1-1 |BINFO.S.A0001(VendorName) |TH reads VendorName from the
DUT. a|
Verify it is of type string.

Verify it is less than or equal to 32 bytes and meaningful name matching
the manufacturer of the product.

|6 | |BINFO.S.A0001(VendorName) |TH writes VendorName as "sample"
|Verify DUT responds with UNSUPPORTED_WRITE

|7 | |BINFO.S.A0001(VendorName) |TH reads VendorName |Verify that the
VendorName remains unchanged

|8 |11.1.6.1-2, 2.5.2, 6.1.3.1 |BINFO.S.A0002(VendorID) |TH reads
VendorID from the DUT. a|
Verify that value is not 0x0000

Verify that the value is in the range of 0x0001 to 0xFFF0, and matches
the value assigned to this manufacturer

|9 | |BINFO.S.A0002(VendorID) |TH writes VendorID as "0x0011" |Verify
DUT responds with UNSUPPORTED_WRITE

|10 | |BINFO.S.A0002(VendorID) |TH reads VendorID |Verify that the
VendorID remains unchanged

|11 |11.1.6.1-3 |BINFO.S.A0003(ProductName) |TH reads ProductName from
the DUT. a|
Verify it is a human readable string.

Verify that the length is less than or equal to 32 bytes.

|12 | |BINFO.S.A0003(ProductName) |TH writes ProductName as "newproduct"
|Verify DUT responds with UNSUPPORTED_WRITE

|13 | |BINFO.S.A0003(ProductName) |TH reads ProductName |Verify that the
ProductName remains unchanged

|14 |11.1.6.1-4, 7.18.1.3, 6.1.3.1 |BINFO.S.A0004(ProductID) |TH reads
ProductID from the DUT. a|
Verify that the value is in the inclusive range of 1 to 65534

Verify that value is not 0 (0x0000).

|15 | |BINFO.S.A0004(ProductID) |TH writes ProductID as "0x4521" |Verify
DUT responds with UNSUPPORTED_WRITE

|16 | |BINFO.S.A0004(ProductID) |TH reads ProductID |Verify that the
ProductID remains unchanged

|17 |11.1.6.1-5 |BINFO.S.A0005(NodeLabel) |TH reads NodeLabel from the
DUT a|
Verify it is of type string.

Verify that the current value has a length between 0 and 32 bytes
inclusive.

|18 | |BINFO.S.A0005(NodeLabel) |TH writes "newnode" to NodeLabel
|Verify that the DUT sends success response

|19 | |BINFO.S.A0005(NodeLabel) |TH reads NodeLabel |Verify that the
NodeLabel is changed as "newnode"

|20a |11.1.6.1-6 |BINFO.S.A0006(Location) |TH reads Location from the
DUT. a|
Verify it is of type string.

Verify length is less than or equal to 2 bytes.

Verify that the Location is same as CountryCode value saved from step1

|20b | |BINFO.S.A0006(Location) |TH selects a country code value that is
different from the CountryCode saved from step1 and known to be
supported on the DUT. TH writes this value to Location |Verify that the
DUT sends success response

|20c | |BINFO.S.A0006(Location) |TH reads Location |Verify that the
Location is changed to the value from step 20b

|21 |11.1.6.1-7, 7.18.1.3 |BINFO.S.A0007(HardwareVersion) |TH reads
HardwareVersion from the DUT. |Verify that the value is in range of 0 to
65534

|22 | |BINFO.S.A0007(HardwareVersion) |TH writes HardwareVersion as
"0x4531" |Verify DUT responds with UNSUPPORTED_WRITE

|23 | |BINFO.S.A0007(HardwareVersion) |TH reads HardwareVersion |Verify
that the HardwareVersion remains unchanged

|24 |11.1.6.1-8 |BINFO.S.A0008(HardwareVersionString) |TH reads
HardwareVersionString from the DUT. a|
Verify it is of type string.

Verify it has a length in the inclusive range of 1 to 64 bytes

|25 | |BINFO.S.A0008(HardwareVersionString) |TH writes
HardwareVersionString as "newhardwareversion" |Verify DUT responds with
UNSUPPORTED_WRITE

|26 | |BINFO.S.A0008(HardwareVersionString) |TH reads
HardwareVersionString |Verify that the HardwareVersionString remains
unchanged

|27 |11.1.6.1-9, 7.18.1.3, 11.1.6.2 |BINFO.S.A0009(SoftwareVersion) |TH
reads SoftwareVersion from the DUT. a|
Verify that the value is the range of 0 to 4294967294

Verify that the SoftwareVersion is not displayed to the end-user through
any device specific means (ex: screen, audio)

|28 | |BINFO.S.A0009(SoftwareVersion) |TH writes SoftwareVersion as
"0x8213" |Verify DUT responds with UNSUPPORTED_WRITE

|29 | |BINFO.S.A0009(SoftwareVersion) |TH reads SoftwareVersion |Verify
that the SoftwareVersion remains unchanged

|30 |11.1.6.1-10 |BINFO.S.A000a(SoftwareVersionString) |TH reads
SoftwareVersionString from the DUT. a|
Verify it is of type string.

Verify that it has a length of 1 to 64 bytes of UTF-8 characters.

Verify that it uses 7-bit ASCII alphanumeric and punctuation characters.

|31 | |BINFO.S.A000a(SoftwareVersionString) |TH writes
SoftwareVersionString as "1.0" |Verify DUT responds with
UNSUPPORTED_WRITE

|32 | |BINFO.S.A000a(SoftwareVersionString) |TH reads
SoftwareVersionString |Verify that the SoftwareVersionString remains
unchanged

|33 |11.1.6.1-11 |BINFO.S.A000b(ManufacturingDate) |TH reads
ManufacturingDate from the DUT. a|
Verify it is of type string.

Verify it has length in the inclusive range of 8 to 16 bytes.

Verify if the first 8 characters specify date according to ISO 8601,
i.e, YYYYMMDD.

|34 | |BINFO.S.A000b(ManufacturingDate) |TH writes ManufacturingDate as
"20210814789452IN" |Verify DUT responds with UNSUPPORTED_WRITE

|35 | |BINFO.S.A000b(ManufacturingDate) |TH reads ManufacturingDate
|Verify that the ManufacturingDate remains unchanged

|36 |11.1.6.1-12 |BINFO.S.A000c(PartNumber) |TH reads PartNumber from
the DUT. a|
Verify it is a human readable string.

Verify that the string has a maximum length of 32 bytes

|37 | |BINFO.S.A000c(PartNumber) |TH writes PartNumber as "newpart"
|Verify DUT responds with UNSUPPORTED_WRITE

|38 | |BINFO.S.A000c(PartNumber) |TH reads PartNumber |Verify that the
PartNumber remains unchanged

|39 |11.1.6.1-13 |BINFO.S.A000d(ProductURL) |TH reads ProductURL from
the DUT. a|
Verify it is of type string.

Verify it is less than or equal to 256 ASCII characters.

Verify that it specifies a link to a specific web page.

Verify that it follows the syntax rules specified in RFC 3986.

|40 | |BINFO.S.A000d(ProductURL) |TH writes ProductURL as
"https://www.example.com" |Verify DUT responds with UNSUPPORTED_WRITE

|41 | |BINFO.S.A000d(ProductURL) |TH reads ProductURL |Verify that the
ProductURL remains unchanged

|42 |11.1.6.1-14 |BINFO.S.A000e(ProductLabel) |TH reads ProductLabel
from the DUT. a|
Verify it is of type string.

Verify it is less than or equal to 64 bytes.

Verify that it does not include the name of the vendor as defined within
the VendorName attribute

|43 | |BINFO.S.A000e(ProductLabel) |TH writes ProductLabel as
"newproductlabel" |Verify DUT responds with UNSUPPORTED_WRITE

|44 | |BINFO.S.A000e(ProductLabel) |TH reads ProductLabel |Verify that
the ProductLabel remains unchanged

|45 |11.1.6.1-15 |BINFO.S.A000f(SerialNumber) |TH reads SerialNumber
from the DUT. a|
Verify it is of type string.

Verify it is less than or equal to 32 bytes.

|46 | |BINFO.S.A000f(SerialNumber) |TH writes SerialNumber_test as
"newserialnumber" |Verify DUT responds with UNSUPPORTED_WRITE

|47 | |BINFO.S.A000f(SerialNumber) |TH reads SerialNumber |Verify that
the SerialNumber remains unchanged

|48 |11.1.6.1-16, 7.18.1.1 |BINFO.S.A0010(LocalConfigDisabled) |TH reads
LocalConfigDisabled from the DUT. |Verify that the value is false

|49 | |BINFO.S.A0010(LocalConfigDisabled) |TH sets LocalConfigDisabled
to True |Verify that the DUT sends success response

|50 | |BINFO.S.A0010(LocalConfigDisabled) |TH Reads LocalConfigDisabled
|Verify that LocalConfigDisabled is set to True

|51 |11.1.6.1-17,7.18.1.1 |BINFO.S.A0011(Reachable) |TH reads Reachable
from the DUT. a|
Verify it is of type bool

Verify that the value is true

|52 | |BINFO.S.A0011(Reachable) |TH sends Write request message to DUT
to change value of Reachable to "false". |Verify DUT responds with
UNSUPPORTED_WRITE

|52b | |BINFO.S.A0011(Reachable) |TH reads Reachable from the DUT.
|Verify that the Reachable flag remains unchanged

|53 |11.1.6.1-18 |BINFO.S.A0012(UniqueID) |TH reads UniqueID from the
DUT. a|
Verify it is of type string

Verify that the value is not be identical to SerialNumber attribute

Verify that the value is not be printed on the product or on any
included materials.

|54 | |BINFO.S.A0012(UniqueID) |TH writes UniqueID as "newid" |Verify
DUT responds with UNSUPPORTED_WRITE

|55 | |BINFO.S.A0012(UniqueID) |TH reads UniqueID |Verify that the
UniqueID remains unchanged

|56 |11.1.6.1-19 |BINFO.S.A0013(CapabilityMinima) |TH reads
CapabilityMinima attribute from the DUT a|
* Verify that the CaseSessionsPerFabric is in the inclusive range of 3
to 65535
* Verify that the SubscriptionsPerFabric is in the inclusive range of 3
to 65535

|57 | |BINFO.S.A0013(CapabilityMinima) |TH writes the CapabilityMinima
value with CaseSessionsPerFabric set to 4 and SubscriptionsPerFabric set
to 4 |Verify that the DUT responds with UNSUPPORTED_WRITE

|58 | |BINFO.S.A0013(CapabilityMinima) |TH reads CapabilityMinima
attribute from DUT |Verify that the CapabilityMinima remains unchanged

|59 | |BINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance from
the DUT. |Verify it is of type ProductAppearanceStruct.

|60 | |BINFO.S.A0014(ProductAppearance) |TH writes ProductAppearance to
the DUT. |Verify DUT responds with UNSUPPORTED_WRITE

|61 | |BINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance from
the DUT. |Verify that the ProductAppearance remains unchanged
|===

[[_tc_binfo_2_2_events_dut_server]]
===== link:#_tc_binfo_2_2_events_dut_server[]12.2.2. [TC-BINFO-2.2] Events [DUT-Server]

[[_category_41]]
====== link:#_category_41[]Category

Functional conformance

[[_purpose_42]]
====== link:#_purpose_42[]Purpose

Verify if all the events have been implemented correctly on the DUT.

[[_pics_41]]
====== link:#_pics_41[]PICS

* BINFO.S

[[_precondition_2]]
====== link:#_precondition_2[]Precondition

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT and TH can interact with each other. DUT is commissioned. |

|2 |BINFO.S.A0009(SoftwareVersion) |TH reads SoftwareVersion attribute
from DUT and saves for future use |

|3 |BINFO.S.A0011(Reachable) |TH reads Reachable attribute from DUT and
saves for future use |Should be True

|4 |BINFO.S.E00(StartUp) | BINFO.S.E01(ShutDown) | BINFO.S.E02(Leave)
|TH subscribes to StartUp, ShutDown, Leave and ReachableChanged events
on the Basic Information cluster of the DUT |

|5 | |TH saves the FabricIndex during commissioning |
|===

[[_required_devices_41]]
====== link:#_required_devices_41[]Required Devices

[width="100%",cols="15%,28%,57%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness which will be used to send and receive events and
messages to the DUT

|2 |DUT |DUT which will send events to the TH
|===

[[_device_topology_16]]
====== link:#_device_topology_16[]Device Topology

DUT and TH are on the same fabric

[[_test_procedure_41]]
====== link:#_test_procedure_41[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.1.6.2-0 |BINFO.S.E00(StartUp) a|
* Reboot the DUT
* TH reads the StartUp event from DUT

a|
* Verify that the DUT sends the StartUp event before other events to TH
* Verify that the SoftwareVersion field in the event data is equivalent
to the precondition
* Verify that StartUp event has priority set as CRITICAL

|2 |11.1.6.2-1 |BINFO.S.E01(ShutDown) a|
TH subscribes to the ShutDown event on the DUT. Shutdown DUT.

a|
Verify that ShutDown event is received from DUT and has priority set as
CRITICAL

|===

[[_tc_binfo_3_1_appearance_attribute_dut_as_server]]
===== link:#_tc_binfo_3_1_appearance_attribute_dut_as_server[]12.2.3. [TC-BINFO-3.1] Appearance Attribute DUT as Server

[[_category_42]]
====== link:#_category_42[]Category

Functional conformance

[[_purpose_43]]
====== link:#_purpose_43[]Purpose

Verify if the appearance is correctly set within the allowed ranges.
Finish and PrimaryColor should reasonably reflect the appearance of the
product.

[[_pics_42]]
====== link:#_pics_42[]PICS

* BINFO.S

[[_precondition_3]]
====== link:#_precondition_3[]Precondition

[width="100%",cols="10%,14%,38%,38%",]
|===
|*#* |*Ref* |*Condition* |*Notes*
|===

[[_required_devices_42]]
====== link:#_required_devices_42[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_17]]
====== link:#_device_topology_17[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_42]]
====== link:#_test_procedure_42[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | |BINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance from
the DUT. |ProductAppearance.Finish Value has to be between a range of
[min=Other(0), max=Fabric(5)]

|2 | |BINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance from
the DUT. |ProductAppearance.PrimaryColor Value has to be between a range
of [min=Black(0), max=Gold(20) ]

|3 | |BINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance from
the DUT. |ProductAppearance.Finish Value has to be equal to
PIXIT.BINFO.Finish

|4 | |BINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance from
the DUT. |ProductAppearance.PrimaryColor Value has to be equal to
PIXIT.BINFO.PrimaryColor
|===

[[_node_operational_credentials_test_plan]]
== link:#_node_operational_credentials_test_plan[]**Node Operational Credentials Test Plan**

[[_pics_definition_4]]
=== link:#_pics_definition_4[]13. PICS Definition

This section covers the Node Operational Credentials Cluster related
PICS items that are referenced in the following test cases.

[[_role_3]]
==== link:#_role_3[]13.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.S |Does the device implement the Node Operational Credentials
Cluster as a server? |M |

|OPCREDS.C |Does the device implement the Node Operational Credentials
Cluster as a client? |O |
|===

[[_server_2]]
==== link:#_server_2[]13.2. Server

[[_attributes_2]]
===== link:#_attributes_2[]13.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.S.A0000(NOCs) |Does the DUT(server) support the NOCs list
attribute? |M |

|OPCREDS.S.A0001(Fabrics) |Does the DUT(server) support the Fabrics list
attribute? |M |

|OPCREDS.S.A0002(SupportedFabrics) |Does the DUT(server) support the
SupportedFabrics attribute? |M |

|OPCREDS.S.A0003(CommissionedFabrics) |Does the DUT(server) support the
CommissionedFabrics attribute? |M |

|OPCREDS.S.A0004(TrustedRootCertificates) |Does the DUT(server) support
the TrustedRootCertificates attribute? |M |

|OPCREDS.S.A0005(CurrentFabricIndex) |Does the DUT(server) support the
CurrentFabricIndex attribute? |M |
|===

[[_commands_received]]
===== link:#_commands_received[]13.2.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.S.C00.Rsp(AttestationRequest) |Does the Device(Server)
implement receiving the AttestationRequest command? |M |

|OPCREDS.S.C02.Rsp(CertificateChainRequest) |Does the Device(Server)
implement receiving the CertificateChainRequest command? |M |

|OPCREDS.S.C04.Rsp(CSRRequest) |Does the Device(Server) implement
receiving the CSRRequest command? |M |

|OPCREDS.S.C06.Rsp(AddNOC) |Does the Device(Server) implement receiving
the AddNOC command? |M |

|OPCREDS.S.C07.Rsp(UpdateNOC) |Does the Device(Server) implement
receiving the UpdateNOC command? |M |

|OPCREDS.S.C09.Rsp(UpdateFabricLabel) |Does the Device(Server) implement
receiving the UpdateFabricLabel command? |M |

|OPCREDS.S.C0a.Rsp(RemoveFabric) |Does the Device(Server) implement
receiving the RemoveFabric command? |M |

|OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |Does the Device(Server)
implement receiving the AddTrustedRootCertificate command? |M |
|===

[[_commands_generated]]
===== link:#_commands_generated[]13.2.3. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.S.C01.Tx(AttestationResponse) |Does the Device(Server)
invoking/generating the AttestationResponse command? |M |

|OPCREDS.S.C03.Tx(CertificateChainResponse) |Does the Device(Server)
invoking/generating the CertificateChainResponse command? |M |

|OPCREDS.S.C05.Tx(CSRResponse) |Does the Device(Server)
invoking/generating the CSRResponse command? |M |

|OPCREDS.S.C08.Tx(NOCResponse) |Does the Device(Server)
invoking/generating the NOCResponse command? |M |
|===

[[_client]]
==== link:#_client[]13.3. Client

[[_attributes_3]]
===== link:#_attributes_3[]13.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.C.A0000(NOCs) |Does the DUT(client) have access privileges for
the NOC list attribute implemented on the server? |O |

|OPCREDS.C.A0002(SupportedFabrics) |Does the DUT(client) have access
privileges for the SupportedFabrics attribute implemented on the server?
|O |

|OPCREDS.C.A0003(CommissionedFabrics) |Does the DUT(client) have access
privileges for the CommissionedFabrics attribute implemented on the
server? |O |

|OPCREDS.C.A0004(TrustedRootCertificates) |Does the DUT(client) have
access privileges for the TrustedRootCertificates attribute implemented
on the server? |O |

|OPCREDS.C.A0005(CurrentFabricIndex) |Does the DUT(client) have access
privileges for the CurrentFabricIndex attribute implemented on the
server? |O |
|===

[[_commands_received_2]]
===== link:#_commands_received_2[]13.3.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.C.C01.Rsp(AttestationResponse) |Does the Device(Client)
invoking/generating the AttestationResponse command? |O |

|OPCREDS.C.C03.Rsp(CertificateChainResponse) |Does the Device(Client)
invoking/generating the CertificateChainResponse command? |O |

|OPCREDS.C.C05.Rsp(CSRResponse) |Does the Device(Client)
invoking/generating the CSRResponse command? |O |

|OPCREDS.C.C08.Rsp(NOCResponse) |Does the Device(Client)
invoking/generating the NOCResponse command? |O |
|===

[[_commands_generated_2]]
===== link:#_commands_generated_2[]13.3.3. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.C.C00.Tx(AttestationRequest) |Does the Device(Client) implement
receiving the AttestationRequest command? |O |

|OPCREDS.C.C02.Tx(CertificateChainRequest) |Does the Device(Client)
implement receiving the CertificateChainRequest command? |O |

|OPCREDS.C.C04.Tx(CSRRequest) |Does the Device(Client) implement
receiving the CSRRequest command? |O |

|OPCREDS.C.C06.Tx(AddNOC) |Does the Device(Client) implement receiving
the AddNOC command? |O |

|OPCREDS.C.C07.Tx(UpdateNOC) |Does the Device(Client) implement
receiving the UpdateNOC command? |O |

|OPCREDS.C.C09.Tx(UpdateFabricLabel) |Does the Device(Client) implement
receiving the UpdateFabricLabel command? |O |

|OPCREDS.C.C0a.Tx(RemoveFabric) |Does the Device(Client) implement
receiving the RemoveFabric command? |O |

|OPCREDS.C.C0b.Tx(AddTrustedRootCertificate) |Does the Device(Client)
implement receiving the AddTrustedRootCertificate command? |O |
|===

[[_test_case_list_3]]
=== link:#_test_case_list_3[]14. Test Case List

[width="100%",cols="20%,80%",]
|===
|*TC UUID* |*Test Case Name*

|TC-OPCREDS-1.2 |Global Attributes with DUT as Server

|TC-OPCREDS-3.1 |Attribute-NOCs,TrustedRootCertificates list validation
[DUT-Server]

|TC-OPCREDS-3.2 |Attribute-CurrentFabricIndex validation [DUT-Server]

|TC-OPCREDS-3.3 |Attribute-NOCs,Commands[DUT-Client]

|TC-OPCREDS-3.4 |UpdateNOC-Error Condition [DUT-Server]

|TC-OPCREDS-3.5 |NOC Check for UpdateNOC [DUT-Server]

|TC-OPCREDS-3.6 |Last Fabric removal validation [DUT-Server]

|TC-OPCREDS-3.7 |Add Second Fabric over CASE [DUT-Server]
|===

[[_test_cases_3]]
=== link:#_test_cases_3[]15. Test Cases

'''''

[[_generic_test_cases_2]]
==== link:#_generic_test_cases_2[]15.1. Generic Test Cases

'''''

[[_tc_opcreds_1_2_global_attributes_with_dut_as_server]]
===== link:#_tc_opcreds_1_2_global_attributes_with_dut_as_server[]15.1.1. [TC-OPCREDS-1.2] Global Attributes with DUT as Server

[[_category_43]]
====== link:#_category_43[]Category

Functional conformance.

[[_purpose_44]]
====== link:#_purpose_44[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_43]]
====== link:#_pics_43[]PICS

* OPCREDS.S

[[_required_devices_43]]
====== link:#_required_devices_43[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_43]]
====== link:#_test_procedure_43[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0xfff8, 0xfff9, 0xfffb,
0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00, 0x02, 0x04, 0x06, 0x07, 0x09, 0x0a & 0x0b.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +
0x01, 0x03, 0x05 & 0x08.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_40]]
====== link:#_notestesting_considerations_40[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_dut_as_server_2]]
==== link:#_dut_as_server_2[]15.2. DUT as Server

'''''

[[_tc_opcreds_3_1_attribute_nocs_trustedrootcertificates_list_validation_dut_server]]
===== link:#_tc_opcreds_3_1_attribute_nocs_trustedrootcertificates_list_validation_dut_server[]15.2.1. [TC-OPCREDS-3.1] Attribute-NOCs, TrustedRootCertificates list validation [DUT-Server]

[[_category_44]]
====== link:#_category_44[]Category

Functional conformance

[[_purpose_45]]
====== link:#_purpose_45[]Purpose

The following checks are covered by this test:

AddNOC error cases

* (link:#noc-re-add[24]) Prior AddNOC command successfully executed in
fail-safe timer period → CONSTRAINT_ERROR
* (link:#add-noc-for-update-csr[65]) Prior CSRRequest has IsForUpdateNOC
set to true → CONSTRAINT_ERROR
* (link:#fabric-conflict[58]) Adding NOC for <Root Public Key, FabricID>
already on device → FabricConflict
* (link:#invalid-public-key[56]) Public Key in NOC does not match Public
Key in NOCSR → InvalidPublicKey
* (link:#noc-invalid[20]) Validation error (signed by TrustedRoot not in
table) → InvalidNOC
* (link:#missing-csr[54]) No prior CSR matching NOC → MissingCsr
* (link:#cat-invalid[21]) CaseAdminSubject field is not a valid ACL
subject → InvalidAdminSubject

AddNOC positive cases

* (link:#noc-ok[22]) Valid AddNOC with CaseAdminSubject is NodeID
* (link:#add-noc-cat[46]) Valid AddNOC with CaseAdminSubject is CAT
* (link:#fabrics-table-ok[40]) AddNOC results in generation of new
fabric and is reflected in fabrics table
* (link:#noc-table-ok[38]) AddNOC results in entry in NOC table
* (link:#ipk-ok[43]) AddNOC results in IPK added to Groups Management
cluster
* (link:#acl-ok[42]) AddNOC results in ACL added to ACL cluster
* (link:#multiple-nocs[48], link:#multiple-fabric-table[51]) Multiple
NOCs can be added and are reflected in the NOC and fabric tables
* (link:#fill-fabric-table[75]) Able to add `NumSupportedFabrics`
fabrics will full-size certificates

AddTrustedRootCertificate error cases

* (link:#root-cert-re-add[16]) Adding a second trusted root certificate
in the same fail-safe period → CONSTRAINT_ERROR
* (link:#root-cert-validity-check[13]) Validity check fails →
INVALID_COMMAND

AddTrustedRootCertificate positive cases

* (link:#root-cert-cmd-ok[[root-cert-cmd-ok]],
link:#root-cert-attribute-ok[19]) Valid AddTrustedRootCertificate is
reflected in TrustedRootCertificates attribute
* (link:#root-cert-duplicate[15]) Adding an exact duplicate succeeds
with no change to list
* (link:#multiple-trusted-root-certs[47]) Multiple Trusted Root
Certificates can be added and are reflected in the Trusted Root
Certificate attribute

NOC attribute

* (link:#noc-attribute[25]) NOC attribute contains successfully added
NOCs
* (link:#noc-attribute-not-writeable[26]) NOC attribute is not writeable

TrustedRootCertificates attribute

* (link:#root-cert-attribute-ok[19]) TrustedRootCertificates attribute
contains successfully added Trusted root certificates
* (link:#trusted-root-attr-not-writeable[18]) TrustedRootCertificates
attribute is not writeable

Failsafe tests

* (link:#failsafe-expiry-root-certs[33], link:#failsafe-expiry-nocs[34],
link:#failsafe-expiry-fabrics[35]) failsafe results in no changes to
fabric table, noc table, trusted root table

UpdateFabricLabel error cases

* (link:#label-conflict[50]) duplicate label cannot be added →
CONSTRAINT_ERROR

UpdateFabricLabel positive cases

* (link:#fabric-label-command[28], link:#fabric-table[30])
UpdateFabricLabel successfully adds label to fabric
* (link:#multiple-fabric-table[51]) Multiple fabrics can each have a
different label

RemoveFabric error cases

* (link:#remove-invalid-fabric[68]) Invalid fabric index →
InvalidFabricIndex

RemoveFabric positive cases

* (link:#remove-fabric-ok[71]) RemoveFabric successfully removes fabric
from fabric table

[[_pics_44]]
====== link:#_pics_44[]PICS

* OPCREDS.S

[[_pre_conditions]]
====== link:#_pre_conditions[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |6.1.3.1 |PAI, DAC certificates are obtained and validated against
externally obtained PAA certificate |

|2 | |This test case assumes that during Commissioning AddNOC will be
sent with ICACValue |

|3 | |TH2 is set up with at least one valid CASE Authenticated Tag
specified in its NOC, saved as `CAT_TH2` |

|4 | |Read SupportedFabrics attributes from the DUT and saves as
`NumSupportedFabrics` . Ensure there are `NumSupportedFabrics` test
harness instances that can each commission the DUT |
|===

[[_required_devices_44]]
====== link:#_required_devices_44[]Required Devices

[width="100%",cols="13%,37%,50%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH1 |client
|3 |TH2 |client
|4 |TH3 to TH `NumSupportedFabrics` + 1 |clients
|===

[[_device_topology_18]]
====== link:#_device_topology_18[]Device Topology

[[_test_setup_7]]
====== link:#_test_setup_7[]Test Setup

. A new fabric (ID 1) is created by TH1 to which the DUT will be
commissioned
. A new fabric (ID 2) is created by TH2 to which the DUT will be
commissioned

[[_test_procedure_44]]
====== link:#_test_procedure_44[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.17.6.1 |OPCREDS.S.A0000(NOC list) |Factory Reset DUT (to ensure
NOC list is empty at the beginning of the following steps) |

|2 |5.5 | |Start the commissioning process of DUT by TH1 on a first
Fabric |

|3 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with the ExpiryLengthSeconds
field set to 900 |Verify that the DUT sends ArmFailSafeResponse Command
to TH1 with field ErrorCode as 'OK'(0)

|4 a|
* 11.9.7.4
* 11.9.7.5

a|
* CGEN.S.C02.Rsp(SetRegulatoryConfig)
* CGEN.S.C03.Tx(SetRegulatoryConfigResponse)

|TH1 sends SetRegulatoryConfig command to the DUT |Verify DUT sends
SetRegulatoryConfigResponse with ErrorCode as SUCCESS

|5 a|
* 11.17.7.1
* 11.17.7.2

a|
* OPCREDS.S.C00.Rsp(AttestationRequest)
* OPCREDS.S.C01.Tx(AttestationResponse)

|TH1 sends AttestationRequest command to DUT |Verify that the DUT sends
AttestationResponse to TH1

|6 a|
* 11.17.7.3
* 11.17.7.4

a|
* OPCREDS.S.C02.Rsp(CertificateChainRequest)
* OPCREDS.S.C03.Tx(CertificateChainResponse)

|TH1 sends CertificateChainRequest Command to DUT for the PAI and saves
the certificate as 'PAICert' a|
* Verify DUT sends CertificateChainResponse command with the Certificate
Information to TH1
* Verify that the size of certificate is less than or equal to 600 bytes
and of type octstr.

|7 a|
* 11.17.7.3
* 11.17.7.4

a|
* OPCREDS.S.C02.Rsp(CertificateChainRequest)
* OPCREDS.S.C03.Tx(CertificateChainResponse)

|TH1 sends CertificateChainRequest Command to DUT for the DAC and saves
the certificate as 'DACCert' a|
* Verify DUT sends CertificateChainResponse command with the Certificate
Information to TH1
* Verify that the size of certificate is less than or equal to 600 bytes
and of type octstr.

|[#csr-elements]####8 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1
Sends CSRRequest command with a random 32-byte nonce a|
* Verify that the DUT responds with the CSRResponse Command
* Verify that the NOCSRElements field is present and of type octstr
* Verify that the AttestationSignature field is present, is an octstr
type and has a maximum length of 64

|9 |6.2.3.1 | a|
TH1 validates the attestation response

|Verify that the attestation response validates correctly

|[#TH1-gen-real-creds]## 10 |6.4 | a|
* TH1 obtains or generates the NOC, the Root CA Certificate and ICAC
using the CSR elements from step link:#csr-elements[8] and selects an
IPK. The certificates shall have their subjects padded with additional
data such that they are each the maximum certificate size of 400 bytes
when encoded in the MatterCertificateEncoding.
* Save RCAC as `Root_CA_Certificate_TH1`
* Save ICAC as `Intermediate_Certificate_TH1`
* Save NOC as `Node_Operational_Certificate_TH1`
* Save IPK as `IPK_TH1`
* Extract the RCAC public key and save as `Root_Public_Key_TH1`

|

|11 |6.4 | a|
* TH1 obtains or generates Root Certificate with a different Root CA ID
and the corresponding ICAC, NOC and IPK using the CSR elements from step
link:#csr-elements[8]
* Save RCAC as `Root_CA_Certificate_TH1_2`
* Save ICAC as `Intermediate_Certificate_TH1_2`
* Save NOC as `Node_Operational_Certificate_TH1_2`
* Save IPK as `IPK_TH1_2`

|

|12 |6.4 | a|
* TH1 generates an INVALID Root Certificate where the signature does not
match the public key and saves it as `Root_CA_Malformed`

|

|[#root-cert-validity-check]####13 |11.17.7.13
|OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT to install `Root_CA_Malformed`
|Verify that AddTrustedRootCertificate Command fails by sending the
status code as INVALID_COMMAND

|[#root-cert-ok]####14 |11.17.7.13
|OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT with RootCACertificate set to
`Root_CA_Certificate_TH1` |Verify that AddTrustedRootCertificate Command
succeeds by sending the status code as SUCCESS

|[#root-cert-duplicate]####15 |11.17.7.13
|OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT again with the
RootCACertificate field set to `Root_CA_Certificate_TH1` |Verify that
the returned Status Code is SUCCESS

|[#root-cert-re-add]####16 |
|OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT again with the
RootCACertificate field set to `Root_CA_Certificate_TH1_2` |Verify that
the returned Status Code is CONSTRAINT_ERROR

|17 |11.17.6.5 |OPCREDS.S.A0004(TrustedRootCertificates) |TH1 reads the
TrustedRootCertificates list from DUT and saves as `TrustedRootsList`
|Verify that there is only one instance of Root CA Certificate in the
list and that its content matches `Root_CA_Certificate_TH1`

|[#trusted-root-attr-not-writeable]####18 |11.17.6.5
|OPCREDS.S.A0004(TrustedRootCertificates) |TH1 appends
`Root_CA_Certificate_TH1_2` to `TrustedRootsList` and writes the
TrustedRootCertificates attribute with that value |Verify that the
returned status code is UNSUPPORTED_WRITE

|[#root-cert-attribute-ok]####19 |11.17.6.5
|OPCREDS.S.A0004(TrustedRootCertificates) |TH1 reads the
TrustedRootCertificates list from DUT |Verify that there is only one
instance of Root CA Certificate in the list and that its content matches
`Root_CA_Certificate_TH1`

|[#noc-invalid]####20 |11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC) a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1_2`
* ICACValue as `Intermediate_Certificate_TH1_2`
* IpkValue as `IPK_TH1_2`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

a|
* Verify that DUT responds with NOCResponse command with status code
InvalidNOC

|[#cat-invalid]####21 |11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC) a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1`
* ICACValue as `Intermediate_Certificate_TH1`
* IpkValue as `IPK_TH1`
* CaseAdminSubject is an invalid NodeID (not an operational Node ID or
Case Authenticated Tag - ex. 0)
* AdminVendorId as the Vendor ID of TH1

a|
* Verify that DUT responds with NOCResponse command with status code
InvalidAdminSubject

|[#noc-ok]####22 |11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC) a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1`
* ICACValue as `Intermediate_Certificate_TH1`
* IpkValue as `IPK_TH1`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

a|
* Verify that DUT responds with NOCResponse command with status code OK
* Verify that FabricIndex has a size of 1 byte
* Verify that FabricIndex = 1
* If NOCResponse command has DebugText verify that its size is within
128 characters

|23 | | |TH1 saves the FabricIndex as `FabricIndex_TH1` for future use |

|[#noc-re-add]####24 |5.5,11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC) a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1_1`
* ICACValue as `Intermediate_Certificate_TH1_1`
* IpkValue as `IPK_TH1_1`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

|Verify that DUT responds with status code CONSTRAINT_ERROR

|[#noc-attribute]####25 |11.17.6.1 |OPCREDS.S.A0000(NOCs) |TH1 reads the
NOCs attribute from DUT using a non-fabric-filtered read and saves the
list as `NOCList` |Verify that the list contains one entry with NOC
field `Node_Operational_Certificate_TH1` and ICAC field
`Intermediate_Certificate_TH1`

|[#noc-attribute-not-writeable]####26 |11.17.6.1 |OPCREDS.S.A0000(NOCs)
|TH1 appends a second list item to 'NOCList' and writes that value to
the NOCs attribute |Verify that the returned status code is
UNSUPPORTED_WRITE

|27 |11.17.6.1 |OPCREDS.S.A0000(NOCs) |TH1 reads the NOCs attribute from
DUT using a non-fabric-filtered read |Verify that the list contains one
entry with NOC field `Node_Operational_Certificate_TH1` and ICAC field
`Intermediate_Certificate_TH1`

|[#fabric-label-command]####28 |11.17.6.5
|OPCREDS.S.C09.Rsp(UpdateFabricLabel) |TH1 sends UpdateFabricLabel
command with 'Label 1' as Label field to DUT a|
* Verify that the DUT responds with the NOCResponse Command with status
OK

|29 |11.17.6.2 | |TH1 reads the Fabrics Attribute from DUT using a
non-fabric-filtered read and gets the FabricDescriptorStruct for which
the FabricIndex field equals `FabricIndex_TH1` |

|[#fabric-table]####30 | | | a|
* Read the other fields from FabricDescriptorStruct
+
. RootPublicKey
. VendorID
. FabricID
. NodeID
. Label
* Verify that the size of RootPublicKey is exactly 65 bytes
* Verify that the RootPublicKey matches `Root_Public_Key_TH1`
* Verify that the NodeID is the same as the matter-node-id field in the
NOC sent with AddNOC Command
* Verify that the VendorID is the same as the AdminVendorID sent with
AddNOC Command
* Verify that the FabricID is the same as the matter-fabric-id field in
the NOC sent with AddNOC Command
* Verify that the Label field has value "Label 1"

|31 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to 0 |

|32 | | |TH1 reconnects to the DUT over PASE |

|[#failsafe-expiry-root-certs]####33 |11.17.6.5
|OPCREDS.S.A0004(TrustedRootCertificates) |TH1 reads the
TrustedRootCertificates list from DUT |Verify that list is empty

|[#failsafe-expiry-nocs]####34 |11.17.6.1 |OPCREDS.S.A0000(NOCs) |TH1
reads the NOCs attribute from DUT using a non-fabric-filtered read
|Verify that the list is empty

|[#failsafe-expiry-fabrics]####35 |11.17.6.2 |OPCREDS.A.A0001(Fabrics)
|TH1 reads the Fabrics attribute from the DUT using a
non-fabric-filtered read |Verify that the list is empty

|36 |5.5 | |TH1 fully commissions DUT onto the fabric, using
'Root_CA_Certificate_TH1' and the AddNOC parameters specified in step
[#noc-ok]##. This will update the value of `FabricIndex_TH1` so that it
references the fabric the DUT was just commissioned onto |Verify that
TH1 successfully completes commissioning, including establishing a CASE
session on the operational network and issuing a CommissioningComplete
command.

|[#trusted-root-cert-table-ok]####37 |11.17.6.5
|OPCREDS.S.A0004(TrustedRootCertificates) |TH1 reads the
TrustedRootCertificates list from DUT |Verify that there is only one
instance of Root CA Certificate in the list and that its content matches
`Root_CA_Certificate_TH1`

|[#noc-table-ok]####38 |11.17.6.1 |OPCREDS.S.A0000(NOCs) |TH1 reads the
NOCs attribute from DUT using a non-fabric-filtered read |Verify that
the list contains one entry with NOC field
`Node_Operational_Certificate_TH1` and ICAC field
`Intermediate_Certificate_TH1`

|39 |11.17.6.5 |OPCREDS.S.C09.Rsp(UpdateFabricLabel) |TH1 sends
UpdateFabricLabel command with 'Label 1' as Label field to DUT a|
* Verify that the DUT responds with the NOCResponse Command with status
OK

|[#fabrics-table-ok]####40 |11.17.6.2 |OPCREDS.S.A0001(Fabrics) |TH1
reads the Fabrics Attribute from DUT using a non-fabric-filtered read
and gets the FabricDescriptorStruct for which the FabricIndex field
equals `FabricIndex_TH1` |

|41 | | | a|
* Read the other fields from FabricDescriptorStruct
+
. RootPublicKey
. VendorID
. FabricID
. NodeID
. Label
* Verify that the size of RootPublicKey is exactly 65 bytes
* Verify that the RootPublicKey matches `Root_Public_Key_TH1`
* Verify that the NodeID is the same as the matter-node-id field in the
NOC sent with AddNOC Command
* Verify that the VendorID is the same as the AdminVendorID sent with
AddNOC Command
* Verify that the FabricID is the same as the matter-fabric-id field in
the NOC sent with AddNOC Command
* Verify that the Label field has value "Label 1"

|[#acl-ok]####42 a|
* 11.17.7.8
* 9.10.5

|OPCREDS.S.C06.Rsp(AddNOC) |TH1 reads the ACL attribute from the Access
Control cluster a|
* Verify that the returned list includes an entry with:
* Fabric index of `FabricIndex_TH1`
* Administer privilege (5)
* CASE AuthMode (2)
* Includes the NodeID of TH1 in the list of subjects

|[#ipk-ok]####43 a|
* 11.17.7.8
* 11.2.9.2

|OPCREDS.S.C06.Rsp(AddNOC) |TH1 issues a KeySetRead command to the DUT
for GroupKeySetID 0 |Verify that an entry is read-back successfully.

|44 |11.18.8.1 | |TH1 sends an OpenCommissioningWindow command to the
Administrator Commissioning cluster |

|45 |6.4 | a|
* TH2 begins the process of commissioning the DUT. After receiving the
CSRResponse TH2 obtains or generates a NOC, the Root CA Certificate,
ICAC and IPK. The certificates shall have their subjects padded with
additional data such that they are each the maximum certificate size of
400 bytes when encoded in the MatterCertificateEncoding.
* Save RCAC as `Root_CA_Certificate_TH2`
* Save ICAC as `Intermediate_Certificate_TH2`
* Save NOC as `Node_Operational_Certificate_TH2`
* Save IPK as `IPK_TH2`
* Extract the RCAC public key and save as `Root_Public_Key_TH2`

|

|[#add-noc-cat]####46 |5.5 | a|
* TH2 completes the commissioning process using
`Root_CA_Certificate_TH2` when performing the AddTrustedRootCertificate
command and sending AddNOC with the following parameters:
* NOCValue as `Node_Operational_Certificate_TH2`
* ICACValue as `Intermediate_Certificate_TH2`
* IpkValue as `IPK_TH2`
* CaseAdminSubject as `CAT_TH2`
* AdminVendorId as the Vendor ID of TH2

|Verify that TH2 successfully completes commissioning, including
establishing a CASE session on the operational network and issuing a
CommissioningComplete command

|[#multiple-trusted-root-certs]####47 |11.17.6.5
|OPCREDS.S.A0004(TrustedRootCertificates) |TH2 reads the
TrustedRootCertificates list from DUT |Verify that the list length is
two and it contains `Root_CA_Certificate_TH1` and
`Root_CA_Certificate_TH2`

|[#multiple-nocs]####48 |11.17.6.1 |OPCREDS.S.A0000(NOCs) |TH2 reads the
NOCs attribute from DUT using a non-fabric-filtered read a|
* Verify that the list contains two entries
* Verify that one entry has NOC field `Node_Operational_Certificate_TH2`
and ICAC field `Intermediate_Certificate_TH2`

|49 |11.17.6.5 |OPCREDS.S.C09.Rsp(UpdateFabricLabel) |TH2 sends
UpdateFabricLabel command with 'Label 2' as Label field to DUT a|
* Verify that the DUT responds with the NOCResponse Command with status
OK

|[#label-conflict]####50 |11.17.7.11
|OPCREDS.S.C09.Rsp(UpdateFabricLabel) |TH2 sends UpdateFabricLabel
command with 'Label 1' as Label field to DUT a|
* Verify that the DUT responds with the NOCResponse Command with status
LabelConflict

|[#multiple-fabric-table]####51 |11.17.6.2 |OPCREDS.S.A0001(Fabrics)
|Read the Fabrics List from DUT using a non-fabric-filtered read a|
* Verify that there are two entries
* Verify that one entry has Label field 'Label 1'
* Verify that the other entry has label field 'Label 2'
* Verify that the list item with Label 'Label 1' has RootPublicKey field
`Root_Public_Key_TH1`, NodeId field matches matter-node-id in
`Node_Operational_Certificate_TH1`, FabricID field matches
matter-fabric-id field in `Node_Operational_Certificate_TH1` and
VendorID is the vendor ID of TH1
* Verify that the list item with Label 'Label 2' has RootPublicKey field
`Root_Public_Key_TH2`, NodeId field matches matter-node-id in
`Node_Operational_Certificate_TH2`, FabricID field matches
matter-fabric-id field in `Node_Operational_Certificate_TH2` and
VendorID is the vendor ID of TH2

|52 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with the ExpiryLengthSeconds
field set to 900 |Verify that the DUT sends ArmFailSafeResponse Command
to TH1 with field ErrorCode as 'OK'(0)

|53 |11.17.7.13 |OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT with RootCACertificate set to
`Root_CA_Certificate_TH1_2` |Verify that AddTrustedRootCertificate
Command succeeds by sending the status code as SUCCESS

|[#missing-csr]####54 |5.5,11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC) a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1_2`
* ICACValue as `Intermediate_Certificate_TH1_2`
* IpkValue as `IPK_TH1_2`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

|Verify that DUT responds with status code MissingCsr

|[#csr-step]####55 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1 Sends
CSRRequest command with a random 32-byte nonce a|
* Verify that the DUT responds with the CSRResponse Command
* Verify that the NOCSRElements field is present and of type octstr
* Verify that the AttestationSignature field is present, is an octstr
type and has a maximum length of 64

|[#invalid-public-key]####56 |5.5,11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC)
a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1_2`
* ICACValue as `Intermediate_Certificate_TH1_2`
* IpkValue as `IPK_TH1_2`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

|Verify that DUT responds with status code InvalidPublicKey

|57 |6.4 | |TH1 obtains or generates a NOC and ICAC using the CSR
elements from step link:#csr-step[55] with a different NodeID, but the
same Root CA Certificate and fabric ID as step
link:#TH1-gen-real-creds[10]. Save as
`Node_Operational_Certificates_TH1_fabric_conflict` and
`Intermediate_Certificate_TH1_fabric_conflict` |

|[#fabric-conflict]####58 |11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC) a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1_fabric_conflict`
* ICACValue as `Intermediate_Certificate_TH1_fabric_conflict`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

|Verify that DUT responds with status code FabricConflict

|59 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that the DUT sends ArmFailSafeResponse Command to TH1 with
field ErrorCode as 'OK'(0)

|60 |11.17.6.5 |OPCREDS.S.A0004(TrustedRootCertificates) |TH1 reads the
TrustedRootCertificates list from DUT |Verify that list contains a
single entry matching `Root_CA_Certificate_TH1`

|61 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with the ExpiryLengthSeconds
field set to 900 |Verify that the DUT sends ArmFailSafeResponse Command
to TH1 with field ErrorCode as 'OK'(0)

|[#csr-step-update]####62 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1
Sends CSRRequest command with a random 32-byte nonce and the
IsForUpdateNOC field set to true a|
* Verify that the DUT responds with the CSRResponse Command
* Verify that the NOCSRElements field is present and of type octstr
* Verify that the AttestationSignature field is present, is an octstr
type and has a maximum length of 64

|63 | | a|
* TH1 obtains or generates a NOC, Root CA Certificate, ICAC using the
CSR elements from the previous step
* Save RCAC as `Root_CA_Certificate_TH1_3`
* Save ICAC as `Intermediate_Certificate_TH1_3`
* Save NOC as `Node_Operational_Certificate_TH1_3`

|

|64 |11.17.7.13 |OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT with RootCACertificate set to
`Root_CA_Certificate_TH1_3` |Verify that AddTrustedRootCertificate
Command succeeds by sending the status code as SUCCESS

|[#add-noc-for-update-csr]####65 |11.17.7.10 |OPCREDS.S.C06.Rsp(AddNOC)
a|
* TH1 sends the AddNOC Command to DUT with the following fields:
* NOCValue as `Node_Operational_Certificate_TH1_3`
* ICACValue as `Intermediate_Certificate_TH1_3`
* CaseAdminSubject as the NodeID of TH1
* AdminVendorId as the Vendor ID of TH1

|Verify that DUT responds with status code CONSTRAINT_ERROR

|66 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that the DUT sends ArmFailSafeResponse Command to TH1 with
field ErrorCode as 'OK'(0)

|67 a|
* 11.9.7.2
* 11.9.7.3

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with the ExpiryLengthSeconds
field set to 900 |Verify that the DUT sends ArmFailSafeResponse Command
to TH1 with field ErrorCode as 'OK'(0)

|[#remove-invalid-fabric]####68 |11.17.7.12
|OPCREDS.S.C0a.Rsp(RemoveFabric) |TH2 sends RemoveFabric command with
Fabric Index as FabricIndexTH2 + 5 (Invalid Fabric Index) to DUT |Verify
that DUT sends NOCResponse Command with StatusCode of InvalidFabricIndex

|69 |11.17.6.2 |OPCREDS.S.A0001(Fabrics) |TH2 reads the Fabrics List
from DUT using a non-fabric-filtered read a|
Verify that there are two entries

|70 |11.17.7.12 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH2 sends RemoveFabric
command with Fabric Index as FabricIndex_TH1 (Valid Fabric Index) to DUT
|Verify that DUT sends NOCResponse Command with StatusCode of OK

|[#remove-fabric-ok]####71 |11.17.6.2 |OPCREDS.S.A0001(Fabrics) |TH2
reads the Fabrics List from DUT using a non-fabric-filtered read a|
* Verify that there is a single entry with the following fields:
* Label is "Label 2"
* RootPublicKey field `Root_Public_Key_TH2`
* NodeId field matches matter-node-id in
`Node_Operational_Certificate_TH2`
* FabricID field matches matter-fabric-id field in
`Node_Operational_Certificate_TH2`
* VendorID is the vendor ID of TH2

|72 |11.9.7.6 | |TH2 sends a CommissioningComplete command to the DUT
|Verify that the DUT responds with a CommissioningCompleteResponse with
the ErrorCode as 'OK'(0)

|[#open-commissioning-window]####73 |11.18.8.1 | |TH2 sends an
OpenCommissioningWindow command to the Administrator Commissioning
cluster |

|[#commission-with-big-certs]####74 |5.5 | |TH1 fully commissions the
DUT using subject-padded, 400 byte certificates |Verify that the
commissioning completes successfully

|[#fill-fabric-table]####75 | | |Repeat steps
link:#open-commissioning-window[73] and
link:#commission-with-big-certs[74] to fill the fabric table using the
remaining test harnesses (TH3 through TH `NumSupportedFabrics`). Each
test harness should commission the DUT using subject-padded, 400-byte
certificates |Verify that each commissioning completes successfully

|76 |11.17.6.4 |OPCREDS.S.A0003(CommissionedFabrics) |TH1 reads
CommissionedFabrics attribute |Verify that attribute value matches
`NumSupportedFabrics`

|77 | | |Repeat steps link:#open-commissioning-window[73] and
link:#commission-with-big-certs[74] with TH `NumSupportedFabrics` + 1
|Verify that commissioning fails

|78 |9.10.5.5 | |TH1 reads the SubjectsPerAccessControlEntry attribute
from the Access Control Cluster and saves the value as `maxSubjects` |

|79 |9.10.5.6 | |TH1 reads the TargetsPerAccessControlEntry attribute
from the Access Control Cluster and saves the value as `maxTargets` |

|80 |9.10.5.7 | |TH1 reads the AccessControlEntriesPerFabric attribute
from the Access Control Cluster and saves the value as `maxEntries` |

|[#add-acls]####81 | | |TH1 creates a valid list of
AccessControlEntryStructs with `maxEntries` entries. Each
AccessControlEntryStruct specifies `maxSubjects` subjects and
`maxTargets` targets. TH1 writes this list to the AccessControl cluster
ACL attribute |Verify that the DUT returns SUCCESS

|82 | | |Repeat step link:#add-acls[81] for TH2 through TH
`NumSupportedFabrics` to fill the ACL table |
|===

[[_notestesting_considerations_41]]
====== link:#_notestesting_considerations_41[]Notes/Testing considerations

'''''

[[_tc_opcreds_3_2_attribute_currentfabricindex_validation_dut_server]]
===== link:#_tc_opcreds_3_2_attribute_currentfabricindex_validation_dut_server[]15.2.2. [TC-OPCREDS-3.2] Attribute-CurrentFabricIndex validation [DUT-Server]

[[_category_45]]
====== link:#_category_45[]Category

Functional conformance

[[_purpose_46]]
====== link:#_purpose_46[]Purpose

To Verify that the CurrentFabricIndex attribute satisfies the following
conditions:

. CurrentFabricIndex is same as the accessing fabric index in the DUT
. CurrentFabricIndex references an entry in the fabric list

[[_pics_45]]
====== link:#_pics_45[]PICS

* OPCREDS.S

[[_pre_conditions_2]]
====== link:#_pre_conditions_2[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |This test case assumes that during Commissioning AddNOC will be
sent with ICACValue |
|===

[[_required_devices_45]]
====== link:#_required_devices_45[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH1 |client
|3 |TH2 |client
|===

[[_device_topology_19]]
====== link:#_device_topology_19[]Device Topology

[[_test_setup_8]]
====== link:#_test_setup_8[]Test Setup

. A new fabric (Example: FabricID1 = 1111) is created by TH1 under its
root of trust to which the DUT will be commissioned
. A new fabric (Example: FabricID2 = 2222) is created by TH2 under its
root of trust to which the DUT will be commissioned

[[_test_procedure_45]]
====== link:#_test_procedure_45[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Factory Reset DUT |

|2 | | a|
* Commission DUT to TH1’s Fabric
* When DUT sends NOC response save FabricIndex as FabricIndex_TH1

|

|3 | | |Save TH1’s Fabric ID as FabricID1 |

|4 | | a|
* Commission DUT to TH2’s Fabric
* When DUT sends NOC response save FabricIndex as FabricIndex_TH2

|

|5 | | |Save TH2’s Fabric ID as FabricID2 |

|6 | |OPCREDS.S.A0005(CurrentFabricIndex) |From TH1 read the
CurrentFabricIndex |

|7 | | | |Verify that CurrentFabricIndex = FabricIndex_TH1

|8 |11.17.6.1 | |From TH1 read the entire NOCs List attribute with a
non-fabric-filtered read |

|9 | | | |Verify that there is only data for the entry whose FabricIndex
field is equal to FabricIndex_TH1

|10 |11.17.6.1 | |From TH1 read the entire NOCs List attribute with a
fabric-filtered read |

|11 | | | |Verify that there is only data for the entry whose
FabricIndex field is equal to FabricIndex_TH1

|12 | | |Read NOCStruct values from entry at index 0 |Verify that the
FabricIndex field equal to FabricIndex_TH1

|13 | | | a|
* From the NOCStruct values verify the following:
* NOC matches the NOC sent to the DUT during commissioning process
* ICAC matches the ICAC sent to the DUT during commissioning process
from AddNOC in pre-condition

|14 |11.17.5.3 | |Read the Fabrics List and get the
FabricDescriptorStruct for the entry where FabricIndex = FabricIndex_TH1
from DUT |

|15 | | | a|
* Verify that TH1 is able to read the FabricDescriptorStruct values
* Verify that Fabrics list does not have any entry as FabricID =
FabricID2

|16 | | |From TH2 read the CurrentFabricIndex |

|17 | | | |Verify that CurrentFabricIndex = FabricIndex_TH2

|18 |11.17.6.1 | |From TH2 read the entire NOCs List attribute with a
non-fabric-filtered read |

|19 | | | |Verify that there is only data for the entry whose
FabricIndex field is equal to FabricIndex_TH2

|20 |11.17.6.1 | |From TH2 read the entire NOCs List attribute with a
fabric-filtered read |

|21 | | | |Verify that there is only data for the entry whose
FabricIndex field is equal to FabricIndex_TH2

|22 | | |Read NOCStruct values from entry at index 1 |Verify that the
FabricIndex field equal to FabricIndex_TH2

|23 | | | a|
* From the NOCStruct values verify the following:
* NOC matches the NOC sent to the DUT during commissioning process
* ICAC matches the ICAC sent to the DUT during commissioning process
from AddNOC in pre-condition

|===

[[_notestesting_considerations_42]]
====== link:#_notestesting_considerations_42[]Notes/Testing considerations

'''''

[[_tc_opcreds_3_4_updatenoc_error_condition_dut_server]]
===== link:#_tc_opcreds_3_4_updatenoc_error_condition_dut_server[]15.2.3. [TC-OPCREDS-3.4] UpdateNOC-Error Condition [DUT-Server]

[[_category_46]]
====== link:#_category_46[]Category

Functional conformance

[[_purpose_47]]
====== link:#_purpose_47[]Purpose

This test verifies that the DUT properly handles the following error
conditions on UpdateNOC command:

* (link:#update-failsafe-required[4]) UpdateNOC command sent without
failsafe armed → FAILSAFE_REQUIRED
* (link:#update-no-csr[6]) UpdateNOC command sent without CSRRequest →
MissingCsr in StatusCode field in the CSRResponse
* (link:#update-not-update-csr[9]) UpdateNOC command send with
CSRRequest for IsForUpdateNOC set to false → CONSTRAINT_ERROR
* (link:#update-invalid-pubkey[11]) UpdateNOC certificate public key
does not match CSRRequest → InvalidPublicKey in the StatusCode field in
the CSRResponse
* (link:#update-bad-chain[14]) NOC does not chain back to the
TrustedRoot for this fabric → InvalidNOC in StatusCode field in the
CSRResponse
* (link:#update-bad-fabric-on-noc[16]) NOC has improper FabricID for
this fabric → InvalidNOC in StatusCode field in the CSRResponse
* (link:#update-bad-fabric-on-icac[18])ICAC has improper FabricID for
this fabric → InvalidNOC in StatusCode field in the CSRResponse
* (link:#update-after-root-cert[20]) AddTrustedRootCertificate in same
failsafe causes CONSTRAINT_ERROR
* (link:#update-pase[26]) UpdateNOC over PASE → UNSUPPORTED_ACCESS

[[_pics_46]]
====== link:#_pics_46[]PICS

* OPCREDS.S

[[_pre_conditions_3]]
====== link:#_pre_conditions_3[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH and DUT are commissioned |
|===

[[_required_devices_46]]
====== link:#_required_devices_46[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH |client
|===

[[_device_topology_20]]
====== link:#_device_topology_20[]Device Topology

TH1 commissions DUT on its fabric

[[_test_setup_9]]
====== link:#_test_setup_9[]Test Setup

[[_test_procedure_46]]
====== link:#_test_procedure_46[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.5 | |TH1 fully commissions the DUT |Verify that the commissioning
completes successfully

|2 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that the
returned list has a single entry. Save the NOC field as `noc_original`
and the ICAC field as `icac_original`

|3 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the returned list
has a single entry. Save the entry as `trusted_root_original`

|[#update-failsafe-required]####4 |11.17.7.9
|OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_original`
* ICACValue is to set `icac_original`

|Verify that the DUT responds with FAILSAFE_REQUIRED

|5 |11.9.7.2 | |TH1 sends ArmFailSafe command to the DUT with the
ExpiryLengthSeconds field set to 900 |Verify that DUT sends
ArmFailSafeResponse with the ErrorCode set to OK

|[#update-no-csr]####6 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_original`
* ICACValue is to set `icac_original`

|Verify that the DUT responds with a NOCResponse with the StatusCode
field set to MissingCsr

|7 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1 Sends CSRRequest
command with the IsForUpdateNOC field set to false |Verify that the DUT
returns a CSRResponse and save as `csr_not_update`

|8 |6.4.5.1 | a|
* TH1 generates a new NOC chain with ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_not_for_update`
and is signed by ICA. Save as `noc_not_for_update`
* ICAC must be signed by the original key for `trusted_root_original`.
Save as `icac_not_for_update`

|

|[#update-not-update-csr]####9 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC)
a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_not_for_update`
* ICACValue is to set `icac_not_for_update`

|Verify that the DUT responds with CONSTRAINT_ERROR

|10 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest ) |TH1 Sends CSRRequest
command with the IsForUpdateNOC field set to true |Verify that the DUT
returns a CSRResponse and save as `csr_update`

|[#update-invalid-pubkey]####11 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC)
a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_original`
* ICACValue is to set `icac_original`

|Verify that the DUT responds with a NOCResponse with the StatusCode
field set to InvalidPublicKey

|12 |6.4.5.1 | a|
* TH1 generates a new Trusted Root Certificate and Private Key and saves
as `new_root_cert` and `new_root_key` so that TH can generate an NOC for
UpdateNOC that doesn’t chain to the original root

|

|13 |6.4.5.1 | a|
* TH1 generates a new NOC and ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_update` and is
signed by new ICA. Save as `noc_update_new_root`
* new ICAC is generated and signed by `new_root_key`. Save as
`icac_update_new_root`

|

|[#update-bad-chain]####14 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_update_new_root`
* ICACValue is to set `icac_update_new_root`

|Verify that the DUT responds with a NOCResponse with the StatusCode
field set to InvalidNOC

|15 |6.4.5.1 | a|
* TH1 generates a new NOC and ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_update` with the
matter-fabric-id set to a different value than `noc_original`. The NOC
is signed by new ICA. Save as `noc_update_bad_fabric_on_noc`
* new ICAC is generated with the and matter-fabric-id omitted. ICAC is
signed by the original key for `trusted_root_original`. Save as
`icac_update_bad_fabric_on_noc`

|

|[#update-bad-fabric-on-noc]####16 |11.17.7.9
|OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_update_bad_fabric_on_noc`
* ICACValue is to set `icac_update_bad_fabric_on_noc`

|Verify that the DUT responds with a NOCResponse with the StatusCode
field set to InvalidNOC

|17 |6.4.5.1 | a|
* TH1 generates a new NOC and ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_update` with the
matter-fabric-id set to the same value as `noc_original`. The NOC is
signed by new ICA. Save as `noc_update_bad_fabric_on_icac`
* new ICAC is generated with the and matter-fabric-id included as set to
a different value than `noc_original`. ICAC is signed by the original
key for `trusted_root_original`. Save as
`icac_update_bad_fabric_on_icac`

|

|[#update-bad-fabric-on-icac]####18 |11.17.7.9
|OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_update_bad_fabric_on_icac`
* ICACValue is to set `icac_update_bad_fabric_on_icac`

|Verify that the DUT responds with a NOCResponse with the StatusCode
field set to InvalidNOC

|19 |11.17.7.13 |OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) |TH1 sends
AddTrustedRootCertificate command to DUT again with the
RootCACertificate field set to `new_root_cert` |Verify that the returned
Status Code is SUCCESS

|[#update-after-root-cert]####20 |11.17.7.9
|OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_update_new_root`
* ICACValue is to set `icac_update_new_root`

|Verify that the DUT responds with CONSTRAINT_ERROR

|21 |11.9.7.2 | |TH1 sends ArmFailSafe command to the DUT with the
ExpiryLengthSeconds field set to 0 |Verify that DUT sends
ArmFailSafeResponse with the ErrorCode set to OK

|22 |11.18.8.1 | |TH1 sends an OpenCommissioningWindow command to the
DUT |Verify that the DUT returns SUCCESS

|23 | | |TH1 connects to the DUT over PASE and sends ArmFailSafe command
to the DUT with the ExpiryLengthSeconds field set to 900. Steps
link:#pase-start[24]-link:#update-pase[26] are all performed over the
PASE connection. |Verify that DUT sends ArmFailSafeResponse with the
ErrorCode set to OK.

|[#pase-start]####24 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1
Sends CSRRequest command over PASE with the IsForUpdateNOC field set to
true |Verify that the DUT returns a CSRResponse and save as `csr_pase`

|25 |6.4.5.1 | a|
* TH1 generates a new NOC chain with ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_pase` and is
signed by ICA. Save as `noc_pase`
* ICAC must be signed by the original key for `trusted_root_original`.
Save as `icac_pase`

|

|[#update-pase]####26 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster over PASE with the following fields:
* NOCValue is set to `noc_pase`
* ICACValue is to set `icac_pase`

|Verify that the DUT responds with UNSUPPORTED_ACCESS
|===

[[_tc_opcreds_3_5_noc_check_for_updatenoc_dut_server]]
===== link:#_tc_opcreds_3_5_noc_check_for_updatenoc_dut_server[]15.2.4. [TC-OPCREDS-3.5] NOC Check for UpdateNOC [DUT-Server]

[[_category_47]]
====== link:#_category_47[]Category

Functional conformance

[[_purpose_48]]
====== link:#_purpose_48[]Purpose

. To verify that when TH sends UpdateNOC command the NOC values are
updated correctly on the DUT.
. To verify that the previous NOC value from TH is not stored on DUT.
. To verify that failsafe expiry successfully reverts NOC changes.

[[_pics_47]]
====== link:#_pics_47[]PICS

* OPCREDS.S

[[_pre_conditions_4]]
====== link:#_pre_conditions_4[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_47]]
====== link:#_required_devices_47[]Required Devices

[width="100%",cols="14%,33%,53%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH1 |client
|===

[[_device_topology_21]]
====== link:#_device_topology_21[]Device Topology

[[_test_setup_10]]
====== link:#_test_setup_10[]Test Setup

[[_test_procedure_47]]
====== link:#_test_procedure_47[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.5 | |TH1 fully commissions the DUT |Verify that the commissioning
completes successfully

|2 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that the
returned list has a single entry. Save the NOC field as `noc_original`
and the ICAC field as `icac_original`

|3 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the returned list
has a single entry. Save the entry as `trusted_root_original`

|4 |11.9.7.2 | |TH1 sends ArmFailSafe command to the DUT with the
ExpiryLengthSeconds field set to 900 |Verify that DUT sends
ArmFailSafeResponse with the ErrorCode set to OK

|5 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1 Sends CSRRequest
command with the IsForUpdateNOC field set to true |Verify that the DUT
returns a CSRResponse and save as `csr_update1`

|6 |6.4.5.1 | a|
* TH1 generates a new NOC and ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_update1`. The
subject is set to match `noc_original`. The NOC is signed by the new
ICA. Save as `noc_update1`
* new ICAC must be distinguishable from `icac_original`. This can be
accomplished by changing any of the following: the subject, subject
public key or validity. The certificate must be valid. ICAC is signed by
the original key for `trusted_root_original`. Save as `icac_update1`

|

|7 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_update1`
* ICACValue is to set `icac_update1`

|Verify that the DUT responds with a NOCResponse having its StatusCode
field set to Ok

|8 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that the
returned list has a single entry. Verify that the NOC field matches
`noc_update1` and the ICAC field matches `icac_update1`

|9 |11.9.7.2 | |TH1 sends ArmFailSafe command to the DUT with the
ExpiryLengthSeconds field set to 0 |Verify that DUT sends
ArmFailSafeResponse with the ErrorCode set to OK

|10 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that the
returned list has a single entry. Verify that the NOC field matches
`noc_original` and the ICAC field matches `icac_original`, due to the
explicit expiry of the fail-safe done in the previous step, which is
expected to have reverted the updated credentials back to their original
value.

|11 |11.9.7.2 | |TH1 sends ArmFailSafe command to the DUT with the
ExpiryLengthSeconds field set to 900 |Verify that DUT sends
ArmFailSafeResponse with the ErrorCode set to OK

|12 |11.17.7.5 |OPCREDS.S.C04.Rsp(CSRRequest) |TH1 Sends CSRRequest
command with the IsForUpdateNOC field set to true |Verify that the DUT
returns a CSRResponse and save as `csr_update2`

|13 |6.4.5.1 | a|
* TH1 generates a new NOC and ICAC with the following properties:
* new NOC is generated from the NOCSR returned in `csr_update2`. The
subject is set to match `noc_original`. The NOC is signed by new ICA.
Save as `noc_update2`
* new ICAC must be distinguishable from `icac_original` and
`icac_update1`. This can be accomplished by changing any of the
following: the subject, subject public key or validity. The certificate
must be valid. ICAC is signed by the original key for
`trusted_root_original`. Save as `icac_update2`

|

|14 |11.17.7.9 |OPCREDS.S.C07.Rsp(UpdateNOC) a|
* TH1 sends the UpdateNOC command to the Node Operational Credentials
cluster with the following fields:
* NOCValue is set to `noc_update2`
* ICACValue is to set `icac_update2`

|Verify that the DUT responds with a NOCResponse having its StatusCode
field set to Ok

|15 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that the
returned list has a single entry. Verify that the NOC field matches
`noc_update2` and the ICAC field matches `icac_update2`

|16 |11.9.7.6 | |TH1 sends the CommissioningComplete command to the
General Commissioning cluster |Verify that the DUT returns a
CommissioningCompleteResponse with the ErrorCode set to OK

|17 |11.9.7.2 | |TH1 sends ArmFailSafe command to the DUT with the
ExpiryLengthSeconds field set to 0 to verify that the
CommissioningComplete command successfully persisted the failsafe
context. |Verify that DUT sends ArmFailSafeResponse with the ErrorCode
set to OK

|18 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that the
returned list has a single entry. Verify that the NOC field matches
`noc_update2` and the ICAC field matches `icac_update2`
|===

[[_notestesting_considerations_43]]
====== link:#_notestesting_considerations_43[]Notes/Testing considerations

[[_tc_opcreds_3_6_last_fabric_removal_validation_dut_server]]
===== link:#_tc_opcreds_3_6_last_fabric_removal_validation_dut_server[]15.2.5. [TC-OPCREDS-3.6] Last Fabric removal validation [DUT-Server]

[[_category_48]]
====== link:#_category_48[]Category

Functional conformance

[[_purpose_49]]
====== link:#_purpose_49[]Purpose

To verify that when TH sends RemoveFabric command for last Fabric, DUT
SHALL delete all Matter related data on the node which was created since
it was commissioned.

[[_pics_48]]
====== link:#_pics_48[]PICS

* OPCREDS.S

[[_pre_conditions_5]]
====== link:#_pre_conditions_5[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_48]]
====== link:#_required_devices_48[]Required Devices

[width="100%",cols="14%,33%,53%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH1 |client
|===

[[_device_topology_22]]
====== link:#_device_topology_22[]Device Topology

[[_test_setup_11]]
====== link:#_test_setup_11[]Test Setup

[[_test_procedure_48]]
====== link:#_test_procedure_48[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.5 | |TH1 fully commissions the DUT |Verify that the commissioning
completes successfully

|2 |11.17.7.12 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH1 sends RemoveFabric
command with Fabric Index as FabricIndex_TH1 to DUT |

|3 |11.17.6.5 | |DUT shouldn’t be discoverable via both commissionable
and operational advertisements |Verify that the DUT is not discoverable
over DNS-SD in both TCP and UDP
|===

[[_notestesting_considerations_44]]
====== link:#_notestesting_considerations_44[]Notes/Testing considerations

[[_tc_opcreds_3_7_add_second_fabric_over_case_dut_server]]
===== link:#_tc_opcreds_3_7_add_second_fabric_over_case_dut_server[]15.2.6. [TC-OPCREDS-3.7] Add Second Fabric over CASE [DUT-Server]

[[_category_49]]
====== link:#_category_49[]Category

Functional conformance

[[_purpose_50]]
====== link:#_purpose_50[]Purpose

To verify that a DUT can be added to a second fabric using AddNOC
command.

[[_pics_49]]
====== link:#_pics_49[]PICS

* OPCREDS.S

[[_pre_conditions_6]]
====== link:#_pre_conditions_6[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |6.4.10 |TH1 and TH2 are 2 clients that trust each other |
|===

[[_required_devices_49]]
====== link:#_required_devices_49[]Required Devices

[width="100%",cols="14%,33%,53%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH1 |Test harness as Client 1, a commissioner device
|2 |TH2 |Test harness as Client 2, a commissioner device
|3 |DUT |DUT - Server, a commissionee device
|===

[[_device_topology_23]]
====== link:#_device_topology_23[]Device Topology

[[_test_setup_12]]
====== link:#_test_setup_12[]Test Setup

[[_test_procedure_49]]
====== link:#_test_procedure_49[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.17.5.1 |OPCREDS.S.A0000(NOCs) |Factory Reset DUT (to ensure NOC
list is empty at the beginning of the following steps) |

|2 |5.5 | a|
Start the commissioning process of DUT by TH1 on the first Fabric.

a|
Verify that TH1 successfully completes commissioning, including
establishing a CASE session on the operational network and issuing a
`CommissioningComplete` command.

|3 |11.17.5.2 |OPCREDS.S.A0001(Fabrics) a|
TH1 does a non-fabric-filtered read of the `Fabrics` attribute from the
Node Operational Credentials cluster. Save the FabricIndex for TH1 as
[#TH1_FABRICINDEX]## `TH1_Fabric_Index` for future use.

a|
Verify that there is a single entry in the list and the FabricIndex for
that entry matches link:#TH1_FABRICINDEX[`TH1_Fabric_Index`].

|4 |11.9.6.2, 11.9.6.3 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

a|
TH1 sends `ArmFailSafe` command to the DUT with the
`ExpiryLengthSeconds` field set to 60 seconds

a|
Verify that the DUT sends `ArmFailSafeResponse` command to TH1 with
field ErrorCode as `OK`(0)

|[#step_csr_elements]####5 |11.17.6.5 |OPCREDS.S.C04.Rsp(CSRRequest) a|
TH1 Sends `CSRRequest` command with a random 32-byte nonce

a|
Verify that the DUT responds with the `CSRResponse` command

|6 |6.4.6.1, 11.17.4.9 |OPCREDS.S.C04.Rsp(CSRRequest) a|
TH1 validates the Device Attestation Signature (attestation_signature)
field from `CSRResponse` command in link:#step_csr_elements[Step 5]

a|
Verify that TH1 successfully validates the Device Attestation Signature.

|7 |6.4 | a|
* TH2 generates the NOC, the Root CA Certificate and ICAC using the CSR
elements from link:#step_csr_elements[Step 5] and selects an IPK, all
for use by TH2. The certificates shall have their subjects padded with
additional data such that they are each the maximum certificate size of
400 bytes when encoded in the MatterCertificateEncoding.
* [#TH2_RCAC]## Save RCAC as `Root_CA_Certificate_TH2`
* [#TH2_ICAC]## Save ICAC as `Intermediate_Certificate_TH2`
* [#TH2_NOC]## Save NOC as `Node_Operational_Certificate_TH2`
* [#TH2_IPK]## Save IPK as `IPK_TH2`
* Extract the RCAC public key and save as `Root_Public_Key_TH2`

|

|8 |11.17.6.13 |OPCREDS.S.C0b.Rsp(AddTrustedRootCertificate) a|
TH1 sends `AddTrustedRootCertificate` command to DUT with
`RootCACertificate` set to link:#TH2_RCAC[`Root_CA_Certificate_TH2`]

a|
Verify that `AddTrustedRootCertificate` command succeeds by sending the
status code as `SUCCESS`

|9 |11.17.6.8, 11.17.6.10 a|
* OPCREDS.S.C06.Rsp(AddNOC)
* OPCREDS.S.C08.Tx(NOCResponse)

a|
TH1 sends the `AddNOC` command to DUT with the following fields:

* NOCValue as link:#TH2_NOC[`Node_Operational_Certificate_TH2`]
* ICACValue as link:#TH2_ICAC[`Intermediate_Certificate_TH2`]
* IpkValue as link:#TH2_IPK[`IPK_TH2`]
* CaseAdminSubject as the NodeID of TH2
* AdminVendorId as the Vendor ID of TH2

a|
* Verify that DUT responds with `NOCResponse` with status code `OK`

|10 |5.5 - 13 | |TH2 starts discovery of DUT using Operational Discovery
|

|11 |5.5 - 14, 4.13.2 | |TH2 opens a CASE session with DUT over
operational network |DUT is able to open the CASE session with TH2

|12 |5.5 - 15 |CGEN.S.C05.Tx a|
TH2 sends `CommissioningComplete` command

a|
DUT respond with `SUCCESS` at `CommissioningComplete` command sent by
TH2

|13 |11.17.5.2 |OPCREDS.S.A0001(Fabrics) a|
TH1 does a non-fabric-filtered read of the `Fabrics` attribute from the
Node Operational Credentials cluster. Save the FabricIndex for TH2’s
entry as [#TH2_FABRICINDEX]## `TH2_Fabric_Index` for future use.

|Verify that there are 2 entries in the list where one entry matches
link:#TH1_FABRICINDEX[`TH1_Fabric_Index`] and the other matches
link:#TH2_FABRICINDEX[`TH2_Fabric_Index`].

|14 |11.17.5.2 |OPCREDS.S.A0001(Fabrics) a|
TH2 does a non-fabric-filtered read of the `Fabrics` attribute from the
Node Operational Credentials cluster

|Verify that there are 2 entries in the list where one entry matches
link:#TH1_FABRICINDEX[`TH1_Fabric_Index`] and the other matches
link:#TH2_FABRICINDEX[`TH2_Fabric_Index`].

|15 |11.17.6.12 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH1 sends
`RemoveFabric` command to DUT with the FabricIndex field set to
link:#TH2_FABRICINDEX[`TH2_Fabric_Index`]. a|
Verify that DUT sends `NOCResponse` command with status code `OK`

|===

[[_notestesting_considerations_45]]
====== link:#_notestesting_considerations_45[]Notes/Testing considerations

'''''

[[_dut_as_client]]
==== link:#_dut_as_client[]15.3. DUT as Client

'''''

[[_tc_opcreds_3_3_attribute_nocs_commands_dut_client]]
===== link:#_tc_opcreds_3_3_attribute_nocs_commands_dut_client[]15.3.1. [TC-OPCREDS-3.3] Attribute-NOCs, Commands [DUT-Client]

[[_category_50]]
====== link:#_category_50[]Category

Functional conformance

[[_purpose_51]]
====== link:#_purpose_51[]Purpose

This test case verifies that the

. DUT is able to read the attributes of Node Operational Credential
cluster
. DUT is able to send the commands of the Operational Credential cluster
from the client side.

[[_pics_50]]
====== link:#_pics_50[]PICS

* OPCREDS.C

[[_pre_conditions_7]]
====== link:#_pre_conditions_7[]Pre-Conditions

[[_required_devices_50]]
====== link:#_required_devices_50[]Required Devices

[width="100%",cols="7%,40%,53%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |client
|2 |TH |server
|===

[[_device_topology_24]]
====== link:#_device_topology_24[]Device Topology

[[_test_setup_13]]
====== link:#_test_setup_13[]Test Setup

A new fabric is created by DUT to which the TH will be commissioned

[[_test_procedure_50]]
====== link:#_test_procedure_50[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.17.6.1 |MCORE.UI.FACTORYRESET |Factory Reset DUT (to ensure NOC
list is empty at the beginning of the following steps) |

|2 |5.5 | |Start the commissioning process of TH with DUT |

|3 |11.17.7.1 |OPCREDS.C.C00.Tx(AttestationRequest) |Verify that TH
receives AttestationRequest Command from DUT |

|4 |11.17.7.3 |OPCREDS.C.C02.Tx(CertificateChainRequest) |Verify that TH
receives CertificateChainRequest Command from DUT |

|5a |11.17.7.5 |OPCREDS.C.C04.Tx(CSRRequest ) |Verify that the TH
receives CSRRequest command from DUT |

|5b | | a|
Extract the CSRResponse values for future use from TH

. NOCSRElements - which contains the Node Operational PublicKey from CSR
. AttestationSignature

|

|6 |11.17.7.13 |OPCREDS.C.C0b.Tx(AddTrustedRootCertificate) |Verify that
TH receives AddTrustedRootCertificate command from DUT |

|7a |11.17.7.8 |OPCREDS.C.C06.Tx(AddNOC) |Verify that TH receives AddNOC
Command from DUT |

|7b | | a|
TH saves the following values as:

* NOCValue as nocvalue1
* ICACValue as icacvalue1
* IpkValue as ipkvalue1
* CaseAdminSubject as caseadmin1
* AdminVendorId as adminvendorid1

|

|8 | | a|
Extract the following FabricDescriptorStruct values from TH

. RootPublicKey
. VendorID
. FabricID
. NodeID
. Label

|

|9 | | | a|
* Verify that the size of RootPublicKey is within 65 octstr
* Verify that the NodeID is the same as the chip-node-id in the NOC sent
with AddNOC Command
* Verify that the VendorID is the same as the AdminVendorID sent with
AddNOC Command
* Verify that the FabricID is the same as the matter-fabric-id field
from the operational certificate
* Verify that the size of Label has a maximum value of 32 bytes.

|10 | | | a|
* Verify that the public Key extracted NOCValue of the AddNOC matches
the Node Operational Public Key extracted from CSRResponse

|11 |11.17.7.9 |OPCREDS.C.C07.Tx(UpdateNOC ) |Trigger the DUT to send
UpdateNOC to TH |Verify that TH receives UpdateNOC Command from DUT
successfully.

|12 |11.17.7.11 |OPCREDS.C.C09.Tx(UpdateFabricLabel) |Trigger the DUT to
send UpdateFabricLabel to TH |Verify that TH receives UpdateFabricLabel
Command from DUT successfully.

|13 |11.17.6.3 |OPCREDS.C.A0002(SupportedFabrics) |Trigger the DUT to
Read SupportedFabrics from TH |Verify that TH receives read
SupportedFabrics attribute from DUT successfully

|14 |11.17.6.4 |OPCREDS.C.A0003(CommissionedFabrics) |Trigger the DUT to
read CommissionedFabrics attribute from TH |Verify that TH receives read
CommissionedFabrics attribute from DUT successfully.

|15 |11.17.6.4 |OPCREDS.C.A0004(TrustedRootCertificates) |Trigger the
DUT to read TrustedRootCertificates attribute from TH |Verify that TH
receives read TrustedRootCertificates from DUT successfully.

|16 |11.17.6.5 |OPCREDS.C.A0005(CurrentFabricIndex) |Trigger the DUT to
read CurrentFabricIndex attribute from TH |Verify that TH receives read
CurrentFabricIndex from DUT successfully.

|17 |11.17.7.12 |OPCREDS.C.C0a.Tx(RemoveFabric) |Trigger the DUT to send
RemoveFabric command to TH |Verify that TH receives RemoveFabric Command
for the FabricID saved from FabricDescriptor
|===

[[_notestesting_considerations_46]]
====== link:#_notestesting_considerations_46[]Notes/Testing considerations

Test Step #10 cannot be executed with V1.0 SDK.

[[_network_commissioning_test_plan]]
== link:#_network_commissioning_test_plan[]**Network Commissioning Test Plan**

[[_pics_definition_5]]
=== link:#_pics_definition_5[]16. PICS Definition

This section covers the NetworkCommissioning Cluster Cluster related
PICS items that are referenced in the following test cases.

[[_role_4]]
==== link:#_role_4[]16.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.S |Does the device implement the NetworkCommissioning Cluster
cluster as a server? |M |

|CNET.C |Does the device implement the NetworkCommissioning Cluster
cluster as a client? |O |
|===

[[_server_3]]
==== link:#_server_3[]16.2. Server

[[_features]]
===== link:#_features[]16.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.S.F00(WI) |Does the device implement the "Wi-Fi related features"
? |MCORE.COM.WIFI |

|CNET.S.F01(TH) |Does the device implement the "Thread related features"
|MCORE.COM.THR |

|CNET.S.F02(ET) |Does the device implement the "Ethernet related
features" ? |MCORE.COM.ETH |
|===

[[_attributes_4]]
===== link:#_attributes_4[]16.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.S.A0000(MaxNetworks) |Does the DUT(Server) support MaxNetworks
attribute? |M |

|CNET.S.A0001(Networks) |Does the DUT(Server) support Networks
attribute? |M |

|CNET.S.A0002(ScanMaxTimeSeconds) |Does the DUT(Server) support
ScanMaxTimeSeconds attribute? |CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.A0003(ConnectMaxTimeSeconds) |Does the DUT(Server) support
ConnectMaxTimeSeconds attribute? |CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.A0004(InterfaceEnabled) |Does the DUT(Server) support
InterfaceEnabled attribute? |M |

|CNET.S.A0005(LastNetworkingStatus) |Does the DUT(Server) support
LastNetworkingStatus attribute? |M |

|CNET.S.A0006(LastNetworkID) |Does the DUT(Server) support LastNetworkID
attribute? |M |

|CNET.S.A0007(LastConnectErrorValue) |Does the DUT(Server) support
LastConnectErrorValue attribute? |M |
|===

[[_commands_received_3]]
===== link:#_commands_received_3[]16.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.S.C00.Rsp(ScanNetworks) |Does the Device(Server) implement
receiving the ScanNetworks command? |CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork) |Does the Device(Server)
implement receiving the AddOrUpdateWiFiNetwork command? |CNET.S.F00(WI)
|

|CNET.S.C03.Rsp(AddOrUpdateThreadNetwork) |Does the Device(Server)
implement receiving the AddOrUpdateThreadNetwork command?
|CNET.S.F01(TH) |

|CNET.S.C04.Rsp(RemoveNetwork) |Does the Device(Server) implement
receiving the RemoveNetwork command? |CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.C06.Rsp(ConnectNetwork) |Does the Device(Server) implement
receiving the ConnectNetwork command? |CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.C08.Rsp(ReorderNetwork) |Does the Device(Server) implement
receiving the ReorderNetwork command? |CNET.S.F00(WI)|CNET.S.F01(TH) |
|===

[[_commands_generated_3]]
===== link:#_commands_generated_3[]16.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.S.C01.Tx(ScanNetworksResponse) |Does the Device(Server)
invoking/generating the ScanNetworksResponse command?
|CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.C05.Tx(NetworkConfigResponse) |Does the Device(Server)
invoking/generating the NetworkConfigResponse command?
|CNET.S.F00(WI)|CNET.S.F01(TH) |

|CNET.S.C07.Tx(ConnectNetworkResponse) |Does the Device(Server)
invoking/generating the ConnectNetworkResponse command?
|CNET.S.F00(WI)|CNET.S.F01(TH) |
|===

[[_client_2]]
==== link:#_client_2[]16.3. Client

[[_features_2]]
===== link:#_features_2[]16.3.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.C.F00(WI) |Does the device implement the "Wi-Fi related features"
? |O |

|CNET.C.F01(TH) |Does the device implement the "Thread related features"
|O |

|CNET.C.F02(ET) |Does the device implement the "Ethernet related
features" ? |O |
|===

[[_commands_generated_4]]
===== link:#_commands_generated_4[]16.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CNET.C.C00.Tx(ScanNetworks) |Does the Device(Client)
invoking/generating the ScanNetworks command? |O |

|CNET.C.C02.Tx(AddOrUpdateWiFiNetwork) |Does the Device(Client)
invoking/generating the AddOrUpdateWiFiNetwork command? |O |

|CNET.C.C03.Tx(AddOrUpdateThreadNetwork) |Does the Device(Client)
invoking/generating the AddOrUpdateThreadNetwork command? |O |

|CNET.C.C04.Tx(RemoveNetwork) |Does the Device(Client)
invoking/generating the RemoveNetwork command? |O |

|CNET.C.C06.Tx(ConnectNetwork) |Does the Device(Client)
invoking/generating the ConnectNetwork command? |O |

|CNET.C.C08.Tx(ReorderNetwork) |Does the Device(Client)
invoking/generating the ReorderNetwork command? |O |
|===

[[_pixit_definition_2]]
=== link:#_pixit_definition_2[]17. PIXIT Definition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |Access point SSID to use for
tests |CNET.S.F00(WI) |

|PIXIT.CNET.WIFI_1ST_ACCESSPOINT_CREDENTIALS |Credentials for SSID
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |CNET.S.F00(WI) |

|PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID |SSID of a second valid access
point |CNET.S.F00(WI) |

|PIXIT.CNET.WIFI_2ND_ACCESSPOINT_CREDENTIALS |Credentials for SSID
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID |CNET.S.F00(WI) |

|PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |Valid thread
OperationalDataset |CNET.S.F01(TH) |

|PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET |Second valid thread
OperationalDataset |CNET.S.F01(TH) |

|PIXIT.CNET.ENDPOINT_WIFI |DUT’s supporting Endpoint for the Network
Commissioning |CNET.S.F00(WI) |

|PIXIT.CNET.ENDPOINT_THREAD |DUT’s supporting Endpoint for the Network
Commissioning |CNET.S.F01(TH) |

|PIXIT.CNET.ENDPOINT_ETHERNET |DUT’s supporting Endpoint for the Network
Commissioning |CNET.S.F02(ET) |
|===

[[_test_case_list_4]]
=== link:#_test_case_list_4[]18. Test Case List

[width="100%",cols="20%,80%",]
|===
|*TC UUID* |*Test Case Name*

|TC-CNET-1.3 |Global Attributes with DUT as Server

|TC-CNET-4.1 |[Wi-Fi] Verification for attributes check [DUT-Server]

|TC-CNET-4.2 |[Thread] Verification for attributes check [DUT-Server]

|TC-CNET-4.3 |[Ethernet] Verification for attributes check [DUT-Server]

|TC-CNET-4.4 |[Wi-Fi] Verification for ScanNetworks command [DUT-Server]

|TC-CNET-4.5 |[Wi-Fi] FAILSAFE_REQUIRED message Validation [DUT-Server]

|TC-CNET-4.6 |[Thread] FAILSAFE_REQUIRED message Validation [DUT-Server]

|TC-CNET-4.9 |[Wi-Fi] Verification for RemoveNetwork Command
[DUT-Server]

|TC-CNET-4.10 |[Thread] Verification for RemoveNetwork Command
[DUT-Server]

|TC-CNET-4.11 |[Wi-Fi] Verification for ConnectNetwork Command
[DUT-Server]

|TC-CNET-4.12 |[Thread] Verification for ConnectNetwork Command
[DUT-Server]

|TC-CNET-4.13 |[Wi-Fi] Verification for ReorderNetwork command
[DUT-Server]

|TC-CNET-4.14 |[Thread] Verification for ReorderNetwork command
[DUT-Server]

|TC-CNET-4.15 |[Wi-Fi] NetworkIDNotFound returned in
LastNetworkingStatus field validation [DUT-Server]

|TC-CNET-4.16 |[Thread] NetworkIDNotFound returned in
LastNetworkingStatus field validation [DUT-Server]

|TC-CNET-4.20 |[Wi-Fi] Verification for commands check [DUT-Client]

|TC-CNET-4.21 |[Thread] Verification for commands check [DUT-Client]

|TC-CNET-4.22 |[Thread] Verification for ScanNetworks command
[DUT-Server]
|===

[[_test_cases_4]]
=== link:#_test_cases_4[]19. Test Cases

'''''

[[_generic_test_cases_3]]
==== link:#_generic_test_cases_3[]19.1. Generic Test Cases

'''''

[[_tc_cnet_1_3_global_attributes_with_dut_as_server]]
===== link:#_tc_cnet_1_3_global_attributes_with_dut_as_server[]19.1.1. [TC-CNET-1.3] Global Attributes with DUT as Server

[[_category_51]]
====== link:#_category_51[]Category

Functional conformance.

[[_purpose_52]]
====== link:#_purpose_52[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_51]]
====== link:#_pics_51[]PICS

* CNET.S

[[_required_devices_51]]
====== link:#_required_devices_51[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_51]]
====== link:#_test_procedure_51[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if CNET.S.F00(WI)

- bit 1: SHALL be 1 if and only if CNET.S.F01(TH)

- bit 2: SHALL be 1 if and only if CNET.S.F02(ET)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0004, 0x0005, 0x0006, 0x0007, 0xfff8, 0xfff9, 0xfffb,
0xfffc & 0xfffd.

The list include entries based on feature support: +
- 0x0002: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and
SHALL NOT be included otherwise.

- 0x0003: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and
SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list include entries based on feature support: +
- 0x00: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

- 0x02: SHALL be included if CNET.S.F00(WI) and SHALL NOT be included
otherwise.

- 0x03: SHALL be included if CNET.S.F01(TH) and SHALL NOT be included
otherwise.

- 0x04: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

- 0x06: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

- 0x08: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list include entries based on feature support: +
- 0x01: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

- 0x05: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

- 0x07: SHALL be included if CNET.S.F00(WI) or CNET.S.F01(TH) and SHALL
NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_47]]
====== link:#_notestesting_considerations_47[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_dut_as_server_3]]
==== link:#_dut_as_server_3[]19.2. DUT as Server

'''''

[[_tc_cnet_4_1_wi_fi_verification_for_attributes_check_dut_server]]
===== link:#_tc_cnet_4_1_wi_fi_verification_for_attributes_check_dut_server[]19.2.1. [TC-CNET-4.1] [Wi-Fi] Verification for attributes check [DUT-Server]

[[_category_52]]
====== link:#_category_52[]Category

Functional conformance

[[_purpose_53]]
======= link:#_purpose_53[]Purpose

* Verifying the DUT is connected with the Wi-Fi interface
* Verifying the following attributes check:
+
. DUT’s MaxNetworks attribute value needs to be within a range of 1 to
255
. DUT’s Networks attribute list will follow the NetworkInfo structure
for each entry
. DUT’s ScanMaxTimeSeconds attribute value must be within 255 seconds
. DUT’s ConnectMaxTimeSeconds attribute value must be within 255 seconds
. DUT’s InterfaceEnabled attribute value must be True
. DUT’s LastNetworkingStatus attribute value will be within any one of
the following values Success, NetworkNotFound, OutOfRange,
RegulatoryError, UnknownError, null
. DUT’s LastNetworkID attribute value will be of type octstr with a
length range of 1 to 32 and even null value
. DUT’s LastConnectErrorValue attribute value must be null

[[_pics_52]]
====== link:#_pics_52[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_8]]
====== link:#_pre_conditions_8[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F00(WI) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|4 | |TH can communicate with the DUT |
|===

[[_required_devices_52]]
======= link:#_required_devices_52[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_52]]
======= link:#_test_procedure_52[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Factory reset the DUT |

|2 | | |Commission TH and DUT over BLE to setup the Wi-Fi |

|3 a|
* 9.6
* 9.6.4.2

| a|
* TH reads Descriptor Cluster from the DUT with EP0
* TH reads ServerList from the DUT

|Verify for the presence of an element with value 49 (0x0031) in the
ServerList. If the value is present, then continue with the test case

|4 |7.13.2 | |TH reads FeatureMap attribute from the DUT |Verify that
FeatureMap attribute value is equal to 1. If the value is 1, then
continue with the test case

|5 |11.8.7.1 |CNET.S.A0000(MaxNetworks) |TH reads the MaxNetworks
attribute from the DUT |Verify that MaxNetworks attribute value is
within a range of 1 to 255

|6 | | |TH saves the MaxNetworks attribute value as 'MaxNetworksValue'
for future use |

|7 a|
* 11.8.7.2
* 11.8.6.3

|CNET.S.A0001(Networks) |TH reads the Networks attribute list from the
DUT a|
* Verify that each element in the Networks attribute list has the
following fields:
+
. NetworkID field is of type octstr with a length range 1 to 32
. The connected field is of type bool
* Verify that only one entry has connected status as TRUE and that entry
has the NetworkID set to the hex representation of the ASCII values for
the SSID of the Wi-Fi set up during commissioning
* Verify that the number of entries in the `Networks` attribute is less
than or equal to 'MaxNetworksValue'

|8 |11.8.7.3 |CNET.S.A0002(ScanMaxTimeSeconds) |TH reads
ScanMaxTimeSeconds attribute from the DUT |Verify that
ScanMaxTimeSeconds attribute value is within the range of 1 to 255
seconds

|9 |11.8.7.4 |CNET.S.A0003(ConnectMaxTimeSeconds) |TH reads
ConnectMaxTimeSeconds Attribute from the DUT |Verify that
ConnectMaxTimeSeconds attribute value is within the range of 1 to 255
seconds

|10 |11.8.7.5 |CNET.S.A0004(InterfaceEnabled) |TH reads InterfaceEnabled
attribute from the DUT |Verify that InterfaceEnabled attribute value is
true

|11 |11.8.7.6 |CNET.S.A0005(LastNetworkingStatus) |TH reads
LastNetworkingStatus attribute from the DUT a|
* Verify that LastNetworkingStatus attribute is Success

|12 |11.8.7.7 |CNET.S.A0006(LastNetworkID) a|
* TH reads the LastNetworkID attribute from the DUT
* TH reads the Networks attribute from the DUT

|Verify that LastNetworkID attribute matches the NetworkID value of one
of the entries in the Networks attribute list, or if the Networks
attribute list is Empty, then LastNetworkID attribute value is null

|13 |11.8.7.8 |CNET.S.A0007(LastConnectErrorValue) |TH reads the
LastConnectErrorValue attribute from the DUT |Verify that
LastConnectErrorValue attribute value is null
|===

[[_tc_cnet_4_2_thread_verification_for_attributes_check_dut_server]]
===== link:#_tc_cnet_4_2_thread_verification_for_attributes_check_dut_server[]19.2.2. [TC-CNET-4.2] [Thread] Verification for attributes check [DUT-Server]

[[_category_53]]
====== link:#_category_53[]Category

Functional conformance

[[_purpose_54]]
====== link:#_purpose_54[]Purpose

* Verifying the DUT is connected with the Thread interface
* Verifying the following attributes check:
+
. DUT’s MaxNetworks attribute value needs to be within a range of 1 to
255
. DUT’s Networks attribute list will follow the NetworkInfo structure
for each entry
. DUT’s ScanMaxTimeSeconds attribute value must be within 255 seconds
. DUT’s ConnectMaxTimeSeconds attribute value must be within 255 seconds
. DUT’s InterfaceEnabled attribute value must be True
. DUT’s LastNetworkingStatus attribute value will be within any one of
the following values Success, NetworkNotFound, OutOfRange,
RegulatoryError, UnknownError, null
. DUT’s LastNetworkID attribute value will be of type octstr with a
length range of 1 to 32 and even null value
. DUT’s LastConnectErrorValue attribute value must be null

[[_pics_53]]
====== link:#_pics_53[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_9]]
====== link:#_pre_conditions_9[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F01(TH) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
|

|4 | |TH can communicate with the DUT on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |
|===

[[_required_devices_53]]
====== link:#_required_devices_53[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_53]]
====== link:#_test_procedure_53[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Factory reset the DUT |

|2 | | |Commission TH and DUT on Thread network |

|3 a|
* 9.6
* 9.6.4.2

| a|
* TH reads Descriptor Cluster from the DUT with EP0
* TH reads ServerList from the DUT

|Verify for the presence of an element with value 49 (0x0031) in the
ServerList. If the value is present, then continue with the test case

|4 |7.13.2 | |TH reads FeatureMap attribute from the DUT |Verify that
FeatureMap attribute value is equal to 2. If the value is 2, then
continue with the test case

|5 |11.8.7.1 |CNET.S.A0000(MaxNetworks) |TH reads the MaxNetworks
attribute from the DUT |Verify that MaxNetworks attribute value is
within a range of 1 to 255

|6 | | |TH saves the MaxNetworks attribute value as 'MaxNetworksValue'
for future use |

|7 a|
* 11.8.7.2
* 11.8.6.3

|CNET.S.A0001(Networks) |TH reads the Networks attribute list from the
DUT a|
* Verify that each element in the Networks attribute list has the
following fields:
+
. NetworkID field is of type octstr with a length range 1 to 32
. The connected field is of type bool
* Verify that only one entry has connected status as TRUE and that entry
has the NetworkID set to the XPAN of the thread network set up during
commissioning
* Verify that the number of entries in the `Networks` attribute is less
than or equal to 'MaxNetworksValue'

|8 |11.8.7.3 |CNET.S.A0002(ScanMaxTimeSeconds) |TH reads
ScanMaxTimeSeconds attribute from the DUT |Verify that
ScanMaxTimeSeconds attribute value is within the range of 1 to 255
seconds

|9 |11.8.7.4 |CNET.S.A0003(ConnectMaxTimeSeconds) |TH reads
ConnectMaxTimeSeconds Attribute from the DUT |Verify that
ConnectMaxTimeSeconds attribute value is within the range of 1 to 255
seconds

|10 |11.8.7.5 |CNET.S.A0004(InterfaceEnabled) |TH reads InterfaceEnabled
attribute from the DUT |Verify that InterfaceEnabled attribute value is
true

|11 |11.8.7.6 |CNET.S.A0005(LastNetworkingStatus) |TH reads
LastNetworkingStatus attribute from the DUT a|
* Verify that LastNetworkingStatus attribute value is Success.

|12 |11.8.7.7 |CNET.S.A0006(LastNetworkID) a|
* TH reads the LastNetworkID attribute from the DUT
* TH reads the Networks attribute from the DUT

|Verify that LastNetworkID attribute matches the NetworkID value of one
of the entries in the `Networks` attribute list, or if the Networks
attribute list is Empty, then LastNetworkID attribute value is null

|13 |11.8.7.8 |CNET.S.A0007(LastConnectErrorValue) |TH reads the
LastConnectErrorValue attribute from the DUT |Verify that
LastConnectErrorValue attribute value is null
|===

[[_tc_cnet_4_3_ethernet_verification_for_attributes_check_dut_server]]
===== link:#_tc_cnet_4_3_ethernet_verification_for_attributes_check_dut_server[]19.2.3. [TC-CNET-4.3] [Ethernet] Verification for attributes check [DUT-Server]

[[_category_54]]
====== link:#_category_54[]Category

Functional conformance

[[_purpose_55]]
====== link:#_purpose_55[]Purpose

* Verifying the DUT is connected with Ethernet interface
* Verifying the following attributes check:
+
. DUT’s MaxNetworks attribute value needs to be within a range of 1 to
255
. DUT’s Networks attribute list will follow the NetworkInfo structure
for each entry
. DUT’s InterfaceEnabled attribute value must be True
. DUT’s LastNetworkingStatus attribute value will be within any one of
the following values Success, NetworkNotFound, OutOfRange,
RegulatoryError, UnknownError, null
. DUT’s LastNetworkID attribute value will be of type octstr with a
length range of 1 to 32 and even null value
. DUT’s LastConnectErrorValue attribute value must be null

[[_pics_54]]
====== link:#_pics_54[]PICS

* CNET.S.F02(ET)

[[_pre_conditions_10]]
====== link:#_pre_conditions_10[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F02(ET) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_ETHERNET with FeatureMap attribute of 4 |

|3 |5.5 |DUT has a valid Ethernet connection |

|4 | |TH can communicate with the DUT |
|===

[[_required_devices_54]]
====== link:#_required_devices_54[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_54]]
====== link:#_test_procedure_54[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Factory reset the DUT |

|2 | | |Commission TH and DUT on Ethernet setup |

|3 a|
* 9.6
* 9.6.4.2

| a|
* TH reads Descriptor Cluster from the DUT with EP0
* TH reads ServerList from the DUT

|Verify for the presence of an element with value 49 (0x0031) in the
ServerList. If the value is present, then continue with the test case

|4 |7.13.2 | |TH reads FeatureMap attribute from the DUT |Verify that
FeatureMap attribute value is equal to 4. If the value is 4, If the
value is 4, then continue with the test case

|5 |11.8.7.1 |CNET.S.A0000(MaxNetworks) |TH reads the MaxNetworks
attribute from the DUT |Verify that MaxNetworks attribute value is
within a range of 1 to 255

|6 | | |TH saves the MaxNetworks attribute value as 'MaxNetworksValue'
for future use |

|7 a|
* 11.8.7.2
* 11.8.6.3

|CNET.S.A0001(Networks) |TH reads the Networks attribute list from the
DUT a|
* Verify that each element in the Networks attribute list has the
following fields:
+
. NetworkID field is of type octstr with a length range 1 to 32
. The connected field is of type bool
* Verify that only one entry has connected status as TRUE
* Verify that the number of entries in the `Networks` attribute is less
than or equal to 'MaxNetworksValue'

|8 |11.8.7.5 |CNET.S.A0004(InterfaceEnabled) |TH reads InterfaceEnabled
attribute from the DUT |Verify that InterfaceEnabled attribute value is
true

|9 |11.8.7.6 |CNET.S.A0005(LastNetworkingStatus) |TH reads
LastNetworkingStatus attribute from the DUT a|
* Verify that LastNetworkingStatus attribute value is Success

|10 |11.8.7.7 |CNET.S.A0006(LastNetworkID) a|
* TH reads the LastNetworkID attribute from the DUT
* TH reads the Networks attribute from the DUT

|Verify that LastNetworkID attribute matches the NetworkID value of one
of the entries in the `Networks` attribute list, or if the Networks
attribute list is Empty, then LastNetworkID attribute value is null

|11 |11.8.7.8 |CNET.S.A0007(LastConnectErrorValue) |TH reads the
LastConnectErrorValue attribute from the DUT |Verify that
LastConnectErrorValue attribute value is null
|===

[[_tc_cnet_4_4_wi_fi_verification_for_scannetworks_command_dut_server]]
===== link:#_tc_cnet_4_4_wi_fi_verification_for_scannetworks_command_dut_server[]19.2.4. [TC-CNET-4.4] [Wi-Fi] Verification for ScanNetworks command [DUT-Server]

[[_category_55]]
====== link:#_category_55[]Category

Functional conformance

[[_purpose_56]]
====== link:#_purpose_56[]Purpose

. Verification of ScanNetworks command for listing all available Wi-Fi
networks within the range using a null value
. Verification of ScanNetworks command for user-input SSID Wi-Fi network

[[_pics_55]]
====== link:#_pics_55[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_11]]
====== link:#_pre_conditions_11[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F00(WI) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|4 | |TH can communicate with the DUT |
|===

[[_required_devices_55]]
====== link:#_required_devices_55[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_55]]
====== link:#_test_procedure_55[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.8.8.2
* 11.8.8.3

a|
* CNET.S.C00.Rsp(ScanNetworks)
* CNET.S.C01.Tx(ScanNetworksResponse)

|TH sends ScanNetworks command to the DUT with the SSID field set to
'null' and Breadcrumb field set to 1 a|
* Verify that DUT sends ScanNetworksResponse command to the TH with the
following fields:
* NetworkingStatus is any one of the following values: Success,
NetworkNotFound, OutOfRange, RegulatoryError, UnknownError
* DebugText is of type string with max length 512 or absent
* Each element in the WiFiScanResults list will have the following
fields:
+
. Security is of type map8 with a length range 0 to 254
. SSID is of type octstr with a length range 0 to 32
. BSSID is of type octstr with a length of 6
. Channel is of type uint16 with a range 0 to 65,535
. Wi-Fi Band, if present, is of type enum8 with a range of -128 to 127
. RSSI, if present, is of type int8 with a range of -120 to 0

|1b |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 1

|2a a|
* 11.8.8.2
* 11.8.8.3

a|
* CNET.S.C00.Rsp(ScanNetworks)
* CNET.S.C01.Tx(ScanNetworksResponse)

|TH sends ScanNetworks Command to the DUT with SSID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 2 a|
* Verify that DUT sends ScanNetworksResponse command to the TH with the
following fields:
* NetworkingStatus is Success
* DebugText is of type string with max length 512 or absent
* WiFiScanResults list contains only one entry with the following fields
and values:
+
. Security is of type map8 with a length range 0 to 254
. SSID is PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. BSSID is of type octstr with a length of 6
. Channel
. WifiBand
. RSSI, if present, is of type int8 with a range of -120 to 0

|2b |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 2
|===

[[_tc_cnet_4_5_wi_fi_failsafe_required_message_validation_dut_server]]
===== link:#_tc_cnet_4_5_wi_fi_failsafe_required_message_validation_dut_server[]19.2.5. [TC-CNET-4.5] [Wi-Fi] FAILSAFE_REQUIRED message Validation [DUT-Server]

[[_category_56]]
====== link:#_category_56[]Category

Functional conformance

[[_purpose_57]]
====== link:#_purpose_57[]Purpose

* Verify that DUT sends status code FAILSAFE_REQUIRED message for the
following commands that are initiated before sending ArmFailSafe command
by the TH:
+
. AddOrUpdateWiFiNetwork Command
. RemoveNetwork Command and
. ConnectNetwork command

[[_pics_56]]
====== link:#_pics_56[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_12]]
====== link:#_pre_conditions_12[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F00(WI) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|4 | |TH can communicate with the DUT |
|===

[[_required_devices_56]]
====== link:#_required_devices_56[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_56]]
====== link:#_test_procedure_56[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.8.8.4 a|
* CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork)

a|
* TH sends the AddOrUpdateWiFiNetwork command to the DUT with the
following fields:
+
. SSID field set to PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. Credentials field set to PIXIT.CNET.WIFI_1ST_ACCESSPOINT_CREDENTIALS
. Breadcrumb field set to 1

|Verify that DUT sends FAILSAFE_REQUIRED status code message to the TH

|2 |11.8.8.8 a|
* CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork)

|TH sends RemoveNetwork command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 1
|Verify that DUT sends FAILSAFE_REQUIRED status code message to the TH

|3 |11.8.8.10 a|
* CNET.S.C06.Rsp(ConnectNetwork)

|TH sends ConnectNetwork command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 1
|Verify that DUT sends FAILSAFE_REQUIRED status code message to the TH
|===

[[_tc_cnet_4_6_thread_failsafe_required_message_validation_dut_server]]
===== link:#_tc_cnet_4_6_thread_failsafe_required_message_validation_dut_server[]19.2.6. [TC-CNET-4.6] [Thread] FAILSAFE_REQUIRED message Validation [DUT-Server]

[[_category_57]]
====== link:#_category_57[]Category

Functional conformance

[[_purpose_58]]
====== link:#_purpose_58[]Purpose

* Verify that DUT sends status code FAILSAFE_REQUIRED message for the
following commands that are initiated before sending ArmFailSafe command
by the TH:
+
. AddOrUpdateThreadNetwork Command
. RemoveNetwork Command and
. ConnectNetwork command

[[_pics_57]]
====== link:#_pics_57[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_13]]
====== link:#_pre_conditions_13[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F01(TH) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
|

|4 | |TH can communicate with the DUT on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |
|===

[[_required_devices_57]]
====== link:#_required_devices_57[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_57]]
====== link:#_test_procedure_57[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.8.8.5 a|
* CNET.S.C03.Rsp(AddOrUpdateThreadNetwork)

a|
* TH sends the AddOrUpdateThreadNetwork command to the DUT with the
following fields:
+
. OperationalDataset field set to
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. Breadcrumb field set to 1

|Verify that DUT sends FAILSAFE_REQUIRED status code message to the TH

|2 |11.8.8.8 a|
* CNET.S.C04.Rsp(RemoveNetwork)

|TH sends RemoveNetwork command to the DUT with NetworkID field set to
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and Breadcrumb field set to 1
|Verify that DUT sends FAILSAFE_REQUIRED status code message to the TH

|3 |11.8.8.10 a|
* CNET.S.C06.Rsp(ConnectNetwork)

|TH sends ConnectNetwork command to the DUT with NetworkID field set to
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and Breadcrumb field set to 1
|Verify that DUT sends FAILSAFE_REQUIRED status code message to the TH
|===

[[_tc_cnet_4_9_wi_fi_verification_for_removenetwork_command_dut_server]]
===== link:#_tc_cnet_4_9_wi_fi_verification_for_removenetwork_command_dut_server[]19.2.7. [TC-CNET-4.9] [Wi-Fi] Verification for RemoveNetwork Command [DUT-Server]

[[_category_58]]
====== link:#_category_58[]Category

Functional conformance

[[_purpose_59]]
====== link:#_purpose_59[]Purpose

. Verification for RemoveNetwork Command by removing a Wi-Fi network
from the Networks list
. Verification that network changes are reverted when fail safe times
out
. Verification that network changes are retained when
CommissioningComplete command is called

[[_pics_58]]
====== link:#_pics_58[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_14]]
====== link:#_pre_conditions_14[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F00(WI) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|4 | |TH can communicate with the DUT |
|===

[[_required_devices_58]]
====== link:#_required_devices_58[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_58]]
====== link:#_test_procedure_58[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|2 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the number of entries as 'NumNetworks' a|
* Verify that the Networks attribute list has an entry with the
following values:
+
. NetworkID field value as PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. Connected field value is of type bool and has the value true

|3 |11.8.7.2 | |TH finds the index of the Networks list entry with
NetworkID field value PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and saves it
as 'Userwifi_netidx' |

|4 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following fields:
+
. NetworkingStatus is success
. NetworkIndex is 'Userwifi_netidx'

|5 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has 'NumNetworks' - 1 entries

|6 |11.8.7.6 |CNET.S.A0005(LastNetworkingStatus) |TH reads
LastNetworkingStatus attribute from the DUT |Verify that DUT sends
LastNetworkingStatus as Success which is 0

|7 a|
* 11.8.7.6 *11.8.8.9

|CNET.S.A0006(LastNetworkID) |TH reads LastNetworkID attribute from the
DUT |Verify that DUT sends LastNetworkID as
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID

|8 |11.8.8.8 |CNET.S.C04.Rsp(RemoveNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 1

|9 |11.8.8.8 |CNET.S.C04.Rsp(RemoveNetwork) |TH sends ConnectNetwork
command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 2
|Verify that the DUT sends a ConnectNetworkResponse to the command with
the NetworkingStatus field set to NetworkIdNotFound

|10 |11.8.8.8 |CNET.S.C04.Rsp(RemoveNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 1

|11 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|10 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list contains 'NumNetworks' entries
and has an entry with the following fields:
+
. NetworkID is the hex representation of the ASCII values for
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. Connected is of type bool and has the value true

|11 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|12 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following fields:
+
. NetworkingStatus is success
. NetworkIndex is 'Userwifi_netidx'

|13 |11.9.7.6 |CNET.S.C04.Rsp(RemoveNetwork) |TH sends the
CommissioningComplete command to the DUT |Verify that DUT sends
CommissioningCompleteResponse with the ErrorCode field set to OK (0)

|14 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 to ensure the CommissioningComplete call properly persisted the
failsafe context. This call should have no effect if Commissioning
Complete call is handled correctly |Verify that DUT sends
ArmFailSafeResponse command to the TH

|15 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has 'NumNetworks' - 1 entries
and does NOT contain an entry with the NetworkID for
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID

|===

[[_tc_cnet_4_10_thread_verification_for_removenetwork_command_dut_server]]
===== link:#_tc_cnet_4_10_thread_verification_for_removenetwork_command_dut_server[]19.2.8. [TC-CNET-4.10] [Thread] Verification for RemoveNetwork Command [DUT-Server]

[[_category_59]]
====== link:#_category_59[]Category

Functional conformance

[[_purpose_60]]
====== link:#_purpose_60[]Purpose

. Verification for RemoveNetwork Command by removing a thread network
from the Networks list
. Verification that network changes are reverted when fail safe times
out
. Verification that network changes are retained when
CommissioningComplete command is called

[[_pics_59]]
====== link:#_pics_59[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_15]]
====== link:#_pre_conditions_15[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F01(TH) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
|

|4 | |TH can communicate with the DUT on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |
|===

[[_required_devices_59]]
====== link:#_required_devices_59[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_59]]
====== link:#_test_procedure_59[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|2 |11.8.7.2 |CNET.S.A0001(Networks) |TH1 reads Networks attribute from
the DUT and save the number of entries as 'NumNetworks' a|
* Verify that the Networks attribute list has an entry with the
following values:
+
. NetworkID field value as the extended PAN ID for
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. Connected field value is of type bool and has the value true

|3 |11.8.7.2 | |TH finds the index of the Networks list entry with
NetworkID field value PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and saves
it as 'Userth_netidx' |

|4 |* 11.8.8.8 * 11.8.8.9 a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and Breadcrumb field set to 1
a|
* Verify that DUT sends NetworkConfigResponse to command with the
following fields:
+
. NetworkingStatus is success
. NetworkIndex is 'Userth_netidx'

|5 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has 'NumNetworks' - 1 entries

|6 |11.8.7.6 |CNET.S.A0005(LastNetworkingStatus) |TH reads
LastNetworkingStatus attribute from the DUT |Verify that DUT sends
LastNetworkingStatus as Success which is 0

|7 a|
* 11.8.7.6 *11.8.8.9

|CNET.S.A0006(LastNetworkID) |TH reads LastNetworkID attribute from the
DUT |Verify that DUT sends LastNetworkID as the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET

|8 |11.8.8.8 |CNET.S.C04.Rsp(RemoveNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 1

|9 |11.8.8.8 |CNET.S.C04.Rsp(RemoveNetwork) |TH sends ConnectNetwork
command to the DUT with NetworkID field set to the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and Breadcrumb field set to 2
|Verify that the DUT sends a ConnectNetworkResponse to the command with
the NetworkingStatus field set to NetworkIdNotFound

|10 |11.8.8.8 |CNET.S.C04.Rsp(RemoveNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 1

|11 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|12 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list contains 'NumNetworks' entries
and has an entry with the following values:
+
. NetworkID field value as the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. Connected field value is of type bool and has the value true

|11 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|12 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
extended PAN ID of PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and
Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following fields:
+
. NetworkingStatus is success
. NetworkIndex is 'Userth_netidx'

|13 |11.9.7.6 |CNET.S.C04.Rsp(RemoveNetwork) |TH sends the
CommissioningComplete command to the DUT |Verify that DUT sends
CommissioningCompleteResponse with the ErrorCode field set to OK (0)

|14 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 to ensure the CommissioningComplete call properly persisted the
failsafe context. This call should have no effect if Commissioning
Complete call is handled correctly |Verify that DUT sends
ArmFailSafeResponse command to the TH

|15 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has 'NumNetworks' - 1 entries
and does NOT contain an entry with the NetworkID field set to the
extended PAN ID of PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET

|===

[[_tc_cnet_4_11_wi_fi_verification_for_connectnetwork_command_dut_server]]
===== link:#_tc_cnet_4_11_wi_fi_verification_for_connectnetwork_command_dut_server[]19.2.9. [TC-CNET-4.11] [Wi-Fi] Verification for ConnectNetwork Command [DUT-Server]

[[_category_60]]
====== link:#_category_60[]Category

Functional conformance

[[_purpose_61]]
====== link:#_purpose_61[]Purpose

. Verify that the Wi-Fi network is connected using the ConnectNetwork
Command
. Verify that changes are reverted successfully after a failsafe timeout
. Verify that changes are persisted successfully after a
CommissioningComplete command

[[_pics_60]]
====== link:#_pics_60[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_16]]
====== link:#_pre_conditions_16[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F00(WI) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|4 | |TH can connect to two valid Wi-Fi access points:
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID |
|===

[[_required_devices_60]]
====== link:#_required_devices_60[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_60]]
====== link:#_test_procedure_60[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|2 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the number of entries as 'NumNetworks' a|
* Verify that the Networks attribute list has an entry with the
following fields:
+
. NetworkID is the hex representation of the ASCII values for
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. Connected is of type bool and is TRUE

|3 |11.8.7.2 | |TH finds the index of the Networks list entry with
NetworkID for PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and saves it as
'Userwifi_netidx' |

|4 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following fields:
+
. NetworkingStatus is Success
. NetworkIndex matches previously saved 'Userwifi_netidx'

|5 a|
* 11.8.8.4
* 11.8.8.6
* 11.8.8.9

a|
* CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateWiFiNetwork command to the DUT with SSID field set
to PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID, Credentials field set to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_CREDENTIALS and Breadcrumb field set to
1 a|
* Verify that DUT sends the NetworkConfigResponse command to the TH with
the following response fields:
+
. NetworkingStatus is success which is "0"
. DebugText is of type string with max length 512 or empty

|6 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has an entry with the
following fields:
+
. NetworkID is the hex representation of the ASCII values for
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID
. Connected is of type bool and is FALSE

|7 |11.8.8.10 |CNET.S.C06.Rsp(ConnectNetwork) |TH sends ConnectNetwork
command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID and Breadcrumb field set to 2 a|

|8 | | |TH changes its WiFi connection to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID |

|9 |4.3.2 | |TH discovers and connects to DUT on the
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID operational network |Verify that
the TH successfully connects to the DUT

|10 |11.8.8.8 |CNET.S.C06.Rsp(ConnectNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 2

|11 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0. This forcibly disarms the fail-safe and is expected to cause the
changes of configuration to NetworkCommissioning cluster done so far to
be reverted. |Verify that DUT sends ArmFailSafeResponse command to the
TH

|12 | | |TH changes its WiFi connection to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|13 |4.3.2 | |TH discovers and connects to DUT on the
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID operational network |Verify that
the TH successfully connects to the DUT

|14 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|15 a|
* 11.8.8.8

* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID and Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following response fields:
+
. NetworkingStatus is success
. NetworkIndex is 'Userwifi_netidx'

|16 |* 11.8.8.4 * 11.8.8.6 * 11.8.8.9 a|
* CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateWiFiNetwork command to the DUT with SSID field set
to PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID, Credentials field set to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_CREDENTIALS and Breadcrumb field set to
1 a|
* Verify that DUT sends the NetworkConfigResponse command to the TH with
the following response fields:
+
. NetworkingStatus is success which is "0"
. DebugText is of type string with max length 512 or empty

|17 a|
* 11.8.8.10
* 11.8.8.11

a|
* CNET.S.C06.Rsp(ConnectNetwork)
* CNET.S.C07.Tx(ConnectNetworkResponse)

|TH sends ConnectNetwork command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID and Breadcrumb field set to 3 a|

|18 | | |TH changes its WiFi connection to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID |

|19 |4.3.2 | |TH discovers and connects to DUT on the
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID operational network |Verify that
the TH successfully connects to the DUT

|20 |11.8.8.8 |CNET.S.C06.Rsp(ConnectNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 3

|21 |11.9.7.6 | |TH sends the CommissioningComplete command to the DUT
|Verify that DUT sends CommissioningCompleteResponse with the ErrorCode
field set to OK (0)

|23 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has an entry with the
following fields:
+
. NetworkID is the hex representation of the ASCII values for
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID
. Connected is of type bool and is TRUE

|===

[[_notestesting_considerations_48]]
====== link:#_notestesting_considerations_48[]Notes/Testing Considerations

Test Steps #11- #16 cannot be executed with V1.0 SDK

[[_tc_cnet_4_12_thread_verification_for_connectnetwork_command_dut_server]]
===== link:#_tc_cnet_4_12_thread_verification_for_connectnetwork_command_dut_server[]19.2.10. [TC-CNET-4.12] [Thread] Verification for ConnectNetwork Command [DUT-Server]

[[_category_61]]
====== link:#_category_61[]Category

Functional conformance

[[_purpose_62]]
====== link:#_purpose_62[]Purpose

. Verify that the time taken by DUT to make successful connectivity is
within ConnectMaxTimeSeconds by thread network
. Verify that the thread network is connected using the ConnectNetwork
Command

[[_pics_61]]
====== link:#_pics_61[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_17]]
====== link:#_pre_conditions_17[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F01(TH) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
|

|4 | |TH has can communicate to two valid thread PANs:
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET and
PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET |

|5 | |XPANID of PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET is saved as
`th_xpan` and the XPANID of PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET is
saved as `th_xpan1` |
|===

[[_required_devices_61]]
====== link:#_required_devices_61[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_61]]
====== link:#_test_procedure_61[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT responds with ArmFailSafeResponse to the TH

|2 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the number of entries as 'NumNetworks' a|
* Verify that the Networks attribute list has an entry with the
following fields:
+
. NetworkID is `th_xpan`
. Connected is of type bool and is TRUE

|3 |11.8.7.2 | |TH saves the index of the Networks list entry from step
2 as `Userth_netidx` |

|4 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
`th_xpan` and Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following response fields:
+
. NetworkingStatus is success
. NetworkIndex is `Userth_netidx`

|5 a|
* 11.8.8.5
* 11.8.8.6
* 11.8.8.9

a|
* CNET.S.C03.Rsp(AddOrUpdateThreadNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateThreadNetwork command to the DUT with operational
dataset field set to PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET and
Breadcrumb field set to 1 a|
* Verify that DUT sends the NetworkConfigResponse command to the TH with
the following fields:
+
. NetworkingStatus is success which is "0"
. DebugText is of type string with max length 512 or empty

|6 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has an entry with the
following fields:
+
. NetworkID is `th_xpan`
. Connected is of type bool and is FALSE

|7 |11.8.8.10 |CNET.S.C06.Rsp(ConnectNetwork) |TH sends ConnectNetwork
command to the DUT with NetworkID field set to
PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET and Breadcrumb field set to 2
a|

|8 |4.3.2 | |TH discovers and connects to DUT on the
PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET operational network |Verify
that the TH successfully connects to the DUT

|9 |11.8.8.8 |CNET.S.C06.Rsp(ConnectNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 2

|10 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|11 | | |TH ensures it can communicate on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |

|12 |4.3.2 | |TH discovers and connects to DUT on the
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET operational network |Verify
that the TH successfully connects to the DUT

|13 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|14 |* 11.8.8.8 * 11.8.8.9 a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
`th_xpan` and Breadcrumb field set to 1 a|
* Verify that DUT sends NetworkConfigResponse to command with the
following fields:
+
. NetworkingStatus is success
. NetworkIndex is 'Userth_netidx'

|15 |* 11.8.8.5 * 11.8.8.6 * 11.8.8.9 a|
* CNET.S.C03.Rsp(AddOrUpdateThreadNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateThreadNetwork command to the DUT with the
OperationalDataset field set to PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET
and Breadcrumb field set to 1 a|
* Verify that DUT sends the NetworkConfigResponse command to the TH with
the following fields:
+
. NetworkingStatus is success which is "0"
. DebugText is of type string with max length 512 or empty

|16 a|
* 11.8.8.10
* 11.8.8.11

a|
* CNET.S.C06.Rsp(ConnectNetwork)
* CNET.S.C07.Tx(ConnectNetworkResponse)

|TH sends ConnectNetwork command to the DUT with NetworkID field set to
the extended PAN ID of PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET and
Breadcrumb field set to 3 a|

|17 |4.3.2 | |TH discovers and connects to DUT on the
PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET operational network |Verify
that the TH successfully connects to the DUT

|18 |11.8.8.8 |CNET.S.C06.Rsp(ConnectNetwork) |TH reads Breadcrumb
attribute from the General Commissioning cluster of the DUT |Verify that
the breadcrumb value is set to 3

|19 |11.9.7.6 | |TH sends the CommissioningComplete command to the DUT
|Verify that DUT sends CommissioningCompleteResponse with the ErrorCode
field set to OK (0)

|20 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT a|
* Verify that the Networks attribute list has an entry with the
following values:
+
. NetworkID field value as the extended PAN ID of
PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET
. Connected field value is of type bool and is TRUE

|===

[[_tc_cnet_4_13_wi_fi_verification_for_reordernetwork_command_dut_server]]
===== link:#_tc_cnet_4_13_wi_fi_verification_for_reordernetwork_command_dut_server[]19.2.11. [TC-CNET-4.13] [Wi-Fi] Verification for ReorderNetwork command [DUT-Server]

[[_category_62]]
====== link:#_category_62[]Category

Functional conformance

[[_purpose_63]]
====== link:#_purpose_63[]Purpose

Verify that the Networks list is re-ordered when using ReorderNetwork
Command

[[_pics_62]]
====== link:#_pics_62[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_18]]
====== link:#_pre_conditions_18[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 |5.5 |Commission TH and DUT over BLE to setup the Wi-Fi on
PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|2 |9.6.4.2 |The cluster Identifier 49 (0x0031) is present in the
ServerList attribute |

|3 |7.13.2 |The FeatureMap attribute value is 1 |

|4 |11.8.7.1 |MaxNetworks attribute value is at least 2 which is saved
as 'MaxNetworksValue' for future use |
|===

[[_required_devices_62]]
====== link:#_required_devices_62[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_62]]
====== link:#_test_procedure_62[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|2 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the number of entries as 'NumNetworks' a|
* Verify that the Networks attribute list has an entry with the
following values:
+
. NetworkID field value as PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. Connected field value is of type bool and has the value true

|3 | | |TH calculates the number of remaining network slots as
'MaxNetworksValue' - 'NumNetworks' and saves as 'RemainingNetworkSlots'
|

|4 | | |TH calculates the midpoint of the network list as
floor(('MaxNetworksValue' + 1)/2) and saves as 'Midpoint' |

|5 a|
* 11.8.8.4
* 11.8.8.6
* 11.8.8.9

a|
* CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateWiFiNetwork command to the DUT. This step should be
repeated 'RemainingNetworkSlots' times using DIFFERENT SSID and
credential values and the Breadcrumb field set to 1. Note that these
credentials are NOT required to be connectable. a|
* Verify that DUT sends the NetworkConfigResponse to each command with
the following fields:
+
. NetworkingStatus is success which is "0"
. DebugText is of type string with max length 512 or empty

|6 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the list as 'OriginalNetworkList' a|
* Verify that the Networks attribute list has 'MaxNetworkValues' entries
and contains one entry for each network added in step 5.

|7 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. NetworkIndex is 'MaxNetworksValue'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse to the TH with following
fields:
+
. NetworkingStatus is OutOfRange
. DebugText is of type string with max length 512 or empty

|8 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 1

|9 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is a NetworkID value NOT present in 'OriginalNetworkList'
. NetworkIndex is 'Midpoint'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse to the TH with following
fields:
+
. NetworkingStatus is NetworkIdNotFound
. DebugText is of type string with max length 512 or empty

|10 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 1

|11 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. NetworkIndex is 'Midpoint'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse to the TH with following
fields:
+
. NetworkingStatus is success
. DebugText is of type string with max length 512 or empty
. NetworkIndex value as 'Midpoint'

|12 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 2

|13 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute list
from the DUT a|
* Verify that Networks attribute list has the following properties:
+
. List item with NetworkID value the hex representation of the ASCII
values for PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID in position 'Midpoint'
. Other list items in same relative order as 'OriginalNetworkList'

|14 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|15 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute list
from the DUT a|
* Verify that Networks attribute list ordering matches
'OriginalNetworkList'

|16 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|17 a|
* 11.8.8.4
* 11.8.8.6
* 11.8.8.9

a|
* CNET.S.C02.Rsp(AddOrUpdateWiFiNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateWiFiNetwork command to the DUT. This step should be
repeated 'RemainingNetworkSlots' times using DIFFERENT SSID and
credential values and Breadcrumb field set to 1. Note that these
credentials are NOT required to be connectable. a|
* Verify that DUT sends the NetworkConfigResponse command to each
command to the TH with the following fields:
+
. NetworkingStatus is success which is "0"
. DebugText is of type string with max length 512 or empty

|18 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID
. NetworkIndex is 'Midpoint'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse Command to the TH with
following fields:
+
. NetworkingStatus is success
. DebugText is of type string with max length 512 or empty
. NetworkIndex is 'Midpoint'

|19 |11.9.7.6 | |TH sends the CommissioningComplete command to the DUT
|Verify that DUT sends CommissioningCompleteResponse with the ErrorCode
field set to OK (0)

|20 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|21 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute list
from the DUT a|
* Verify that Networks attribute list has the following properties:
+
. List item with NetworkID value PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID in
position 'Midpoint'
. Other list items in same relative order as 'OriginalNetworkList'

|===

[[_tc_cnet_4_14_thread_verification_for_reordernetwork_command_dut_server]]
===== link:#_tc_cnet_4_14_thread_verification_for_reordernetwork_command_dut_server[]19.2.12. [TC-CNET-4.14] [Thread] Verification for ReorderNetwork command [DUT-Server]

[[_category_63]]
====== link:#_category_63[]Category

Functional conformance

[[_purpose_64]]
====== link:#_purpose_64[]Purpose

Verify that the Networks list is re-ordered when using ReorderNetwork
Command

[[_pics_63]]
====== link:#_pics_63[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_19]]
====== link:#_pre_conditions_19[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 |5.5 |Commission TH and DUT on Thread setup on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |

|2 |9.6.4.2 |The cluster Identifier 49 (0x0031) is present in the
ServerList attribute |

|3 |7.13.2 |The FeatureMap attribute value is 2 |

|4 |11.8.7.1 |MaxNetworks attribute value is at least 2 which is saved
as 'MaxNetworksValue' for future use |
|===

[[_required_devices_63]]
====== link:#_required_devices_63[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_63]]
====== link:#_test_procedure_63[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|2 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the number of entries as 'NumNetworks' a|
* Verify that the Networks attribute list has an entry with the
following values:
+
. NetworkID field value as the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. Connected field value is of type bool and has the value true

|3 | | |TH calculates the number of remaining network slots as
'MaxNetworksValue' - 'NumNetworks' and saves as 'RemainingNetworkSlots'
|

|4 | | |TH calculates the midpoint of the network list as
floor(('MaxNetworksValue' + 1)/2) and saves as 'Midpoint' |

|5 a|
* 11.8.8.5
* 11.8.8.6
* 11.8.8.9

a|
* CNET.S.C03.Rsp(AddOrUpdateThreadNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateThreadNetwork command to the DUT. This step should
be repeated 'RemainingNetworkSlots' times using DIFFERENT
OperationalDataset values and Breadcrumb set to 1. Note that these
credentials are NOT required to be connectable. a|
* Verify that DUT sends the NetworkConfigResponse command to each
command to the TH with the following fields:
+
. NetworkingStatus is success, which is "0"
. DebugText is of type string with max length 512 or empty

|6 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute from
the DUT and saves the list as 'OriginalNetworkList' a|
* Verify that the Networks attribute list has 'MaxNetworkValues' entries
and contains one entry for each network added in step 5.

|7 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. NetworkIndex is 'MaxNetworksValue'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse to the TH with following
fields:
+
. NetworkingStatus is OutOfRange
. DebugText is of type string with max length 512 or empty

|8 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 1

|9 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is a NetworkID NOT present in 'OriginalNetworkList'
. NetworkIndex is 'Midpoint'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse to the TH with following
fields:
+
. NetworkingStatus is NetworkIdNotFound
. DebugText is of type string with max length 512 or empty

|10 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 1

|11 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. NetworkIndex is 'Midpoint'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse Command to the TH with
following fields:
+
. NetworkingStatus is success
. DebugText is of type string with max length 512 or empty
. NetworkIndex value as 'Midpoint'

|12 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 2

|13 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute list
from the DUT a|
* Verify that Networks attribute list has the following properties:
+
. List item with NetworkID value of the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET in position 'Midpoint'
. Other list items in same relative order as 'OriginalNetworkList'

|14 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|15 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute list
from the DUT a|
* Verify that Networks attribute list ordering matches
'OriginalNetworkList'

|16 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 900 |Verify that DUT sends ArmFailSafeResponse command to the TH

|17 a|
* 11.8.8.5
* 11.8.8.6
* 11.8.8.9

a|
* CNET.S.C03.Rsp(AddOrUpdateThreadNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends AddOrUpdateThreadNetwork command to the DUT. This step should
be repeated 'RemainingNetworkSlots' times using DIFFERENT
OperationalDataset values and Breadcrumb set to 1. Note that these
credentials are NOT required to be connectable. a|
* Verify that DUT sends the NetworkConfigResponse command to each
command to the TH with the following fields:
+
. NetworkingStatus is success, which is "0"
. DebugText is of type string with max length 512 or empty

|18 a|
* 11.8.8.12
* 11.8.8.9

a|
* CNET.S.C08.Rsp(ReorderNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

a|
* TH sends ReorderNetwork Command to the DUT with the following fields:
+
. NetworkID is the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
. NetworkIndex is 'Midpoint'
. Breadcrumb is 2

a|
* Verify that DUT sends NetworkConfigResponse Command to the TH with
following fields:
+
. NetworkingStatus is success
. DebugText is of type string with max length 512 or empty
. NetworkIndex value as 'Midpoint'

|19 |11.9.7.6 | |TH sends the CommissioningComplete command to the DUT
|Verify that DUT sends CommissioningCompleteResponse with the ErrorCode
field set to OK (0)

|20 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with ExpiryLengthSeconds set
to 0 |Verify that DUT sends ArmFailSafeResponse command to the TH

|21 |11.8.7.2 |CNET.S.A0001(Networks) |TH reads Networks attribute list
from the DUT a|
* Verify that Networks attribute list has the following properties:
+
. List item with NetworkID value with the extended PAN ID of
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET in position 'Midpoint'
. Other list items in same relative order as 'OriginalNetworkList'

|===

[[_tc_cnet_4_15_wi_fi_networkidnotfound_returned_in_lastnetworkingstatus_field_validation_dut_server]]
===== link:#_tc_cnet_4_15_wi_fi_networkidnotfound_returned_in_lastnetworkingstatus_field_validation_dut_server[]19.2.13. [TC-CNET-4.15] [Wi-Fi] NetworkIDNotFound returned in LastNetworkingStatus field validation [DUT-Server]

[[_category_64]]
====== link:#_category_64[]Category

Functional conformance

[[_purpose_65]]
====== link:#_purpose_65[]Purpose

* Verify that DUT responds with LastNetworkingStatus field set to
NetworkIDNotFound for the following commands when the NetworkID does not
exist:
+
. RemoveNetwork Command
. ConnectNetwork Command

[[_pics_64]]
====== link:#_pics_64[]PICS

* CNET.S.F00(WI)

[[_pre_conditions_20]]
====== link:#_pre_conditions_20[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F00(WI) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |

|3 | |DUT is factory reset |

|4 |5.5 |DUT is commissioned on PIXIT.CNET.WIFI_1ST_ACCESSPOINT_SSID |

|5 | |TH can communicate with the DUT |

|6 |11.8.7.1 |DUT MaxNetworks attribute value is at least 1 and is saved
as 'MaxNetworksValue' for future use |
|===

[[_required_devices_64]]
====== link:#_required_devices_64[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_64]]
====== link:#_test_procedure_64[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with the ExpiryLengthSeconds
field set to 900 |Verify that DUT sends ArmFailSafeResponse command to
the TH

|2 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID, which does not match the
provisioned network, and Breadcrumb field set to 1 |Verify that DUT
sends NetworkConfigResponse command to the TH1 with NetworkingStatus
field set as NetworkIDNotFound which is '3'

|3 a|
* 11.8.8.10
* 11.8.8.9

a|
* CNET.S.C06.Rsp(ConnectNetwork)
* CNET.S.C07.Tx(ConnectNetworkResponse)

|TH sends ConnectNetwork Command to the DUT with NetworkID field set to
PIXIT.CNET.WIFI_2ND_ACCESSPOINT_SSID, which does not match the
provisioned network, and Breadcrumb field set to 1 |Verify that DUT
sends ConnectNetworkResponse command to the TH1 with NetworkingStatus
field as NetworkIDNotFound which is '3'
|===

[[_tc_cnet_4_16_thread_networkidnotfound_returned_in_lastnetworkingstatus_field_validation_dut_server]]
===== link:#_tc_cnet_4_16_thread_networkidnotfound_returned_in_lastnetworkingstatus_field_validation_dut_server[]19.2.14. [TC-CNET-4.16] [Thread] NetworkIDNotFound returned in LastNetworkingStatus field validation [DUT-Server]

[[_category_65]]
====== link:#_category_65[]Category

Functional conformance

[[_purpose_66]]
====== link:#_purpose_66[]Purpose

* Verify that DUT responds with LastNetworkingStatus field set to
NetworkIDNotFound for the following commands when the NetworkID does not
exist:
+
. RemoveNetwork Command
. ConnectNetwork Command

[[_pics_65]]
====== link:#_pics_65[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_21]]
====== link:#_pre_conditions_21[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F01(TH) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |

|3 | |DUT is factory reset |

|4 |5.5 |DUT is commissioned on PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
|

|5 | |TH can communicate with the DUT on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |

|6 |11.8.7.1 |DUT MaxNetworks attribute value is at least 1 and is saved
as 'MaxNetworksValue' for future use |
|===

[[_required_devices_65]]
====== link:#_required_devices_65[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_65]]
====== link:#_test_procedure_65[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.9.7.1
* 11.9.7.2

| |TH sends ArmFailSafe command to the DUT with the ExpiryLengthSeconds
field set to 900 |Verify that DUT sends ArmFailSafeResponse command to
the TH

|2 a|
* 11.8.8.8
* 11.8.8.9

a|
* CNET.S.C04.Rsp(RemoveNetwork)
* CNET.S.C05.Tx(NetworkConfigResponse)

|TH sends RemoveNetwork Command to the DUT with NetworkID field set to
the extended PAN ID of PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET, which
does not match the commissioned network, and Breadcrumb field set to 1
|Verify that DUT sends NetworkConfigResponse command to the TH1 with
NetworkingStatus field set to NetworkIDNotFound which is '3'

|3 a|
* 11.8.8.10
* 11.8.8.9

a|
* CNET.S.C06.Rsp(ConnectNetwork)
* CNET.S.C07.Tx(ConnectNetworkResponse)

|TH sends ConnectNetwork Command to the DUT with NetworkID value as the
extended PAN ID of PIXIT.CNET.THREAD_2ND_OPERATIONALDATASET, which does
not match the commissioned network, and Breadcrumb field set to 1
|Verify that DUT sends ConnectNetworkResponse command to the TH1 with
NetworkingStatus field set to NetworkIDNotFound which is '3'
|===

[[_tc_cnet_4_22_thread_verification_for_scannetworks_command_dut_server]]
===== link:#_tc_cnet_4_22_thread_verification_for_scannetworks_command_dut_server[]19.2.15. [TC-CNET-4.22] [Thread] Verification for ScanNetworks command [DUT-Server]

[[_category_66]]
====== link:#_category_66[]Category

Functional conformance

[[_purpose_67]]
====== link:#_purpose_67[]Purpose

. Verification of ScanNetworks command for listing all available Thread
networks within the range

[[_pics_66]]
====== link:#_pics_66[]PICS

* CNET.S.F01(TH)

[[_pre_conditions_22]]
====== link:#_pre_conditions_22[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.S.F01(TH) |

|2 | |DUT has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |

|3 |5.5 |DUT is commissioned on PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET
|

|4 | |TH can communicate with the DUT on
PIXIT.CNET.THREAD_1ST_OPERATIONALDATASET |
|===

[[_required_devices_66]]
====== link:#_required_devices_66[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_test_procedure_66]]
====== link:#_test_procedure_66[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 a|
* 11.8.8.2
* 11.8.8.3

a|
* CNET.S.C00.Rsp(ScanNetworks)
* CNET.S.C01.Tx(ScanNetworksResponse)

|TH sends ScanNetworks command to the DUT with the SSID field omitted
and the Breadcrumb field set to 1 a|
* Verify that DUT sends ScanNetworksResponse command to the TH with the
following fields:
* NetworkingStatus field value will be any one of the following values:
Success, NetworkNotFound, OutOfRange, RegulatoryError, UnknownError
* DebugText is of type string with max length 512 or absent
* Each element in the ThreadScanResults list will have the following
fields:
+
. PanId with a range of 0 to 65534
. ExtendedPanId
. NetworkName is a string with a size of 1 to 16 bytes
. Channel is of type uint16 with a range 0 to 65535
. Version is a uint8
. ExtendedAddress is a hwaddr with a size of 8 bytes
. RSSI is an of type int8 with a range of -120 to 0
. LQI is a uint8

|2 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 1

|3 | a|
* CNET.S.C00.Rsp(ScanNetworks)
* CNET.S.C01.Tx(ScanNetworksResponse)

|TH sends ScanNetworks command to the DUT with the SSID field set to
null and the Breadcrumb field set to 2 a|
* Verify that DUT sends ScanNetworksResponse command to the TH with the
following fields:
* NetworkingStatus is any one of the following values: Success,
NetworkNotFound, OutOfRange, RegulatoryError, UnknownError
* DebugText is of type string with max length 512 or absent
* Each element in the ThreadScanResults list will have the following
fields:
+
. PanId with a range of 0 to 65534
. ExtendedPanId
. NetworkName is a string with a size of 1 to 16 bytes
. Channel is of type uint16 with a range 0 to 65535
. Version is a uint8
. ExtendedAddress is a hwaddr with a size of 8 bytes
. RSSI is an of type int8 with a range of -120 to 0
. LQI is a uint8

|4 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 2

|5 | a|
* CNET.S.C00.Rsp(ScanNetworks)
* CNET.S.C01.Tx(ScanNetworksResponse)

|TH sends ScanNetworks command to the DUT with the SSID field set to a
random string of ASCII characters with a size of between 1 and 31
characters and the Breadcrumb field set to 3 a|
* Verify that DUT sends ScanNetworksResponse command to the TH with the
following fields:
* NetworkingStatus is any one of the following values: Success,
NetworkNotFound, OutOfRange, RegulatoryError, UnknownError
* DebugText is of type string with max length 512 or absent
* Each element in the ThreadScanResults list will have the following
fields:
+
. PanId with a range of 0 to 65534
. ExtendedPanId
. NetworkName is a string with a size of 1 to 16 bytes
. Channel is of type uint16 with a range 0 to 65535
. Version is a uint8
. ExtendedAddress is a hwaddr with a size of 8 bytes
. RSSI is an of type int8 with a range of -120 to 0
. LQI is a uint8

|6 |11.8.8.2 | |TH reads Breadcrumb attribute from the General
Commissioning Cluster |Verify that the Breadcrumb attribute is set to 3
|===

'''''

[[_dut_as_client_2]]
==== link:#_dut_as_client_2[]19.3. DUT as Client

'''''

[[_tc_cnet_4_20_wi_fi_verification_for_commands_check_dut_client]]
===== link:#_tc_cnet_4_20_wi_fi_verification_for_commands_check_dut_client[]19.3.1. [TC-CNET-4.20] [Wi-Fi] Verification for commands check [DUT-Client]

[[_category_67]]
====== link:#_category_67[]Category

Functional conformance

[[_purpose_68]]
====== link:#_purpose_68[]Purpose

Verify the DUT is able to correctly send all commands to the TH

[[_pics_67]]
====== link:#_pics_67[]PICS

* CNET.C.F00(WI)

[[_pre_conditions_23]]
====== link:#_pre_conditions_23[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.C.F00(WI) |

|2 | |TH has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_WIFI with FeatureMap attribute of 1 |
|===

[[_required_devices_67]]
====== link:#_required_devices_67[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Client
|2 |TH |Server
|===

[[_test_procedure_67]]
====== link:#_test_procedure_67[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.8.8.2 |CNET.C.C00.Tx(ScanNetworks) |DUT sends the ScanNetwork
command to the TH |TH receives the ScanNetwork command from the DUT

|2 |11.9.7.2 | |DUT sends the ArmFailSafe command to the TH |TH receives
the ArmFailSafeResponse command from the DUT

|3 |11.8.8.4 |CNET.C.C02.Tx(AddOrUpdateWiFiNetwork) |DUT sends the
AddOrUpdateWiFiNetwork command to the TH |TH receives the
AddOrUpdateWiFiNetwork command from the DUT

|4 |11.8.8.10 |CNET.C.C06.Tx(ConnectNetwork) |DUT sends the
ConnectNetwork command to the TH |TH receives the ConnectNetwork command
from the DUT

|5 |11.8.8.12 |CNET.C.C08.Tx(ReorderNetwork) |DUT sends the
ReorderNetwork command to the TH |TH receives the ReorderNetwork command
from the DUT

|6 |11.8.8.8 |CNET.C.C04.Tx(RemoveNetwork) |DUT sends the RemoveNetwork
command to the TH |TH receives the RemoveNetwork command from the DUT
|===

[[_tc_cnet_4_21_thread_verification_for_commands_check_dut_client]]
===== link:#_tc_cnet_4_21_thread_verification_for_commands_check_dut_client[]19.3.2. [TC-CNET-4.21] [Thread] Verification for commands check [DUT-Client]

[[_category_68]]
====== link:#_category_68[]Category

Functional conformance

[[_purpose_69]]
====== link:#_purpose_69[]Purpose

Verify the DUT is able to correctly send all commands to the TH

[[_pics_68]]
====== link:#_pics_68[]PICS

* CNET.C.F01(TH)

[[_pre_conditions_24]]
====== link:#_pre_conditions_24[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT supports CNET.C.F01(TH) |

|2 | |TH has a Network Commissioning cluster on endpoint
PIXIT.CNET.ENDPOINT_THREAD with FeatureMap attribute of 2 |
|===

[[_required_devices_68]]
====== link:#_required_devices_68[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Client
|2 |TH |Server
|===

[[_test_procedure_68]]
====== link:#_test_procedure_68[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.8.8.2 |CNET.C.C00.Tx(ScanNetworks) |DUT sends the ScanNetwork
command to the TH |If CNET.C.C00.Tx(ScanNetworks), TH receives the
ScanNetwork command from the DUT

|2 |11.9.7.2 | |DUT sends the ArmFailSafe command to the TH |If
CGEN.S.C00.Rsp(ArmFailSafe), TH receives the ArmFailSafeResponse command
from the DUT

|3 |11.8.8.5 |CNET.C.C03.Tx(AddOrUpdateThreadNetwork) |DUT sends the
AddOrUpdateThreadNetwork command to the TH |If
CNET.C.C03.Tx(AddOrUpdateThreadNetwork), TH receives the
AddOrUpdateThreadNetwork command from the DUT

|4 |11.8.8.10 |CNET.C.C06.Tx(ConnectNetwork) |DUT sends the
ConnectNetwork command to the TH |If CNET.C.C06.Tx(ConnectNetwork), TH
receives the ConnectNetwork command from the DUT

|5 |11.8.8.12 |CNET.C.C08.Tx(ReorderNetwork) |DUT sends the
ReorderNetwork command to the TH |If CNET.C.C08.Tx(ReorderNetwork), TH
receives the ReorderNetwork command from the DUT

|6 |11.8.8.8 |CNET.C.C04.Tx(RemoveNetwork) |DUT sends the RemoveNetwork
command to the TH |If CNET.C.C04.Tx(RemoveNetwork),TH receives the
RemoveNetwork command from the DUT
|===

[[_secure_channel_test_plan]]
== link:#_secure_channel_test_plan[]**Secure Channel Test Plan**

[[_pics_definition_6]]
=== link:#_pics_definition_6[]20. PICS Definition

This section covers the Secure Channel related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.SC.VENDOR_SUBTYPE |Does device support optional subtype _V in
commissionable node discovery mDNS? |O |

|MCORE.SC.DEVTYPE_SUBTYPE |Does device support optional subtype _T in
commissionable node discovery mDNS? |O |

|MCORE.SC.VP_KEY |Does device support optional key VP in commissionable
node discovery mDNS? |O |

|MCORE.SC.DT_KEY |Does device support optional key DT in commissionable
node discovery mDNS? |O |

|MCORE.SC.DN_KEY |Does device support optional key DN in commissionable
node discovery mDNS? |O |

|MCORE.SC.RI_KEY |Does device support optional key RI in commissionable
node discovery mDNS? |O |

|MCORE.SC.PH_KEY |Does device support optional key PH in commissionable
node discovery mDNS? |O |

|MCORE.SC.PI_KEY |Does device support optional key PI in commissionable
node discovery mDNS? |O |

|MCORE.SC.SII_OP_DISCOVERY_KEY |Does device support optional key SII in
operational discovery mDNS? |O |

|MCORE.SC.SAI_OP_DISCOVERY_KEY |Does device support optional key SII in
operational discovery mDNS? |O |

|MCORE.SC.SAT_OP_DISCOVERY_KEY |Does device support optional key SAT in
operational discovery mDNS? |O |

|MCORE.SC.T_KEY |Does device support optional key SII in operational
discovery mDNS? |O |

|MCORE.SC.DT_CONTROLLER |Is the DUT a Controller? |O |

|MCORE.SC.SII_COMM_DISCOVERY_KEY |Does device support optional key SII
in commissionable node discovery mDNS? |O |

|MCORE.SC.SAI_COMM_DISCOVERY_KEY |Does device support optional key SAI
in commissionable node discovery mDNS? |O |

|MCORE.SC.EXTENDED_DISCOVERY |Does device support Extended Discovery for
Commissionable Node Discovery? |O |

|MCORE.SC.SIT_ICD |Is the device a Short Idle Time ICD? |O |

|MCORE.SC.ADV |Does the Controller DUT support Service Advertising? |O |

|MCORE.DD.COMM_DISCOVERY |Does the DUT support advertising Commissioner
Discovery service records? |O |

|BINFO.C.A0002(VendorID) |Does the Device support VendorID attribute? |O
|

|MCORE.SC.LWIP |Does Device support LwIP stack? |O |

|CADMIN.S.F00(BC) |Does the Device support Basic Commissioning Method |O
|
|===

[[_server_4]]
==== link:#_server_4[]20.1. Server

[[_commands_received_4]]
===== link:#_commands_received_4[]20.1.1. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Does the Device support
Enhanced Commissioning Method (ECM)? |M |

|CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |Does the Device support
Basic Commissioning Method (BCM)? |CADMIN.S.F00(BC) |
|===

[[_test_case_list_5]]
=== link:#_test_case_list_5[]21. Test Case List

[width="100%",cols="50%,50%",options="header",]
|===
|*TC UUID* |*Test Case Name*
|TC-SC-1.1 |MRP Max Messaging Size Verification - REMOVED

|TC-SC-1.2 |MRP Message Flows - REMOVED

|TC-SC-1.3 |MRP Retransmissions - REMOVED

|TC-SC-1.4 |MRP Message Counter and Duplicate Messaging Verification -
REMOVED

|TC-SC-2.1 |PASE Session Establishment - REMOVED

|TC-SC-2.2 |PASE Bidirectional Connection Session Establishment -
REMOVED

|TC-SC-2.3 |PASE Error Handling [DUT_Responder/Commissionee] - REMOVED

|TC-SC-2.4 |PASE Error Handling [DUT_Initiator/Commissioner] - REMOVED

|TC-SC-3.1 |CASE Session Establishment - REMOVED

|TC-SC-3.2 |CASE Session Resumption [DUT_Responder] - REMOVED

|TC-SC-3.3 |CASE Session Resumption [DUT_Initiator] - REMOVED

|TC-SC-3.4 |CASE Error Handling [DUT_Responder] - REMOVED

|TC-SC-3.5 |CASE Error Handling [DUT_Initiator] - REMOVED

|TC-SC-3.6 |CASE Resource validation

|TC-SC-4.1 |Commissionable Node Discovery [DUT as Commissionee]

|TC-SC-4.2 |Discovery [DUT as Commissioner]

|TC-SC-4.3 |Discovery [DUT as Commissionee]

|TC-SC-4.4 |Discovery [DUT as Controller]

|TC-SC-4.5 |Discovery [DUT as Commissionee][Thread] - REMOVED

|TC-SC-4.6 |Commissioner Discovery [DUT as Commissioner]

|TC-SC-4.7 |Commissioner Discovery [DUT as Commissionee]

|TC-SC-4.8 |Compressed Fabric ID remains the same for Nodes commissioned
to the same fabric [DUT as Commissioner]

|TC-SC-4.9 |Operational Discovery - RIO support [DUT as Commissionee]

|TC-SC-4.10 |Operational Discovery - Sleepy Node [DUT as Commissionee]
|===

[[_test_cases_5]]
=== link:#_test_cases_5[]22. Test Cases

'''''

[[_matter_reliable_message_protocol_mrp_test_cases]]
==== link:#_matter_reliable_message_protocol_mrp_test_cases[]22.1. Matter Reliable Message Protocol (MRP) Test Cases

[[_tc_sc_1_1_mrp_max_message_size_removed]]
===== link:#_tc_sc_1_1_mrp_max_message_size_removed[]22.1.1. [TC-SC-1.1] MRP Max Message Size - REMOVED

[[_category_69]]
====== link:#_category_69[]Category

Functional conformance

[[_purpose_70]]
====== link:#_purpose_70[]Purpose

This test case verifies that the DUT handles large messages as per the
specification

[[_pics_69]]
====== link:#_pics_69[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_36]]
====== link:#_preconditions_36[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT and TH are on the same fabric and joined to the same Matter
network |

|2 | |DUT has implemented/supports the Matter Echo protocol |
|===

[[_required_devices_69]]
====== link:#_required_devices_69[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_25]]
====== link:#_device_topology_25[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_14]]
====== link:#_test_setup_14[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_69]]
====== link:#_test_procedure_69[]Test Procedure

[width="99%",cols="10%,9%,9%,36%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |4.4.4 (Message Size Requirements) | |TH sends a single message to
DUT with a message size *equal to* 1280 bytes inclusive of headers and
reliability flag set to 1 |Verify DUT responds with an acknowledgement
of receipt.

|2 |4.4.4 | |TH sends a single message to DUT with a message size
*larger than* 1280 bytes and reliability flag set to 1 |Verify that the
DUT ignore the message and no response is sent.
|===

[[_notestesting_considerations_49]]
====== link:#_notestesting_considerations_49[]Notes/Testing considerations

'''''

[[_tc_sc_1_2_mrp_message_flows_removed]]
===== link:#_tc_sc_1_2_mrp_message_flows_removed[]22.1.2. [TC-SC-1.2] MRP Message Flows - REMOVED

[[_category_70]]
====== link:#_category_70[]Category

Functional conformance

[[_purpose_71]]
====== link:#_purpose_71[]Purpose

Verify that MRP handles and processes messages accordingly with flags
set in the message header.

[[_pics_70]]
====== link:#_pics_70[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_37]]
====== link:#_preconditions_37[]Preconditions

[width="100%",cols="12%,11%,55%,22%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT and TH are on the same fabric and joined to the same Matter
network |

|2 | |DUT has implemented/supports the Matter Echo protocol |
|===

[[_required_devices_70]]
====== link:#_required_devices_70[]Required Devices

[width="100%",cols="15%,14%,71%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_26]]
====== link:#_device_topology_26[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_15]]
====== link:#_test_setup_15[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_70]]
====== link:#_test_procedure_70[]Test Procedure

[width="99%",cols="10%,9%,9%,36%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |4.11.2.2, 4.11.5.1 | |TH sends a reliable (R flag set) MRP message
to DUT that requires a data response. |Verify that the DUT receives the
message.

|1b |4.11.2.2, 4.11.5.1 | |DUT must respond to the message with a MRP
reply packet that piggybacks the ACK(A flag set). |DUT should piggyback
the ACKs of the message in the reply to TH.

|2a |4.11.2.2, 4.11.5.1 | |TH sends a reliable (R flag set) MRP message
to DUT that doesn’t require a data response. |DUT must receive the
message.

|2b |4.11.2.2, 4.11.5.1 | |DUT must respond to the message with an ACK
message. |DUT must sent only the ACK packet to TH.

|3a |4.11.2.2, 4.11.5.1 | |TH sends 5 unreliable (R flag not set) MRP
messages to DUT that requires a data response. |DUT may receive the
messages.

|3b |4.11.2.2, 4.11.5.1 | |DUT must respond to the message with a MRP
reply packet that doesn’t piggyback the ACK (A flag not set). |DUT
should send only a MRP reply packet to TH with no ACK piggybacked or
sent in a separate message.
|===

[[_notestesting_considerations_50]]
====== link:#_notestesting_considerations_50[]Notes/Testing considerations

'''''

[[_tc_sc_1_3_mrp_retransmissions_removed]]
===== link:#_tc_sc_1_3_mrp_retransmissions_removed[]22.1.3. [TC-SC-1.3] MRP Retransmissions - REMOVED

[[_category_71]]
====== link:#_category_71[]Category

Functional conformance - Negative Testing

[[_purpose_72]]
====== link:#_purpose_72[]Purpose

This test case verifies that the message is dropped after the max number
of failed attempts

[[_pics_71]]
====== link:#_pics_71[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_38]]
====== link:#_preconditions_38[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT and TH are on the same fabric and joined to the same Matter
network |

|2 | |DUT has implemented/supports the Matter Echo protocol |
|===

[[_required_devices_71]]
====== link:#_required_devices_71[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_27]]
====== link:#_device_topology_27[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_16]]
====== link:#_test_setup_16[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_71]]
====== link:#_test_procedure_71[]Test Procedure

[width="99%",cols="10%,9%,9%,36%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Simulate TH to ignore all messages received by DUT (100% message
loss) |

|2 |4.11.2.1 | |DUT sends a message to TH with the R flag set to 1
|Verify that no reply is received by the DUT.

|3 |4.11.2.1 | |DUT sends a retransmission of the message in step 2
|Verify that the message is sent after waiting for
MRP_RETRY_INTERVAL_IDLE milliseconds. Verify that no response is
received by the DUT.

|4 |4.11.2.1 | |DUT continues to send retransmissions of the message in
step 2 up to MRP_MAX_TRANSMISSIONS times. |Verify that the DUT stops
sending messages after a total of MRP_MAX_TRANSMISSIONS - 1 messages
have been sent.
|===

[[_notestesting_considerations_51]]
====== link:#_notestesting_considerations_51[]Notes/Testing considerations

. Step 3 - The DUT should also start operational discovery in parallel
with retransmission and the DUT should also be able to receive discovery
packets during this test. Associated verification steps are not yet
included here due to a desire to keep test cases
separated/single-purpose, but we may add a combined test case at a later
point.
. Step 3 - The value for MRP_RETRY_INTERVAL_IDLE should be obtained by
the TH from the DNS-SD TXT record for the node if present. If it is not
available, then the default value is 5000 ms.
. Step 4 - The default value for MRP_MAX_TRANSMISSIONS is 4.

'''''

[[_tc_sc_1_4_mrp_message_counter_and_duplicate_messaging_removed]]
===== link:#_tc_sc_1_4_mrp_message_counter_and_duplicate_messaging_removed[]22.1.4. [TC-SC-1.4] MRP message counter and duplicate messaging - REMOVED

[[_category_72]]
====== link:#_category_72[]Category

Functional conformance - Negative testing

[[_purpose_73]]
====== link:#_purpose_73[]Purpose

This test case verifies that duplicate messages are discarded.

[[_pics_72]]
====== link:#_pics_72[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_39]]
====== link:#_preconditions_39[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT and TH are on the same fabric and joined to the same Matter
network |

|2 | |DUT has implemented/supports the Matter Echo protocol |
|===

[[_required_devices_72]]
====== link:#_required_devices_72[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_28]]
====== link:#_device_topology_28[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_17]]
====== link:#_test_setup_17[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_72]]
====== link:#_test_procedure_72[]Test Procedure

[width="99%",cols="10%,9%,9%,36%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |TH sends a message to DUT with the R flag set to 1. |Verify DUT
responds with an acknowledgement message with the A flag set and the
Acknowledged Message Counter field set to the Message Counter of the
received message.

|2 |4.11.2.3 | |TH sends a duplicate message to the DUT, with the R flag
set to 1 and the same message counter as the message in step 1. a|
Verify DUT responds with an acknowledgement message with the A flag set
and the Acknowledged Message Counter field set to the Message Counter of
the received message.

Verify that the DUT takes no further action on duplicate messages.

|===

[[_notestesting_considerations_52]]
====== link:#_notestesting_considerations_52[]Notes/Testing considerations

'''''

[[_session_establishment]]
==== link:#_session_establishment[]22.2. Session Establishment

'''''

[[_tc_sc_2_1_session_establishment_passcode_authenticated_session_establishment_pase_removed]]
===== link:#_tc_sc_2_1_session_establishment_passcode_authenticated_session_establishment_pase_removed[]22.2.1. [TC-SC-2.1] Session Establishment - Passcode Authenticated Session Establishment (PASE) - REMOVED

[[_category_73]]
====== link:#_category_73[]Category

Functional conformance

[[_purpose_74]]
====== link:#_purpose_74[]Purpose

This test case verifies that the DUT can successfully establish a
session using a passcode and Password Authenticated Key Agreement
(PAKE), which for now is only used when commissioning a node.

[[_pics_73]]
====== link:#_pics_73[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_40]]
====== link:#_preconditions_40[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |Spec 4.13.1.1 |Initiator has obtained the Matter passcode and that
the responder has the relevant CHIP_Crypto_PAKEValues_Responder
corresponding to the passcode |
|===

[[_required_devices_73]]
====== link:#_required_devices_73[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_test_procedure_73]]
====== link:#_test_procedure_73[]Test Procedure

[width="100%",cols="5%,5%,10%,30%,50%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |4.13.1.2 | |Initiator constructs and sends a TLV-encoded
PBKDFParamRequest message a|
Verify that the responder receives the PBKDFParamRequest message.

Verify that the protocol header is properly constructed:

. Message Flags: S Flag is set to 0, and DSIZ field is set to 0
. Session ID is set to 0
. Security Flags: Session Type bits are set to 0
. Exchange Flags: I Flag is set to 1
. Protocol Opcode is set to 32 (0x20)
. Protocol ID is set to 0

Verify, if possible in a debug mode, that the PBKDFParamRequest message
contains:

. initiatorRandom - randomly generated 32-bit octet string
. initiatorSessionId - max size 16-bits unsigned integer that does not
overlap with existing initiator session identifiers
. passcodeId - max size 16-bits unsigned integer
. hasPBKDFParameters - boolean
+
[loweralpha]
.. If hasPBKDFParameters is set to true then PBKDF parameters are not
known for the given passcodeId
.. If hasPBKDFParameters is set to false then PBKDF parameters are known
for the given passcodeId
. initiatorSessionParams - optional session-parameter-struct which
contains
+
[loweralpha]
.. SESSION_IDLE_INTERVAL - max size 32-bits unsigned integer
.. SESSION_ACTIVE_INTERVAL - max size 32-bits unsigned integer
.. SESSION_ACTIVE_THRESHOLD - max size 16-bits unsigned integer

|2 |4.13.1.2 | |Responder verifies the passcodeID, constructs and sends
a TLV-encoded PBKDFParamResponse message a|
Verify that the Initiator receives the PBKDFParamResponse message.

Verify that the protocol header is properly constructed:

. Message Flags: S Flag is set to 0, and DSIZ field is set to 0
. Session ID is set to 0
. Security Flags: Session Type bits are set to 0
. Exchange Flags: I Flag is set to 0
. Protocol Opcode is set to 33 (0x21)
. Protocol ID is set to 0

Verify, if possible in a debug mode, that the PBKDFParamResponse message
contains:

. initiatorRandom - value from the PBKDFParamRequest message
. responderRandom - randomly generated 32-bit octet string
. responderSessionId - max size 16-bits unsigned integer that does not
overlap with existing that does not overlap with existing responder
session identifiers
. pbkdf_parameters
+
[loweralpha]
.. If hasPBKDFParameters from the PBKDFParamRequest message is true,
then pbkdf_parameters should not be included.
.. If hasPBKDFParameters from the PBKDFParamRequest message is false,
then PBKDFParameters should contain a + Crypto_PBKDFParameterSet struct
with values for iterations (max size 32 bit unsigned integer) and +
salt (octet string with a minimum of 16 bits and maximum of 32 bits)
. responderSessionParams - optional session-parameter-struct
+
[loweralpha]
.. SESSION_IDLE_INTERVAL - max size 32-bits unsigned integer
.. SESSION_ACTIVE_INTERVAL - max size 32-bits unsigned integer
.. SESSION_ACTIVE_THRESHOLD - max size 16-bits unsigned integer

|3 a|
4.13.1.2,

3.5

| |Initiator constructs and sends a TLV-encoded Pake1 message a|
Verify that the Responder receives the Pake1 message.

Verify that the protocol header is properly constructed:

{empty}1. Message Flags: S Flag is set to 0, and DSIZ field is set to 0

{empty}2. Session ID is set to 0

{empty}3. Security Flags: Session Type bits are set to 0

{empty}4. Exchange Flags: I Flag is set to 1

{empty}5. Protocol Opcode is set to 34 (0x22)

{empty}6. Protocol ID is set to 0

Verify, if possible in a debug mode, that the Pake1 message contains:

{empty}1. pA - 65 bit octet string

|4 a|
4.13.1.2,

3.5,

3.3

| |Responder constructs and sends a TLV-encoded Pake2 message a|
Verify that the Initiator receives the Pake2 message.

Verify that the protocol header is properly constructed:

{empty}1. Message Flags: S Flag is set to 0, and DSIZ field is set to 0

{empty}2. Session ID is set to 0

{empty}3. Security Flags: Session Type bits are set to 0

{empty}4. Exchange Flags: I Flag is set to 0

{empty}5. Protocol Opcode is set to 35 (0x23)

{empty}6. Protocol ID is set to 0

Verify, if possible in a debug mode, that the Pake1 message contains:

{empty}1. pB - 65 bit octet string

{empty}2. cB - 32 bit octet string

|5 a|
4.13.1.2,

3.3

| |Initiator constructs and sends a TLV-encoded Pake3 message a|
Verify that the Responder receives the Pake3 message.

Verify that the protocol header is properly constructed:

{empty}1. Message Flags: S Flag is set to 0, and DSIZ field is set to 0

{empty}2. Session ID is set to 0

{empty}3. Security Flags: Session Type bits are set to 0

{empty}4. Exchange Flags: I Flag is set to 1

{empty}5. Protocol Opcode is set to 36 (0x24)

{empty}6. Protocol ID is set to 0

Verify, if possible in a debug mode, that the Pake3 message contains:

{empty}1. cA - 32 bit octet string

|6 a|
4.13.1.2,

4.9.1

| |Responder validates Pake3, then constructs and sends a status report
(PakeFinished) message a|
Verify that the Initiator receives the status report/PakeFinished
message.

Verify that the status report contains:

{empty}1. GeneralCode - SUCCESS (value 0)

{empty}2. ProtocolId - SECURE_CHANNEL (value 0x0000)

{empty}3. ProtocolCode - SESSION_ESTABLISHMENT_SUCCESS (value 0x0000)

Verify that the initiator has not sent any encrypted data to the
responder prior to receiving PakeFinished.

|===

[[_notestesting_considerations_53]]
====== link:#_notestesting_considerations_53[]Notes/Testing considerations

. Step 1 and Step 3 - Potentially non-testable item - Session IDs,
InitiatorSessionId in this case, should not overlap.
. Can we check session context somehow?

'''''

[[_tc_sc_2_2_bidirectional_communication_passcode_authenticated_session_establishment_pase_removed]]
===== link:#_tc_sc_2_2_bidirectional_communication_passcode_authenticated_session_establishment_pase_removed[]22.2.2. [TC-SC-2.2] Bidirectional Communication - Passcode Authenticated Session Establishment (PASE) - REMOVED

[[_category_74]]
====== link:#_category_74[]Category

Functional conformance

[[_purpose_75]]
====== link:#_purpose_75[]Purpose

This test case verifies that the initiator and responder can
successfully send and receive encrypted messages

[[_pics_74]]
====== link:#_pics_74[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_41]]
====== link:#_preconditions_41[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |Spec-4.13.1.2 |Initiator and Responder have completed session
establishment (TC 6.2.1) |
|===

[[_required_devices_74]]
====== link:#_required_devices_74[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_29]]
====== link:#_device_topology_29[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_18]]
====== link:#_test_setup_18[]Test Setup

The device set up as Commissioner is the Initiator and the device
serving as Commissionee is the Responder

[[_test_procedure_74]]
====== link:#_test_procedure_74[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Initiator uses I2RKey to encrypt and send a message |Responder
receives the encrypted message

|2 | | |Responder uses I2RKey to decrypt the message |Responder is able
to decrypt the message

|3 | | |Responder uses R2IKey to encrypt and send a message |Initiator
receives the encrypted message

|4 | | |Initiator uses R2IKey to decrypt the message |Initiator is able
to decrypt the message

|5 | | |An error is encountered in initiator or responder decryption
|Session is terminated and keys are cleared from memory
|===

[[_notestesting_considerations_54]]
====== link:#_notestesting_considerations_54[]Notes/Testing considerations

This test case needs to be cleaned up to provide additional context
about preconditions, possibly merged with the main PASE test case. TODO

'''''

[[_tc_sc_2_3_pase_error_handling_dut_respondercommissionee_removed]]
===== link:#_tc_sc_2_3_pase_error_handling_dut_respondercommissionee_removed[]22.2.3. [TC-SC-2.3] PASE Error Handling [DUT_Responder/Commissionee] - REMOVED

[[_category_75]]
====== link:#_category_75[]Category

Functional conformance - Negative testing

[[_purpose_76]]
====== link:#_purpose_76[]Purpose

This test case verifies that the DUT can properly respond to error cases
during PASE messaging

[[_pics_75]]
====== link:#_pics_75[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_42]]
====== link:#_preconditions_42[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |Spec 4.12.1.2 |Initiator has obtained the Matter passcode and that
the responder has the relevant CHIP_Crypto_PAKEValues_Responder
corresponding to the passcode |
|===

[[_required_devices_75]]
====== link:#_required_devices_75[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a initiator node on a Matter network
|2 |DUT |Device acting as a responder node on a Matter network
|===

[[_device_topology_30]]
====== link:#_device_topology_30[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_19]]
====== link:#_test_setup_19[]Test Setup

The TH is set up as a Commissioner/Initiator and the DUT as a
Commissionee/Responder

[[_test_procedure_75]]
====== link:#_test_procedure_75[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |4.13.1.2 | |TH generates and sends PBKDFParamRequest with an
invalid passcodeID |Verify DUT receives the PBKDFParamRequest message.

|1b |4.13.1.2 | |DUT verifies the passcodeID. |Verify that the DUT fails
verification of the passcodeID and sends a status report to the TH with
a FAILURE general code (value 1), protocol ID of SECURE_CHANNEL
(0x0000), and Protocol code of INVALID_PARAMETER (0X0002). Verify that
the DUT performs no further processing after sending the status report.

|2a |4.13.1.2 | |TH generates and sends PBKDFParamRequest with a valid
passcodeID |Verify DUT receives the PBKDFParamRequest message.

|2b |4.13.1.2 | |DUT verifies the passcodeID. |Verify that the DUT
passes verification, then constructs and sends a PBKDFParamResponse
message. Verify that the TH receives the message.

|2c |4.13.1.2 | |TH generates and sends Pake1 |Verify DUT receives the
Pake1 message.

|2b |4.13.1.2 | |DUT generates and sends Pake2 |Verify TH receives the
Pake2 message.

|2e |4.13.1.2 | |TH generates and sends Pake3 with an invalid key
confirmation message (cA) |Verify DUT receives the Pake3 message.

|2f |4.13.1.2 | |DUT verifies Pake3.cA. |Verify that the DUT fails
verification and sends a status report to the TH with a FAILURE general
code (value 1), protocol ID of SECURE_CHANNEL (0x0000), and Protocol
code of INVALID_PARAMETER (0X0002). Verify that the DUT performs no
further processing after sending the status report.
|===

[[_notestesting_considerations_55]]
====== link:#_notestesting_considerations_55[]Notes/Testing considerations

'''''

[[_tc_sc_2_4_pase_error_handling_dut_initiatorcommissioner_removed]]
===== link:#_tc_sc_2_4_pase_error_handling_dut_initiatorcommissioner_removed[]22.2.4. [TC-SC-2.4] PASE Error Handling [DUT_Initiator/Commissioner] - REMOVED

[[_category_76]]
====== link:#_category_76[]Category

Functional conformance - Negative testing

[[_purpose_77]]
====== link:#_purpose_77[]Purpose

This test case verifies that the DUT can properly respond to error cases
during PASE messaging

[[_pics_76]]
====== link:#_pics_76[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_43]]
====== link:#_preconditions_43[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |Spec-4.12.1.2 |Initiator has obtained the Matter passcode and that
the responder has the relevant CHIP_Crypto_PAKEValues_Responder
corresponding to the passcode |
|===

[[_required_devices_76]]
====== link:#_required_devices_76[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a responder node on a Matter network
|2 |DUT |Device acting as a initiator node on a Matter network
|===

[[_device_topology_31]]
====== link:#_device_topology_31[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_20]]
====== link:#_test_setup_20[]Test Setup

The DUT set up as a Commissioner/Initiator and the TH as a
Commissionee/Responder

[[_test_procedure_76]]
====== link:#_test_procedure_76[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |4.13.1.2 | |DUT generates and sends PBKDFParamRequest |Verify TH
receives the PBKDFParamRequest message.

|2 |4.13.1.2 | |TH generates and sends PBKDFParamResponse |Verify DUT
receives the PBKDFParamResponse message.

|3 |4.13.1.2 | |DUT generates and sends Pake1 |Verify TH receives the
Pake1 message.

|4 |4.13.1.2 | |TH generates and sends Pake2 with an invalid key
confirmation message (cB) |Verify DUT receives the Pake2 message.

|5 |4.13.1.2 | |DUT verifies Pake2.cB. |Verify that the DUT fails
verification and sends a status report to the TH with a _FAILURE_
general code (value 1), protocol ID of _SECURE_CHANNEL_ (0x0000), and
Protocol code of _INVALID_PARAMETER_ (0X0002). Verify that the DUT
performs no further processing after sending the status report.
|===

[[_notestesting_considerations_56]]
====== link:#_notestesting_considerations_56[]Notes/Testing considerations

'''''

[[_certificate_authenticated_session_establishment_case_test_cases]]
==== link:#_certificate_authenticated_session_establishment_case_test_cases[]22.3. Certificate Authenticated Session Establishment (CASE) Test Cases

'''''

[[_tc_sc_3_1_session_establishment_removed]]
===== link:#_tc_sc_3_1_session_establishment_removed[]22.3.1. [TC-SC-3.1] Session Establishment - REMOVED

[[_category_77]]
====== link:#_category_77[]Category

Functional conformance

[[_purpose_78]]
====== link:#_purpose_78[]Purpose

This test case verifies that the initiator and responder can establish a
sessions to successfully send and receive encrypted messages

[[_pics_77]]
====== link:#_pics_77[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_44]]
====== link:#_preconditions_44[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.13.2.3 |Underlying transport is reliable, either implicitly (i.e.:
TCP) or explicitly (i.e.: MRP) |
|===

[[_required_devices_77]]
====== link:#_required_devices_77[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network - Initiator
|2 |DUT |DUT acting as a node on a Matter network -Responder
|===

[[_test_procedure_77]]
====== link:#_test_procedure_77[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a |4.13.2.2 | a|
TH and the DUT are commissioned.

|

|1b |4.13.2.2 | a|
* Send Read Request from Initiator (TH) to Responder (DUT)
* Note: Example for Read Request could be reading OnOff attribute value
from OnOff Cluster

|Verify that the responder sends response to Read Request.

|1c |4.13.2.2 | |Initiator (TH) sends a Close Session message to the
Responder (DUT) |

|1d |4.13.2.2 | |Initiator (TH) triggers a CASE session resumption. This
can be accomplished in the TH using a read attribute command, which will
trigger a session resumption before reading since it has no active
session. |

|1e a|
4.13.2.3

4.4.1

4.4.3.4

4.4.3.2

| a|
Initiator constructs and sends a TLV-encoded Sigma1 message containing a
random initiation value, destination identifier, session identifier, the
public key for its ephemeral key pair, and optional MRP parameters and
sends the message to the Responder.

{empty}1. I Flag is set to 1 (Initiator)

{empty}2. S flag and DSIZ fields of message flags are set to 0 (Source
and Destination Node ID not present)

{empty}3. The message payload follows the sigma-1-struct TLV encoding
format

{empty}4. The Session Type field is set to 0 (Unicast)

{empty}5. The Protocol ID field is set to 0 (PROTOCOL_ID_SECURE_CHANNEL)

{empty}6. Protocol Opcode field is set to 48 (0x30) (Case Sigma 1)

|

|2 a|
4.13.2.3

4.13.2.4

| |Upon receiving the Sigma1 message the responder proceeds to generate
a Sigma 2 message. |Verify that the Initiator receives Sigma2 message
from the Responder.

|3 a|
4.13.2.2

4.4.1

4.4.3.4

4.4.3.2

| | a|
Verify that the Sigma 2 message having the following values:

{empty}1. I flag is set to 0 (Responder)

{empty}2. S flag and DSIZ fields of message flags are set to 0 (Source
and Destination Node ID not present)

{empty}3. The message payload follows the sigma-2-struct TLV encoding
format

{empty}4. The Session Type field is set to 0 (Unicast)

{empty}5. The Protocol ID field is set to 0 (PROTOCOL_ID_SECURE_CHANNEL)

{empty}6. Protocol Opcode field is set to 49 (0x31) (CASE Sigma2)

|4 a|
4.13.2.3

3.6.2

4.9.1.6

3.5.3.2

| |Initiator generates a shared secret, generates a S2K key, and
decrypts and verifies the message data, node operational certificate
(NOC), and signature data. |

|5 |4.13.2.2 | a|
Initiator constructs and sends a TLV-encoded Sigma3 message containing
encrypted integrity data.

{empty}1. I Flag is set to 1 (Initiator)

{empty}2. S flag and DSIZ fields of message flags are set to 0 (Source
and Destination Node ID not present)

{empty}3. The message payload follows the sigma-3-struct TLV encoding
format

{empty}4. The Session Type field is set to 0 (Unicast)

{empty}5. The Protocol ID field is set to 0 (PROTOCOL_ID_SECURE_CHANNEL)

{empty}6. Protocol Opcode field is set to 50 (0x32) (CASE Sigma3)

the initiator moves to the next step to send a Sigma3 message to the
Responder.

|

|6 a|
4.13.2.3

3.6.2

4.9.1.6

3.5.3.2

| | |Verify that the session is established and the responder sends a
SigmaFinished StatusReport message with GeneralCode _SUCCESS_,
ProtocolId _PROTOCOL_ID_SECURE_CHANNEL_, and ProtocolCode
_SessionEstablishmentSuccess_.
|===

[[_notestesting_considerations_57]]
====== link:#_notestesting_considerations_57[]Notes/Testing considerations

'''''

[[_tc_sc_3_2_case_session_resumption_dut_responder]]
===== link:#_tc_sc_3_2_case_session_resumption_dut_responder[]22.3.2. [TC-SC-3.2] CASE Session Resumption [DUT_Responder]

[[_category_78]]
====== link:#_category_78[]Category

Functional conformance

[[_purpose_79]]
====== link:#_purpose_79[]Purpose

This test case verifies that the initiator and responder can
successfully resume a CASE exchange

[[_pics_78]]
====== link:#_pics_78[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_45]]
====== link:#_preconditions_45[]Preconditions

[width="99%",cols="10%,18%,36%,36%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.13.2.3 |Underlying transport is reliable, either implicitly (i.e.:
TCP) or explicitly (i.e.: MRP) |

|2 |4.13.2.2 |CASE was previously successfully completed between the
Initiator and Responder and the previous session context is known by
both nodes. |
|===

[[_required_devices_78]]
====== link:#_required_devices_78[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network - Initiator
|2 |DUT |DUT acting as a node on a Matter network -Responder
|===

[[_device_topology_32]]
====== link:#_device_topology_32[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_21]]
====== link:#_test_setup_21[]Test Setup

TH is the Initiator and the DUT is the Responder. TH and the DUT are
commissioned.

[[_test_procedure_78]]
====== link:#_test_procedure_78[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |4.13.2.2 | a|
* Send Read Request from Initiator (TH) to Responder (DUT)
* Save the value as 'read response'
* Note: Example for Read Request could be reading OnOff attribute value
from OnOff Cluster

|Verify that the responder sends response to Read Request.

|1b |4.13.2.2 | |Initiator (TH) sends a Close Session message to the
Responder (DUT) |

|1c |4.13.2.2 | |Initiator triggers a CASE session resumption. This can
be accomplished in the TH using a read attribute command, which will
automatically trigger a session resumption before reading since it has
no active session. |

|2 |4.13.2.3 | a|
Initiator constructs and sends a TLV-encoded Sigma1 message to Responder
with resumption containing

. initiatorRandom
. initiatorSessionId
. destinationId
. resumptionID
. initiatorResumeMIC
. initiatorEphPubKey
. initiatorSessionParams

|Verify that Responder sends Sigma2_Resume message to Initiator

|3 |4.13.2.3 | a|
Initiator receives the Sigma2_Resume message and extracts the following
values

. resumptionID
. responderSessionID
. sigma2ResumeMIC
. responderMRPParams

a|
* Verify that the message is properly formatted:
+
. I Flag is set to 0
. S flag and DSIZ fields of message flags are set to 0
. The Session Key Type field is set to 0
. The Protocol ID field is set to 0x0000 and
. The Protocol Opcode field is set to 0x33
* Verify that the resumptionID is of Octet String maximum of length 16
bytes
* Verify that the responderSessionID is of uint16
* Verify that the sigma2ResumeMIC is of Octet String maximum of length
16 bytes

|4a |4.13.2.3 | a|
Initiator sends SigmaFinished message to Responder

|

|4b |4.13.2.3 | a| a|
* Verify that the responder sends response to Read Request with the
value that is same as 'read response'

|===

[[_tc_sc_3_3_case_session_resumption_dut_initiator_removed]]
===== link:#_tc_sc_3_3_case_session_resumption_dut_initiator_removed[]22.3.3. [TC-SC-3.3] CASE Session Resumption [DUT_Initiator] - REMOVED

[[_category_79]]
====== link:#_category_79[]Category

Functional conformance

[[_purpose_80]]
====== link:#_purpose_80[]Purpose

This test case verifies that the Initiator and Responder can
successfully resume a CASE exchange

[[_pics_79]]
====== link:#_pics_79[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_46]]
====== link:#_preconditions_46[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.13.2.3 |Underlying transport is reliable, either implicitly (i.e.:
TCP) or explicitly (i.e.: MRP) |

|2 |4.13.2.2 |CASE was previously successfully completed between the
Initiator and Responder through commissioning and the previous session
context is known by both nodes. |
|===

[[_required_devices_79]]
====== link:#_required_devices_79[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network - Responder
|2 |DUT |DUT acting as a node on a Matter network - Initiator
|===

[[_device_topology_33]]
====== link:#_device_topology_33[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_22]]
====== link:#_test_setup_22[]Test Setup

DUT is the Initiator and the TH is the Responder.TH and the DUT are
commissioned.

[[_test_procedure_79]]
====== link:#_test_procedure_79[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a |4.13.2.2 | a|
* Send Read Request from Initiator to Responder
* Note: Example for Read Request could be reading OnOff attribute value
from OnOff Cluster

|

|1b |4.13.2.2 | |Send a Close Session message from the Initiator to the
Responder |

|1c |4.13.2.2 | |Send Read Request from Initiator to Responder |

|2a | | | |Verify that the Initiator sends the Sigma1 message to
Responder

|2b |4.13.2.2, 4.13.2.3, 4.11.8 | a|
Responder receives the Sigma1 message and extracts the following

. initiatorRandom
. initiatorSessionId
. destinationId
. resumptionID
. initiatorResumeMIC
. initiatorEphPubKey
. initiatorSessionParams

a|
* Verify that the message is properly formatted:
+
. I Flag is set to 1
. S flag and DSIZ fields of message flags are set to 0
. The Session Key Type field is set to 0
. The Protocol ID field is set to 0x0000 and
. The Protocol Opcode field is set to 0x30
* Verify that the initiatorRandom is of Octet String maximum of length
32 bytes
* Verify that the initiatorSessionId is of uint16
* Verify that the destinationId is of Octet string
* Verify that the resumptionID from the Initiator matches with the
precondition
+
. Verify that the resumptionID is of Octet String maximum of length 16
bytes
* Verify that the initiatorEphPubKey is of Octet string
* Verify that the initiatorResumeMIC is of Octet string
* Verify that the responderSessionParams is from any one of the
following:
+
. SESSION_IDLE_INTERVAL
+
[loweralpha]
.. Verify that it is of uint32
. SESSION_ACTIVE_INTERVAL
+
[loweralpha]
.. Verify that it is of uint32
. SESSION_ACTIVE_THRESHOLD
+
[loweralpha]
.. Verify that it is of uint16

|2c |4.13.2.3 | a|
Responder sends a TLV-encoded Sigma2_Resume message to Initiator
containing

. resumptionID
. responderSessionID
. sigma2ResumeMIC
. responderMRPParams

|Verify that the Initiator sends a SigmaFinished message to Responder

|3a |4.13.2.3 | a|
Responder receives the SigmaFinished message and extracts the following

. ProtocolId
. ProtocolCode

a|
Verify that the SigmaFinished Status report with the following

. GeneralCode as SUCCESS
. ProtocolId as SECURE_CHANNEL
. ProtocolCode as SESSION_ESTABLISHMENT_SUCCESS

|3b |4.13.2.3 | a| |Verify that Responder receives the Read Request
Message sent from the Initiator
|===

[[_notestesting_considerations_58]]
====== link:#_notestesting_considerations_58[]Notes/Testing considerations

[[_tc_sc_3_4_case_error_handling_dut_responder_removed]]
===== link:#_tc_sc_3_4_case_error_handling_dut_responder_removed[]22.3.4. [TC-SC-3.4] CASE Error Handling [DUT_Responder] - REMOVED

[[_category_80]]
====== link:#_category_80[]Category

Functional conformance - Negative testing

[[_purpose_81]]
====== link:#_purpose_81[]Purpose

This test case verifies that the DUT can handle CASE error scenarios as
a responder

[[_pics_80]]
====== link:#_pics_80[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_47]]
====== link:#_preconditions_47[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.12.2.2 |Underlying transport is reliable, either implicitly (i.e.:
TCP) or explicitly (i.e.: MRP) |
|===

[[_required_devices_80]]
====== link:#_required_devices_80[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_34]]
====== link:#_device_topology_34[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_23]]
====== link:#_test_setup_23[]Test Setup

The TH is the Initiator and the DUT is the Responder

[[_test_procedure_80]]
====== link:#_test_procedure_80[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |4.13.2.3 | |TH constructs and sends a Sigma1 message with a
_resumptionID_ and no _initiatorResumeMIC_ to DUT |Verify that the DUT
receives the message.

|1b |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code , Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002).
* Verify that the DUT performs no further processing after sending the
status report.

|2a |4.13.2.3 | |TH constructs and sends a Sigma1 message with a
_initiatorResumeMIC_ and no _resumptionID_ to DUT |Verify that the DUT
receives the message.

|2b |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002).
* Verify that the DUT performs no further processing after sending the
status report.

|3a |4.13.2.3 | |TH constructs and sends a Sigma1 message with an
invalid _destinationId_ to DUT |Verify that the DUT receives the
message.

|3b |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _NO_SHARED_TRUST_ROOTS_ (0X0001).
* Verify that the DUT performs no further processing after sending the
status report.

|4a |4.13.2.3 | |TH constructs and sends a properly formatted and
encoded Sigma1 message to DUT |Verify that the DUT receives the message.

|4b |4.13.2.3 | | |DUT sends a Sigma2 message to TH

|4c |4.13.2.3 | | |Verify that the TH receives the message

|4d |4.13.2.3 | |TH constructs and sends a Sigma3 message with
improperly generated encrypted integrity data (TBEData3Encrypted) to DUT
|Verify that the DUT receives the message.

|4e |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report.

|5a |4.13.2.3 | |TH constructs and sends a properly formatted and
encoded Sigma1 message to DUT |Verify that the DUT receives the message.

|5b |4.13.2.3 | | |DUT sends a Sigma2 message to TH

|5c |4.13.2.3 | | |Verify that the TH receives the message.

|5d |4.13.2.3 | |TH constructs and sends a Sigma3 message with invalid
initiatorNOC data to DUT |Verify that the DUT receives the message.

|5e |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report.

|6a |4.13.2.3 | |TH constructs and sends a properly formatted and
encoded Sigma1 message to DUT |Verify that the DUT receives the message.

|6b |4.13.2.3 | | |DUT sends a Sigma2 message to TH

|6c |4.13.2.3 | | |Verify that the TH receives the message.

|6d |4.13.2.3 | |TH constructs and sends a Sigma3 message with invalid
signature data to DUT |Verify that the DUT receives the message.

|6e |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report.

|7a |4.13.2.3 | |TH constructs and sends a properly formatted and
encoded Sigma1 message to DUT |Verify that the DUT receives the message.

|7b |4.13.2.3 | | |DUT sends a Sigma2 message to TH

|7c |4.13.2.3 | | |Verify that the TH receives the message.

|7d |4.13.2.3 | |TH constructs and sends a Sigma3 message with invalid
initiatorICAC to DUT |Verify that the DUT receives the message.

|7e |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report.

|8a |4.13.2.3 | |TH constructs and sends a properly formatted and
encoded Sigma1 message to DUT |Verify that the DUT receives the message.

|8b |4.13.2.3 | | |DUT sends a Sigma2 message to TH

|8c |4.13.2.3 | | |Verify that the TH receives the message.

|8d |4.13.2.3 | |TH constructs and sends a Sigma3 message with invalid
initiatorEphPubKey to DUT |Verify that the DUT receives the message.

|8e |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report.

|9a |4.13.2.3 | |TH constructs and sends a properly formatted and
encoded Sigma1 message to DUT |Verify that the DUT receives the message.

|9b |4.13.2.3 | | |DUT sends a Sigma2 message to TH

|9c |4.13.2.3 | | |Verify that the TH receives the message.

|9d |4.13.2.3 | |TH constructs and sends a Sigma3 message with invalid
responderEphPubKey to DUT |Verify that the DUT receives the message.

|9e |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code, Protocol ID of _SECURE_CHANNEL_ (0x0000), and Protocol
Code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report.

|===

[[_notestesting_considerations_59]]
====== link:#_notestesting_considerations_59[]Notes/Testing considerations

TODO - add ICAC scenarios

'''''

[[_tc_sc_3_5_case_error_handling_dut_initiator_removed]]
===== link:#_tc_sc_3_5_case_error_handling_dut_initiator_removed[]22.3.5. [TC-SC-3.5] CASE Error Handling [DUT_Initiator] - REMOVED

[[_category_81]]
====== link:#_category_81[]Category

Functional conformance - Negative testing

[[_purpose_82]]
====== link:#_purpose_82[]Purpose

This test case verifies that the DUT can handle CASE error scenarios as
a initiator

[[_pics_81]]
====== link:#_pics_81[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_48]]
====== link:#_preconditions_48[]Preconditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.12.2.2 |Underlying transport is reliable, either implicitly (i.e.:
TCP) or explicitly (i.e.: MRP) |
|===

[[_required_devices_81]]
====== link:#_required_devices_81[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness acting as a node on a Matter network
|2 |DUT |Device acting as a node on a Matter network
|===

[[_device_topology_35]]
====== link:#_device_topology_35[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_24]]
====== link:#_test_setup_24[]Test Setup

The DUT is the Initiator and the TH is the Responder

[[_test_procedure_81]]
====== link:#_test_procedure_81[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |4.13.2.3 | | |DUT constructs and sends a Sigma1 message to TH

|1b |4.13.2.3 | | |Verify that the TH receives the message.

|1c |4.13.2.3 | |TH verifies Sigma1, then constructs and sends a Sigma2
message with improperly formatted encrypted data (TBEData2Encrypted) to
DUT |Verify that the DUT receives the message.

|1d |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code (value 1), protocol ID of _SECURE_CHANNEL_ (0x0000), and
Protocol code of _INVALID_PARAMETER_ (0X0002).
* Verify that the DUT performs no further processing after sending the
status report.

|2a |4.13.2.3 | | |DUT constructs and sends a Sigma1 message to TH

|2b |4.13.2.3 | | |Verify that the TH receives the message.

|2c |4.13.2.3 | |TH verifies Sigma1, then constructs and sends a Sigma2
message with invalid responderNOC data to DUT |Verify that the DUT
receives the message.

|2d |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code (value 1), protocol ID of _SECURE_CHANNEL_ (0x0000), and
Protocol code of _INVALID_PARAMETER_ (0X0002).
* Verify that the DUT performs no further processing after sending the
status report.

|3a |4.13.2.3 | | |DUT constructs and sends a Sigma1 message to TH

|3b |4.13.2.3 | | |Verify that the TH receives the message.

|3c |4.13.2.3 | |TH verifies Sigma1, then constructs and sends a Sigma2
message with invalid signature data to DUT |Verify that the DUT receives
the message.

|3d |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code (value 1), protocol ID of _SECURE_CHANNEL_ (0x0000), and
Protocol code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report

|4a |4.13.2.3 | | |DUT constructs and sends a Sigma1 message to TH

|4b |4.13.2.3 | | |Verify that the TH receives the message.

|4c |4.13.2.3 | |TH verifies Sigma1, then constructs and sends a Sigma2
message with invalid responderICAC data to DUT |Verify that the DUT
receives the message.

|4d |4.13.2.3 | | a|
* Verify that the DUT sends a status report to the TH with a _FAILURE_
general code (value 1), protocol ID of _SECURE_CHANNEL_ (0x0000), and
Protocol code of _INVALID_PARAMETER_ (0X0002)
* Verify that the DUT performs no further processing after sending the
status report

|===

[[_tc_sc_3_6_case_resource_validation]]
===== link:#_tc_sc_3_6_case_resource_validation[]22.3.6. [TC-SC-3.6] CASE Resource validation

[[_category_82]]
====== link:#_category_82[]Category

Functional conformance

[[_purpose_83]]
====== link:#_purpose_83[]Purpose

This test case verifies that the DUT is able to handle at least three
CASE sessions.

[[_pics_82]]
====== link:#_pics_82[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_49]]
====== link:#_preconditions_49[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT’s CaseSessionsPerFabric in CapabilityMinima is at least 3 |
|===

[[_required_devices_82]]
====== link:#_required_devices_82[]Required Devices

[width="100%",cols="9%,30%,61%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |RD1A |Reference Device 1A as the commissioner and subscriber
|2 |RD1B |Reference Device 1B as the subscriber
|3 |RD1C |Reference Device 1C as the subscriber
|4 |RD2A |Reference Device 2A as the commissioner and subscriber
|5 |RD2B |Reference Device 2B as the subscriber
|6 |RD2C |Reference Device 2C as the subscriber
|7 |RD3A |Reference Device 3A as the commissioner and subscriber
|8 |RD3B |Reference Device 3B as the subscriber
|9 |RD3C |Reference Device 3C as the subscriber
|10 |RD4A |Reference Device 4A as the commissioner and subscriber
|11 |RD4B |Reference Device 4B as the subscriber
|12 |RD4C |Reference Device 4C as the subscriber
|13 |RD5A |Reference Device 5A as the commissioner and subscriber
|14 |RD5B |Reference Device 5B as the subscriber
|15 |RD5C |Reference Device 5C as the subscriber
|16 |DUT |DUT as the target of the subscription.
|===

[[_device_topology_36]]
====== link:#_device_topology_36[]Device Topology

RD1X, RD2X, RD3X, RD4X, RD5X should be on separate, distinct fabrics.

* RD1A, RD1B and RD1C should be on the same fabric.
* RD2A, RD2B and RD2C should be on the same fabric.
* RD3A, RD3B and RD3C should be on the same fabric.
* RD4A, RD4B and RD4C should be on the same fabric.
* RD5A, RD5B and RD5C should be on the same fabric.
* DUT should be commissioned onto all fabrics

[[_test_setup_25]]
====== link:#_test_setup_25[]Test Setup

[[_test_procedure_82]]
====== link:#_test_procedure_82[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
RD1X, RD2X, RD3X, RD4X, RD5X each send 1 Subscribe Request Messages to
DUT.(Total - 15 active subscriptions)

They can subscribe to any attribute. Once all subscriptions are active,
change the value of the attribute that has been subscribed to

|Verify that all subscribers get data reports. Verify on each of these
Reference Devices that the appropriate attribute value has been
received.
|===

[[_notestesting_considerations_60]]
====== link:#_notestesting_considerations_60[]Notes/Testing considerations

. RD1X indicates RD1A, RD1B, RD1C
. RD2X indicates RD2A, RD2B, RD2C
. RD3X indicates RD3A, RD3B, RD3C
. RD4X indicates RD4A, RD4B, RD4C
. RD5X indicates RD5A, RD5B, RD5C
. Vendor can have greater than 3 CaseSessionsPerFabric

'''''

[[_discovery]]
==== link:#_discovery[]22.4. Discovery

'''''

[[_tc_sc_4_1_commissionable_node_discovery_dut_as_commissionee]]
===== link:#_tc_sc_4_1_commissionable_node_discovery_dut_as_commissionee[]22.4.1. [TC-SC-4.1] Commissionable Node Discovery [DUT as Commissionee]

[[_category_83]]
====== link:#_category_83[]Category

Functional conformance

[[_purpose_84]]
====== link:#_purpose_84[]Purpose

The purpose of this test case is to verify that a device is able to
correctly advertise Commissionable Node Discovery service.

[[_pics_83]]
====== link:#_pics_83[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_50]]
====== link:#_preconditions_50[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.3.1 |DUT is connected to any Matter network |
|2 |4.3.1 |DUT is not commissioned |
|===

[[_required_devices_83]]
====== link:#_required_devices_83[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Node that is advertising Commissionable Node Discovery service
using DNS-SD.

|2 |TH |Commissioner that is scanning for DNS-SD
|===

[[_device_topology_37]]
====== link:#_device_topology_37[]Device Topology

N/A

[[_test_setup_26]]
====== link:#_test_setup_26[]Test Setup

N/A

[[_test_procedure_83]]
====== link:#_test_procedure_83[]Test Procedure

[width="100%",cols="5%,5%,20%,20%,50%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |DUT is
Commissioned and put in Commissioning Mode using Open Basic
Commissioning Window command and starts advertising Commissionable Node
Discovery service using DNS-SD |

|2 |4.3.1.3 a|
MCORE.COM.WIFI

MCORE.COM.ETH

MCORE.COM.THR

MCORE.ICD

MCORE.SC.VENDOR_SUBTYPE MCORE.SC.DEVTYPE_SUBTYPE MCORE.SC.VP_KEY
MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.SAT_OP_DISCOVERY_KEY MCORE.SC.DT_KEY MCORE.SC.DN_KEY
MCORE.SC.RI_KEY MCORE.SC.PH_KEY MCORE.SC.PI_KEY

|Check DNS-SD subtypes used by DUT a|
Check DUT advertising for:

- DNS-SD instance name must be 64-bit randomly selected ID expressed as
a sixteen-char hex string with capital letters

- service type must be _matterc._udp

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- IF (MCORE.COM.WIFI) OR (MCORE.COM.ETH) target hostname is derived from
the 48bit or 64bit MAC address expressed as a twelve or sixteen capital
letter hex string. If the MAC is randomized for privacy, the randomized
version must be used each time.

- IF (MCORE.COM.THR) target hostname is derived from the 48bit or 64bit
MAC extended address expressed as a twelve or sixteen capital letter hex
string. If the MAC is randomized for privacy, the randomized version
must be used each time.

- subtype _L<dddd> 12-bit long discriminator, encoded as a
variable-length decimal number in ASCII text, omitting any leading zeros

- subtype _S<dd> 4-bit short discriminator, encoded as a variable-length
decimal number in ASCII text, omitting any leading zeros

- if (MCORE.SC.VENDOR_SUBTYPE) present, subtype _V<ddddd> is present
must be 16-bit vendor id, encoded as a variable-length decimal number in
ASCII text, omitting any leading zeros

- if (MCORE.SC.DEVTYPE_SUBTYPE) present, subtype _T<ddd> is present,
<ddd> represents device type from Data Model and must be represented as
a variable length decimal number in ASCII without leading zeros

- subtype _CM must be present

- key D must be present and represents the discriminator which must be
encoded as a variable-length decimal value with up to 4 digits omitting
any leading zeros

- if (MCORE.SC.VP_KEY) present, VP key must contain at least Vendor ID
and if Product ID is present, values must be separated by a + sign.

- if (MCORE.SC.SII_OP_DISCOVERY_KEY) present, SII key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAI_OP_DISCOVERY_KEY ) present, SAI key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAT_OP_DISCOVERY_KEY) present, SAT key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 65535.

- key CM=1 must be present

- if (MCORE.SC.DT_KEY) present, DT key must contain the device type
identifier from Data Model Device Types and must be encoded as a
variable length decimal ASCII number without leading zeros

- if (MCORE.SC.DN_KEY) present, DN key must be a UTF-8 encoded string
with a maximum length of 32B

- if (MCORE.SC.RI_KEY ) present, key RI must include the Rotating Device
Identifier encoded as a uppercase string with a maximum length of 100
chars (each octet encoded as a 2-digit hex number, max 50 octets)

- if (MCORE.SC.PH_KEY) present, key PH must be encoded as a
variable-length decimal number in ASCII text, omitting any leading
zeros. If present value must be different of 0

- if (MCORE.SC.PI_KEY) present, key PI must be encoded as a valid UTF-8
string with a maximum length of 128 bytes

DUT must publish AAAA records for each IPv6 address upon which they are
willing to accept Matter messages.

|3 | |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |DUT is rebooted,
then put in Commissioning Mode using Open Basic Commissioning Window
command, starting advertising Commissionable Node Discovery service
using DNS-SD |

|4 |4.3.1.3 4.3.1.1 a|
MCORE.COM.WIFI

MCORE.COM.ETH

MCORE.COM.THR

MCORE.ICD

MCORE.SC.VENDOR_SUBTYPE MCORE.SC.DEVTYPE_SUBTYPE MCORE.SC.VP_KEY
MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.SAT_OP_DISCOVERY_KEY MCORE.SC.DT_KEY MCORE.SC.DN_KEY
MCORE.SC.RI_KEY MCORE.SC.PH_KEY MCORE.SC.PI_KEY

|Check DNS-SD subtypes used by DUT a|
Check DUT advertising for:

- DNS-SD instance name must be 64-bit randomly selected ID expressed as
a sixteen-char hex string with capital letters and must be different
from the one at step 2

- service type must be _matterc._udp

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- IF (MCORE.COM.WIFI) OR (MCORE.COM.ETH) target hostname is derived from
the 48bit or 64bit MAC address expressed as a twelve or sixteen capital
letter hex string. If the MAC is randomized for privacy, the randomized
version must be used each time.

- IF (MCORE.COM.THR) target hostname is derived from the 48bit or 64bit
MAC extended address expressed as a twelve or sixteen capital letter hex
string. If the MAC is randomized for privacy, the randomized version
must be used each time.

- subtype _L<dddd> 12-bit long discriminator, encoded as a
variable-length decimal number in ASCII text, omitting any leading zeros

- subtype _S<dd> 4-bit short discriminator, encoded as a variable-length
decimal number in ASCII text, omitting any leading zeros

- if (MCORE.SC.VENDOR_SUBTYPE ) present, subtype _V<ddddd> is present
must be 16-bit vendor id, encoded as a variable-length decimal number in
ASCII text, omitting any leading zeros

- if (MCORE.SC.DEVTYPE_SUBTYPE) present, subtype _T<ddd> is present,
<ddd> represents device type from Data Model and must be represented as
a variable length decimal number in ASCII without leading zeros

- subtype _CM is present

- key D must be present and represents the discriminator which must be
encoded as a variable-length decimal value with up to 4 digits omitting
any leading zeros

- if (MCORE.SC.VP_KEY) present, VP key must contain at least Vendor ID
and if Product ID is present, values must be separated by a + sign.

- if (MCORE.SC.SII_OP_DISCOVERY_KEY ) present, SII key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAI_OP_DISCOVERY_KEY) present, SAI key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAT_OP_DISCOVERY_KEY) present, SAT key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 65535.

- key CM=1 must be present

- if (MCORE.SC.DT_KEY) present, DT key must contain the device type
identifier from Data Model Device Types and must be encoded as a
variable length decimal ASCII number without leading zeros

- if (MCORE.SC.DN_KEY) present, DN key must be a UTF-8 encoded string
with a maximum length of 32B

- if (MCORE.SC.RI_KEY) present, key RI must include the Rotating Device
Identifier encoded as a uppercase string with a maximum length of 100
chars (each octet encoded as a 2-digit hex number, max 50 octets)

- if (MCORE.SC.PH_KEY) present, key PH must be encoded as a
variable-length decimal number in ASCII text, omitting any leading
zeros. If present value must be different of 0

- if (MCORE.SC.PI_KEY) present, key PI must be encoded as a valid UTF-8
string with a maximum length of 128 bytes

DUT must publish AAAA records for each IPv6 address upon which they are
willing to accept Matter messages.

|5 | | |Wait for OpenBasicCommissioningWindow timeout to expire |DUT
should stop sending DNS-SD advertisements

|6 | |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |DUT is Commissioned and
instructed to enter in commissioning mode using Open Commissioning
Window command |DUT should start to send Commissionable Node Discovery
DNS-SD advertisements

|7 | a|
MCORE.COM.WIFI

MCORE.COM.ETH

MCORE.COM.THR

MCORE.ICD

MCORE.SC.VENDOR_SUBTYPE MCORE.SC.DEVTYPE_SUBTYPE MCORE.SC.VP_KEY
MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.SAT_OP_DISCOVERY_KEY MCORE.SC.DT_KEY MCORE.SC.DN_KEY
MCORE.SC.RI_KEY MCORE.SC.PH_KEY MCORE.SC.PI_KEY

|Check DNS-SD subtypes used by DUT a|
Check DUT advertising for:

- DNS-SD instance name must be 64-bit randomly selected ID expressed as
a sixteen-char hex string with capital letters

- service type must be _matterc._udp

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- IF (MCORE.COM.WIFI) OR (MCORE.COM.ETH) target hostname is derived from
the 48bit or 64bit MAC address expressed as a twelve or sixteen capital
letter hex string. If the MAC is randomized for privacy, the randomized
version must be used each time.

- IF (MCORE.COM.THR) target hostname is derived from the 48bit or 64bit
MAC extended address expressed as a twelve or sixteen capital letter hex
string. If the MAC is randomized for privacy, the randomized version
must be used each time.

- subtype _L<dddd> 12-bit long discriminator, encoded as a
variable-length decimal number in ASCII text, omitting any leading zeros

- subtype _S<dd> 4-bit short discriminator, encoded as a variable-length
decimal number in ASCII text, omitting any leading zeros

- if (MCORE.SC.VENDOR_SUBTYPE) present, subtype _V<ddddd> is present
must be 16-bit vendor id, encoded as a variable-length decimal number in
ASCII text, omitting any leading zeros

- if (MCORE.SC.DEVTYPE_SUBTYPE) present, subtype _T<ddd> is present,
<ddd> represents device type from Data Model and must be represented as
a variable length decimal number in ASCII without leading zeros

- subtype _CM is present

- key D must be present and represents the discriminator which must be
encoded as a variable-length decimal value with up to 4 digits omitting
any leading zeros

- if (MCORE.SC.VP_KEY ) present, VP key must contain at least Vendor ID
and if Product ID is present, values must be separated by a + sign.

- if (MCORE.SC.SII_OP_DISCOVERY_KEY) present, SII key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAI_OP_DISCOVERY_KEY) present, SAI key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAT_OP_DISCOVERY_KEY) present, SAT key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 65535.

- key CM=2 must be present

- if (MCORE.SC.DT_KEY) present, DT key must contain the device type
identifier from Data Model Device Types and must be encoded as a
variable length decimal ASCII number without leading zeros

- if (MCORE.SC.DN_KEY) present, DN key must be a UTF-8 encoded string
with a maximum length of 32B

- if (MCORE.SC.RI_KEY) present, key RI must include the Rotating Device
Identifier encoded as a uppercase string with a maximum length of 100
chars (each octet encoded as a 2-digit hex number, max 50 octets)

- if (MCORE.SC.PH_KEY) present, key PH must be encoded as a
variable-length decimal number in ASCII text, omitting any leading
zeros. If present value must be different of 0

- if (MCORE.SC.PI_KEY) present, key PI must be encoded as a valid UTF-8
string with a maximum length of 128 bytes

DUT must publish AAAA records for each IPv6 address upon which they are
willing to accept Matter messages.

|8 | | |Wait for OCW timeout to expire |DUT should stop sending DNS-SD
advertisements

|9 | |MCORE.SC.EXTENDED_DISCOVERY |If (MCORE.SC.EXTENDED_DISCOVERY )
enable Extended Discovery |DUT should start to send Commissionable Node
Discovery DNS-SD advertisements

|10 | a|
MCORE.SC.EXTENDED_DISCOVERY MCORE.COM.WIFI

MCORE.COM.ETH

MCORE.COM.THR

MCORE.ICD

MCORE.SC.VENDOR_SUBTYPE MCORE.SC.DEVTYPE_SUBTYPE MCORE.SC.VP_KEY
MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.SAT_OP_DISCOVERY_KEY MCORE.SC.DT_KEY MCORE.SC.DN_KEY
MCORE.SC.RI_KEY MCORE.SC.PH_KEY MCORE.SC.PI_KEY

|If (MCORE.SC.EXTENDED_DISCOVERY ) check DNS-SD subtypes used by DUT a|
Check DUT advertising for:

- DNS-SD instance name must be 64-bit randomly selected ID expressed as
a sixteen-char hex string with capital letters

- service type must be _matterc._udp

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- IF (MCORE.COM.WIFI) OR (MCORE.COM.ETH) target hostname is derived from
the 48bit or 64bit MAC address expressed as a twelve or sixteen capital
letter hex string. If the MAC is randomized for privacy, the randomized
version must be used each time.

- IF (MCORE.COM.THR) target hostname is derived from the 48bit or 64bit
MAC extended address expressed as a twelve or sixteen capital letter hex
string. If the MAC is randomized for privacy, the randomized version
must be used each time.

- subtype _L<dddd> 12-bit long discriminator, encoded as a
variable-length decimal number in ASCII text, omitting any leading zeros

- subtype _S<dd> 4-bit short discriminator, encoded as a variable-length
decimal number in ASCII text, omitting any leading zeros

- if (MCORE.SC.VENDOR_SUBTYPE ) present, subtype _V<ddddd> is present
must be 16-bit vendor id, encoded as a variable-length decimal number in
ASCII text, omitting any leading zeros

- if (MCORE.SC.DEVTYPE_SUBTYPE) present, subtype _T<ddd> is present,
<ddd> represents device type from Data Model and must be represented as
a variable length decimal number in ASCII without leading zeros

- subtype _CM must not be present

- key D must be present and represents the discriminator which must be
encoded as a variable-length decimal value with up to 4 digits omitting
any leading zeros

- if (MCORE.SC.VP_KEY) present, VP key must contain at least Vendor ID
and if Product ID is present, values must be separated by a + sign.

- if (MCORE.SC.SII_OP_DISCOVERY_KEY) present, SII key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAI_OP_DISCOVERY_KEY) present, SAI key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 3600000.

- if (MCORE.SC.SAT_OP_DISCOVERY_KEY) present, SAT key must be an
unsigned integer with units of milliseconds and shall be encoded as a
variable length decimal number in ASCII, omitting leading zeros. Shall
not exceed 65535.

- key CM=0 may be present

- if (MCORE.SC.DT_KEY) present, DT key must contain the device type
identifier from Data Model Device Types and must be encoded as a
variable length decimal ASCII number without leading zeros

- if (MCORE.SC.DN_KEY) present, DN key must be a UTF-8 encoded string
with a maximum length of 32B

- if (MCORE.SC.RI_KEY) present, key RI must include the Rotating Device
Identifier encoded as a uppercase string with a maximum length of 100
chars (each octet encoded as a 2-digit hex number, max 50 octets)

- if (MCORE.SC.PH_KEY) present, key PH must be encoded as a
variable-length decimal number in ASCII text, omitting any leading
zeros. If present value must be different of 0

- if (MCORE.SC.PI_KEY) present, key PI must be encoded as a valid UTF-8
string with a maximum length of 128 bytes

|===

[[_notestesting_considerations_61]]
====== link:#_notestesting_considerations_61[]Notes/Testing considerations

'''''

[[_tc_sc_4_2_discovery_dut_as_commissioner]]
===== link:#_tc_sc_4_2_discovery_dut_as_commissioner[]22.4.2. [TC-SC-4.2] Discovery [DUT as Commissioner]

[[_category_84]]
====== link:#_category_84[]Category

Functional conformance

[[_purpose_85]]
====== link:#_purpose_85[]Purpose

The purpose of this test case is to verify that a commissioner is able
to discover a node that announce Commissionable Node Discovery service.

[[_pics_84]]
====== link:#_pics_84[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_51]]
====== link:#_preconditions_51[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.2.1 |TH is not commissioned |
|===

[[_required_devices_84]]
====== link:#_required_devices_84[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissioner scanning for commissionee nodes that advertise
Commissionable Node Discovery service.

|2 |TH |Node that is advertising Commissionable Node Discovery service.
|===

[[_device_topology_38]]
====== link:#_device_topology_38[]Device Topology

N/A

[[_test_setup_27]]
====== link:#_test_setup_27[]Test Setup

N/A

[[_test_procedure_84]]
====== link:#_test_procedure_84[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |By any means, TH adds an unknown key/value pair in the
advertised data(e.g. AB=12345) and is in Commissioning Mode |TH must
advertise with new data added

|2 | | |DUT attempts to commission TH |DUT successfully commissions TH
and the unknown key/value pair added at step 1 must be silently
discarded
|===

[[_notestesting_considerations_62]]
====== link:#_notestesting_considerations_62[]Notes/Testing considerations

Open discussion over the utility of this TC. May be removed in the
future!

'''''

[[_tc_sc_4_3_discovery_dut_as_commissionee]]
===== link:#_tc_sc_4_3_discovery_dut_as_commissionee[]22.4.3. [TC-SC-4.3] Discovery [DUT as Commissionee]

[[_category_85]]
====== link:#_category_85[]Category

Functional conformance

[[_purpose_86]]
====== link:#_purpose_86[]Purpose

The purpose of this test case is to verify that a Matter node is
discoverable and can advertise its services in a Matter network.

[[_pics_85]]
====== link:#_pics_85[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_52]]
====== link:#_preconditions_52[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Nodes are joined in the same Fabric |
|===

[[_required_devices_85]]
====== link:#_required_devices_85[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Matter Node that is advertising a service
|2 |TH |Matter Controller that is advertising a service
|===

[[_device_topology_39]]
====== link:#_device_topology_39[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_28]]
====== link:#_test_setup_28[]Test Setup

N/A

[[_test_procedure_85]]
====== link:#_test_procedure_85[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |4.3.2.1 | |DUT is commissioned to TH and DUT is instructed to
advertise its operational service (`_matter._tcp`). |DUT should start to
advertise service via DNS-SD

|2 |4.3.2.3 a|
MCORE.COM.WIFI

MCORE.COM.ETH

MCORE.COM.THR

MCORE.ICD

MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.SAT_OP_DISCOVERY_KEY MCORE.SC.T_KEY

|Scan for DNS-SD advertising a|
Check DUT advertising for:

- DNS-SD instance name must be 64-bit compressed FabricID

- service type must be _matter._tcp

- subtype _I<hhhh> represents compressed FabricID encoded as 16 hex
UPPERcase chars.

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- IF (MCORE.COM.WIFI OR MCORE.COM.ETH) target hostname is derived from
the 48bit MAC address expressed as a twelve capital letter hex string.
If the MAC is randomized for privacy, the randomized version must be
used each time.

- IF (MCORE.COM.THR) target hostname is derived from the 64bit MAC
extended address expressed as a sixteen capital letter hex string. If
the MAC is randomized for privacy, the randomized version must be used
each time.

- if (MCORE.SC.SII_OP_DISCOVERY_KEY), key SII shall not exceed 3600000
(1h in ms) and must be encoded as a decimal value omitting any leading
zeros. if key is not available or has an invalid value, the default
MRP_RETRY_INTERVAL_IDLE value must be used

- if (MCORE.SC.SAI_OP_DISCOVERY_KEY), key SAI shall not exceed 3600000
(1h in ms) and must be encoded as a decimal value omitting any leading
zeros. if key is not available or has an invalid value, the default
MRP_RETRY_INTERVAL_ACTIVE value must be used

- if (MCORE.SC.SAT_OP_DISCOVERY_KEY), key SAT shall not exceed 65535
(65.535 seconds) and must be encoded as a decimal value omitting any
leading zeros. if key is not available or has an invalid value, the
default SESSION_ACTIVE_THRESHOLD value shall be used

- if (MCORE.SC.T_KEY), key T it can have only 0 or 1 values and must be
encoded as a decimal value omitting any leading zeros. if key is not
available or has an invalid value, the default value 0 must be used
indicating TCP is not supported.

DUT must publish AAAA records for each IPv6 address upon which they are
willing to accept Matter messages.

|===

[[_notestesting_considerations_63]]
====== link:#_notestesting_considerations_63[]Notes/Testing considerations

'''''

[[_tc_sc_4_4_discovery_dut_as_controller]]
===== link:#_tc_sc_4_4_discovery_dut_as_controller[]22.4.4. [TC-SC-4.4] Discovery [DUT as Controller]

[[_category_86]]
====== link:#_category_86[]Category

Functional conformance

[[_purpose_87]]
====== link:#_purpose_87[]Purpose

The purpose of this test case is to verify that a Matter controller is
able to discover the IP address of nodes that interacted with.

[[_pics_86]]
====== link:#_pics_86[]PICS

* MCORE.ROLE.CONTROLLER

[[_preconditions_53]]
====== link:#_preconditions_53[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Nodes are joined in the same Fabric |
|===

[[_required_devices_86]]
====== link:#_required_devices_86[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Matter Controller
|2 |TH |Matter Node that is advertising a service
|===

[[_device_topology_40]]
====== link:#_device_topology_40[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_29]]
====== link:#_test_setup_29[]Test Setup

[[_test_procedure_86]]
====== link:#_test_procedure_86[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |4.3.2.1 | |TH starts commissioning process with DUT |TH is
commissioned by DUT

|2 |4.3.2.6 |BINFO.C.A0002(VendorID) |DUT reads Vendor Id attribute from
TH |Verify TH receives the read command and shows Vendor Id value

|3 |4.3.2.6 | |Change the IP address of TH by any means within the same
network |

|4 |4.3.2.6 |BINFO.C.A0002(VendorID) |DUT reads Vendor Id attribute from
TH |Verify TH receives the read command and shows Vendor Id value
|===

[[_notestesting_considerations_64]]
====== link:#_notestesting_considerations_64[]Notes/Testing considerations

'''''

[[_tc_sc_4_5_discovery_dut_as_commissioneethread_removed]]
===== link:#_tc_sc_4_5_discovery_dut_as_commissioneethread_removed[]22.4.5. [TC-SC-4.5] Discovery [DUT as Commissionee][Thread] - REMOVED

[[_category_87]]
====== link:#_category_87[]Category

Functional conformance

[[_purpose_88]]
====== link:#_purpose_88[]Purpose

The purpose of this test case is to verify that a Matter node with
Thread transport layer is able to discover and advertise it’s own
services in a Matter network.

[[_pics_87]]
====== link:#_pics_87[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_preconditions_54]]
====== link:#_preconditions_54[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |Nodes are joined in the same Fabric |

|2 |4.2 |TH must implement DNS-SD Discovery Proxy, SRP and Advertising
Proxy |

|3 |4.2 |DUT must implement SRP |
|===

[[_required_devices_87]]
====== link:#_required_devices_87[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Matter node that has Thread transport layer
|2 |TH |Matter controller has Thread transport layer
|===

[[_device_topology_41]]
====== link:#_device_topology_41[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_30]]
====== link:#_test_setup_30[]Test Setup

N/A

[[_test_procedure_87]]
====== link:#_test_procedure_87[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |4.3.2-1 | |TH is instructed to start advertising two or more
services using DNS-SD |TH should start advertising its services

|2 |4.3.2-1 |MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.T_KEY |By any means, DUT is instructed to perform an unicast
UDP query to the DNS-SD Discovery Proxy on TH for services a|
TH should respond with a list of services available in Matter network
containing the following:

- DNS-SD instance name must be build from the compressed FabricID and
the NodeID, separated by a hyphen

- service type must be _matter._tcp

- subtype _I<hhhh> represents compressed FabricID encoded as 16 hex
UPPERcase chars.

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- target hostname is derived from the 64 bit extended MAC address
expressed as a sixteen capital letter hex string. If the MAC is
randomized for privacy, the randomized version must be used each time.

- if (MCORE.SC.SII_OP_DISCOVERY_KEY), key SII shall not exceed 3600000
(1h in ms) and must be encoded as a decimal value omitting any leading
zeros. if key is not available or has an invalid value, the default
MRP_RETRY_INTERVAL_IDLE value must be used

- if (MCORE.SC.SAI_OP_DISCOVERY_KEY ), key SAI shall not exceed 3600000
(1h in ms) and must be encoded as a decimal value omitting any leading
zeros. if key is not available or has an invalid value, the default
MRP_RETRY_INTERVAL_ACTIVE value must be used

- if (MCORE.SC.T_KEY), key T it can have only 0 or 1 values and must be
encoded as a decimal value omitting any leading zeros. if key is not
available or has an invalid value, the default value 0 must be used
indicating TCP is not supported.

|3 |4.3.2-1 | |TH performs a change in one of the services configured at
step 1 |

|4 |4.3.2-1 |MCORE.SC.SII_OP_DISCOVERY_KEY MCORE.SC.SAI_OP_DISCOVERY_KEY
MCORE.SC.T_KEY |DUT must receive a notification with new data a|
New data must contain the changes from step 3 and include:

- DNS-SD instance name must be 64-bit compressed FabricID

- service type must be _matter._tcp

- subtype _I<hhhh> represents compressed FabricID encoded as 16 hex
UPPERcase chars.

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- target hostname is derived from the 64 bit MAC address expressed as a
sixteen capital letter hex string. If the MAC is randomized for privacy,
the randomized version must be used each time.

- if (MCORE.SC.SII_COMM_DISCOVERY_KEY), key SII shall not exceed 3600000
(1h in ms) and must be encoded as a decimal value omitting any leading
zeros. if key is not available or has an invalid value, the default
MRP_RETRY_INTERVAL_IDLE value must be used

- if (MCORE.SC.SAI_COMM_DISCOVERY_KEY), key SAI shall not exceed 3600000
(1h in ms) and must be encoded as a decimal value omitting any leading
zeros. if key is not available or has an invalid value, the default
MRP_RETRY_INTERVAL_ACTIVE value must be used

- if (MCORE.SC.T_KEY), key T it can have only 0 or 1 values and must be
encoded as a decimal value omitting any leading zeros. if key is not
available or has an invalid value, the default value 0 must be used
indicating TCP is not supported.

|===

[[_notestesting_considerations_65]]
====== link:#_notestesting_considerations_65[]Notes/Testing considerations

'''''

[[_tc_sc_4_6commissioner_discovery_dut_as_commissioner]]
===== link:#_tc_sc_4_6commissioner_discovery_dut_as_commissioner[]22.4.6. [TC-SC-4.6]Commissioner Discovery [DUT as Commissioner]

[[_category_88]]
====== link:#_category_88[]Category

Functional conformance

[[_purpose_89]]
====== link:#_purpose_89[]Purpose

The purpose of this test case is to verify that a device that support
Commissioner Discovery is able to advertise its commissioner service.
This feature is optional for both Commissioner and Commissionee and must
be run only if the device have support for this.

[[_pics_88]]
====== link:#_pics_88[]PICS

* MCORE.ROLE.COMMISSIONER
* MCORE.DD.COMM_DISCOVERY

[[_preconditions_55]]
====== link:#_preconditions_55[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.2.3 |DUT is connected to the IP network or supports SoftAP |
|2 |4.2.3 |DUT and TH support Commissioner Discovery |
|===

[[_required_devices_88]]
====== link:#_required_devices_88[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Node that is scanning for DNS-SD records from DUT
|2 |DUT |Node that is advertising its services using DNS-SD
|===

[[_device_topology_42]]
====== link:#_device_topology_42[]Device Topology

TH and DUT are in the same IP network if DUT has support.

[[_test_setup_31]]
====== link:#_test_setup_31[]Test Setup

[[_test_procedure_88]]
====== link:#_test_procedure_88[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |DUT is instructed to start advertising its presence as a
commissioner in the network |

|2 |4.3.3-1 |MCORE.SC.DEVTYPE_SUBTYPE MCORE.SC.VP_KEY MCORE.SC.DT_KEY
MCORE.SC.DN_KEY |Check DNS-SD subtypes used by DUT a|
DUT must publish AAAA records for each IPv6 address with the following:

- DNS-SD instance name must be 64-bit randomly selected ID expressed as
a sixteen-char hex string with capital letters

- service type must be _matterd._udp

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- if (MCORE.SC.DEVTYPE_SUBTYPE) present, _T<ddd> subtype is present,
<ddd> represents device type from Data Model and must be represented as
a variable length decimal number in ASCII without leading zeros.

- target hostname is derived from the 48bit MAC address expressed as a
twelve capital letter hex string. If the MAC is randomized for privacy,
the randomized version must be used each time.

- if (MCORE.SC.VP_KEY) present, VP key must contain at least Vendor ID
and if Product ID is present, values must be separated by a + sign.

- if (MCORE.SC.DT_KEY) present, DT key must contain the device type
identifier from Data Model Device Types and must be encoded as a
variable length decimal ASCII number without leading zeros

- if (MCORE.SC.DN_KEY) present, DN key must be a UTF-8 encoded string
with a maximum length of 32B

|===

[[_notestesting_considerations_66]]
====== link:#_notestesting_considerations_66[]Notes/Testing considerations

'''''

[[_tc_sc_4_7_commissioner_discovery_dut_as_commissionee]]
===== link:#_tc_sc_4_7_commissioner_discovery_dut_as_commissionee[]22.4.7. [TC-SC-4.7] Commissioner Discovery [DUT as Commissionee]

[[_category_89]]
====== link:#_category_89[]Category

Functional conformance

[[_purpose_90]]
====== link:#_purpose_90[]Purpose

The purpose of this test case is to verify that a device that is already
connected to an IP network is able to discover a commissioner. This
feature is optional for both Commissioner and Commissionee and must be
run only if the device have support for this.

[[_pics_89]]
====== link:#_pics_89[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.DD.COMM_DISCOVERY

[[_preconditions_56]]
====== link:#_preconditions_56[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |4.2.3 |DUT is connected to the IP network |
|2 |4.2.3 |DUT and TH support Commissioner Discovery |
|===

[[_required_devices_89]]
====== link:#_required_devices_89[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Node that is scanning for DNS-SD records from DUT
|2 |TH |Node that is advertising its services using DNS-SD
|===

[[_device_topology_43]]
====== link:#_device_topology_43[]Device Topology

TH and DUT are in the same IP network if DUT has support.

[[_test_setup_32]]
====== link:#_test_setup_32[]Test Setup

[[_test_procedure_89]]
====== link:#_test_procedure_89[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH is instructed to start advertising its presence as a
commissioner in the network |

|2 |4.3.3-1 |MCORE.SC.DEVTYPE_SUBTYPE MCORE.SC.VP_KEY MCORE.SC.DT_KEY
MCORE.SC.DN_KEY |Scan for DNS-SD commissioner advertisements from TH a|
TH must publish AAAA records for each IPv6 address with the following:

- DNS-SD instance name must be 64-bit randomly selected ID expressed as
a sixteen-char hex string with capital letters

- service type must be _matterd._udp

- service domain is .local. For Unicast DNS such as used on Thread the
service domain SHALL be as configured automatically by the Thread Border
Router

- if (MCORE.SC.DEVTYPE_SUBTYPE) present, _T<ddd> subtype is present,
<ddd> represents device type from Data Model and must be represented as
a variable length decimal number in ASCII without leading zeros.

- target hostname is derived from the 48bit MAC address expressed as a
twelve capital letter hex string. If the MAC is randomized for privacy,
the randomized version must be used each time.

- if (MCORE.SC.VP_KEY ) present, VP key must contain at least Vendor ID
and if Product ID is present, values must be separated by a + sign.

- if (MCORE.SC.DT_KEY) present, DT key must contain the device type
identifier from Data Model Device Types and must be encoded as a
variable length decimal ASCII number without leading zeros

- if (MCORE.SC.DN_KEY) present, DN key must be a UTF-8 encoded string
with a maximum length of 32B

|3 | | |Scan for DNS-SD commissioner advertisements from TH |DUT is able
to discover TH
|===

[[_notestesting_considerations_67]]
====== link:#_notestesting_considerations_67[]Notes/Testing considerations

'''''

[[_tc_sc_4_8_compressed_fabric_id_remains_the_same_for_nodes_commissioned_to_the_same_fabric_dut_as_commissioner]]
===== link:#_tc_sc_4_8_compressed_fabric_id_remains_the_same_for_nodes_commissioned_to_the_same_fabric_dut_as_commissioner[]22.4.8. [TC-SC-4.8] Compressed Fabric ID remains the same for Nodes commissioned to the same fabric [DUT as Commissioner]

[[_category_90]]
====== link:#_category_90[]Category

Functional conformance

[[_purpose_91]]
====== link:#_purpose_91[]Purpose

This test case validates the following conditions:

. Nodes on the same fabric has the same compressed fabric ID
. Node removed from fabric and commissioned back to the same fabric has
the same compressed fabric ID

[[_pics_90]]
====== link:#_pics_90[]PICS

* MCORE.ROLE.COMMISSIONER

[[_preconditions_57]]
====== link:#_preconditions_57[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
| | | |
|===

[[_required_devices_90]]
====== link:#_required_devices_90[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissioner
|2 |TH1 |Commissionee
|3 |TH2 |Commissionee
|===

[[_device_topology_44]]
====== link:#_device_topology_44[]Device Topology

TH1, TH2 and DUT are on the same fabric

[[_test_setup_33]]
====== link:#_test_setup_33[]Test Setup

[[_test_procedure_90]]
====== link:#_test_procedure_90[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission TH1 to DUT’s Fabric |Extract the Compressed Fabric ID
assigned from DUT to TH1 and save the value for future use

|2 | | |Commission TH2 to DUT’s Fabric a|
* Extract the Compressed Fabric ID assigned from DUT to TH2 and save the
value for future use
* Verify that the value obtained from TH1 and TH2 are same

|3 | | |Send RemoveFabric from DUT to TH1 and commission DUT to TH1
again |Extract the Compressed Fabric ID assigned from DUT to TH1 and
verify it is same as the value obtained in Step1

|4 | | |Send RemoveFabric from DUT to TH2 and commission DUT to TH2
again |Extract the Compressed Fabric ID assigned from DUT to TH2 and
verify it is same as the value obtained in Step2
|===

[[_notestesting_considerations_68]]
====== link:#_notestesting_considerations_68[]Notes/Testing considerations

'''''

[[_tc_sc_4_9_operational_discovery_rio_support_dut_as_commissionee]]
===== link:#_tc_sc_4_9_operational_discovery_rio_support_dut_as_commissionee[]22.4.9. [TC-SC-4.9] Operational Discovery - RIO support [DUT as Commissionee]

[[_category_91]]
====== link:#_category_91[]Category

Functional conformance

[[_purpose_92]]
====== link:#_purpose_92[]Purpose

This test case validates that RIO (Route Information Options) is
properly processed by Matter nodes.

[[_pics_91]]
====== link:#_pics_91[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.SC.LWIP

[[_preconditions_58]]
====== link:#_preconditions_58[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 |4.2.2 |TH_CR1 is a Commissioner, working over Ethernet or Wi-Fi
transport, able to commission DUT into a given Fabric and implementing
RFC-4191 |

|2 |4.2.2 |TH_CR2 is a Commissioner/Controller Thread 1.3 device (only
on Thread, not on Wi-Fi or Ethernet), joined to the PAN of the BR and
already commissioned on the same Fabric |

|3 |4.2.2 |DUT_CE is a Commissionee Ethernet or Wi-Fi device and
implementing RFC-4191 |

|4 |4.2.2 |DUT_CE will adopt an address on the GUA prefix e.g.
2001:12ab::/64 and use it as default route (::/0) |

|5 |4.2.2 |DUT_CE sees the RA w/ RIO and adds the off-mesh prefix
preferred route, so that any messages for that off-mesh prefix routes
there INSTEAD of the default gateway |

|6 |4.2.2 |BR is a Thread 1.3 border router, with link to DUT over Wi-Fi
or Ethernet, in the same VLAN |

|7 |4.2.2 |RT is a Wi-Fi or Ethernet router advertising a default route
(i,e, against ::/0 prefix) with a GUA prefix advertised. That prefix
MUST also route to the public internet to avoid the different entities
bailing out of having this prefix because it’s an invalid environment
detected to be artificial. |
|===

[[_required_devices_91]]
====== link:#_required_devices_91[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as a Commissioner, working over Ethernet or
Wi-Fi transport,

|2 |TH_CR2 |Test harness as a Commissioner/Controller Thread 1.3 device

|3 |DUT_CE |DUT - Commissionee over Ethernet or Wi-Fi transport

|4 |BR |Thread 1.3 Border Router - This is a passive element

|5 |RT |Wi-Fi or Ethernet Router - This is a passive element
|===

[[_device_topology_45]]
====== link:#_device_topology_45[]Device Topology

TH_CR1 will use to commission DUT_CE. TH_CR2 is on thread network whose
BR is reachable to TH_CR1.

[[_test_setup_34]]
====== link:#_test_setup_34[]Test Setup

[[_test_procedure_91]]
====== link:#_test_procedure_91[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |4.2.2 | |Using TH_CR1, commission the DUT_CE onto the Matter network
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 and is assigned a node
ID1, under TH_CR1’s root of trust. Note the compressed fabric ID and
node ID of DUT_CE post-commissioning for purposes of constructing an
operational service instance name in step 3.

|2 |4.2.2 | |Bring the TH_CR2 onto the thread network |TH_CR2 is on a
thread network whose BR is reachable to TH_CR1

|3 |4.2.2 | |Using TH_CR2, using ICMPv6 echo to ping with a payload >=
32 bytes to the the DUT_CE that is already commissioned to the Matter
network. IP address is determined by operational discovery of the DNS-SD
operational service record (_matter._tcp service instance) of DUT_CE
done by TH_CR2. |Successful ping indicates DUT_CE is reachable from
TH_CR2 and that it can route an echo response via a border router back
to TH_CR2, which is only possible if a preferred route for the
destination was properly handled by DUT_CE by processing of a Route
Information Option within a Router Advertisement previously sent by BR.
|===

[[_notestesting_considerations_69]]
====== link:#_notestesting_considerations_69[]Notes/Testing considerations

'''''

[[_tc_sc_4_10_operational_discovery_sit_icd_node_dut_as_commissionee]]
===== link:#_tc_sc_4_10_operational_discovery_sit_icd_node_dut_as_commissionee[]22.4.10. [TC-SC-4.10] Operational Discovery - SIT ICD Node [DUT as Commissionee]

[[_category_92]]
====== link:#_category_92[]Category

Functional conformance

[[_purpose_93]]
====== link:#_purpose_93[]Purpose

The purpose of this test case is to verify that a Short Idle Time ICD
node properly advertises SAI/SII values. This verification is in
addition any other operational/commissionable discovery test cases.

[[_pics_92]]
====== link:#_pics_92[]PICS

* MCORE.ROLE.COMMISSIONEE
* MCORE.SC.SIT_ICD

[[_preconditions_59]]
====== link:#_preconditions_59[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Nodes are joined in the same Fabric |
|2 | |DUT is a Short Idle Time ICD (MCORE.SC.SIT_ICD) |
|===

[[_required_devices_92]]
====== link:#_required_devices_92[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Matter Node that is advertising a service
|2 |TH |Matter Controller
|===

[[_device_topology_46]]
====== link:#_device_topology_46[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_35]]
====== link:#_test_setup_35[]Test Setup

N/A

[[_test_procedure_92]]
====== link:#_test_procedure_92[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |4.3.2.1 | |DUT is instructed to advertise its service |DUT should
start to advertise its service via DNS-SD

|2 |2.9 | |TH scans for DNS-SD advertising a|
Verify that the TH finds the DUT advertisement.

Verify the DUT advertising for:

- SII key is higher than the SESSION_IDLE_INTERVAL default value (> 300
milliseconds)

- SII key and SAI key is less than 3600000 (1hour in milliseconds)

|===

[[_notestesting_considerations_70]]
====== link:#_notestesting_considerations_70[]Notes/Testing considerations

. Refer to device manufacturer specifications for polling intervals.

'''''

[[_group_communication]]
== link:#_group_communication[]**Group Communication**

[[_pics_definition_7]]
=== link:#_pics_definition_7[]23. PICS Definition

This section covers the Group Communication related PICS items that are
referenced in the following test cases.

[[_role_5]]
==== link:#_role_5[]23.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S |Does the device implement the Groups cluster as a server? |O |

|G.C |Does the device implement the Groups cluster as a client? |O |

|GRPKEY.S |Does the device implement the Group Key Management cluster as
a server? |M |

|GRPKEY.C |Does the device implement the Group Key Management cluster as
a client? |O |
|===

[[_server_5]]
==== link:#_server_5[]23.2. Server

[[_features_3]]
===== link:#_features_3[]23.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S.F00(GN) |Does the DUT(Server) support Group Names feature? |O |

|GRPKEY.S.F00(CS) |Does the DUT(Server) support CacheAndSync security
policy and MCSP feature? |O |
|===

[[_attributes_5]]
===== link:#_attributes_5[]23.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|GRPKEY.S.A0000(GroupKeyMap) |Does the device implement the GroupKeyMap
attribute? |M |

|GRPKEY.S.A0001(GroupTable) |Does the device implement the GroupTable
attribute? |M |

|GRPKEY.S.A0002(MaxGroupsPerFabric) |Does the device implement the
MaxGroupsPerFabric attribute? |M |

|GRPKEY.S.A0003(MaxGroupKeysPerFabric) |Does the device implement the
MaxGroupKeysPerFabric attribute? |M |
|===

[[_commands_received_5]]
===== link:#_commands_received_5[]23.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|GRPKEY.S.C00.Rsp(KeySetWrite) |Does the device implement the
KeySetWrite command}? |M |

|GRPKEY.S.C01.Rsp(KeySetRead) |Does the device implement the KeySetRead
command? |M |

|GRPKEY.S.C03.Rsp(KeySetRemove) |Does the device implement the
KeySetRemove command? |M |

|GRPKEY.S.C04.Rsp(KeySetReadAllIndices) |Does the device implement the
KeySetReadAllIndices command? |M |

|G.S.C00.Rsp(AddGroup) |Does the device implement the AddGroup Command?
|M |

|G.S.C01.Rsp(ViewGroup) |Does the device implement the ViewGroup
Command? |M |

|G.S.C04.Rsp(RemoveAllGroups) |Does the device implement the
RemoveAllGroups Command? |M |
|===

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|GRPKEY.S.C02.Rsp(KeySetReadResponse) |Does the device implement
transmitting of the KeySetReadResponse command? |M |

|GRPKEY.S.C05.Rsp(KeySetReadAllIndicesResponse) |Does the device
implement transmitting of the KeySetReadAllIndicesResponse command? |M |
|===

[[_client_3]]
==== link:#_client_3[]23.3. Client

[[_attributes_6]]
===== link:#_attributes_6[]23.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|GRPKEY.C.A0000(GroupKeyMap) |Does the DUT(client) have access
privileges for the GroupKeyMap attribute implemented on the server? |O |

|GRPKEY.C.A0001(GroupKeyTable) |Does the DUT(client) have access
privileges for the GroupKeyTable attribute implemented on the server? |O
|
|===

[[_commands_generated_5]]
===== link:#_commands_generated_5[]23.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.C.C00.Tx(AddGroup) |Does the DUT(Client) implement sending AddGroup
Command? |O |

|G.C.C01.Tx(ViewGroup) |Does the DUT(Client) implement sending ViewGroup
Command? |O |

|GRPKEY.C.C00.Tx(KeySetWrite) |Does the DUT(Client) implement sending
KeySetWrite Command? |O |

|GRPKEY.C.C01.Tx(KeySetRead) |Does the DUT(Client) implement sending
KeySetRead Command? |O |
|===

[[_pixit_definition_3]]
=== link:#_pixit_definition_3[]24. PIXIT Definition

This section covers the Group Communication related PIXIT items that are
referenced in the following test cases

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.G.ENDPOINT |Endpoint supported for Groups cluster is given by the
DUT Manufacturer |M |
|===

[[_test_case_list_6]]
=== link:#_test_case_list_6[]25. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-GRPKEY-1.1 |Global Attributes with DUT as Server

|TC-GRPKEY-2.1 |Attributes \{DUT-Server}

|TC-GRPKEY-2.2 |Commands - All Commands of Group Key Management Cluster

|TC-SC-5.1 |Adding member to a group - TH as Admin and DUT as Group
Member

|TC-SC-5.2 |Receiving a group message - TH to DUT

|TC-SC-5.3 |Sending a group message - TH to DUT

|TC-GRPKEY-5.4 |Verification for KeySetReadResponse Command for
CacheAndSync

|TC-SC-6.1 |Adding member to a group - DUT as Admin and TH as Group
Member [DUT-Client]
|===

[[_test_cases_6]]
=== link:#_test_cases_6[]26. Test Cases

[[_generic_test_cases_4]]
==== link:#_generic_test_cases_4[]26.1. Generic test cases

[[_tc_grpkey_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_grpkey_1_1_global_attributes_with_dut_as_server[]26.1.1. [TC-GRPKEY-1.1] Global Attributes with DUT as Server

[[_category_93]]
====== link:#_category_93[]Category

Functional conformance

[[_purpose_94]]
====== link:#_purpose_94[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_93]]
====== link:#_pics_93[]PICS

* GRPKEY.S

[[_required_devices_93]]
====== link:#_required_devices_93[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_93]]
====== link:#_test_procedure_93[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the FeatureMap attribute and have
the following bit set:

- bit 0: SHALL be 1 if and only if GRPKEY.S.F00(CS)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x003, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00, 0x01, 0x03 & 0x04

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +
0x02 & 0x05.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_71]]
====== link:#_notestesting_considerations_71[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut]]
==== link:#_server_as_dut[]26.2. Server as DUT

'''''

[[_dut_as_server_4]]
==== link:#_dut_as_server_4[]26.3. DUT as Server

'''''

[[_tc_grpkey_2_1_attributes_dut_server]]
===== link:#_tc_grpkey_2_1_attributes_dut_server[]26.3.1. [TC-GRPKEY-2.1] Attributes [DUT-Server]

[[_category_94]]
====== link:#_category_94[]Category

Functional.

[[_purpose_95]]
====== link:#_purpose_95[]Purpose

This test case verifies the non-global attributes of the
NetworkCommissioning Cluster cluster server.

[[_pics_94]]
====== link:#_pics_94[]PICS

* GRPKEY.S

[[_required_devices_94]]
====== link:#_required_devices_94[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_47]]
====== link:#_device_topology_47[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_36]]
====== link:#_test_setup_36[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_94]]
====== link:#_test_procedure_94[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |CoreSpec-11.2.6.1 |GRPKEY.S.A0000(GroupKeyMap) |TH reads GroupKeyMap
attribute from DUT using a fabric-filtered read. |Verify that TH is able
to read the GroupKeyMap attribute list successfully.

|2 |CoreSpec-11.2.6.1 |GRPKEY.S.A0000(GroupKeyMap) a|
TH binds GroupId 0x0103 with GroupKeySetID 0x01a3 in the GroupKeyMap
attribute list on GroupKeyManagement cluster by writing the GroupKeyMap
attribute with one entry as follows:

List item 1:

GroupId: 0x0103

GroupKeySetId: 0x01a3

|Verify DUT responds w/ status SUCCESS(0x00)

|3 |CoreSpec-11.2.6.1 |GRPKEY.S.A0000(GroupKeyMap) |TH reads GroupKeyMap
Attribute from the GroupKeyManagement cluster from DUT using a
fabric-filtered read. a|
Verify that the returned list contains a a single list item with
structure fields:

GroupId: 0x0103

GroupKeySetId: 0x01a3

|4 |CoreSpec-11.2.7.1 |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT.
GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a3

* GroupKeySecurityPolicy: TrustFirst (0)

* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf

* EpochStartTime0:1

* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf

* EpochStartTime1: 18446744073709551613

* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf

* EpochStartTime2: 18446744073709551614

|Verify DUT responds w/ status SUCCESS(0x00)

|5 |1.3.7.1 |G.S.C00.Rsp(AddGroup) |TH sends AddGroup Command to DUT on
PIXIT.G.ENDPOINT with the the following settings GroupID: 0x0103
GroupName: "Test Group" |Verify that the DUT sends a AddGroupResponse
with the Status set to SUCCESS and the GroupID set to 0x0103

|6 |11.2.6.2 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from GroupKeyManagement cluster on DUT. a|
Verify the returned list has a single item containing a
GroupInfoMapStruct with:

GroupId: 0x0103

Endpoints: [PIXIT.G.ENDPOINT]

GroupName: "Test Group"

|7a |CoreSpec-11.2.6.2 |GRPKEY.S.A0001(GroupTable), G.S.F00(GN) a|
TH attempts to write to the GroupTable attribute from GroupKeyManagement
cluster on DUT with one entry as follows:

GroupId: 0x0104

Endpoints: [PIXIT.G.ENDPOINT]

GroupName: "Test Group2"

|Verify DUT responds w/ status UNSUPPORTED_WRITE(0x88)

|7b |CoreSpec-11.2.6.2 |GRPKEY.S.A0001(GroupTable), !G.S.F00(GN) a|
TH attempts to write to the GroupTable attribute from GroupKeyManagement
cluster on DUT with one entry as follows:

GroupId: 0x0104

Endpoints: [PIXIT.G.ENDPOINT]

GroupName: ""

|Verify DUT responds w/ status UNSUPPORTED_WRITE(0x88)

|8 |CoreSpec-11.2.6.3 |GRPKEY.S.A0002(MaxGroupsPerFabric) |TH reads
MaxGroupsPerFabric attribute from GroupKeyManagement cluster on DUT
using a fabric-filtered read. |Verify the MaxGroupsPerFabric attribute,
Value has to be between a range of [min=0, max=65535].

|9 |CoreSpec-11.2.6.3 |GRPKEY.S.A0002(MaxGroupsPerFabric) |TH attempts
to write MaxGroupsPerFabric attribute of GroupKeyManagement cluster to
the same value as read in step 9. |Verify DUT responds w/ status
UNSUPPORTED_WRITE(0x88)

|10 |CoreSpec-11.2.6.4 |GRPKEY.S.A0003(MaxGroupKeysPerFabric) |TH reads
MaxGroupKeysPerFabric attribute from GroupKeyManagement cluster on DUT
using a fabric-filtered read. |Verify that the value is within the range
from 1 to 65535.

|11 |CoreSpec-11.2.6.4 |GRPKEY.S.A0003(MaxGroupKeysPerFabric) |TH
attempts to write MaxGroupKeysPerFabric attribute of GroupKeyManagement
cluster on DUT to the same value as read in step 11. |Verify DUT
responds w/ status UNSUPPORTED_WRITE(0x88)

|12 |1.3.7.5 |G.S.C04.Rsp(RemoveAllGroups) |TH cleans up the groups by
sending the RemoveAllGroups command to the DUT on PIXIT.G.ENDPOINT
|Verify DUT responds w/ status SUCCESS(0x00)
|===

[[_notestesting_considerations_72]]
====== link:#_notestesting_considerations_72[]Notes/Testing Considerations

This test checks for attribute values in basic ranges. The Resource
Requirement test (TC-RR-1.1) will test that the minimum values are set
correctly based on the device requirements.

[[_tc_grpkey_2_2_primary_functionality_with_dut_as_server]]
===== link:#_tc_grpkey_2_2_primary_functionality_with_dut_as_server[]26.3.2. [TC-GRPKEY-2.2] Primary functionality with DUT as Server

[[_category_95]]
====== link:#_category_95[]Category

Functional.

[[_purpose_96]]
====== link:#_purpose_96[]Purpose

This test case verifies the primary functionality of the
NetworkCommissioning Cluster cluster server.

[[_pics_95]]
====== link:#_pics_95[]PICS

* GRPKEY.S

[[_required_devices_95]]
====== link:#_required_devices_95[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_48]]
====== link:#_device_topology_48[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_37]]
====== link:#_test_setup_37[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_95]]
====== link:#_test_procedure_95[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.3.6.1 |GRPKEY.S.A0003(MaxGroupKeysPerFabric) |TH reads
MaxGroupKeysPerFabric attribute from GroupKeyManagement cluster on DUT
using a fabric-filtered read. Save the value as Max_GrpKey for future
use. |

|2 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2:18446744073709551614

|Verify DUT responds w/ status SUCCESS(0x00)

|3 |CoreSpec-11.2.5.1. |GRPKEY.S.C01.Rsp(KeySetRead) a|
TH sends KeySetRead command to GroupKeyManagement cluster with
GroupKeySetID as 0x01a

a|
* Verify that EpochKey fields are replaced by null.
* Verify that EpochStartTime values matches the values sent in step 2
* Verify that the DUT sends a KeySetReadResponse with the GroupKeySet
having the following fields:

GroupKeySetID: 0x01a

GroupKeySecurityPolicy: TrustFirst (0)

EpochKey0: null

EpochStartTime0: 1

EpochKey1: null

EpochStartTime1: 18446744073709551613

EpochKey2: null

EpochStartTime2: 18446744073709551614

|4 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: null
* EpochStartTime1: null
* EpochKey2: null
* EpochStartTime2: null
+
** Note: EpochKey1 and EpochKey2 are null

|Verify DUT responds w/ status SUCCESS(0x00)

|5 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: null
* EpochStartTime2: null
+
** Note: Only EpochKey2 is null

|Verify DUT responds w/ status SUCCESS(0x00)

|6 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with command fields as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: null
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 18446744073709551614
+
** Note: EpochKey0 is null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|7 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: null
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 18446744073709551614
+
** Note: EpochStartTime0 is null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|8 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 0
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2:18446744073709551614
+
** Note: EpochStartTime0 is set to 0

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|9 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: null
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2:18446744073709551614
+
** Note: EpochKey1 is set to null and EpochStartTime1 is not null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|10 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: null
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2:18446744073709551614
+
** Note: EpochKey1 is not null and EpochStartTime1 is null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|11 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 18446744073709551613
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 1
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 18446744073709551614
+
** Note: EpochStartTime1 is earlier than EpochStartTime0

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|12 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: null
* EpochStartTime1: null
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 18446744073709551614
+
** Note: EpochKey1 and EpochStartTime1 are null when EpochKey2 and
EpochStartTime2 are not null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|13 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: null
* EpochStartTime2: 18446744073709551614
+
** Note: EpochKey2 is set to null and EpochStartTime2 is not null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|14 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: null
+
** Note: EpochKey2 is not null and EpochStartTime2 is null

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|15 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 1
+
** Note: EpochStartTime2 is earlier than EpochStartTime1

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|[#KeySetWrite]####16 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite)
a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields are as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 1
+
** Note1: Repeat the step by sending EpochKey1 and EpochKey2 with 1 byte
value (< 16 bytes)

|Verify TH responds w/ status CONSTRAINT_ERROR(0x87)

|16a |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
Repeat step link:#KeySetWrite[16] by sending KeySetWrite Command with
EpochKey0, EpochKey1 and EpochKey2 having 15 bytes value (< 16 byte)

|Verify TH responds w/ status CONSTRAINT_ERROR(0x87)

|16b |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
Repeat step link:#KeySetWrite[16] by sending KeySetWrite Command with
EpochKey0, EpochKey1 and EpochKey2 having 17 bytes value (> 16 bytes)

|Verify TH responds w/ status CONSTRAINT_ERROR(0x87)

|17 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 with GroupKeySet fields as follows:

* GroupKeySetID: 0x01a
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d3d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d4d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 17446744073709551613
* EpochKey2: d5d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 17446744073709551614
+
** Note: KeySetWrite command is sent with different
EpochKeys,EpochStartTime1 and EpochStartTime2 values

|Verify DUT responds w/ status SUCCESS(0x00)

|18 |CoreSpec-11.2.5.1. |GRPKEY.S.C01.Rsp(KeySetRead) a|
TH sends KeySetRead command to GroupKeyManagement cluster with
GroupKeySetID as 0x01a

a|
* Verify that EpochStartTime values matches the values sent in the
previous step
* Verify that the DUT sends a KeySetReadResponse with the GroupKeySet
having the following fields:

GroupKeySetID: 0x01a

GroupKeySecurityPolicy: TrustFirst (0)

EpochKey0: null

EpochStartTime0: 1

EpochKey1: null

EpochStartTime1: 17446744073709551613

EpochKey2: null

EpochStartTime2: 17446744073709551614

|19 |CoreSpec-11.2.5.1. |GRPKEY.S.C01.Rsp(KeySetRead) a|
TH sends KeySetRead command to GroupKeyManagement cluster with
GroupKeySetID as 0x01b that does not exist in the GroupKeyMap attribute
list.

a|
Verify DUT responds w/ status NOT_FOUND(0x8b)

|20 |CoreSpec-11.2.5.1. |GRPKEY.S.C03.Rsp(KeySetRemove) a|
TH removes the Group key set that was added by sending a KeySetRemove
command to the GroupKeyManagement cluster with the GroupKeySetID field
set to 0x01a.

|Verify DUT responds w/ status SUCCESS(0x00)

|21 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) |TH sends
KeySetWrite command to DUT until size of list for TH’s fabric in
GroupKeyMap attribute contains Max_GrpKey entries, starting with
GroupKeySetID 1 and incrementing by 1 each time. |Verify that the DUT
sends SUCCESS response

|23 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) |TH again sends
KeySetWrite command to DUT with any other GroupKeySetID not used yet.
|Verify DUT responds w/ status RESOURCE_EXHAUSTED(0x89)

|24 |CoreSpec-11.2.5.1. |GRPKEY.S.C05.Rsp(KeySetReadAllIndicesResponse)
|TH sends KeySetReadAllIndices command to DUT. a|
Verify that DUT sends KeySetReadAllIndicesResponse Command with
Max_GrpKey number of GroupKeySetID as follows:

[1]: 2

[2]: 1

[3]: 0

|22 |CoreSpec-11.2.5.1. |GRPKEY.S.C03.Rsp(KeySetRemove) a|
TH removes the Group key set that was added by sending a KeySetRemove
command to the GroupKeyManagement cluster with the GroupKeySetID field
set to 0x0

|Verify DUT responds w/ status INVALID_COMMAND(0x85)

|23 |CoreSpec-11.2.5.1. |GRPKEY.S.C03.Rsp(KeySetRemove) a|
TH removes the Group key set that was added by sending a KeySetRemove
command to the GroupKeyManagement cluster with the GroupKeySetID field
set to 0x01b that does not exist in the GroupKeyMap attribute list.

|Verify DUT responds w/ status NOT_FOUND(0x8b)
|===

[[_tc_sc_5_1_adding_member_to_a_group_th_as_admin_and_dut_as_group_member]]
===== link:#_tc_sc_5_1_adding_member_to_a_group_th_as_admin_and_dut_as_group_member[]26.3.3. [TC-SC-5.1] Adding member to a group - TH as Admin and DUT as Group Member

[[_category_96]]
====== link:#_category_96[]Category

Functional conformance

[[_purpose_97]]
====== link:#_purpose_97[]Purpose

To verify that GroupKeySets and Groups can be added and removed from DUT

[[_pics_96]]
====== link:#_pics_96[]PICS

* GRPKEY.S
* G.S

[[_precondition_4]]
====== link:#_precondition_4[]Precondition

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |CoreSpec-5.5 |DUT is commissioned by TH |
|===

[[_required_devices_96]]
====== link:#_required_devices_96[]Required Devices

[width="100%",cols="5%,10%,85%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness
|2 |DUT |Device Under Test
|===

[[_device_topology_49]]
====== link:#_device_topology_49[]Device Topology

DUT is commissioned to a single fabric by TH.

[[_test_setup_38]]
====== link:#_test_setup_38[]Test Setup

[[_test_procedure_96]]
====== link:#_test_procedure_96[]Test Procedure

[width="100%",cols="5%,10%,5%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |CoreSpec-9.10.5.3 | a|
TH writes the ACL attribute in the Access Control cluster to add Operate
privileges for group 0x0103 and maintain the current administrative
privileges for the TH. The following access control list shall be used:

* List item 1 (TH admin):
+
** Privilege: Administer (5)
** AuthMode: CASE (2)
** Subjects: TH node id ([`N1`])
** Targets: all (null)
* List item 2 (group operate access):
+
** Privilege: Operate (3)
** AuthMode: Group (3)
** Subjects: group 0x0103 ([0x0103])
** Targets: all (null)

|Verify DUT responds w/ status SUCCESS(0x00)

|2a |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is NOT installed on the TH. This is intended to test
that the key set is correctly updated in the next step. GroupKeySet
fields are as follows:

* GroupKeySetID: 0x01a3
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: 00000000000000000000000000000001
* EpochStartTime0: 111
* EpochKey1: 00000000000000000000000000000002
* EpochStartTime1: 222
* EpochKey2: 00000000000000000000000000000003
* EpochStartTime2: 333

|Verify DUT responds w/ status SUCCESS(0x00)

|2b |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a3
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 18446744073709551614

|Verify DUT responds w/ status SUCCESS(0x00)

|3 |CoreSpec-11.2.7.2 |GRPKEY.S.A0000(GroupKeyMap) a|
TH binds GroupId 0x0103 with GroupKeySetID 0x01a3 in the GroupKeyMap
attribute list on GroupKeyManagement cluster by writing the GroupKeyMap
attribute with one entry as follows:

* List item 1:
+
** GroupId: 0x0103
** GroupKeySetId: 0x01a3

|Verify DUT responds w/ status SUCCESS(0x00)

|4 |appclusters-1.3.7.5 |G.S.C04.Rsp(RemoveAllGroups) |TH sends
RemoveAllGroups command to the DUT on PIXIT.G.ENDPOINT |Verify that the
DUT sends SUCCESS response

|[#add-group]####5 |appclusters-1.3.6.1 |G.S.C00.Rsp(AddGroup) a|
TH sends AddGroup Command to DUT on PIXIT.G.ENDPOINT with the the
following settings

* GroupID: 0x0103
* GroupName: "Test Group"

|Verify that the DUT sends a AddGroupResponse with the Status set to
SUCCESS and the GroupID set to 0x0103

|6a |appclusters-1.3.7.2 |G.S.F00(GN),G.S.C01.Rsp(ViewGroup) |TH sends
ViewGroup command with the GroupID to the Group cluster on the DUT on
PIXIT.G.ENDPOINT a|
Verify DUT sends a ViewGroupResponse command with

* Status: SUCCESS
* GroupID: 0x0103
* GroupName: "Test Group"

|6b |appclusters-1.3.7.2 |!G.S.F00(GN),G.S.C01.Rsp(ViewGroup) |TH sends
ViewGroup command with the GroupID to the Group cluster on the DUT on
PIXIT.G.ENDPOINT a|
Verify DUT sends a ViewGroupResponse command with

* Status: SUCCESS
* GroupID: 0x0103
* GroupName: ""

|7 |CoreSpec-11.2.5.2 |GRPKEY.S.C01.Rsp(KeySetRead) |TH sends KeySetRead
command to GroupKeyManagement cluster with GroupKeySetID as 0x01a3 a|
Verify that the DUT sends a KeySetReadResponse with the GroupKeySet
having the following fields:

* GroupKeySetID: 0x01a3
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: null
* EpochStartTime0:1
* EpochKey1: null
* EpochStartTime1:18446744073709551613
* EpochKey2: null
* EpochStartTime2:18446744073709551614

|8 | |GRPKEY.S.A0000(GroupKeyMap) |TH reads GroupKeyMap Attribute from
the GroupKeyManagement cluster from DUT a|
Verify that the returned list contains a a single list item with
structure fields

* GroupId: 0x0103
* GroupKeySetId: 0x01a3

|9a |CoreSpec-11.2.7.3 |G.S.F00(GN),GRPKEY.S.A0001(GroupTable) |TH reads
GroupTable attribute from GroupKeyManagement cluster on DUT using a
fabric-filtered read. a|
Verify the returned list has a single item containing a
GroupInfoMapStruct with:

* GroupId: 0x0103
* Endpoints: [PIXIT.G.ENDPOINT]
* GroupName: "Test Group"

|9b |CoreSpec-11.2.7.3 |!G.S.F00(GN),GRPKEY.S.A0001(GroupTable) |TH
reads GroupTable attribute from GroupKeyManagement cluster on DUT using
a fabric-filtered read. a|
Verify the returned list has a single item containing a
GroupInfoMapStruct with:

* GroupId: 0x0103
* Endpoints: [PIXIT.G.ENDPOINT]
* GroupName: ""

|[#remove-key-set]####10 |CoreSpec-11.2.9.4
|GRPKEY.S.C03.Rsp(KeySetRemove) |TH removes the Group key set that was
added by sending a KeySetRemove command to the GroupKeyManagement
cluster with the GroupKeySetID field set to 0x01a3 |Verify that the DUT
sends SUCCESS response

|11 |CoreSpec-11.2.9.4 |GRPKEY.S.A0000(GroupKeyMap) |TH verifies that
the key set removal in step link:#remove-key-set[10] also removed the
corresponding entries in the GroupKeyMap by Reading the GroupKeyMap
attribute from the GroupKeyManagement cluster using a fabric-filtered
read. |Verify that the returned list contains no items

|12 |appclusters-1.3.7.5 |G.S.C04.Rsp(RemoveAllGroups) |TH cleans up the
groups by sending the RemoveAllGroups command to the DUT on
PIXIT.G.ENDPOINT |Verify that the DUT sends SUCCESS response

|13 |CoreSpec-11.2.7.3 |GRPKEY.S.A0001(GroupTable) |TH reads verifies
the group has been removed by reading the GroupTable attribute from
GroupKeyManagement cluster on DUT using a fabric-filtered read. |Verify
the returned list is empty

|14 |CoreSpec-9.10.5.3 | a|
TH writes the ACL attribute in the Access Control cluster to remove
Operate privileges for group 0x0103 and maintain the current
administrative privileges for the TH. The following access control list
shall be used:

* List item 1 (TH admin):
+
** Privilege: Administer (5)
** AuthMode: CASE (2)
** Subjects: TH node id ([`N1`])
** Targets: all (null)

|Verify DUT responds w/ status SUCCESS(0x00)
|===

[[_tc_sc_5_2_receiving_a_group_message_th_to_dut]]
===== link:#_tc_sc_5_2_receiving_a_group_message_th_to_dut[]26.3.4. [TC-SC-5.2] Receiving a group message - TH to DUT

[[_category_97]]
====== link:#_category_97[]Category

Functional conformance

[[_purpose_98]]
====== link:#_purpose_98[]Purpose

To verify that the DUT can receive group message sent by TH.

[[_pics_97]]
====== link:#_pics_97[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_precondition_5]]
====== link:#_precondition_5[]Precondition

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |CoreSpec-5.5 |DUT and TH are commissioned |
|===

[[_required_devices_97]]
====== link:#_required_devices_97[]Required Devices

[width="100%",cols="9%,16%,75%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness with node ID `N1`
|2 |DUT |DUT
|===

[[_device_topology_50]]
====== link:#_device_topology_50[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_39]]
====== link:#_test_setup_39[]Test Setup

[[_test_procedure_97]]
====== link:#_test_procedure_97[]Test Procedure

[width="100%",cols="5%,10%,5%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |CoreSpec-9.10.5.3 | a|
TH writes the ACL attribute in the Access Control cluster to add Manage
privileges for group 0x0103 and maintain the current administrative
privileges for the TH. The following access control list shall be used:

* List item 1 (TH admin):
+
** Privilege: Administer (5)
** AuthMode: CASE (2)
** Subjects: TH node id ([`N1`])
** Targets: all (null)
* List item 2 (group operate access):
+
** Privilege: Manage (4)
** AuthMode: Group (3)
** Subjects: group 0x0103 ([0x0103])
** Targets: all (null)

|Verify that the DUT sends SUCCESS response.

|2 |CoreSpec-11.2.5.1. |GRPKEY.S.C00.Rsp(KeySetWrite) a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a3
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0:1
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 18446744073709551613
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 18446744073709551614

|Verify DUT responds w/ status SUCCESS(0x00)

|3 |CoreSpec-11.2.7.2 |GRPKEY.S.A0000(GroupKeyMap) a|
TH binds GroupId 0x0103 and 0x0101 with GroupKeySetID 0x01a3 in the
GroupKeyMap attribute list on GroupKeyManagement cluster by writing the
GroupKeyMap attribute with 2 entries as follows:

* List item 1:
+
** GroupId: 0x0103
** GroupKeySetId: 0x01a3
* List item 2:
+
** GroupId: 0x0101
** GroupKeySetId: 0x01a3

|Verify that the DUT sends SUCCESS response.

|4 |appclusters-1.3.7.5 |G.S.C04.Rsp(RemoveAllGroups) |TH cleans up the
groups by sending the RemoveAllGroups command to the DUT on
PIXIT.G.ENDPOINT |Verify DUT responds w/ status SUCCESS(0x00)

|5 |appclusters-1.3.6.1 |G.S.C00.Rsp(AddGroup) a|
TH sends AddGroup Command to DUT on PIXIT.G.ENDPOINT with the the
following settings

* GroupID: 0x0103
* GroupName: "Test Group 0103"

|Verify that the DUT sends a AddGroupResponse with the Status set to
SUCCESS and the GroupID set to 0x0103

|6 |appclusters-1.3.6.1 |G.S.C00.Rsp(AddGroup) a|
TH sends a AddGroup Command to the Groups cluster with the GroupID field
set to 0x0101 and the GroupName set to an "Test Group 0101". The command
is sent as a group command using GroupID 0x0103

|

|7 |appclusters-1.3.7.2 |G.S.F00(GN), G.S.C01.Rsp(ViewGroup) |TH sends a
ViewGroup Command to the Groups cluster on Endpoint PIXIT.G.ENDPOINT
over CASE with the GroupID set to 0x0101 to confirm that the AddGroup
command from step 6 was successful a|
Verify DUT sends a ViewGroupResponse command with * Status: SUCCESS *
GroupID: 0x0101 * GroupName: "Test Group 0101"

|8 |appclusters-1.3.7.2 |!G.S.F00(GN), G.S.C01.Rsp(ViewGroup) |TH sends
a ViewGroup Command to the Groups cluster on Endpoint PIXIT.G.ENDPOINT
over CASE with the GroupID set to 0x0101 to confirm that the AddGroup
command from step 6 was successful a|
Verify DUT sends a ViewGroupResponse command with * Status: SUCCESS *
GroupID: 0x0101 * GroupName: ""

|9 |CoreSpec-11.2.9.4 |GRPKEY.S.C03.Rsp(KeySetRemove) |TH removes the
Group key set that was added by sending a KeySetRemove command to the
GroupKeyManagement cluster with the GroupKeySetID field set to 0x01a3
|Verify that the DUT sends SUCCESS response

|10 |appclusters-1.3.7.5 |G.S.C04.Rsp(RemoveAllGroups) |TH cleans up the
groups by sending the RemoveAllGroups command to the DUT on
PIXIT.G.ENDPOINT |Verify that the DUT sends SUCCESS response

|11 |CoreSpec-9.10.5.3 | a|
TH writes the ACL attribute in the Access Control cluster to remove
Manage privileges for group 0x0103 and maintain the current
administrative privileges for the TH. The following access control list
shall be used:

* List item 1 (TH admin):
+
** Privilege: Administer (5)
** AuthMode: CASE (2)
** Subjects: TH node id ([`N1`])
** Targets: all (null)

|Verify that the DUT sends SUCCESS response.
|===

[[_tc_sc_5_3_sending_a_group_message_dut_to_th]]
===== link:#_tc_sc_5_3_sending_a_group_message_dut_to_th[]26.3.5. [TC-SC-5.3] Sending a group message - DUT to TH

[[_category_98]]
====== link:#_category_98[]Category

Functional conformance

[[_purpose_99]]
====== link:#_purpose_99[]Purpose

To verify that the DUT can send group message to TH and validate the
Group Message received by TH.

[[_pics_98]]
====== link:#_pics_98[]PICS

* MCORE.ROLE.COMMISSIONER
* GRPKEY.C

[[_precondition_6]]
====== link:#_precondition_6[]Precondition

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |CoreSpec-5.5 |DUT and TH are commissioned. |
|2 | |DUT supports Groups Cluster |
|===

[[_required_devices_98]]
====== link:#_required_devices_98[]Required Devices

[width="100%",cols="9%,16%,75%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_51]]
====== link:#_device_topology_51[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_40]]
====== link:#_test_setup_40[]Test Setup

[[_test_procedure_98]]
====== link:#_test_procedure_98[]Test Procedure

[width="100%",cols="5%,10%,5%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a | | |TH should have the ACL entry with the AuthMode as Group by DUT
|

|1b | | a|
* DUT generates fabric-unique GroupID, GroupName, random key, EpochKey0
and GroupKeySetID.
* Save the GroupID as GroupID_1, GroupName as GroupName_1 and
GroupSetID_1

|

|2 |CoreSpec-11.2.5.1. |GRPKEY.C.C00.Tx(KeySetWrite) a|
DUT sends KeySetWrite command to GroupKeyManagement cluster to TH on EP0

a|
Test Harness receives the KeySetWrite command from the DUT.

|3 |CoreSpec-11.2.5.1 |GRPKEY.C.A0000(GroupKeyMap) |DUT binds GroupId
with GroupKeySetID in the GroupKeyMap attribute list on
GroupKeyManagement cluster a|
Test Harness receives the binding of GroupKeySetID with the GroupID from
DUT

|4 |appclusters-1.3.6.1 |G.C.C00.Tx(AddGroup) a|
DUT sends AddGroup Command to DUT on EP0 with the the following settings

* GroupID: GroupID_1
* GroupName: GroupName_1

a|
Test Harness receives the AddGroup command from the DUT

|5 | | a|
* DUT generates fabric-unique GroupID, GroupName.
* Save the GroupID as GroupID_2, GroupName as GroupName_2

|

|6 |appclusters-1.3.6.1 |G.C.C00.Tx(AddGroup) a|
DUT sends a AddGroup Command to the Groups cluster with the GroupID
field set to GroupID_2 and the GroupName set to an GroupName_2. The
command is sent as a group command using GroupID_1

a|
Validate the group message received from DUT:

* Verify that the IPv6 Destination Multicast address follows the format
"FF35:0040:FD<Fabric ID>00:<Group ID>
* Verify the UDP port is 5540
* Verify the DSIZ flag is set to group
* Verify the Destination Node ID matches the GroupID_1

|===

[[_notestesting_considerations_73]]
====== link:#_notestesting_considerations_73[]Notes/Testing considerations

In the above test case Groups cluster is used for testing the multicast
message. Any other cluster like Identify can also be used depending on
the DUT capability.

[[_tc_grpkey_5_4_verification_for_keysetreadresponse_command_for_cacheandsync]]
===== link:#_tc_grpkey_5_4_verification_for_keysetreadresponse_command_for_cacheandsync[]26.3.6. [TC-GRPKEY-5.4] Verification for KeySetReadResponse Command for CacheAndSync

[[_category_99]]
====== link:#_category_99[]Category

Functional conformance

[[_purpose_100]]
====== link:#_purpose_100[]Purpose

To verify that the DUT sends the correct KeySetReadResponse command for
CacheAndSync

[[_pics_99]]
====== link:#_pics_99[]PICS

* GRPKEY.S

[[_precondition_7]]
====== link:#_precondition_7[]Precondition

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |CoreSpec-5.5 |Group Member is commissioned with Admin |
|===

[[_required_devices_99]]
====== link:#_required_devices_99[]Required Devices

[width="100%",cols="5%,10%,85%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Admin
|2 |DUT |Device Under Test as GM-Group Member
|===

[[_device_topology_52]]
====== link:#_device_topology_52[]Device Topology

DUT and Admin are on the same fabric.

[[_test_setup_41]]
====== link:#_test_setup_41[]Test Setup

[[_test_procedure_99]]
====== link:#_test_procedure_99[]Test Procedure

[width="100%",cols="5%,10%,5%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |CoreSpec-11.2.5.1. |!GRPKEY.S.F00(CS),GRPKEY.S.C00.Rsp(KeySetWrite)
a|
* Admin sends KeySetWrite command by setting GroupKeySecurityPolicy to
CacheAndSync to GroupKeyManagement cluster on the DUT
* Note: KeySetWrite command is sent by setting the following fields to
the corresponding values. Values given below are for reference purpose.
+
. groupKeySetID: 0x01a3
. groupKeySecurityPolicy: CacheAndSync (1)
. epochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
. epochStartTime0: 0
. epochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
. epochStartTime1: 2220001
. epochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
. epochStartTime2: 2220002

a|
Verify that the DUT sends INVALID_COMMAND response as CacheAndSync is
not supported.

|2 |CoreSpec-11.2.5.1. |GRPKEY.S.F00(CS) ,GRPKEY.S.C00.Rsp(KeySetWrite)
a|
Admin sends KeySetWrite command by setting the values as given in Step 1

a|
Verify that the DUT sends SUCCESS response as CacheAndSync is supported

|3 | |GRPKEY.F00(CS),GRPKEY.S.A0000(GroupKeyMap) |Admin maps GroupId
0x0103 with GroupKeySetID 0x01a3 in the GroupKeyMap attribute list on
GroupKeyManagement cluster on the DUT a|
Verify DUT responds w/ status SUCCESS(0x00)

|4 |CoreSpec-11.2.6.2 |GRPKEY.S.F00(CS),GRPKEY.S.C01.Rsp(KeySetRead)
|Admin sends KeySetRead Command to DUT a|
* Verify that the DUT sends a KeySetReadResponse Command with the
GroupKeySetStructure.
* Verify that GroupKeySetStructure has GroupKeySecurityPolicy value set
to CacheAndSync (1)

|===

[[_client_as_dut]]
==== link:#_client_as_dut[]26.4. Client as DUT

[[_tc_sc_6_1_adding_member_to_a_group_dut_as_admin_and_th_as_group_member_dut_client]]
===== link:#_tc_sc_6_1_adding_member_to_a_group_dut_as_admin_and_th_as_group_member_dut_client[]26.4.1. [TC-SC-6.1] Adding member to a group - DUT as Admin and TH as Group Member [DUT-Client]

[[_category_100]]
====== link:#_category_100[]Category

Functional conformance

[[_purpose_101]]
====== link:#_purpose_101[]Purpose

To verify that the TH can be added to a group by DUT

[[_pics_100]]
====== link:#_pics_100[]PICS

* MCORE.ROLE.COMMISSIONER
* GRPKEY.C

[[_precondition_8]]
====== link:#_precondition_8[]Precondition

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |CoreSpec-5.5 |Group Member is commissioned with Admin |
|2 | |DUT supports Groups Cluster |
|===

[[_required_devices_100]]
====== link:#_required_devices_100[]Required Devices

[width="100%",cols="5%,10%,85%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as GM-Group Member
|2 |DUT |Device Under Test as Admin
|===

[[_device_topology_53]]
====== link:#_device_topology_53[]Device Topology

DUT and TH are on the same fabric.

[[_test_setup_42]]
====== link:#_test_setup_42[]Test Setup

[[_test_procedure_100]]
====== link:#_test_procedure_100[]Test Procedure

[width="100%",cols="5%,10%,20%,35%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a | | |TH should have the ACL entry with the AuthMode as Group by DUT
|

|1b | | a|
* DUT generates fabric-unique GroupID, GroupName, random key, EpochKey0
and GroupKeySetID.
* Admin sets GroupKeySecurityPolicy = TrustFirst (0) EpochStartTime0 = 0

|

|2 |CoreSpec-11.2.5.1. |GRPKEY.C.C00.Tx(KeySetWrite) a|
DUT sends KeySetWrite command to GroupKeyManagement cluster to TH on EP0

a|
Test Harness receives the KeySetWrite command from the DUT.

|3 |CoreSpec-11.2.5.1 |GRPKEY.C.A0000(GroupKeyMap) |DUT binds GroupID
with GroupKeySetID in the GroupKeyMap attribute list on
GroupKeyManagement cluster a|
Test Harness receives the binding of GroupKeySetID with the GroupID from
DUT

|4 |appclusters-1.3.6.1 |G.C.C00.Tx(AddGroup) |DUT sends AddGroup
Command to TH on EP0 a|
Test Harness receives the AddGroup command from the DUT

|5 |appclusters-1.3.7.2 |G.C.C01.Tx(ViewGroup) |DUT sends ViewGroup
command with the GroupID and GroupName to the Group cluster on the TH on
EP0 a|
Test Harness receives the ViewGroup command from the DUT

|6 |CoreSpec-11.2.5.2 |GRPKEY.C.C01.Tx(KeySetRead) |DUT sends KeySetRead
Command to TH a|
Test Harness receives the KeySetRead command from the DUT

|7 | |GRPKEY.C.A0000(GroupKeyMap) |DUT reads GroupKeyMap Attribute from
the GroupKeyManagement cluster from TH a|
Verify that DUT reads GroupKeyMap attribute from the TH successfully

|8 | |GRPKEY.C.A0001(GroupTable) |DUT reads GroupTable attribute from
GroupKeyManagement cluster on TH a|
Verify that DUT reads GroupTable attribute from the TH successfully

|===

[[_device_attestation_test_plan]]
== link:#_device_attestation_test_plan[]**Device Attestation Test Plan**

[[_pics_definition_8]]
=== link:#_pics_definition_8[]27. PICS Definition

This section covers the Door Lock Cluster related PICS items that are
referenced in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.DA.ATTEST_WARNING |Does Commissioner notify user that
Commissionee is not a fully trusted device on device attestation
failure? |O |

|MCORE.DA.CERTDECL_ORIGIN_VENDORID |Does commissionee-provided
certification declaration make use of dac_origin_vendor_id field? |O |

|MCORE.DA.CERTDECL_ORIGIN_PRODUCTID |Does commissionee-provided
certification declaration make use of dac_origin_product_id field? |O |

|MCORE.DA.CERTDECL_AUTH_PAA |Does commissionee-provided certification
declaration make use of authorized_paa_list field? |O |

|MCORE.DA.ATTESTELEMENT_FW_INFO |Does commissionee provide a Firmware
Information field in the AttestationResponse? |O |
|===

[[_test_case_list_7]]
=== link:#_test_case_list_7[]28. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-DA-1.1 |The NOC SHALL be wiped on Factory Reset [DUT-Commissionee]

|TC-DA-1.2 |Device Attestation Request Validation [DUT-Commissionee]

|TC-DA-1.3 |Device Attestation Request Validation [DUT-Commissioner]

|TC-DA-1.4 |Device Attestation Request Validation-Error Scenario
[DUT-Commissioner]

|TC-DA-1.5 |NOCSR Procedure Validation [DUT-Commissionee]

|TC-DA-1.6 |NOCSR Procedure Validation [DUT-Commissioner]

|TC-DA-1.7 |Validate CertificateChainRequest [DUT-Commissionee]

|TC-DA-1.8 |Device Attestation Request Validation-Success Scenario
[DUT-Commissioner]
|===

[[_test_cases_7]]
=== link:#_test_cases_7[]29. Test Cases

[[_server_as_dut_2]]
==== link:#_server_as_dut_2[]29.1. Server as DUT

[[_tc_da_1_1_the_noc_shall_be_wiped_on_factory_reset_dut_commissionee]]
===== link:#_tc_da_1_1_the_noc_shall_be_wiped_on_factory_reset_dut_commissionee[]29.1.1. [TC-DA-1.1] The NOC SHALL be wiped on Factory Reset [DUT - Commissionee]

[[_category_101]]
====== link:#_category_101[]Category

Functional conformance

[[_purpose_102]]
====== link:#_purpose_102[]Purpose

This test case validates the following condition:

. NOCs attribute gets deleted on the DUT after factory reset.

[[_pics_101]]
====== link:#_pics_101[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_25]]
====== link:#_pre_conditions_25[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT Commissioned to TH1’s fabric |
|2 | |DUT Supports Factory Reset Method |
|===

[[_required_devices_101]]
====== link:#_required_devices_101[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Commissioner
|===

[[_device_topology_54]]
====== link:#_device_topology_54[]Device Topology

DUT will be commissioned in a Fabric 1 with TH1 and a Fabric 2 with TH2.
These are separate fabrics.

[[_test_setup_43]]
====== link:#_test_setup_43[]Test Setup

[[_test_procedure_101]]
====== link:#_test_procedure_101[]Test Procedure

[width="100%",cols="6%,16%,12%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH1’s Fabric |

|2a |11.17.6.1 | |TH1 does a non-fabric filtered read of the `NOCs`
attribute from the Node Operational Credentials cluster and saves the
returned list as `noc_th1` |Verify that there is a single entry in the
list

|2b |11.17.6.2 | |TH1 does a non-fabric-filtered read of the `Fabrics`
attribute from the Node Operational Credentials cluster |Verify that
there is a single entry in the list and the FabricID for that entry
matches the FabricID for TH1

|3 | |MCORE.UI.FACTORYRESET a|
* Factory reset DUT and perform the necessary actions to put the DUT
into a commissionable state

|

|4 | | |Commission DUT to TH2’s Fabric |

|5 |11.17.6 | |TH2 does a non-fabric-filtered read of `Fabrics`
attribute list from DUT a|
* Verify that there is only one entry in the 'Fabrics' List
* Verify that the FabricID is the same as the TH2’s Fabric ID
* Verify that the entry saved in Step 2 for TH1' Fabric does not appear
in the list

|6 |11.17.6 | |TH2 does a non-fabric-filtered read of `NOCs` attribute
list from DUT a|
* Verify that there is only one entry in the 'NOCs' List and the NOC for
that entry is different than the NOC entry in `noc_th1`

|===

[[_tc_da_1_2_device_attestation_request_validation_dut_commissionee]]
===== link:#_tc_da_1_2_device_attestation_request_validation_dut_commissionee[]29.1.2. [TC-DA-1.2] Device Attestation Request Validation [DUT - Commissionee]

[[_category_102]]
====== link:#_category_102[]Category

Functional conformance

[[_purpose_103]]
====== link:#_purpose_103[]Purpose

To verify the following during the Device Attestation procedure:

. DUT responds with correct AttestationResponse upon receiving
AttestationRequest Command with AttestationNonce from TH1
. DUT-generated AttestationResponse Information is valid and sent
through AttestationResponse Command to TH1
. DUT does not accept invalid AttestationNonce sent by TH1

[[_pics_102]]
====== link:#_pics_102[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_26]]
====== link:#_pre_conditions_26[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |6.2.3.1 |PAA certificates were obtained externally |
|2 |6.2.3.1 |Commission DUT to TH1’s Fabric |
|===

[[_required_devices_102]]
====== link:#_required_devices_102[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_device_topology_55]]
====== link:#_device_topology_55[]Device Topology

[[_test_setup_44]]
====== link:#_test_setup_44[]Test Setup

[[_test_procedure_102]]
====== link:#_test_procedure_102[]Test Procedure

[width="100%",cols="5%,10%,20%,25%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |6.2.3 | a|
* TH1 generates 32-byte AttestationNonce

|

|2 |6.2.3 | |TH1 sends AttestationRequest Command with a random 32 bytes
`AttestationNonce\`` to the DUT. |

|3a |6.2.3 | | |Verify that the DUT generates the Attestation
Information and that it is sent to TH1 using AttestationResponse Command

|3b |6.2.3 | |TH1 sends `CertificateChainRequest` Command with
`CertificateType` field set to `DACCertificate` (1) to DUT to obtain DAC
|

|3c |6.2.3 | |TH1 saves DAC certificate |DUT responds with
`CertificateChainResponse` the DAC certificate in X.509v3 format with
size ⇐ 600 bytes

|3d |6.2.3 | |TH1 sends `CertificateChainRequest` Command with
`CertificateType` field set to `PAICertificate` (2) to DUT to obtain DAC
|DUT responds with `CertificateChainResponse` the PAI certificate in
X.509v3 format with size ⇐ 600 bytes

|3e |6.2.3 | |TH1 saves PAI certificate |

|4a | | |TH1 Reads the `VendorID` attribute of the Basic Information
cluster and saves it as `basic_info_vendor_id` |

|4b | | |TH1 Reads the `ProductID` attribute of the Basic Information
cluster and saves it as `basic_info_product_id` |

|5 | | |Extract the attestation_elements_message structure fields from
the AttestationResponse Command received by TH1 from DUT |

|6 |11.17.5.5 | | a|
* Verify that the DUT generated the AttestationResponse has the
following fields:
+
. AttestationElements
. AttestationSignature

|7 |11.17.5.5 | |Read the attestation_elements_message structure fields
|

|8 |11.17.5.5 | | a|
* Verify that the `attestation_elements_message` structure fields
satisfy the following conditions:

|8.1 |11.17.5.5 | | a|
* AttestationElements field size should not be greater than RESP_MAX(900
bytes)

|8.2 |11.17.5.5 | | a|
* certification_declaration is present and is an octet string
representation CMS-format certification declaration, as described in
section 6.3.1

|8.3 | | | a|
Verify for the following contents of CD:

* format_version = 1
* The vendor_id field matches the one saved as `basic_info_vendor_id`
saved earlier
* The vendor_id field is in range [0x0001 .. 0xFFF0]
* The product_id_array field contains the value of
`basic_info_product_id` saved earlier
* device_type_id has a value between 0 and (2^31 - 1)
* certificate_id has a length of 19
* security level = 0
* security_information = 0
* `version_number` is an integer in range 0..65535
* certification_type has a value between 1..2

|8.4 | |MCORE.DA.CERTDECL_ORIGIN_VENDORID,
MCORE.DA.CERTDECL_ORIGIN_PRODUCTID | a|
* Confirm that both the fields dac_origin_vendor_id and
dac_origin_product_id are present in Certification Declaration

|8.5 | |!MCORE.DA.CERTDECL_ORIGIN_VENDORID,
!MCORE.DA.CERTDECL_ORIGIN_PRODUCTID | a|
* Or confirm both the fields dac_origin_vendor_id and
dac_origin_product_id are not present in the Certification Declaration

|8.6 | |MCORE.DA.CERTDECL_ORIGIN_VENDORID,
MCORE.DA.CERTDECL_ORIGIN_PRODUCTID | a|
* If the Certification Declaration has both the dac_origin_vendor_id and
the dac_origin_product_id fields then check for the following
conditions:
+
. The Vendor ID (VID) in the DAC subject and PAI subject are the same as
the dac_origin_vendor_id field in the Certification Declaration.
. The Product ID (PID) in the DAC subject is same as the
dac_origin_product_id field in the Certification Declaration.
. If it is present in the PAI certificate, the Product ID (PID) in the
subject is same as the dac_origin_product_id field in the Certification
Declaration.

|8.7 | |!MCORE.DA.CERTDECL_ORIGIN_VENDORID,
!MCORE.DA.CERTDECL_ORIGIN_PRODUCTID | a|
* If the Certification Declaration has neither the dac_origin_vendor_id
nor the dac_origin_product_id fields then check for the following
conditions:
+
. The Vendor ID (VID) in the DAC subject and PAI subject are the same as
the vendor_id field in the Certification Declaration.
. The Product ID (PID) subject DN in the DAC is contained in the
product_id_array field in the Certification Declaration.
. If it is present in the PAI certificate, the Product ID (PID) in the
subject is contained in the product_id_array field in the Certification
Declaration.

|8.8 | |MCORE.DA.CERTDECL_AUTH_PAA | a|
* If the Certification Declaration has authorized_paa_list then check
for the following conditions:
+
. The authority key id extension of the PAI certificate matches the one
found in the authorized_paa_list

|8.9 | | | a|
Verify that the certification_declaration CMS enveloped can be verified
with the well-known Certification Declaration public key used to
originally sign the Certification Declaration

|9 | | | a|
* attestation_nonce is present in the attestation_elements_message
structure
* attestation_nonce value matches the AttestationNonce field value sent
in the AttestationRequest Command sent by the commissioner
* attestation_nonce is a 32 byte-long octet string

|10 | |MCORE.DA.ATTESTELEMENT_FW_INFO | a|
* firmware_information is optional, may be present
* if firmware_information field is present it is a octet string

|11 | | | a|
* Using _Crypto_Verify_ cryptographic primitive, validate that the
AttestationSignature from the AttestationResponse Command is valid if
verified against a message constructed by concatenating
AttestationElements with the attestation challenge associated with the
secure session over which the AttestationResponse was obtained, using
the subject public key found in the DAC.

|12 | | |TH1 sends AttestationRequest Command with Invalid
AttestationNonce (size > 32 bytes) as the field to the DUT. |Verify DUT
responds w/ status INVALID_COMMAND(0x85)

|13 | | |TH1 sends AttestationRequest Command with invalid
AttestationNonce (size < 32 bytes) as the field to the DUT. |Verify that
the DUT reports an INVALID_COMMAND error
|===

[[_tc_da_1_3_device_attestation_request_validation_dut_commissioner]]
===== link:#_tc_da_1_3_device_attestation_request_validation_dut_commissioner[]29.1.3. [TC-DA-1.3] Device Attestation Request Validation [DUT - Commissioner]

[[_category_103]]
====== link:#_category_103[]Category

Functional conformance

[[_purpose_104]]
====== link:#_purpose_104[]Purpose

Validate correct handling of a well-formed AttestationResponse Command
by the DUT, including all the following fields being valid:

* AttestationInformation
+
** AttestationNonce properly repeated
** certification_declaration present
** firmware_information validated if present
** AttestationSignature value

[[_pics_103]]
====== link:#_pics_103[]PICS

* MCORE.ROLE.COMMISSIONER

[[_pre_conditions_27]]
====== link:#_pre_conditions_27[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |6.2.3.1 |PAI, DAC certificates are obtained and validated against
externally obtained PAA certificate |

|2 |11.9.7.1 |Operations happen within the Fail-Safe Context |

|3 |5.5 |TH1 should be known about Commissioner based error
condition/warning |
|===

[[_required_devices_103]]
====== link:#_required_devices_103[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissioner
|2 |TH1 |Commissionee
|===

[[_device_topology_56]]
====== link:#_device_topology_56[]Device Topology

[[_test_setup_45]]
====== link:#_test_setup_45[]Test Setup

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Condition* |*Notes*
|1 |Manual intervention would be required during Device Attestation Test
Procedure |
|===

[[_test_procedure_103]]
====== link:#_test_procedure_103[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Start the commissioning process of TH1 on DUT |

|2 |6.2.3 | |DUT generates 32-byte AttestationNonce |

|3 |6.2.3 | |DUT sends AttestationRequest Command with AttestationNonce
as field to the TH1. |

|4 |6.2.3 | |TH1 records the AttestationNonce received in
AttestationRequest as Nonce_1 |

|5 |6.2.3 | |TH1 responds with a well-formed AttestationResponse Command
|

|6 | | | |Verify that DUT Completes the commissioning process
successfully

|7 | | |Factory Reset TH1 so that it is commissionable again |

|8 |6.2.3 | |Start the commissioning process of TH1 on DUT again |

|9 |6.2.3 | |DUT generates 32-byte AttestationNonce |

|10 |6.2.3 | |DUT sends AttestationRequest Command with AttestationNonce
as field to the TH1. |

|11 |6.2.3 | |TH1 records the AttestationNonce received in
AttestationRequest as Nonce_2 |

|12 |6.2.3 | | |Verify that the Nonce_1 and Nonce_2 are different.
|===

[[_tc_da_1_4_device_attestation_request_validation_error_scenario_dut_commissioner]]
===== link:#_tc_da_1_4_device_attestation_request_validation_error_scenario_dut_commissioner[]29.1.4. [TC-DA-1.4] Device Attestation Request Validation-Error Scenario [DUT-Commissioner]

[[_category_104]]
====== link:#_category_104[]Category

Functional conformance

[[_purpose_105]]
====== link:#_purpose_105[]Purpose

Validate the handling of an invalid AttestationResponse received by the
DUT from TH during commissioning process and ensure the DUT responds
with correct warning message.

[[_pics_104]]
====== link:#_pics_104[]PICS

* MCORE.ROLE.COMMISSIONER

[[_pre_conditions_28]]
====== link:#_pre_conditions_28[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |6.2.3.1 |PAA, PAI, DAC certificates are obtained and validated |

|2 |11.9.7.1 |Operations happen within the Fail-Safe Context |

|3 |5.5 |TH should be known about Commissioner based error
condition/warning |
|===

[[_required_devices_104]]
====== link:#_required_devices_104[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissioner
|2 |TH |Commissionee
|===

[[_device_topology_57]]
====== link:#_device_topology_57[]Device Topology

[[_test_setup_46]]
====== link:#_test_setup_46[]Test Setup

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Condition* |*Notes*
|1 |Manual intervention would be required during Device Attestation Test
Procedure |
|===

[[_test_procedure_104]]
====== link:#_test_procedure_104[]Test Procedure

[width="100%",cols="5%,10%,20%,25%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Start the commissioning process of TH on DUT |

|2 |6.2.3 | |DUT generates 32-byte AttestationNonce |

|3 |6.2.3 | |DUT sends AttestationRequest Command with AttestationNonce
as field to the TH. |

|4 | | a|
* TH responds to the DUT with an invalid AttestationResponse Command by
setting the following error condition:
+
. Commissionee is not yet certified

|

|5 | |MCORE.DA.ATTEST_WARNING | a|
* Verify that DUT notifies a warning stating that Commissionee is not a
fully trusted device.
* Verify that the warning contains the information about the reason for
error condition
* If the warning message indicates that Commissioning is allowed then
confirm that CSRRequest Command is sent from DUT to TH

|6 | | |Factory Reset TH so that it is commissionable again |

|7 |5.5 | a|
For each of the following test cases, start the TH using the appropriate
certificate set, commission the TH using the DUT, then factory reset the
TH:

* CD Test Vector: The device_type_id field doesn’t match the
device_type_id value in the DCL entries associated with the VID and PID.
+
** example certs: struct_cd_device_type_id_mismatch (pid=32768)
* CD Test Vector: The authorized_paa_list contains ten PAAs none of
which is a valid PAA authorized to sign the PAI.
+
** example certs: struct_cd_authorized_paa_list_count10_invalid
(pid=32768)
* CD Test Vector: Invalid Signer Info version set to v2.
+
** example certs: struct_cd_signer_info_v2 (pid=32768)
* PAI Test Vector: Certificate doesn’t include Authority Key ID (AKID)
extension
+
** example certs: struct_pai_ext_akid_missing (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mvid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_dac_vidpid_fallback_encoding_07 (pid=177)
* PAI Test Vector: Certificate Basic Constraint extension PathLen field
set to 2
+
** example certs: struct_pai_ext_basic_pathlen2 (pid=32768)
* PAI Test Vector: Certificate validity period starts in the future
+
** example certs: struct_pai_valid_in_future (pid=32768)
* PAI Test Vector: Invalid certificate version field set to v2(1)
+
** example certs: struct_pai_cert_version_v2 (pid=32768)
* DAC Test Vector: Certificate doesn’t include Basic Constraint
extension
+
** example certs: struct_dac_ext_basic_missing (pid=32768)
* CD Test Vector: The product_id_array field has one PID value that
doesn’t match the PID value in DAC.
+
** example certs: struct_cd_pid_array_count01_mismatch (pid=32768)
* CD Test Vector: The version_number field doesn’t match the VID and PID
used in a DeviceSoftwareVersionModel entry in the DCL matching the
certification record associated with the product presenting this CD.
+
** example certs: struct_cd_version_number_wrong (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mpid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_dac_vidpid_fallback_encoding_09 (pid=177)
* CD Test Vector: The dac_origin_vendor_id and dac_origin_product_id
fields present and the VID value doesn’t match the VID found in the DAC
Subject DN.
+
** example certs: struct_cd_dac_origin_vid_pid_present_vid_mismatch
(pid=32768)
* CD Test Vector: The dac_origin_vendor_id fild is not present and
dac_origin_product_id is present.
+
** example certs: struct_cd_dac_origin_vid_missing_pid_present
(pid=32768)
* DAC Test Vector: VID in Subject field doesn’t match VID in Issuer
field
+
** example certs: struct_dac_subject_vid_mismatch (pid=32768)
* CD Test Vector: The dac_origin_vendor_id fild is present and
dac_origin_product_id fields is not present.
+
** example certs: struct_cd_dac_origin_vid_present_pid_missing
(pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension PathLen field
presence is wrong (present for DAC not present for PAI)
+
** example certs: struct_dac_ext_basic_pathlen_presence_wrong
(pid=32768)
* CD Test Vector: Invalid CMS version set to v2.
+
** example certs: struct_cd_cms_v2 (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension CA field is
wrong (TRUE for DAC and FALSE for PAI)
+
** example certs: struct_pai_ext_basic_ca_wrong (pid=32768)
* DAC Test Vector: Certificate doesn’t include Authority Key ID (AKID)
extension
+
** example certs: struct_dac_ext_akid_missing (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension PathLen field
set to 1
+
** example certs: struct_pai_ext_basic_pathlen1 (pid=32768)
* CD Test Vector: The certificate_id field doesn’t contain a globally
unique serial number allocated by the CSA for this CD.
+
** example certs: struct_cd_cert_id_mismatch (pid=32768)
* PAI Test Vector: VID in Subject field doesn’t match VID in Issuer
field
+
** example certs: struct_pai_subject_vid_mismatch (pid=32768)
* CD Test Vector: Invalid CMS signature algorithm ECDSA_WITH_SHA1.
+
** example certs: struct_cd_cms_sig_algo_ecdsa_with_sha1 (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension critical field
is set as 'non-critical'
+
** example certs: struct_pai_ext_basic_critical_wrong (pid=32768)
* PAI Test Vector: Certificate doesn’t include Subject Key ID (SKID)
extension
+
** example certs: struct_pai_ext_skid_missing (pid=32768)
* DAC Test Vector: Certificate validity period starts in the past
+
** example certs: struct_dac_valid_in_past (pid=32768)
* DAC Test Vector: Mix of Fallback and Matter OID encoding for VID and
PID: wrong, Correct values encoded in the common-name are ignored
+
** example certs: struct_dac_vidpid_fallback_encoding_16 (pid=177)
* CD Test Vector: The format_version field is missing.
+
** example certs: struct_cd_format_version_missing (pid=32768)
* CD Test Vector: Invalid CMS Signature.
+
** example certs: struct_cd_cms_signature (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example: invalid VID
prefix
+
** example certs: struct_dac_vidpid_fallback_encoding_13 (pid=177)
* DAC Test Vector: Certificate Key Usage extension cRLSign field is
wrong (present for DAC and not present for PAI)
+
** example certs: struct_dac_ext_key_usage_crl_sign_wrong (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension CA field is
missing
+
** example certs: struct_pai_ext_basic_ca_missing (pid=32768)
* DAC Test Vector: Certificate Key Usage extension critical field is
missing
+
** example certs: struct_dac_ext_key_usage_critical_missing (pid=32768)
* CD Test Vector: The product_id_array field has 10 PID values none of
which matches the PID value in DAC.
+
** example certs: struct_cd_pid_array_count10_mismatch (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example: invalid VID
encoding
+
** example certs: struct_dac_vidpid_fallback_encoding_10 (pid=177)
* DAC Test Vector: Invalid certificate public key curve secp256k1
+
** example certs: struct_dac_sig_curve_secp256k1 (pid=32768)
* DAC Test Vector: Certificate Key Usage extension digitalSignature
field is wrong (not present for DAC and present for PAI, which is OK as
optional)
+
** example certs: struct_dac_ext_key_usage_dig_sig_wrong (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example: invalid PID
and VID prefixes
+
** example certs: struct_dac_vidpid_fallback_encoding_14 (pid=177)
* PAI Test Vector: Mix of Fallback and Matter OID encoding for VID and
PID: invalid, PID is using Matter OID then VID must also use Matter OID
+
** example certs: struct_pai_vidpid_fallback_encoding_17 (pid=177)
* DAC Test Vector: Certificate doesn’t include Subject Key ID (SKID)
extension
+
** example certs: struct_dac_ext_skid_missing (pid=32768)
* DAC Test Vector: Invalid certificate version field set to v2(1)
+
** example certs: struct_dac_cert_version_v2 (pid=32768)
* DAC Test Vector: Certificate Key Usage extension keyCertSign field is
wrong (present for DAC and not present for PAI)
+
** example certs: struct_dac_ext_key_usage_key_cert_sign_wrong
(pid=32768)
* CD Test Vector: The security_level field is missing.
+
** example certs: struct_cd_security_level_missing (pid=32768)
* DAC Test Vector: Invalid certificate signature algorithm
ECDSA_WITH_SHA1
+
** example certs: struct_dac_sig_algo_ecdsa_with_sha1 (pid=32768)
* CD Test Vector: The dac_origin_vendor_id and dac_origin_product_id
fields present and the PID value doesn’t match the PID found in the DAC
Subject DN.
+
** example certs: struct_cd_dac_origin_vid_pid_present_pid_mismatch
(pid=32768)
* PAI Test Vector: Certificate Key Usage extension keyCertSign field is
wrong (present for DAC and not present for PAI)
+
** example certs: struct_pai_ext_key_usage_key_cert_sign_wrong
(pid=32768)
* CD Test Vector: The security_level field is set to invalid value
(different from 0).
+
** example certs: struct_cd_security_level_wrong (pid=32768)
* PAI Test Vector: Invalid certificate public key curve secp256k1
+
** example certs: struct_pai_sig_curve_secp256k1 (pid=32768)
* PAA Test Vector: Use Invalid PAA (Not Registered in the DCL).
+
** example certs: invalid_paa (pid=32768)
* CD Test Vector: The vendor_id field is missing.
+
** example certs: struct_cd_vid_missing (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mvid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_pai_vidpid_fallback_encoding_07 (pid=177)
* CD Test Vector: The product_id_array field is empty TLV array.
+
** example certs: struct_cd_pid_array_count0 (pid=32768)
* PAI Test Vector: Mix of Fallback and Matter OID encoding for VID and
PID: wrong, Correct values encoded in the common-name are ignored
+
** example certs: struct_pai_vidpid_fallback_encoding_16 (pid=177)
* PAI Test Vector: Certificate validity period starts in the past
+
** example certs: struct_pai_valid_in_past (pid=32768)
* CD Test Vector: The product_id_array field is missing.
+
** example certs: struct_cd_pid_array_missing (pid=32768)
* PAI Test Vector: Certificate doesn’t include Basic Constraint
extension
+
** example certs: struct_pai_ext_basic_missing (pid=32768)
* CD Test Vector: The vendor_id field doesn’t match the VID in DAC.
+
** example certs: struct_cd_vid_mismatch (pid=32768)
* CD Test Vector: Invalid CMS digest algorithm SHA1.
+
** example certs: struct_cd_cms_digest_algo_sha1 (pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension CA field is
missing
+
** example certs: struct_dac_ext_basic_ca_missing (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mvid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_dac_vidpid_fallback_encoding_06 (pid=177)
* PAI Test Vector: Fallback VID and PID encoding example: invalid PID
and VID prefixes
+
** example certs: struct_pai_vidpid_fallback_encoding_14 (pid=177)
* DAC Test Vector: Certificate Basic Constraint extension critical field
is set as 'non-critical'
+
** example certs: struct_dac_ext_basic_critical_wrong (pid=32768)
* PAI Test Vector: Certificate Key Usage extension critical field is
missing
+
** example certs: struct_pai_ext_key_usage_critical_missing (pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension CA field is
wrong (TRUE for DAC and FALSE for PAI)
+
** example certs: struct_dac_ext_basic_ca_wrong (pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension critical field
is missing
+
** example certs: struct_dac_ext_basic_critical_missing (pid=32768)
* DAC Test Vector: PID in Subject field doesn’t match PID in Issuer
field
+
** example certs: struct_dac_subject_pid_mismatch (pid=32768)
* CD Test Vector: The product_id_array field has 100 PID values none of
which matches the PID value in DAC.
+
** example certs: struct_cd_pid_array_count100_mismatch (pid=32768)
* CD Test Vector: The security_information field is missing.
+
** example certs: struct_cd_security_info_missing (pid=32768)
* DAC Test Vector: Mix of Fallback and Matter OID encoding for VID and
PID: invalid, PID is using Matter OID then VID must also use Matter OID
+
** example certs: struct_dac_vidpid_fallback_encoding_17 (pid=177)
* PAI Test Vector: Certificate Key Usage extension critical field is set
as 'non-critical'
+
** example certs: struct_pai_ext_key_usage_critical_wrong (pid=32768)
* DAC Test Vector: Certificate Key Usage extension critical field is set
as 'non-critical'
+
** example certs: struct_dac_ext_key_usage_critical_wrong (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mvid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_pai_vidpid_fallback_encoding_06 (pid=177)
* CD Test Vector: The certification_type field is missing.
+
** example certs: struct_cd_cert_type_missing (pid=32768)
* CD Test Vector: The authorized_paa_list contains one valid PAA which
is authorized to sign the PAI.
+
** example certs: struct_cd_authorized_paa_list_count0 (pid=32768)
* CD Test Vector: The certificate_id field has wrong length.
+
** example certs: struct_cd_cert_id_len_wrong (pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension PathLen field
set to 2
+
** example certs: struct_dac_ext_basic_pathlen2 (pid=32768)
* PAI Test Vector: Certificate Key Usage extension cRLSign field is
wrong (present for DAC and not present for PAI)
+
** example certs: struct_pai_ext_key_usage_crl_sign_wrong (pid=32768)
* PAI Test Vector: Certificate doesn’t include Key Usage extension
+
** example certs: struct_pai_ext_key_usage_missing (pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension PathLen field
set to 1
+
** example certs: struct_dac_ext_basic_pathlen1 (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mpid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_dac_vidpid_fallback_encoding_08 (pid=177)
* PAI Test Vector: Fallback VID and PID encoding example: invalid VID
encoding
+
** example certs: struct_pai_vidpid_fallback_encoding_10 (pid=177)
* PAI Test Vector: PID in Subject field doesn’t match PID in Issuer
field
+
** example certs: struct_pai_subject_pid_mismatch (pid=32768)
* CD Test Vector: The authorized_paa_list contains three PAAs none of
which is a valid PAA authorized to sign the PAI.
+
** example certs: struct_cd_authorized_paa_list_count3_invalid
(pid=32768)
* DAC Test Vector: Certificate Basic Constraint extension PathLen field
set to 0
+
** example certs: struct_dac_ext_basic_pathlen0 (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example: invalid, PID
not present and VID not upper case
+
** example certs: struct_dac_vidpid_fallback_encoding_12 (pid=177)
* CD Test Vector: The device_type_id field is missing.
+
** example certs: struct_cd_device_type_id_missing (pid=32768)
* CD Test Vector: The certification_type field is set to invalid value.
+
** example certs: struct_cd_cert_type_wrong (pid=32768)
* CD Test Vector: Invalid format_version field set to 2.
+
** example certs: struct_cd_format_version_2 (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension PathLen field
presence is wrong (present for DAC not present for PAI)
+
** example certs: struct_pai_ext_basic_pathlen_presence_wrong
(pid=32768)
* CD Test Vector: Invalid CMS eContentType is set to Microsoft
Authenticode [MSAC] OID = \{ 1.3.6.1.4.1.311.2.1.4 }.
+
** example certs: struct_cd_cms_econtent_type_msac (pid=32768)
* DAC Test Vector: Certificate doesn’t include Key Usage extension
+
** example certs: struct_dac_ext_key_usage_missing (pid=32768)
* CD Test Vector: Invalid Signer Info digest algorithm SHA1.
+
** example certs: struct_cd_signer_info_digest_algo_sha1 (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example: invalid, PID
not present and VID not upper case
+
** example certs: struct_pai_vidpid_fallback_encoding_12 (pid=177)
* PAI Test Vector: Fallback VID and PID encoding example: invalid VID
prefix
+
** example certs: struct_pai_vidpid_fallback_encoding_13 (pid=177)
* DAC Test Vector: Certificate validity period starts in the future
+
** example certs: struct_dac_valid_in_future (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension critical field
is missing
+
** example certs: struct_pai_ext_basic_critical_missing (pid=32768)
* CD Test Vector: The certificate_id field is missing.
+
** example certs: struct_cd_cert_id_missing (pid=32768)
* CD Test Vector: The security_information field is set to invalid value
(different from 0).
+
** example certs: struct_cd_security_info_wrong (pid=32768)
* CD Test Vector: The subjectKeyIdentifier contains invalid SKID of a
certificate unknown by Zigbee Alliance.
+
** example certs: struct_cd_signer_info_skid_invalid (pid=32768)
* CD Test Vector: The version_number field is missing.
+
** example certs: struct_cd_version_number_missing (pid=32768)
* PAI Test Vector: Invalid certificate signature algorithm
ECDSA_WITH_SHA1
+
** example certs: struct_pai_sig_algo_ecdsa_with_sha1 (pid=32768)

|Verify that the DUT indicates that the device is not genuine, or
otherwise indicates a failure of device attestation, within its error
handling APIs or user interface.
|===

[[_tc_da_1_5_nocsr_procedure_validation_dut_commissionee]]
===== link:#_tc_da_1_5_nocsr_procedure_validation_dut_commissionee[]29.1.5. [TC-DA-1.5] NOCSR Procedure Validation [DUT - Commissionee]

[[_category_105]]
====== link:#_category_105[]Category

Functional conformance

[[_purpose_106]]
====== link:#_purpose_106[]Purpose

To verify the following checks during the NOCSR procedure:

. DUT generates the NOCSR Information using CSRResponse Command
. DUT generated NOCSR Information includes a signature using the Device
Attestation Private Key
. CSR SHALL follow the encoding and rules from PKCS #10
. DUT generated that Node Operational Key Pair is unique
. DUT rejects invalid CSRNonce sent by TH1

[[_pics_105]]
====== link:#_pics_105[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_29]]
====== link:#_pre_conditions_29[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH1 fully commissions DUT |

|2 | |PAI, DAC certificates are obtained and validated against
externally obtained PAA certificate |

|3 |11.9.7.1 |Operations happen within the Fail-Safe Context |
|===

[[_required_devices_105]]
====== link:#_required_devices_105[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Commissioner
|===

[[_device_topology_58]]
====== link:#_device_topology_58[]Device Topology

[[_test_setup_47]]
====== link:#_test_setup_47[]Test Setup

[[_test_procedure_105]]
====== link:#_test_procedure_105[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.5 | |TH1 fully commissions the DUT |Verify that the DUT is
commissioned successfully

|2 | | |TH1 establishes a CASE session to the DUT and saves the
attestation challenge as `attestation_challenge` |

|3 |11.17.7.3 | |TH1 sends a CertificateChainRequest command with the
CertificateType field set to DACCertificate. |Verify that the DUT sends
a CertificateChainResponse. TH1 saves the return certificate as `dac`

|4 |11.9.7.2 | |TH1 sends an ArmFailSafe command to the General
Commissioning cluster with the ExpiryLengthSeconds field set to 900
|Verify that the DUT returns SUCCESS

|5 |11.17.7.5 | |TH1 sends a CSRRequest command to the Node Operational
Credentials cluster with the CSRNonce set to a random 32-bit value. The
nonce is saved as `csr_nonce` a|
Verify that the DUT returns a CSRResponse command.

* TH1 saves the NOCSRElements field as `nocsr_elements`
* TH1 saves the AttestationSignature field as
`noscr_attestation_signature`

|6 |11.17.5.6 | a|
* TH1 extracts extracts the TLV-encoded nocsr_elements_message from
`nocsr_elements` and saves the following fields:
* csr is saved as `csr`
* CSRNonce is saved as `csr_nonce_returned`
* if present, vendor_reserved fields are saved as `vendor1`, `vendor2`
and `vendor3`

a|
* TH1 verifies that:
* the length of the nocsr_elements_message is < = 900 bytes
* `csr` is DER-encoded octet string
* `csr` follows the encoding and rules from PKCS #10
* `csr` specifies Public Key algorithm id-ecPublicKey with curve
prime256v1 (ASN1 OID) / P-256 (NIST)
* `csr` specifies a 256-bit public key (save as `csr_pubkey`)
* `csr` Signature Algorithm is ecdsa-with-SHA256
* `csr` Signature is valid
* `csr_nonce_returned` field is OCTET string of length 32
* `csr_nonce_returned` matches `csr_nonce`

|7 |11.17.5.7 | |TH1 creates `nocsr_tbs` = `nocsr_elements_message` ||
`attestation_challenge` |TH1 verifies `nocsr_attestation_signature`
signs `nocsr_tbs` using the public key in `dac`

|8 |11.17.5.7 | | |if vendor_reserved fields are present in the
nocsr_elements_message, TH1 verifies that `attestation_challenge` does
not appear in any of the `vendor` fields

|9 |11.9.7.2 | |TH1 sends an ArmFailSafe command to the General
Commissioning cluster with the ExpiryLengthSeconds field set to 0
|Verify that the DUT returns SUCCESS

|10 |11.9.7.2 | |TH1 sends an ArmFailSafe command to the General
Commissioning cluster with the ExpiryLengthSeconds field set to 900
|Verify that the DUT returns SUCCESS

|11 |11.17.7.5 | |TH1 sends a CSRRequest command to the Node Operational
Credentials cluster with the CSRNonce set to a random 31-bytes value.
|Verify that the DUT responds with INVALID_COMMAND

|12 |11.9.7.2 | |TH1 sends an ArmFailSafe command to the General
Commissioning cluster with the ExpiryLengthSeconds field set to 0
|Verify that the DUT returns SUCCESS

|13 |11.18.8.1 | |TH1 sends the OpenCommissioningWindow command to the
Administrator Commissioning Cluster |Verify the command completes
successfully

|14 |5.5 | |TH2 fully commissions the DUT |Verify commissioning
completes successfully

|15 |11.17.5.2 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that there is a
single element in the list and save the NOC field as `th1_noc`

|16 |11.17.5.2 | |TH2 reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-filtered read |Verify that there is a
single element in the list and save the NOC field as `th2_noc`

|17 |6.4.6.1 | |Extract the pubic keys from `th1_noc` and `th2_noc`
|Verify that the public keys do not match

|18 |11.17.5.6 | |TH2 reads the CurrentFabricIndex attribute from the
Node Operational Credentials cluster and saves as `th2_idx` |

|19 |11.17.6.12 | |TH1 sends the RemoveFabric command to the DUT with
the FabricIndex set to `th2_idx` |
|===

[[_notestesting_considerations_74]]
====== link:#_notestesting_considerations_74[]Notes/Testing Considerations

Test Steps 6,7,8 cannot be executed with V1.0 SDK

[[_tc_da_1_6_nocsr_procedure_validation_dut_commissioner]]
===== link:#_tc_da_1_6_nocsr_procedure_validation_dut_commissioner[]29.1.6. [TC-DA-1.6] NOCSR Procedure Validation [DUT - Commissioner]

[[_category_106]]
====== link:#_category_106[]Category

Functional conformance

[[_purpose_107]]
====== link:#_purpose_107[]Purpose

To verify the following checks during the NOCSR procedure

To verify the following checks during the NOCSR procedure

. DUT generates a valid 32 byte CSRNonce

2.DUT detects errors generated by the TH1 in the NOCSR Information and
reports failure

3.DUT detects collision in Node Operational Key Pair sent from TH1 and
reports failure

[[_pics_106]]
====== link:#_pics_106[]PICS

* MCORE.ROLE.COMMISSIONER

[[_pre_conditions_30]]
====== link:#_pre_conditions_30[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |6.1.2 |Device Attestation is completed |
|2 |6.2.3.1 |PAA, PAI, DAC certificates are obtained and validated |
|3 |11.9.7.1 |Operations happen within the Fail-Safe Context |
|===

[[_required_devices_106]]
====== link:#_required_devices_106[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissioner
|2 |TH1 |Commissionee
|===

[[_device_topology_59]]
====== link:#_device_topology_59[]Device Topology

[[_test_setup_48]]
====== link:#_test_setup_48[]Test Setup

[[_test_procedure_106]]
====== link:#_test_procedure_106[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.3.6.1 | |DUT completes the attestation procedure |

|2 |6.3.6.1 | |DUT generates 32-byte CSRNonce and is sent to TH1 through
CSRRequest Command |

|3 |6.3.6.1 | a|
* TH1 generates Invalid NOCSR Information and sends the CSRResponse
Command.
* Refer Steps 6.1 to 6.8

|

|4 | | | |Verify that DUT reports error

|5 | | |Factory Reset DUT so that it is commissionable again |

|6 | | |Repeat Step1 to Step 4 multiple times. For each time in Step 3
TH1 generates the following error: |

|6.1 | | |CSRNonce is OCTET string of length > 32 |

|6.2 | | |CSRNonce value does not match the value CSR Nonce field in the
corresponding CSRRequest Command |

|6.3 | | |NOCSRElement size is greater than RESP_MAX |
|===

[[_notestesting_considerations_75]]
====== link:#_notestesting_considerations_75[]Notes/Testing Considerations

Test Steps 3, 6, 6.1, 6.2, 6.3 cannot be executed with V1.0 SDK

[[_tc_da_1_7_validate_certificatechainrequest_dut_commissionee]]
===== link:#_tc_da_1_7_validate_certificatechainrequest_dut_commissionee[]29.1.7. [TC-DA-1.7] Validate CertificateChainRequest [DUT-Commissionee]

[[_category_107]]
====== link:#_category_107[]Category

Functional conformance

[[_purpose_108]]
====== link:#_purpose_108[]Purpose

This test case validates that the device attestation certificates are
properly signed and use different device attestation keys on each
individual device.

[[_pics_107]]
====== link:#_pics_107[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_31]]
====== link:#_pre_conditions_31[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH only has official PAAs from DCL |
|===

[[_required_devices_107]]
====== link:#_required_devices_107[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT1 |Commissionee

|2 |DUT2 |Commissionee - different device within the same device family
as DUT1 (same VID/PID)

|3 |TH |Commissioner
|===

[[_device_topology_60]]
====== link:#_device_topology_60[]Device Topology

[[_test_setup_49]]
====== link:#_test_setup_49[]Test Setup

[[_test_procedure_107]]
====== link:#_test_procedure_107[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.5 | |Commission DUT1 to TH fabric |Verify the commissioning
completes successfully

|2 |11.17.7.3 | |TH sends CertificateChainRequest Command to DUT1 with
the CertificateType set to PAICertificate |Verify that the DUT returns a
CertificateChainResponse. Save the returned Certificate as 'pai_1'

|3 |11.17.7.3 | |TH sends CertificateChainRequest Command to DUT1 with
the CertificateType set to DACCertificate |Verify that the DUT returns a
CertificateChainResponse. Save the returned Certificate as 'dac_1'

|4 |6.2.2.4 | |TH extracts the Authority Key Identifier from the PAI
certificate a|
* Verify that the Authority Key Identifier is signed by a PAA in the
DCL.(Ensure that it is not SDK’s test PAA’s)
* Verify that PAI authority key ID must not be one of:
+
** 78:5C:E7:05:B8:6B:8F:4E:6F:C7:93:AA:60:CB:43:EA:69:68:82:D5
** 6A:FD:22:77:1F:51:1F:EC:BF:16:41:97:67:10:DC:DC:31:A1:71:7E

|5 |6.2.2.3 | |TH extracts the public key from the DAC and saves as
'pk_1' |

|6 |6.2.2 | |Repeat Step 1 to 4 with DUT2, saving the PAI, DAC and
public key as `pk_2` |Verify that `pk_1` does not match `pk_2`
|===

[[_tc_da_1_8_device_attestation_request_validation_success_scenario_dut_commissioner]]
===== link:#_tc_da_1_8_device_attestation_request_validation_success_scenario_dut_commissioner[]29.1.8. [TC-DA-1.8] Device Attestation Request Validation-Success Scenario [DUT-Commissioner]

[[_category_108]]
====== link:#_category_108[]Category

Functional conformance

[[_purpose_109]]
====== link:#_purpose_109[]Purpose

Validate successful handing of valid certificates with different
properties.

[[_pics_108]]
====== link:#_pics_108[]PICS

* MCORE.ROLE.COMMISSIONER

[[_required_devices_108]]
====== link:#_required_devices_108[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissioner
|2 |TH |Commissionee
|===

[[_device_topology_61]]
====== link:#_device_topology_61[]Device Topology

[[_test_setup_50]]
====== link:#_test_setup_50[]Test Setup

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Condition* |*Notes*
|1 |Manual intervention would be required during Device Attestation Test
Procedure |
|===

[[_test_procedure_108]]
====== link:#_test_procedure_108[]Test Procedure

[width="100%",cols="5%,10%,20%,25%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.5 | a|
For each of the following test cases, start the TH using the appropriate
certificate set, commission the TH using the DUT, then factory reset the
TH:

* CD Test Vector: The product_id_array field has one PID value which
matches the PID value in DAC.
+
** example certs: struct_cd_pid_array_count01_valid (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
valid example showing that order or separators are not considered at all
for the overall validity of the embedded fields
+
** example certs: struct_pai_vidpid_fallback_encoding_03 (pid=177)
* PAI Test Vector: Fallback VID and PID encoding example: valid, but
less human-readable
+
** example certs: struct_pai_vidpid_fallback_encoding_11 (pid=177)
* CD Test Vector: The authorized_paa_list contains two PAAs one of which
is valid PAA authorized to sign the PAI.
+
** example certs: struct_cd_authorized_paa_list_count2_valid (pid=32768)
* DAC Test Vector: Valid certificate public key curve prime256v1
+
** example certs: struct_dac_sig_curve_prime256v1 (pid=32768)
* PAI Test Vector: Valid certificate public key curve prime256v1
+
** example certs: struct_pai_sig_curve_prime256v1 (pid=32768)
* PAI Test Vector: Certificate includes optional Authority Information
Access extension
+
** example certs: struct_pai_ext_authority_info_access_present
(pid=32768)
* PAI Test Vector: Certificate includes optional Subject Alternative
Name extension
+
** example certs: struct_pai_ext_subject_alt_name_present (pid=32768)
* DAC Test Vector: Certificate includes optional Extended Key Usage
extension
+
** example certs: struct_dac_ext_extended_key_usage_present (pid=32768)
* CD Test Vector: The product_id_array field has 100 PID values one of
which matches the PID value in DAC.
+
** example certs: struct_cd_pid_array_count100_valid (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
valid, but less readable
+
** example certs: struct_pai_vidpid_fallback_encoding_04 (pid=177)
* DAC Test Vector: Fallback VID and PID encoding example: valid, but
less human-readable
+
** example certs: struct_dac_vidpid_fallback_encoding_11 (pid=177)
* DAC Test Vector: Mix of Fallback and Matter OID encoding for VID and
PID: valid, Matter OIDs are used and wrong values in the common-name are
ignored
+
** example certs: struct_dac_vidpid_fallback_encoding_15 (pid=177)
* CD Test Vector: The dac_origin_vendor_id and dac_origin_product_id
fields are not present.
+
** example certs: struct_cd_dac_origin_vid_pid_missing (pid=32768)
* PAI Test Vector: Certificate Key Usage extension digitalSignature
field is wrong (not present for DAC and present for PAI, which is OK as
optional)
+
** example certs: struct_pai_ext_key_usage_dig_sig_wrong (pid=32768)
* PAI Test Vector: Valid certificate signature algorithm
ECDSA_WITH_SHA256
+
** example certs: struct_pai_sig_algo_ecdsa_with_sha256 (pid=32768)
* DAC Test Vector: Valid certificate signature algorithm
ECDSA_WITH_SHA256
+
** example certs: struct_dac_sig_algo_ecdsa_with_sha256 (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
valid example showing that order or separators are not considered at all
for the overall validity of the embedded fields
+
** example certs: struct_dac_vidpid_fallback_encoding_03 (pid=177)
* CD Test Vector: Valid CMS version set to v3.
+
** example certs: struct_cd_cms_v3 (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
valid and recommended since easily human-readable
+
** example certs: struct_pai_vidpid_fallback_encoding_01 (pid=177)
* CD Test Vector: The subjectKeyIdentifier contains SKID of a well-known
Zigbee Alliance certificate.
+
** example certs: struct_cd_signer_info_skid_valid (pid=32768)
* PAI Test Vector: Certificate Basic Constraint extension PathLen field
set to 0
+
** example certs: struct_pai_ext_basic_pathlen0 (pid=32768)
* DAC Test Vector: Certificate includes optional Authority Information
Access extension
+
** example certs: struct_dac_ext_authority_info_access_present
(pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mpid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_pai_vidpid_fallback_encoding_08 (pid=177)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
valid, but less readable
+
** example certs: struct_dac_vidpid_fallback_encoding_04 (pid=177)
* PAI Test Vector: Certificate includes optional Extended Key Usage
extension
+
** example certs: struct_pai_ext_extended_key_usage_present (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
valid and recommended since easily human-readable
+
** example certs: struct_pai_vidpid_fallback_encoding_02 (pid=177)
* CD Test Vector: The product_id_array field has 10 PID values one of
which matches the PID value in DAC.
+
** example certs: struct_cd_pid_array_count10_valid (pid=32768)
* CD Test Vector: Valid CMS digest algorithm SHA256.
+
** example certs: struct_cd_cms_digest_algo_sha256 (pid=32768)
* CD Test Vector: Valid format_version field set to 1.
+
** example certs: struct_cd_format_version_1 (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
valid, but highly discouraged, since embedding of substrings within
other substrings may be confusing to human readers
+
** example certs: struct_pai_vidpid_fallback_encoding_05 (pid=177)
* CD Test Vector: The version_number field matches the VID and PID used
in a DeviceSoftwareVersionModel entry in the DCL matching the
certification record associated with the product presenting this CD.
+
** example certs: struct_cd_version_number_match (pid=32768)
* CD Test Vector: Valid CMS eContentType pkcs7-data.
+
** example certs: struct_cd_cms_econtent_type_pkcs7_data (pid=32768)
* CD Test Vector: The optional authorized_paa_list field is not present.
+
** example certs: struct_cd_authorized_paa_list_missing (pid=32768)
* CD Test Vector: The authorized_paa_list contains one valid PAA which
is authorized to sign the PAI.
+
** example certs: struct_cd_authorized_paa_list_count1_valid (pid=32768)
* DAC Test Vector: Certificate includes optional Subject Alternative
Name extension
+
** example certs: struct_dac_ext_subject_alt_name_present (pid=32768)
* CD Test Vector: The authorized_paa_list contains ten PAAs one of which
is valid PAA authorized to sign the PAI.
+
** example certs: struct_cd_authorized_paa_list_count10_valid
(pid=32768)
* CD Test Vector: The dac_origin_vendor_id and dac_origin_product_id
fields present and contain the VID and PID values that match the VID and
PID found in the DAC Subject DN.
+
** example certs: struct_cd_dac_origin_vid_pid_present_match (pid=32768)
* PAI Test Vector: Valid certificate version field set to v3(2)
+
** example certs: struct_pai_cert_version_v3 (pid=32768)
* PAI Test Vector: Fallback VID and PID encoding example from spec:
invalid, since substring following Mpid: is not exactly 4 uppercase
hexadecimal digits
+
** example certs: struct_pai_vidpid_fallback_encoding_09 (pid=177)
* CD Test Vector: Origin VID/PID different than VID/PID (correct use of
origin)
+
** example certs: struct_cd_origin_pid_vid_correct (pid=32768)
* DAC Test Vector: Valid certificate version field set to v3(2)
+
** example certs: struct_dac_cert_version_v3 (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
valid and recommended since easily human-readable
+
** example certs: struct_dac_vidpid_fallback_encoding_02 (pid=177)
* PAI Test Vector: Mix of Fallback and Matter OID encoding for VID and
PID: valid, Matter OIDs are used and wrong values in the common-name are
ignored
+
** example certs: struct_pai_vidpid_fallback_encoding_15 (pid=177)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
valid, but highly discouraged, since embedding of substrings within
other substrings may be confusing to human readers
+
** example certs: struct_dac_vidpid_fallback_encoding_05 (pid=177)
* CD Test Vector: Valid CMS signature algorithm ECDSA_WITH_SHA256.
+
** example certs: struct_cd_cms_sig_algo_ecdsa_with_sha256 (pid=32768)
* DAC Test Vector: Fallback VID and PID encoding example from spec:
valid and recommended since easily human-readable
+
** example certs: struct_dac_vidpid_fallback_encoding_01 (pid=177)

|Verify that the TH is successfully commissioned for each test case
|===

[[_interaction_data_model_test_plan]]
== link:#_interaction_data_model_test_plan[]**Interaction Data Model Test Plan**

[[_pics_definition_9]]
=== link:#_pics_definition_9[]30. PICS Definition

This section covers the Interaction Data Model Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.IDM.S |Is the device a Server |O |

|MCORE.IDM.C |Is the device a Client |O |

|MCORE.IDM.C.InvokeRequest |Is the device a Client and Supports sending
a Invoke Request Message |O |

|MCORE.IDM.C.ReadRequest |Is the device a Client and Supports sending a
Read Request Message |O |

|MCORE.IDM.C.WriteRequest |Is the device a Client and Supports sending a
Write Request Message |O |

|MCORE.IDM.C.SubscribeRequest |Is the device a Client and Supports
sending a Subscribe Request Message |O |

|MCORE.IDM.S.Attribute.DataType_Bool |Is the device a Server and
supports an attribute of DataType Bool |O |

|MCORE.IDM.S.Attribute.DataType_String |Is the device a Server and
supports an attribute of DataType String |O |

|MCORE.IDM.S.Attribute.DataType_UnsignedInteger |Is the device a Server
and supports an attribute of DataType Unsigned Integer |O |

|MCORE.IDM.S.Attribute.DataType_SignedInteger |Is the device a Server
and supports an attribute of DataType Signed Integer |O |

|MCORE.IDM.S.Attribute.DataType_Struct |Is the device a Server and
supports an attribute of DataType Struct |O |

|MCORE.IDM.S.Attribute.DataType_FloatingPoint |Is the device a Server
and supports an attribute of DataType Floating Point |O |

|MCORE.IDM.S.Attribute.DataType_List |Is the device a Server and
supports an attribute of DataType List |O |

|MCORE.IDM.S.Attribute.DataType_OctetString |Is the device a Server and
supports an attribute of DataType Octet String |O |

|MCORE.IDM.S.Attribute.DataType_Enum |Is the device a Server and
supports an attribute of DataType Enum |O |

|MCORE.IDM.S.Attribute.DataType_Bitmap |Is the device a Server and
supports an attribute of DataType Bitmap |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_Bool |Is the device a Client
and supports Reading an attribute of DataType Bool |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_String |Is the device a
Client and supports Reading an attribute of DataType String |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_UnsignedInteger |Is the
device a Client and supports Reading an attribute of DataType Unsigned
Integer |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_SignedInteger |Is the device
a Client and supports Reading an attribute of DataType Signed Integer |O
|

|MCORE.IDM.C.ReadRequest.Attribute.DataType_Struct |Is the device a
Client and supports Reading an attribute of DataType Struct |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_FloatingPoint |Is the device
a Client and supports Reading an attribute of DataType Floating Point |O
|

|MCORE.IDM.C.ReadRequest.Attribute.DataType_List |Is the device a Client
and supports Reading an attribute of DataType List |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_OctetString |Is the device a
Client and supports Reading an attribute of DataType Octet String |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_Enum |Is the device a Client
and supports Reading an attribute of DataType Enum |O |

|MCORE.IDM.C.ReadRequest.Attribute.DataType_Bitmap |Is the device a
Client and supports Reading an attribute of DataType Bitmap |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_Bool |Is the device a
Client and supports Writing an attribute of DataType Bool |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_String |Is the device a
Client and supports Writing an attribute of DataType String |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_UnsignedInteger |Is the
device a Client and supports Writing an attribute of DataType Unsigned
Integer |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_SignedInteger |Is the
device a Client and supports Writing an attribute of DataType Signed
Integer |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_Struct |Is the device a
Client and supports Writing an attribute of DataType Struct |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_FloatingPoint |Is the
device a Client and supports Writing an attribute of DataType Floating
Point |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_List |Is the device a
Client and supports Writing an attribute of DataType List |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_OctetString |Is the device
a Client and supports Writing an attribute of DataType Octet String |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_Enum |Is the device a
Client and supports Writing an attribute of DataType Enum |O |

|MCORE.IDM.C.WriteRequest.Attribute.DataType_Bitmap |Is the device a
Client and supports Writing an attribute of DataType Bitmap |O |

|MCORE.IDM.S.Attribute_W.DataType_Bool |Is the device a Server and
supports a writable attribute of DataType Bool |O |

|MCORE.IDM.S.Attribute_W.DataType_String |Is the device a Server and
supports a writable attribute of DataType String |O |

|MCORE.IDM.S.Attribute_W.DataType_UnsignedInteger |Is the device a
Server and supports a writable attribute of DataType UnsignedInteger |O
|

|MCORE.IDM.S.Attribute_W.DataType_SignedInteger |Is the device a Server
and supports a writable attribute of DataType SignedInteger |O |

|MCORE.IDM.S.Attribute_W.DataType_Struct |Is the device a Server and
supports a writable attribute of DataType Struct |O |

|MCORE.IDM.S.Attribute_W.DataType_FloatingPoint |Is the device a Server
and supports a writable attribute of DataType FloatingPoint |O |

|MCORE.IDM.S.Attribute_W.DataType_List |Is the device a Server and
supports a writable attribute of DataType List |O |

|MCORE.IDM.S.Attribute_W.DataType_OctetString |Is the device a Server
and supports a writable attribute of DataType OctetString |O |

|MCORE.IDM.S.Attribute_W.DataType_Enum |Is the device a Server and
supports a writable attribute of DataType Enum |O |

|MCORE.IDM.S.Attribute_W.DataType_Bitmap |Is the device a Server and
supports a writable attribute of DataType Bitmap |O |

|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_Bool |Is the device a
Client and supports subscribing to an attribute of DataType Bool |O |

|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_String |Is the device a
Client and supports subscribing to an attribute of DataType String |O |

|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_UnsignedInteger |Is the
device a Client and supports subscribing to an attribute of DataType
UnsignedInteger |O |

|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_Integer |Is the device
a Client and supports subscribing to an attribute of DataType Integer |O
|

|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_FloatingPoint |Is the
device a Client and supports subscribing to an attribute of DataType
FloatingPoint |O |

|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_List |Is the device a
Client and supports subscribing to an attribute of DataType List |O |

|MCORE.IDM.S.LargeData |Is the device a Server and capable of generating
large data which is greater than 1 MTU(1280 bytes) |O |

|MCORE.IDM.C.SubscribeEvent |Is the device a Client and supports
subscribing to an individual Event |O |

|MCORE.IDM.C.ReadEvent |Is the device a Client and supports Reading an
individual Event |O |

|MCORE.IDM.C.SubscribeRequest.MultipleAttributes |Is the device a client
and supports subscribing to Multiple Attributes |O |

|MCORE.IDM.S.PersistentSubscription |Is the device a Server and supports
Persistent subscription |O |
|===

Additionally, these PICS items from the ICD Management cluster are used
in this test plan - these definitions are copies from the relevant test
plan:

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.S |Does the device implement the ICD Management cluster as a
server? |O |
|===

[[_test_case_list_8]]
=== link:#_test_case_list_8[]31. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-IDM-1.1 |Invoke Request Action from DUT to TH. [DUT as Client]

|TC-IDM-1.2 |Invoke Response Action from DUT to TH. [DUT as Server]

|TC-IDM-2.1 |Read Request Action from DUT to TH. [DUT as Client]

|TC-IDM-2.2 |Report Data Action from DUT to TH. [DUT as Server]

|TC-IDM-3.1 |Write Request Message from DUT to TH. [DUT as Client]

|TC-IDM-3.2 |Write Response Message from DUT to TH. [DUT as Server]

|TC-IDM-4.1 |Subscription Request Action from DUT. [DUT as Client]

|TC-IDM-4.2 |Subscription Response Action from DUT. [DUT as Server]

|TC-IDM-4.3 |Report Data Messages post Subscription Activation from DUT.
[DUT as Server]

|TC-IDM-4.4 |Persistent Subscription Test Cases. [DUT as Server]

|TC-IDM-5.1 |Timed Request Action from DUT to TH. [DUT as Client]

|TC-IDM-5.2 |Status Response from DUT in response to a Timed Request
Action from TH. [DUT as Server]

|TC-IDM-6.1 |Events Read Interaction from TH to DUT. [DUT as Server]

|TC-IDM-6.2 |Events Subscribe Interaction from TH to DUT. [DUT as
Server]

|TC-IDM-6.3 |Events Read Interaction from DUT to TH. [DUT as Client]

|TC-IDM-6.4 |Events Subscribe Interaction from DUT to TH. [DUT as
Client]

|TC-IDM-7.1 |Multi Fabric Subscription Test Cases. [DUT as Server]

|TC-IDM-8.1 |Fabric scoped test cases. [DUT as Server]

|TC-IDM-9.1 |CONSTRAINT_ERROR status response test cases [DUT as Server]
- REMOVED

|TC-IDM-10.1 |Cluster requirements - Global attributes [DUT as Server]

|TC-IDM-11.1 |Data types - attribute strings [DUT as Server]
|===

[[_test_cases_8]]
=== link:#_test_cases_8[]32. Test Cases

'''''

[[_invoke_transaction_test_cases]]
==== link:#_invoke_transaction_test_cases[]32.1. Invoke Transaction Test Cases

'''''

[[_tc_idm_1_1_invoke_request_action_from_dut_to_th_dut_as_client]]
===== link:#_tc_idm_1_1_invoke_request_action_from_dut_to_th_dut_as_client[]32.1.1. [TC-IDM-1.1] Invoke Request Action from DUT to TH - [DUT as Client]

[[_category_109]]
====== link:#_category_109[]Category

Functional, Protocol

[[_purpose_110]]
====== link:#_purpose_110[]Purpose

Verifying the Invoke Request Action sent from the DUT is according to
the specification.

[[_pics_109]]
====== link:#_pics_109[]PICS

* MCORE.IDM.C.InvokeRequest

[[_required_devices_109]]
====== link:#_required_devices_109[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as device which is the recipient of the Invoke
Request Message - Server

|2 |DUT |DUT as the device which sends the Invoke Request Message -
Client
|===

[[_device_topology_62]]
====== link:#_device_topology_62[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_51]]
====== link:#_test_setup_51[]Test Setup

Test will need a reference implementation of the cluster of which the
DUT is the client.

[[_test_procedure_109]]
====== link:#_test_procedure_109[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.8.2.1/10.6.9 | |DUT sends the Invoke Request Message to the TH. +
The Message should contain one valid CommandDataIB, which has the
specific Endpoint, Specific Cluster and Specific Command. |On the TH
verify the received request message has the same paths as provided in
the command.

|2 |8.8.2.1/10.6.9 | |DUT sends the Invoke Request Message to the TH. +
The Message should contain the wildcard for Endpoint, specific Cluster
and Specific Command in the CommandDataIB. |On the TH verify the
received request message has the same paths as provided in the command.

|3 |8.8.2.1/10.6.9 | |DUT sends the Invoke Request Message to the TH. +
The Message should contain multiple paths +
Path = [[ Endpoint = Endpoint1, Cluster = ClusterID, Command = Command1
], [ Endpoint = Endpoint1, Cluster = ClusterID, Command = Command2 ] ]
|On the TH verify the received request message has the same paths as
provided in the command.

|4 |8.8.2.1/10.6.9 | |DUT sends the Invoke Request Message to the TH. +
The Message should contain one valid CommandDataIB, which has the
specific Endpoint, Specific Cluster and Specific Command. +
Send 2 more Invoke Request Messages to the TH. |On the TH verify the
received request messages have the same paths as provided in the
command.
|===

[[_notestesting_considerations_76]]
====== link:#_notestesting_considerations_76[]Notes/Testing Considerations

The Cluster and Commands should be based on the cluster implementation
on the DUT. +
Test Step 2, 3 are not in scope for 1.0 +
Test Step 4 can be tested by using the command scan networks.

'''''

[[_tc_idm_1_2_invoke_response_action_from_dut_to_th_dut_as_server]]
===== link:#_tc_idm_1_2_invoke_response_action_from_dut_to_th_dut_as_server[]32.1.2. [TC-IDM-1.2] Invoke Response Action from DUT to TH - [DUT as Server]

[[_category_110]]
====== link:#_category_110[]Category

Functional, Protocol

[[_purpose_111]]
====== link:#_purpose_111[]Purpose

Verifying the Invoke Response of the DUT once it receives the Invoke
Request Action.

[[_pics_110]]
====== link:#_pics_110[]PICS

* MCORE.IDM.S

[[_required_devices_110]]
====== link:#_required_devices_110[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as device which sends the Invoke Request Message -
Client

|2 |DUT |DUT as the device which responds to the Invoke Request Message
- Server
|===

[[_device_topology_63]]
====== link:#_device_topology_63[]Device Topology

Depending on the Test Case, TH and DUT will be commissioned and are on
the same fabric.

[[_test_setup_52]]
====== link:#_test_setup_52[]Test Setup

Test will need a reference implementation of the cluster of which the
DUT is the server

[[_test_procedure_110]]
====== link:#_test_procedure_110[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.8.2.3 | |TH sends the Invoke Request Message to the DUT with the
path that indicates a specific endpoint that is unsupported. |On the TH
verify the received response message has the UNSUPPORTED_ENDPOINT Status
Code

|2 |8.8.2.3 | |TH sends the Invoke Request Message to the DUT with the
path that indicates a specific cluster that is unsupported. |On the TH
verify the received response message has the UNSUPPORTED_CLUSTER Status
Code

|3 |8.8.2.3 | |TH sends the Invoke Request Message to the DUT with the
path that indicates a specific command that is unsupported. |On the TH
verify the received response message has the UNSUPPORTED_COMMAND Status
Code

|4 |8.8.2.3 | |Setup the TH such that it should not have the privilege
for the cluster in the path. +
TH sends the Invoke Request Message to the DUT with a valid
CommandDataIB |On the TH verify the received response message has the
UNSUPPORTED_ACCESS Status Code

|5 |8.8.2.3 | |Setup the TH such that there is no accessing fabric +
TH sends the Invoke Request Message to the DUT with a valid and
fabric-scoped CommandDataIB |On the TH verify the received response
message has the UNSUPPORTED_ACCESS Status Code

|6 |8.8.2.3 | |[OPTIONAL] TH sends the Invoke Request Message to the DUT
with the command which requires a data response to be sent back. |Verify
that the DUT generates an InvokeResponseIB with a valid CommandDataIB
and sends it to the TH. +
TH then verifies that this message is valid.

|7 |8.8.2.3 | |TH sends the Invoke Request Message to the DUT with a
valid CommandDataIB and SuppressResponse set to True |Verify that the
DUT executes the command. +
Verify that the DUT does not send any response back to the TH.

|8 |8.8.2.3 | |TH sends a Invoke Request Message to the DUT with the
TimedRequest set as TRUE.(There should be no previous Timed Invoke
action.) |On the TH verify DUT sends back a Status Response with the
UNSUPPORTED_ACCESS status code.

|9 |8.8.2.3 | |TH sends Invoke Request Message to the DUT with the
command in the path that requires a Timed Invoke transaction to invoke
and this action is not part of a Timed Invoke transaction |On the TH
verify that the DUT sends a status code NEEDS_TIMED_INTERACTION.
|===

[[_notestesting_considerations_77]]
====== link:#_notestesting_considerations_77[]Notes/Testing Considerations

Test Steps #7 cannot be executed with V1.0 SDK

'''''

'''''

[[_read_transaction_test_cases]]
==== link:#_read_transaction_test_cases[]32.2. Read Transaction Test Cases

'''''

[[_tc_idm_2_1_read_request_action_from_dut_to_th_dut_as_client]]
===== link:#_tc_idm_2_1_read_request_action_from_dut_to_th_dut_as_client[]32.2.1. [TC-IDM-2.1] Read Request Action from DUT to TH. [DUT as Client]

[[_category_111]]
====== link:#_category_111[]Category

Functional, Protocol

[[_purpose_112]]
====== link:#_purpose_112[]Purpose

Verifying the Read Request Action sent from the DUT is according to the
specification.

[[_pics_111]]
====== link:#_pics_111[]PICS

* MCORE.IDM.C.ReadRequest

[[_required_devices_111]]
====== link:#_required_devices_111[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as device which is the recipient of the Read
Request Message - Server

|2 |DUT |DUT as the device which sends the Read Request Message - Client
|===

[[_device_topology_64]]
====== link:#_device_topology_64[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_53]]
====== link:#_test_setup_53[]Test Setup

Test will need a reference implementation of the cluster of which the
DUT is the client. TH with Manufacturer specific clusters and attributes
to be used for Test #21.

[[_test_procedure_111]]
====== link:#_test_procedure_111[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read one attribute on a given cluster and endpoint. +
AttributePath = [[Endpoint = Specific Endpoint, Cluster = Specific
ClusterID, Attribute = Specific Attribute]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|2 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read all attributes on a given cluster and Endpoint +
AttributePath = [[Endpoint = Specific Endpoint, Cluster = Specific
ClusterID]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|3 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read all attributes in all clusters and all endpoints +
Path = [[ ]] +
On receipt of this message, TH should send a report data action with the
attribute values to the DUT. |Verify that the TH receives the right Read
Request Message. +

|4 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read a specific attribute from all endpoints and all clusters. +
AttributePath = [[ Attribute = Specific Attribute]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|5 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read all attributes from a specific cluster on all endpoints +
AttributePath = [[ Cluster = Specific ClusterID]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|6 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read a specific attribute from a given cluster on all endpoints. +
AttributePath = [[ Cluster = Specific Cluster, Attribute = specific
attribute]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|7 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read all attributes from all clusters at a given endpoint. +
AttributePath = [[ Endpoint = Specific Endpoint]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|8 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to a
specific endpoint to read a particular attribute from all the clusters
at that endpoint +
AttributePath = [[ Endpoint = Specific Endpoint, Attribute = specific
attribute]] +
On receipt of this message, TH should send a report data action with the
attribute value to the DUT. |Verify that the TH receives the right Read
Request Message. +

|9 |8.4.2.1/10.6.2 |MCORE.IDM.C.ReadRequest.Attribute.DataType_Bool |DUT
sends the Read Request Message to the TH to read an attribute of data
type bool. + |Verify that the TH receives the right Read Request
Message.

|10 |8.4.2.1/10.6.2 |MCORE.IDM.C.ReadRequest.Attribute.DataType_String
|DUT sends the Read Request Message to the TH to read an attribute of
data type string. + |Verify that the TH receives the right Read Request
Message.

|11 |8.4.2.1/10.6.2
|MCORE.IDM.C.ReadRequest.Attribute.DataType_UnsignedInteger |DUT sends
the Read Request Message to the TH to read an attribute of data type
unsigned integer. + |Verify that the TH receives the right Read Request
Message.

|12 |8.4.2.1/10.6.2
|MCORE.IDM.C.ReadRequest.Attribute.DataType_SignedInteger |DUT sends the
Read Request Message to the TH to read an attribute of data type signed
integer. + |Verify that the TH receives the right Read Request Message.

|13 |8.4.2.1/10.6.2
|MCORE.IDM.C.ReadRequest.Attribute.DataType_FloatingPoint |DUT sends the
Read Request Message to the TH to read an attribute of data type
floating point. + |Verify that the TH receives the right Read Request
Message.

|14 |8.4.2.1/10.6.2
|MCORE.IDM.C.ReadRequest.Attribute.DataType_OctetString |DUT sends the
Read Request Message to the TH to read an attribute of data type Octet
String. + |Verify that the TH receives the right Read Request Message.

|15 |8.4.2.1/10.6.2 |MCORE.IDM.C.ReadRequest.Attribute.DataType_Struct
|DUT sends the Read Request Message to the TH to read an attribute of
data type Struct. + |Verify that the TH receives the right Read Request
Message.

|16 |8.4.2.1/10.6.2 |MCORE.IDM.C.ReadRequest.Attribute.DataType_List
|DUT sends the Read Request Message to the TH to read an attribute of
data type List. + |Verify that the TH receives the right Read Request
Message.

|17 |8.4.2.1/10.6.2 |MCORE.IDM.C.ReadRequest.Attribute.DataType_Enum
|DUT sends the Read Request Message to the TH to read an attribute of
data type enum. + |Verify that the TH receives the right Read Request
Message.

|18 |8.4.2.1/10.6.2 |MCORE.IDM.C.ReadRequest.Attribute.DataType_Bitmap
|DUT sends the Read Request Message to the TH to read an attribute of
data type bitmap. + |Verify that the TH receives the right Read Request
Message.

|19 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read an attribute +
Repeat the above steps 3 times. |On the TH verify the received Read
Request message is same for all the 3 times. +

|20 |8.4.2.1/10.6.2 | |DUT sends the Read Request Message to the TH to
read something(Attribute) which is larger than 1 MTU(1280 bytes) and per
spec can be chunked. +
For every chunked data message received, except the last one, DUT sends
a status response. |Verify on the TH that the DUT sends a status message
back to the TH on receipt of the report data action for every chunked
message except the last one. +
Verify that the last chunked message DUT does not send a status response
back.

|21 |7.19 | |DUT sends the Read Request Message to the TH with
Manufacturer specific clusters and attributes to read all attributes in
all clusters and all endpoints +
Path = [[ ]]. +
On receipt of this message, TH should send a report data action with the
attribute values to the DUT. |Verify that the TH receives the right Read
Request Message.
|===

[[_notestesting_considerations_78]]
====== link:#_notestesting_considerations_78[]Notes/Testing Considerations

The Cluster and Commands should be based on the cluster implementation
on the DUT.

'''''

[[_tc_idm_2_2_report_data_action_from_dut_to_th_dut_as_server]]
===== link:#_tc_idm_2_2_report_data_action_from_dut_to_th_dut_as_server[]32.2.2. [TC-IDM-2.2] Report Data Action from DUT to TH. [DUT as Server]

[[_category_112]]
====== link:#_category_112[]Category

Functional, Protocol

[[_purpose_113]]
====== link:#_purpose_113[]Purpose

Verifying the Report Data Action sent from the DUT in response to the
Read Request Action is according to the specification.

[[_pics_112]]
====== link:#_pics_112[]PICS

* MCORE.IDM.S

[[_required_devices_112]]
====== link:#_required_devices_112[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness sends Read Request Message - Client

|2 |DUT |DUT as the device which responds to the Read Request Message -
Server
|===

[[_device_topology_65]]
====== link:#_device_topology_65[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_54]]
====== link:#_test_setup_54[]Test Setup

N/A

[[_test_procedure_112]]
====== link:#_test_procedure_112[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read one attribute on a given cluster and endpoint. +
AttributePath = [[Endpoint = Specific Endpoint, Cluster = Specific
ClusterID, Attribute = Specific Attribute]] +
On receipt of this message, DUT should send a report data action with
the attribute value to the DUT. |On the TH verify the received report
data message has the right attribute values.

|2 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read all attributes on a given cluster and Endpoint +
AttributePath = [[Endpoint = Specific Endpoint, Cluster = Specific
ClusterID]] +
On receipt of this message, DUT should send a report data action with
the attribute value to the DUT. |On the TH verify the received report
data message has only the attributes that the TH has privilege to.

|3 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read an attribute from a cluster at all Endpoints +
AttributePath = [[Cluster = Specific ClusterID, Attribute = Specific
Attribute]] +
On receipt of this message, DUT should send a report data action with
the attribute value from all the Endpoints to the DUT. |On the TH verify
the received report data message has all the right attribute values.

|4 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read a global attribute from all clusters at that Endpoint +
AttributePath = [[Endpoint = Specific Endpoint, Attribute = Specific
Global Attribute]] +
On receipt of this message, DUT should send a report data action with
the attribute value from all the clusters to the DUT. |On the TH verify
the received report data message has all the right attribute values.

|5 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read all attributes from all clusters on all Endpoints +
AttributePath = [[]] +
On receipt of this message, DUT should send a report data action with
the attribute value from all the clusters to the DUT. |On the TH verify
the received report data message has all the right attribute values.

|6 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read a global attribute from all clusters at all Endpoints +
AttributePath = [[Attribute = Specific Global Attribute]] +
On receipt of this message, DUT should send a report data action with
the attribute value from all the clusters to the DUT. |On the TH verify
the received report data message has all the right attribute values.

|7 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read all attributes from a cluster at all Endpoints +
AttributePath = [[Cluster = Specific ClusterID]] +
On receipt of this message, DUT should send a report data action with
the attribute value from all the Endpoints to the DUT. |On the TH verify
the received report data message has all the right attribute values.

|8 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read all attributes from all clusters at one Endpoint +
AttributePath = [[Endpoint = Specific Endpoint]] +
On receipt of this message, DUT should send a report data action with
the attribute value from all the Endpoints to the DUT. |On the TH verify
the received report data message has all the right attribute values.

|9 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_Bool |TH sends the
Read Request Message to the DUT to read an attribute of data type
bool. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|10 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_String |TH sends the
Read Request Message to the DUT to read an attribute of data type
string. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|11 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_UnsignedInteger |TH
sends the Read Request Message to the DUT to read an attribute of data
type unsigned integer. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|12 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_SignedInteger |TH
sends the Read Request Message to the DUT to read an attribute of data
type signed integer. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|13 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_FloatingPoint |TH
sends the Read Request Message to the DUT to read an attribute of data
type floating point. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|14 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_OctetString |TH
sends the Read Request Message to the DUT to read an attribute of data
type Octet String. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|15 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_Struct |TH sends the
Read Request Message to the DUT to read an attribute of data type
Struct. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|16 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_List |TH sends the
Read Request Message to the DUT to read an attribute of data type
List. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|17 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_Enum |TH sends the
Read Request Message to the DUT to read an attribute of data type
enum. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|18 |8.4.3.1/10.6.3 |MCORE.IDM.S.Attribute.DataType_Bitmap |TH sends the
Read Request Message to the DUT to read an attribute of data type
bitmap. +
DUT responds with the report data action with the right attribute value.
|Verify on the TH that the DUT sends the right attribute value

|19 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read any attribute to an unsupported node. +
DUT responds with the report data action. |Verify on the TH that the DUT
sends the status code UNSUPPORTED_NODE

|20 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read any attribute to an unsupported Endpoint. +
DUT responds with the report data action. |Verify on the TH that the DUT
sends the status code UNSUPPORTED_ENDPOINT

|21 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read any attribute to an unsupported cluster. +
DUT responds with the report data action. |Verify on the TH that the DUT
sends the status code UNSUPPORTED_CLUSTER

|22 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read an unsupported attribute +
DUT responds with the report data action. |Verify on the TH that the DUT
sends the status code UNSUPPORTED_ATTRIBUTE

|23 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read an attribute which is not readable. +
DUT responds with the report data action. |Verify on the TH that the DUT
sends the status code UNSUPPORTED_READ

|24 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read an attribute in the path that requires a privilege that is not
granted for the cluster in the path. +
DUT responds with the report data action. |Verify on the TH that the DUT
sends the status code UNSUPPORTED_ACCESS(0x7E)

|25 |8.4.3.1/10.6.3 | |TH sends the Read Request Message to the DUT to
read an attribute +
Repeat the above steps 3 times. |On the TH verify the received Report
data message has the right attribute values for all the 3 times.

|26 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read a particular attribute with the DataVersionFilter Field not set. +
DUT sends back the attribute value with the DataVersion of the
cluster. +
TH sends a second read request to the same cluster with the
DataVersionFilter Field set with the dataversion value received before.
|DUT should not send a report data action with the attribute value to
the TH if the data version is same as that requested.

|27 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read a particular attribute with the DataVersionFilter Field not set. +
DUT sends back the attribute value with the DataVersion of the
cluster. +
TH sends a write request to the same cluster to write to any
attribute. +
TH sends a second read request to read an attribute from the same
cluster with the DataVersionFilter Field set with the dataversion value
received before. |DUT should send a report data action with the
attribute value to the TH.

|28 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read all attributes on a cluster with the DataVersionFilter Field not
set. +
DUT sends back the all the attribute values with the DataVersion of the
cluster. +
TH sends a write request to the same cluster to write to any
attribute. +
TH sends a second read request to read all the attributes from the same
cluster with the DataVersionFilter Field set with the dataversion value
received before. |DUT should send a report data action with all the
attribute values to the TH.

|29 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read a particular attribute on a particular cluster with the
DataVersionFilter Field not set. +
DUT sends back the attribute value with the DataVersion of the
cluster. +
TH sends a read request to the same cluster to read any attribute with
the right DataVersion(received in the previous step) and also an older
DataVersion. +
The Read Request Message should have 2 DataVersionIB filters. |DUT
should send a report data action with the attribute value to the TH.

|30 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read any supported attribute/wildcard on a particular cluster say A with
the DataVersionFilter Field not set. +
DUT sends back the attribute value with the DataVersion of the cluster
A. +
TH sends a Read Request Message to read any supported attribute/wildcard
on cluster A and any supported attribute/wildcard on another cluster
B. +
DataVersionList field should only contain the DataVersion of cluster A.
|Verify that the DUT sends a report data action with the attribute value
from the cluster B to the TH. +
Verify that the DUT does not send the attribute value from cluster A.

|31 |8.4.2.1/10.6.2 |MCORE.IDM.S.LargeData |TH sends a Read Request
Message to the DUT to read something(Attribute) which is larger than 1
MTU(1280 bytes) and per spec can be chunked + |Verify on the TH that the
DUT sends a chunked data message with the SuppressResponse field set to
False for all the messages except the last one. +
Verify the last chunked message sent has the SuppressResponse field set
to True.

|32 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read a non global attribute from all clusters at that Endpoint +
AttributePath = [[Endpoint = Specific Endpoint, Attribute = Specific Non
Global Attribute]] + |On the TH verify that the DUT sends an error
message and not the value of the attribute.

|33 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to the DUT to
read a non global attribute from all clusters at all Endpoints +
AttributePath = [[Attribute = Specific Non Global Attribute]] + |On the
TH verify that the DUT sends an error message and not the value of the
attribute.

|34 |8.4.3.1/10.6.3 | |TH should have access to only a single cluster at
one Endpoint1. +
TH sends a Read Request Message to the DUT to read all attributes from
all clusters at Endpoint1 +
AttributePath = [[Endpoint = Specific Endpoint]] + |Verify that the DUT
sends back data of all attributes only from that one cluster to which it
has access. +
Verify that there are no errors sent back for attributes the TH has no
access to.

|35 |8.4.3.1/10.6.3 | |TH sends a Read Request Message to read all
events and attributes from the DUT. |Verify that the DUT sends back data
of all attributes and events that the TH has access to.
|===

[[_notestesting_considerations_79]]
====== link:#_notestesting_considerations_79[]Notes/Testing Considerations

The Cluster and Commands should be based on the cluster implementation
on the DUT. +
Test Steps #19 cannot be executed with V1.0 SDK

'''''

'''''

[[_write_transaction_test_cases]]
==== link:#_write_transaction_test_cases[]32.3. Write Transaction Test Cases

'''''

[[_tc_idm_3_1_write_request_action_from_dut_to_th_dut_as_client]]
===== link:#_tc_idm_3_1_write_request_action_from_dut_to_th_dut_as_client[]32.3.1. [TC-IDM-3.1] Write Request Action from DUT to TH. [DUT as Client]

[[_category_113]]
====== link:#_category_113[]Category

Functional, Protocol

[[_purpose_114]]
====== link:#_purpose_114[]Purpose

Verifying the Write Request Action sent from the DUT is according to the
specification.

[[_pics_113]]
====== link:#_pics_113[]PICS

* MCORE.IDM.C.WriteRequest

[[_required_devices_113]]
====== link:#_required_devices_113[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as device which is the recipient of the Write
Request Message - Server

|2 |DUT |DUT as the device which sends the Write Request Message -
Client
|===

[[_device_topology_66]]
====== link:#_device_topology_66[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_55]]
====== link:#_test_setup_55[]Test Setup

Test will need a reference implementation of the cluster of which the
DUT is the client.

[[_test_procedure_113]]
====== link:#_test_procedure_113[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.7.2.1/10.6.6 | |DUT sends the WriteRequestMessage to the TH to
modify one attribute data + |Verify on the TH that the correct
WriteRequestMessage has been received. +

|2 |8.7.2.1/10.6.6 | |DUT sends the WriteRequestMessage to the TH to
modify one attribute on all Endpoints. +
On receipt of this message, TH should modify the attribute and send a
WriteResponseMessage to the DUT. |Verify on the TH that the correct
WriteRequestMessage has been received.

|3 |8.7.2.1/10.6.6 |MCORE.IDM.C.WriteRequest.Attribute.DataType_Bool
|DUT sends the WriteRequestMessage to the TH to write an attribute of
data type bool. + |Verify on the TH that the correct WriteRequestMessage
has been received.

|4 |8.7.2.1/10.6.6 |MCORE.IDM.C.WriteRequest.Attribute.DataType_String
|DUT sends the WriteRequestMessage to the TH to write an attribute of
data type string. + |Verify on the TH that the correct
WriteRequestMessage has been received.

|5 |8.7.2.1/10.6.6
|MCORE.IDM.C.WriteRequest.Attribute.DataType_UnsignedInteger |DUT sends
the WriteRequestMessage to the TH to write an attribute of data type
unsigned integer. + |Verify on the TH that the correct
WriteRequestMessage has been received.

|6 |8.7.2.1/10.6.6
|MCORE.IDM.C.WriteRequest.Attribute.DataType_SignedInteger |DUT sends
the WriteRequestMessage to the TH to write an attribute of data type
signed integer. + |Verify on the TH that the correct WriteRequestMessage
has been received.

|7 |8.7.2.1/10.6.6
|MCORE.IDM.C.WriteRequest.Attribute.DataType_FloatingPoint |DUT sends
the WriteRequestMessage to the TH to write an attribute of data type
floating point. + |Verify on the TH that the correct WriteRequestMessage
has been received.

|8 |8.7.2.1/10.6.6
|MCORE.IDM.C.WriteRequest.Attribute.DataType_OctetString |DUT sends the
WriteRequestMessage to the TH to write an attribute of data type Octet
String. + |Verify on the TH that the correct WriteRequestMessage has
been received.

|9 |8.7.2.1/10.6.6 |MCORE.IDM.C.WriteRequest.Attribute.DataType_Struct
|DUT sends the WriteRequestMessage to the TH to write an attribute of
data type Struct. + |Verify on the TH that the correct
WriteRequestMessage has been received.

|10 |8.7.2.1/10.6.6 |MCORE.IDM.C.WriteRequest.Attribute.DataType_List
|DUT sends the WriteRequestMessage to the TH to write an attribute of
data type List. + |Verify on the TH that the correct WriteRequestMessage
has been received.

|11 |8.7.2.1/10.6.6 |MCORE.IDM.C.WriteRequest.Attribute.DataType_Enum
|DUT sends the WriteRequestMessage to the TH to write an attribute of
data type enum. + |Verify on the TH that the correct WriteRequestMessage
has been received.

|12 |8.7.2.1/10.6.6 |MCORE.IDM.C.WriteRequest.Attribute.DataType_Bitmap
|DUT sends the WriteRequestMessage to the TH to write an attribute of
data type bitmap. + |Verify on the TH that the correct
WriteRequestMessage has been received.

|13 |8.7.2.1/10.6.6 | |DUT sends a WriteRequestMessage to the TH with a
large list of attribute data, which is larger than 1 MTU(1280 bytes),
that has to be sent in multiple messages. |Verify on the TH that the
correct WriteRequestMessage has been received and MoreChunkedMessages is
set to True. Verify that the DUT waits for the WriteResponse action from
the TH before sending the next WriteRequestMessage.

|14 |8.7.2.1/10.6.6 | |DUT sends the WriteRequestMessage to the TH to
write one attribute on a given cluster and endpoint. +
Repeat the above steps 3 times. |Verify on the TH that the correct
WriteRequestMessage has been received. for all the 3 times.

|15 |8.7.3.1/10.6.7 | |DUT sends a ReadRequest message to the TH to read
any attribute on two clusters. +
TH returns with a report data action with the attribute values and the
dataversions of the clusters. +
DUT sends a WriteRequestMessage to the DUT to both the clusters with the
appropriate dataversions(received in the previous step) to modify the
value of an attribute + |Verify that the TH sends a Write Response
message with a success back to the DUT. +
Verify by sending a ReadRequest that the Write Action on TH was
successful.
|===

[[_notestesting_considerations_80]]
====== link:#_notestesting_considerations_80[]Notes/Testing Considerations

The Cluster and Commands should be based on the cluster implementation
on the DUT. +
Test Steps #2 and #15 cannot be executed with V1.0 SDK

'''''

[[_tc_idm_3_2_write_response_action_from_dut_to_th_dut_as_server]]
===== link:#_tc_idm_3_2_write_response_action_from_dut_to_th_dut_as_server[]32.3.2. [TC-IDM-3.2] Write Response Action from DUT to TH. [DUT as Server]

[[_category_114]]
====== link:#_category_114[]Category

Functional, Protocol

[[_purpose_115]]
====== link:#_purpose_115[]Purpose

Verifying the Write Response Action sent from the DUT in response to the
Write Request Action is according to the specification.

[[_pics_114]]
====== link:#_pics_114[]PICS

* MCORE.IDM.S

[[_required_devices_114]]
====== link:#_required_devices_114[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness sends Write Request Message
|2 |DUT |DUT as the device which responds with a Write Response Message.
|===

[[_device_topology_67]]
====== link:#_device_topology_67[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_56]]
====== link:#_test_setup_56[]Test Setup

[[_test_procedure_114]]
====== link:#_test_procedure_114[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write one attribute on a given cluster and endpoint. +
On receipt of this message, DUT should send a write response action. |On
the TH verify the DUT sends a WriteResponseMessage with the status set
to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|2 |8.7.3.1/10.6.7 | |TH sends a WriteRequestMessage to the DUT to write
to an attribute on all endpoints. +
On receipt of this message, DUT should send a Write Response action |On
the TH verify the DUT sends a WriteResponseMessage with the status set
to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|3 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_Bool |TH sends the
WriteRequestMessage to the DUT to write an attribute of data type bool.
+ |On the TH verify the DUT sends a WriteResponseMessage with the status
set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|4 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_String |TH sends
the WriteRequestMessage to the DUT to write an attribute of data type
string. + |On the TH verify the DUT sends a WriteResponseMessage with
the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|5 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_UnsignedInteger |TH
sends the WriteRequestMessage to the DUT to write an attribute of data
type unsigned integer. + |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|6 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_SignedInteger |TH
sends the WriteRequestMessage to the DUT to write an attribute of data
type signed integer. + |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|7 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_FloatingPoint |TH
sends the WriteRequestMessage to the DUT to write an attribute of data
type floating point. + |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|8 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_OctetString |TH
sends the WriteRequestMessage to the DUT to write an attribute of data
type Octet String. + |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|9 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_Struct |TH sends
the WriteRequestMessage to the DUT to write an attribute of data type
Struct. + |On the TH verify the DUT sends a WriteResponseMessage with
the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|10 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_List |TH sends the
WriteRequestMessage to the DUT to write an attribute of data type List.
+ |On the TH verify the DUT sends a WriteResponseMessage with the status
set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|11 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_Enum |TH sends the
WriteRequestMessage to the DUT to write an attribute of data type enum.
+ |On the TH verify the DUT sends a WriteResponseMessage with the status
set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|12 |8.7.3.1/10.6.7 |MCORE.IDM.S.Attribute_W.DataType_Bitmap |TH sends
the WriteRequestMessage to the DUT to write an attribute of data type
bitmap. + |On the TH verify the DUT sends a WriteResponseMessage with
the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|13 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write any attribute on an unsupported node. +
DUT responds with the Write Response action |Verify on the TH that the
DUT sends the status code UNSUPPORTED_NODE

|14 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write any attribute on an unsupported Endpoint. +
DUT responds with the Write Response action |Verify on the TH that the
DUT sends the status code UNSUPPORTED_ENDPOINT

|15 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write any attribute on an unsupported cluster. +
DUT responds with the Write Response action |Verify on the TH that the
DUT sends the status code UNSUPPORTED_CLUSTER

|16 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write an unsupported attribute +
DUT responds with the Write Response action |Verify on the TH that the
DUT sends the status code UNSUPPORTED_ATTRIBUTE

|17 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write an attribute which is not writable. +
DUT responds with the Write Response action |Verify on the TH that the
DUT sends the status code UNSUPPORTED_WRITE

|18 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write to an attribute in the path that requires a privilege that is not
granted for the cluster in the path. +
DUT responds with the Write Response action |Verify on the TH that the
DUT sends the status code UNSUPPORTED_ACCESS

|19 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
write one attribute on a given cluster and endpoint. +
Repeat the above steps 3 times. |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified for all 3 times.

|20 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
modify the value of one attribute on a given cluster and endpoint to
null. + |On the TH verify the DUT sends a WriteResponseMessage with the
status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|21 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
append an attribute value + |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|22 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
delete an attribute value + |On the TH verify the DUT sends a
WriteResponseMessage with the status set to Success. +
Verify the updated value by sending a ReadRequestMessage to read the
value that was modified.

|23 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
modify the value of one attribute and Set SuppressResponse to True. +
|On the TH verify that the DUT does not send a Write Response message
with a success back to the TH.

|24 |8.7.3.1/10.6.7 | |TH sends a ReadRequest message to the DUT to read
any attribute on any cluster. +
DUT returns with a report data action with the attribute values and the
dataversion of the cluster. +
TH sends a WriteRequestMessage to the DUT to modify the value of one
attribute with the DataVersion field set to the one received in the
prior step. + |Verify that the DUT sends a Write Response message with a
success back to the TH. +
Verify by sending a ReadRequest that the Write Action on DUT was
successful.

|25 |8.7.3.1/10.6.7 | |TH sends a ReadRequest message to the DUT to read
any attribute on any cluster. +
DUT returns with a report data action with the attribute values and the
dataversion of the cluster. +
TH sends a WriteRequestMessage to the DUT to modify the value of one
attribute no DataVersion indicated. +
TH sends a second WriteRequestMessage to the DUT to modify the value of
an attribute with the dataversion field set to the value received
earlier. |Verify that the DUT sends a Write Response message with the
error DATA_VERSION_MISMATCH for the second Write request.

|26 |8.7.3.1/10.6.7 | |TH sends the WriteRequestMessage to the DUT to
modify the value of a specific attribute data that needs Timed Write
transaction to write and this action is not part of a Timed Write
transaction. |On the TH verify that the DUT sends a status code
NEEDS_TIMED_INTERACTION.
|===

[[_notestesting_considerations_81]]
====== link:#_notestesting_considerations_81[]Notes/Testing Considerations

. The Cluster and Commands should be based on the cluster implementation
on the DUT.
. Test Steps 2, 13, 20, 21, 22 and 23 cannot be executed with V1.0 SDK

'''''

'''''

[[_subscription_transaction_test_cases]]
==== link:#_subscription_transaction_test_cases[]32.4. Subscription Transaction Test Cases

'''''

[[_tc_idm_4_1_subscriptionrequestmessage_from_dut_test_cases_dut_as_client]]
===== link:#_tc_idm_4_1_subscriptionrequestmessage_from_dut_test_cases_dut_as_client[]32.4.1. [TC-IDM-4.1] SubscriptionRequestMessage from DUT test cases. [DUT as Client]

[[_category_115]]
====== link:#_category_115[]Category

Functional

[[_purpose_116]]
====== link:#_purpose_116[]Purpose

This test case will verify the subscription request messages sent from
the DUT to the target node

[[_pics_115]]
====== link:#_pics_115[]PICS

* MCORE.IDM.C.SubscribeRequest

[[_required_devices_115]]
====== link:#_required_devices_115[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as Publisher/Server
|2 |DUT |DUT as subscriber/Client
|===

[[_device_topology_68]]
====== link:#_device_topology_68[]Device Topology

DUT and TH are on the same fabric

[[_test_procedure_115]]
====== link:#_test_procedure_115[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest |DUT sends a subscription
request message to the target node/reference device for a single
attribute of any data type supported. |On the reference device verify
the subscription message received has the following fields. +
KeepSubscriptions which is of type bool +
MinIntervalFloor which is of type uint16 +
MaxIntervalCeiling which is of type uint16 +
[Optional]AttributeRequests which is of type list and contains the
attribute paths +
[Optional]DataVersionFilters which is of type list and contains the data
versions of the attributes requested.+ +
[Optional]EventRequests which is of type list +
[Optional]EventFilters which is of type list +
[Optional]FabricFiltered which is of type bool +

|2 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest |DUT sends the
subscription request message to TH +
TH sends a report data +
DUT sends the status response back to TH |Verify on the TH that the
status response received from the DUT is "Success"

|3 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest.Attribute.DataType_Bool
|Activate the subscription between the DUT and the TH for an attribute
of data type boolean. +
Modify that attribute on the TH. TH should send the modified data to the
DUT. +
Modify the attribute multiple times (3 times). |Verify on the TH that
the status response received from the DUT for every report data sent is
a "Success"

|4 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest.Attribute.DataType_String
|Activate the subscription between the DUT and the TH for an attribute
of data type string. +
Modify that attribute on the TH. TH should send the modified data to the
DUT. +
Modify the attribute multiple times (3 times). |Verify on the TH that
the status response received from the DUT for every report data sent is
a "Success"

|5 |10.6.4/8.5.2
|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_UnsignedInteger
|Activate the subscription between the DUT and the TH for an attribute
of data type unsigned integer. +
Modify that attribute on the TH. TH should send the modified data to the
DUT. +
Modify the attribute multiple times (3 times). |Verify on the TH that
the status response received from the DUT for every report data sent is
a "Success"

|6 |10.6.4/8.5.2
|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_Integer |Activate the
subscription between the DUT and the TH for an attribute of data type
signed integer. +
Modify that attribute on the TH. +
TH should send the modified data to the DUT. +
Modify the attribute multiple times (3 times) |Verify on the TH that the
status response received from the DUT for every report data sent is a
"Success"

|7 |10.6.4/8.5.2
|MCORE.IDM.C.SubscribeRequest.Attribute.DataType_FloatingPoint |Activate
the subscription between the DUT and the TH for an attribute of data
type Floating Point. +
Modify that attribute on the TH. +
TH should send the modified data to the DUT. +
Modify the attribute multiple times (3 times) |Verify on the TH that the
status response received from the DUT for every report data sent is a
"Success"

|8 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest.Attribute.DataType_List
|Activate the subscription between the DUT and the TH for an attribute
of data type list. +
Modify that attribute on the TH. TH should send the modified data to the
DUT. +
Modify the attribute multiple times (3 times) |Verify on the TH that the
status response received from the DUT for every report data sent is a
"Success"

|9 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest |Activate the
subscription between the DUT and the TH for an attribute. +
Force the TH to not send any report data for the duration of the maximum
interval. +
After the maximum interval, TH sends a report data with the subscription
id created during the subscription activation. |Verify on the TH that
the status response received from the DUT says "INVALID_SUBSCRIPTION".

|10 |10.6.4/8.5.2 |MCORE.IDM.C.SubscribeRequest.MultipleAttributes |DUT
sends a subscription request message to the target node/reference device
for multiple attributes (>1 attributes). |On the reference device verify
the subscription request message received has the following fields. +
KeepSubscriptions which is of type bool +
MinIntervalFloor which is of type uint16 +
MaxIntervalCeiling which is of type uint16 +
AttributeRequests which is of type list and contains the paths for the
requested attributes. +
DataVersionFilters which is of type list and contains the data versions
of the attributes requested. +
[Optional]EventRequests which is of type list +
[Optional]EventFilters which is of type list +
FabricFiltered which is of type bool +
|===

[[_notestesting_considerations_82]]
====== link:#_notestesting_considerations_82[]Notes/Testing Considerations

The Expected Outcome for the tests is verified by looking at the pretty
printed TLV on the TH. +
Vendor needs to specify how to trigger the subscription on the DUT.

'''''

[[_tc_idm_4_2_subscription_response_messages_from_dut_test_cases_dut_as_server]]
===== link:#_tc_idm_4_2_subscription_response_messages_from_dut_test_cases_dut_as_server[]32.4.2. [TC-IDM-4.2] Subscription Response Messages from DUT Test Cases. [DUT as Server]

[[_category_116]]
====== link:#_category_116[]Category

Functional

[[_purpose_117]]
====== link:#_purpose_117[]Purpose

This test case will verify the subscription response messages sent in
response to the subscription request messages to activate a subscription
are according to specification.

[[_pics_116]]
====== link:#_pics_116[]PICS

* MCORE.IDM.S

[[_required_devices_116]]
====== link:#_required_devices_116[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as the subscriber - client

|2 |TH2 |Test harness as the subscriber with limited access to the DUT -
client

|3 |DUT |DUT as the target of the subscription - server
|===

[[_device_topology_69]]
====== link:#_device_topology_69[]Device Topology

DUT, TH and TH2 are on the same fabric. +
TH2 is setup such that it has limited access to the DUT based on the
test step.

[[_test_procedure_116]]
====== link:#_test_procedure_116[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|0a |2.11.2.2 |!ICDM.S | |SUBSCRIPTION_MAX_INTERVAL_PUBLISHER_LIMIT = 60
mins

|0b |2.11.2.2 |ICDM.S |TH reads from the DUT the _IdleModeInterval_
attribute. |SUBSCRIPTION_MAX_INTERVAL_PUBLISHER_LIMIT =
_IdleModeInterval_

|1 |10.6.5/8.5.3 | |TH sends a subscription message to the DUT with
_MaxIntervalCeiling_ set to a value greater than
_SUBSCRIPTION_MAX_INTERVAL_PUBLISHER_LIMIT_. +
DUT sends a report data action to the TH. +
TH sends a success status response to the DUT. +
DUT sends a Subscribe Response Message to the TH to activate the
subscription. |Verify on the TH, a report data message is received. +
Verify it contains the following data +
Report data - data of the attribute/event requested earlier. +
Verify on the TH the Subscribe Response has the following fields, +
_SubscriptionId_ - Verify it is of type uint32. +
_MaxInterval_ - Verify it is of type uint32. +
Verify that the _MaxInterval_ is less than or equal to
_MaxIntervalCeiling_.

|2 |10.6.5/8.5.3 | |TH sends a subscription message to the DUT with
_MaxIntervalCeiling_ set to a value less than
_SUBSCRIPTION_MAX_INTERVAL_PUBLISHER_LIMIT_. +
DUT sends a report data action to the TH. +
TH sends a success status response to the DUT. +
DUT sends a Subscribe Response Message to the TH to activate the
subscription. |Verify on the TH, a report data message is received. +
Verify it contains the following data +
Report data - data of the attribute/event requested earlier. +
Verify on the TH the Subscribe Response has the following fields, +
_SubscriptionId_ - Verify it is of type uint32. +
_MaxInterval_ - Verify it is of type uint32. +
Verify that the _MaxInterval_ is less than or equal to
_SUBSCRIPTION_MAX_INTERVAL_PUBLISHER_LIMIT_.

|3 |10.6.5/8.5.3 | |Setup TH2 such that it does not have access to a
specific cluster. +
TH2 sends a subscription message to subscribe to an attribute on that
cluster for which it does not have access. +
AttributePath = [[Attribute = Attribute, Cluster = ClusterID, Endpoint =
EndpointID ]]. |Verify that the DUT returns a "INVALID_ACTION" status
response.

|4 |10.6.5/8.5.3 | |Setup TH2 such that it does not have access to all
attributes on a specific cluster and endpoint. +
TH2 sends a subscription request to subscribe to all attributes for
which it does not have access. +
AttributePath = [[Cluster = ClusterID, Endpoint = EndpointID ]]. |Verify
that the DUT returns a "INVALID_ACTION" status response.

|5 |10.6.5/8.5.3 | |Setup TH2 such that it does not have access to an
Endpoint. +
TH2 sends a subscription request to subscribe to all attributes on all
clusters on a specific Endpoint for which it does not have access. +
AttributePath = [[ Endpoint = EndpointID ]]. |Verify that the DUT
returns a "INVALID_ACTION" status response.

|6 |10.6.5/8.5.3 | |Setup TH2 such that it does not have access to the
Node. +
TH2 sends a subscription request to subscribe to all attributes on all
clusters on all endpoints on a Node for which it does not have access. +
AttributePath = [[ ]]. |Verify that the DUT returns a "INVALID_ACTION"
status response.

|7 |10.6.5/8.5.3 | |TH sends a subscription request action for an
attribute with an empty DataVersionFilters field. +
DUT sends a report data action with the data of the attribute along with
the data version. +
Tear down the subscription for that attribute. +
Start another subscription with the DataVersionFilter field set to the
data version received above. |Verify that the subscription is activated
between TH and DUT.

|8 |10.6.5/8.5.3 | |TH sends a subscription request action for an
attribute and sets the MinIntervalFloor value to be same as
MaxIntervalCeiling. +
Activate the Subscription between TH and DUT. +
Modify the attribute which has been subscribed to on the DUT. |Verify
that the DUT sends a report data with the value of the attribute after
the MinIntervalFloor time.

|9 |10.6.5/8.5.3 | |TH sends a subscription request action for an
attribute and set the MinIntervalFloor value to be greater than
MaxIntervalCeiling. + |Verify that the DUT sends an error message and
the subscription is not established.

|10 |10.6.5/8.5.3 | |TH sends a subscription request to subscribe to a
specific global attribute from all clusters on all endpoints.
AttributePath = [[Attribute = Global Attribute]]. + |Verify that the
Subscription succeeds and the DUT sends back the attribute values for
the global attribute.

|11 |10.6.5/8.5.3 | |TH sends a subscription request to subscribe to a
global attribute on an endpoint on all clusters. AttributePath =
[[Attribute = Global Attribute, Endpoint = EndpointID ]]. + |Verify that
the Subscription succeeds and the DUT sends back the attribute values
for the global attribute.

|12 |8.4.3.2 | |TH sends a subscription request to the DUT with both
AttributeRequests and EventRequests as empty |Verify that the
Subscription does not succeed and the DUT sends back a Status Response
Action with the INVALID_ACTION Status Code
|===

[[_notestesting_considerations_83]]
====== link:#_notestesting_considerations_83[]Notes/Testing Considerations

Test Steps 3, 4, 5 and 6 cannot be executed with V1.0 SDK

'''''

[[_tc_idm_4_3_report_data_messages_post_subscription_activation_from_dut_test_cases_dut_as_server]]
===== link:#_tc_idm_4_3_report_data_messages_post_subscription_activation_from_dut_test_cases_dut_as_server[]32.4.3. [TC-IDM-4.3] Report Data Messages post Subscription Activation from DUT Test Cases. [DUT as Server]

[[_category_117]]
====== link:#_category_117[]Category

Functional

[[_purpose_118]]
====== link:#_purpose_118[]Purpose

This test case will verify the report data messages sent from the DUT
after activating subscription are according to specification.

[[_pics_117]]
====== link:#_pics_117[]PICS

* MCORE.IDM.S

[[_required_devices_117]]
====== link:#_required_devices_117[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as the subscriber - Client
|2 |DUT |DUT as the target of the subscription - Server
|===

[[_device_topology_70]]
====== link:#_device_topology_70[]Device Topology

DUT and TH are on the same fabric

[[_test_procedure_117]]
====== link:#_test_procedure_117[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a |10.6.5/8.5.3 | |DUT and TH activate the subscription. |Verify on
the TH, a report data message is received. +
Verify on the TH the Subscribe Response has the following fields:
_SubscriptionId_ and _MaxInterval_ +
In the following Steps 2, 3, 5-10, 13, and 15, the _MaxInterval_ time
reference in each step is the _MaxInterval_ presented in the Subscribe
Response of the subscription.

|1b |10.6.5/8.5.3 | |Change the value of the attribute which has been
subscribed on the DUT by manually changing some settings on the
device. +
Example: Temperature sensor may update the value of the room
temperature. +
Turning on/off on a light bulb. |Verify that there is a report data
message sent from the DUT for the changed value of the attribute. +
Verify that the Report Data is sent when the minimum interval time is
reached and before the _MaxInterval_ time.

|2 |10.6.5/8.5.3 | |DUT and TH activate the subscription. +
Change the value of the attribute which has been subscribed on the DUT
by sending an IMWrite or Invoke message to the DUT from the TH. +
|Verify that there is a report data message sent from the DUT for the
changed value of the attribute. +
Verify that the Report Data is sent when the minimum interval time is
reached and before the _MaxInterval_ time.

|3 |10.6.5/8.5.3 | |DUT and TH activate the subscription for an
attribute. +
Do not change the value of the attribute which has been subscribed.
|Verify that there is an empty report data message sent from the DUT to
the TH after _MaxInterval_ time.

|4 |10.6.5/8.5.3 | |DUT and TH activate the subscription. +
Change the value of the attribute which has been subscribed on the
DUT. +
TH force sends a status response with an "invalid subscription". +
Change the value of the attribute which has been subscribed on the DUT.
|Verify that DUT does not send report data for the second time after the
subscription has been terminated.

|5 |10.6.5/8.5.3 |MCORE.IDM.S.Attribute.DataType_Bool |Activate the
subscription between the DUT and the TH for an attribute of data type
bool. +
Modify that attribute on the DUT. +
DUT should send the report data with the modified attribute value. +
Modify the attribute multiple times (3 times) before the _MaxInterval_
time specified during the subscription activation. |Verify on the TH
that the DUT sends the correct value of the attribute.

|6 |10.6.5/8.5.3 |MCORE.IDM.S.Attribute.DataType_String |Activate the
subscription between the DUT and the TH for an attribute of data type
string. +
Modify that attribute on the DUT. +
DUT should send the report data with the modified attribute value +
Modify the attribute multiple times (3 times) before the _MaxInterval_
time specified during the subscription activation. |Verify on the TH
that the DUT sends the correct value of the attribute.

|7 |10.6.5/8.5.3 |MCORE.IDM.S.Attribute.DataType_UnsignedInteger
|Activate the subscription between the DUT and the TH for an attribute
of data type "unsigned integer". +
Modify that attribute on the DUT. +
DUT should send the report data with the modified attribute value. +
Modify the attribute multiple times (3 times) before the _MaxInterval_
time specified during the subscription activation. |Verify on the TH
that the DUT sends the correct value of the attribute.

|8 |10.6.5/8.5.3 |MCORE.IDM.S.Attribute.DataType_SignedInteger |Activate
the subscription between the DUT and the TH for an attribute of data
type "signed integer". +
Modify that attribute on the DUT. +
DUT should send the report data with the modified attribute value. +
Modify the attribute multiple times (3 times)before the _MaxInterval_
time specified during the subscription activation. |Verify on the TH
that the DUT sends the correct value of the attribute.

|9 |10.6.5/8.5.3 |MCORE.IDM.S.Attribute.DataType_FloatingPoint |Activate
the subscription between the DUT and the TH for an attribute of data
type "floating point". +
Modify that attribute on the DUT. +
DUT should send the report data with the modified attribute value. +
Modify the attribute multiple times (3 times) before the _MaxInterval_
time specified during the subscription activation. |Verify on the TH
that the DUT sends the correct value of the attribute.

|10 |10.6.5/8.5.3 |MCORE.IDM.S.Attribute.DataType_List |Activate the
subscription between the DUT and the TH for an attribute of data type
list. +
Modify that attribute on the DUT. +
DUT should send the report data with the modified attribute value. +
Modify the attribute multiple times (3 times) before the _MaxInterval_
time specified during the subscription activation. |Verify on the TH
that the DUT sends the correct value of the attribute.

|11 |10.6.5/8.5.3 | |Activate the subscription between the DUT and the
TH for any attribute. +
KeepSubscriptions flag should be set to False +
After the Maximum interval time is elapsed, TH should send another
subscription request message with different parameters than before. +
KeepSubscriptions flag should be set to False +
Change the value of the attribute requested on the DUT. |Verify that the
DUT sends the changed value of the attribute with the newest
subscription id sent with the second request.

|12 |10.6.5/8.5.3 | |Activate the subscription between the DUT and the
TH for any attribute +
After the Maximum interval time is elapsed, change the value of the
attribute requested on the DUT. |Verify that the DUT sends the changed
value of the attribute to the TH after the next MinIntervalFloor time
has passed.

|13 |10.6.5/8.5.3 | |Activate the subscription between the DUT and the
TH for an attribute +
There are no attribute value changes before _MaxInterval_ elapses.
|Verify that the DUT sends a Report Data action with no data to keep the
subscription alive.

|14 |10.6.5/8.5.2.1 | |TH sends a subscription request action for an
attribute to the DUT with the KeepSubscriptions flag set to True. +
Activate the subscription between DUT and the TH. Initiate another
subscription request action to the DUT for another attribute with the
KeepSubscriptions flag set to True. +
Change both the attribute values on the DUT. |Verify that both the
subscriptions are active and the TH receives reports for both these
attributes on both subscriptions.

|15 |10.6.5/8.5.2.1 | |TH sends a subscription request action for an
attribute to the DUT with the KeepSubscriptions flag set to True.
Activate the subscription between DUT and the TH. Initiate another
subscription request action to the DUT for another attribute with the
KeepSubscriptions flag set to False. Change both the attribute values on
the DUT. |Verify that both the subscriptions are active and the TH
receives notifications for both these attributes. +
Verify that the first subscription is terminated after the _MaxInterval_
of the first subscription is reached.

|16 |10.6.5/8.5.3 | |TH sends a subscription request action for an
attribute and all events. +
Set the MinIntervalFloor to some value say "N"(seconds). +
Change the value of the attribute and trigger an action on the DUT to
trigger any event. |Verify on TH that DUT sends a report action data for
both the attribute and the event after N seconds.

|17 |10.6.5/8.5.3 | |TH sends a subscription request action for
attribute wildcard - AttributePath = [[Endpoint = EndpointID, Cluster =
ClusterID]]. +
Set the MinIntervalFloor to some value say "N"(seconds). +
Change all or few of the attributes on the DUT |Verify that the DUT
sends reports for all the attributes that have changed after N seconds.

|18 |10.6.5/8.5.3 | |TH sends a subscription request to subscribe to an
attribute on a specific cluster from all endpoints AttributePath =
[[Attribute = Attribute, Cluster = ClusterID ]]. +
Set the MinIntervalFloor to some value say "N"(seconds). +
Change the attribute on the DUT |Verify that the DUT sends reports for
all the attributes that have changed after N seconds.

|19 |10.6.5/8.5.3 | |TH sends a subscription request to subscribe to all
attributes from all clusters from all endpoints. AttributePath = [[]]. +
Set the MinIntervalFloor to some value say "N"(seconds). +
Change all or few of the attributes on the DUT |Verify that the DUT
sends reports for all the attributes that have changed after N seconds.

|20 |10.6.5/8.5.3 | |TH sends a subscription request to subscribe to all
attributes from all clusters on an endpoint. AttributePath = [[Endpoint
= EndpointID]]. +
Set the MinIntervalFloor to some value say "N"(seconds). +
Change all or few of the attributes on the DUT |Verify that the DUT
sends reports for all the attributes that have changed after N seconds.

|21 |10.6.5/8.5.3 | |TH sends a subscription request to subscribe to all
attributes from a specific cluster on all endpoints. AttributePath =
[[Cluster = ClusterID]]. +
Set the MinIntervalFloor to some value say "N"(seconds). +
Change all or few of the attributes on the DUT |Verify that the DUT
sends reports for all the attributes that have changed after N seconds.
|===

[[_notestesting_considerations_84]]
====== link:#_notestesting_considerations_84[]Notes/Testing Considerations

The Expected Outcome for the tests is verified by looking at the pretty
printed TLV on the TH. +
Test Steps 17 19, 20 and 21 cannot be executed with V1.0 SDK

'''''

[[_tc_idm_4_4_persistent_subscription_test_cases_dut_as_server]]
===== link:#_tc_idm_4_4_persistent_subscription_test_cases_dut_as_server[]32.4.4. [TC-IDM-4.4] Persistent Subscription Test Cases. [DUT as Server]

[[_category_118]]
====== link:#_category_118[]Category

Functional

[[_purpose_119]]
====== link:#_purpose_119[]Purpose

This test case will verify persistent subscription on a server device.

[[_pics_118]]
====== link:#_pics_118[]PICS

* MCORE.IDM.S
* MCORE.IDM.S.PersistentSubscription

[[_required_devices_118]]
====== link:#_required_devices_118[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as the subscriber - Client
|2 |DUT |DUT as the Publisher - Server
|===

[[_device_topology_71]]
====== link:#_device_topology_71[]Device Topology

DUT and TH are on the same fabric

[[_test_procedure_118]]
====== link:#_test_procedure_118[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |9.3.1.1/8.5.3 | |TH sends a subscription request action for an
attribute to the DUT. Activate the subscription between DUT and the TH.
|Verify on the TH that the Report data messages are sent from the DUT to
the TH with the correct attribute values.

|2 |9.3.1.1/8.5.3 | |Power off the DUT. Power on the DUT immediately.
|Verify on the TH that the subscription between the DUT and TH is
reestablished and DUT is able to send report data messages for the
attribute which was subscribed to in step 1 within the MaxInterval time.
|===

[[_notestesting_considerations_85]]
====== link:#_notestesting_considerations_85[]Notes/Testing Considerations

MaxInterval time will start after all DUT initialization is done
(example: bootup, connect to wifi, etc.)

'''''

'''''

[[_timed_request_action_test_cases]]
==== link:#_timed_request_action_test_cases[]32.5. Timed Request Action Test Cases

'''''

[[_tc_idm_5_1_timed_request_action_from_dut_to_th_dut_as_client]]
===== link:#_tc_idm_5_1_timed_request_action_from_dut_to_th_dut_as_client[]32.5.1. [TC-IDM-5.1] Timed Request Action from DUT to TH. [DUT as Client]

[[_category_119]]
====== link:#_category_119[]Category

Functional, Protocol

[[_purpose_120]]
====== link:#_purpose_120[]Purpose

Verifying the Timed Request Action sent from the DUT is according to the
specification for various scenarios.

[[_pics_119]]
====== link:#_pics_119[]PICS

* MCORE.IDM.C

[[_required_devices_119]]
====== link:#_required_devices_119[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as device which is the recipient of the Timed
Request message - Server

|2 |DUT |DUT as the device which sends the Timed Request Message -
Client
|===

[[_device_topology_72]]
====== link:#_device_topology_72[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_57]]
====== link:#_test_setup_57[]Test Setup

Test will need a reference implementation of the cluster of which the
DUT is the client.

[[_test_procedure_119]]
====== link:#_test_procedure_119[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.8.2.1/10.6.8 |MCORE.IDM.C.InvokeRequest |DUT sends the Timed
Request to the TH and then sends an Invoke Request Message to the TH
after receiving the status response message from the TH. +
The Timed Request Message should contain a timeout value in
milliseconds. (Example - 200 milliseconds) |On the TH verify the
received timed request message has the timeout value as sent by the
DUT. +
Verify that the message is unicast. +
Verify that the DUT sends the Invoke Request Message to the TH before
the specified timeout value. +
Verify that the Invoke Request has TimedRequest set to True.

|2 |8.7.2.2/10.6.8 |MCORE.IDM.C.WriteRequest |DUT sends the Timed
Request to the TH and then sends a WriteRequestMessage to the TH after
receiving the status response message from the TH. +
The Timed Request Message should contain a timeout value in
milliseconds. (Example - 200 milliseconds) |On the TH verify the
received timed request message has the timeout value as sent by the
DUT. +
Verify that the message is unicast. +
Verify that the DUT sends the WriteRequestMessage to the TH before the
specified timeout value. +
Verify the WriteRequestMessage has the TimedRequest field set to TRUE.

|3 |8.7.2.2/10.6.8 |MCORE.IDM.C.WriteRequest OR
MCORE.IDM.C.InvokeRequest |DUT sends the Timed Request to the TH +
The Timed Request Message should contain a timeout value in
milliseconds. (Example - 200 milliseconds) +
Force the TH to not send a response back to the DUT for the received
timed request. |Verify that the DUT does not send a follow up message to
the TH as it did not receive the initial response for the Timed request.
|===

[[_notestesting_considerations_86]]
====== link:#_notestesting_considerations_86[]Notes/Testing Considerations

The DUT should have a way of triggering the Timed Request Message for
Testing. +
Test Step #3 might not be testable.

'''''

[[_tc_idm_5_2_status_response_from_dut_in_response_to_a_timed_request_action_from_th]]
===== link:#_tc_idm_5_2_status_response_from_dut_in_response_to_a_timed_request_action_from_th[]32.5.2. [TC-IDM-5.2] Status Response from DUT in response to a Timed Request Action from TH.

[[_category_120]]
====== link:#_category_120[]Category

Functional, Protocol

[[_purpose_121]]
====== link:#_purpose_121[]Purpose

Verifying that the DUT sends a status response when a Timed Request
Action is received. Verifies other error conditions as well.

[[_pics_120]]
====== link:#_pics_120[]PICS

* MCORE.IDM.S

[[_required_devices_120]]
====== link:#_required_devices_120[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as device which sends the Timed Request Message -
Client

|2 |DUT |DUT as the device which receives the Timed Request Message -
Server
|===

[[_device_topology_73]]
====== link:#_device_topology_73[]Device Topology

TH and DUT will be commissioned and are on the same fabric.

[[_test_setup_58]]
====== link:#_test_setup_58[]Test Setup

TH will act as the client.

[[_test_procedure_120]]
====== link:#_test_procedure_120[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.8.2.1/10.6.8 | |TH sends a Timed Request Message with the timeout
value set. (Example - 200 milliseconds). + |On the TH verify the DUT
sends a status response back to TH.

|2 |8.7.2.2/10.6.8 | |TH sends a Timed Request Message(Timed Write
Transaction) with the timeout value set. (Example - 200 milliseconds). +
Wait for the status response message to be received. +
Send the Write Request Message to the DUT. |On the TH verify DUT sends
back a Write Response after performing the write action. +
Verify by sending a ReadRequest that the Write action was performed
correctly.

|3 |8.7.2.2/10.6.8 | |TH sends a Timed Request Message(Timed Invoke
Transaction) with the timeout value set. (Example - 200 milliseconds). +
Wait for the status response message to be received. +
Wait for 5 seconds(Timer has expired) and then send the Invoke Request
Message to the DUT. |On the TH verify DUT sends back a Status Response
with the UNSUPPORTED_ACCESS status code.

|4 |8.7.2.2/10.6.8 | |TH sends a Timed Request Message(Timed Write
Transaction) with the timeout value set. (Example - 200 milliseconds). +
Wait for the status response message to be received. +
Wait for 5 seconds(Timer has expired) and then send the Write Request
Message to the DUT. |On the TH verify DUT sends back a Write Response
with the UNSUPPORTED_ACCESS status code.
|===

[[_notestesting_considerations_87]]
====== link:#_notestesting_considerations_87[]Notes/Testing Considerations

'''''

'''''

[[_events_test_cases]]
==== link:#_events_test_cases[]32.6. Events Test Cases

'''''

[[_tc_idm_6_1_events_read_interaction_from_th_to_dut_dut_as_server]]
===== link:#_tc_idm_6_1_events_read_interaction_from_th_to_dut_dut_as_server[]32.6.1. [TC-IDM-6.1] Events Read Interaction from TH to DUT. [DUT as Server]

[[_category_121]]
====== link:#_category_121[]Category

Protocol

[[_purpose_122]]
====== link:#_purpose_122[]Purpose

This test case will verify the report data messages for events sent from
the DUT are according to specification.

[[_pics_121]]
====== link:#_pics_121[]PICS

* MCORE.IDM.S

[[_required_devices_121]]
====== link:#_required_devices_121[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as Event reader - Client
|2 |DUT |DUT as Event publisher - Server
|===

[[_device_topology_74]]
====== link:#_device_topology_74[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_59]]
====== link:#_test_setup_59[]Test Setup

DUT should be setup to generate events which the TH can read.

[[_test_procedure_121]]
====== link:#_test_procedure_121[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.4.2.1/8.9.3.2 | |TH sends Read Request Message to DUT with
EventRequests set to a specific event from a specific cluster on a
specific endpoint on a specific node that is, [Node = Specific, Endpoint
= Specific, Cluster = Specific, Event = Specific]. |Verify TH receives
Report Data Message with the data for specific event in Read Request
Message.

|2 |8.4.2.1/8.9.3.2 | |TH sends Read Request Message to DUT with
EventRequests set to all events from a specific cluster on a specific
endpoint on a specific node that is, [Node = Specific, Endpoint =
Specific, Cluster = Specific, Event = Wildcard]. |Verify TH receives
Report Data Message with the data for events in Read Request Message.

|3 |8.4.2.1/8.9.3.2 | |TH sends Read Request Message to DUT with
EventRequests set to all events from all clusters on a specific endpoint
on a specific node that is, [Node = Specific, Endpoint = Specific,
Cluster = Wildcard, Event = Wildcard]. |Verify TH receives Report Data
Message with the data for events in Read Request Message.

|4 |8.4.2.1/8.9.3.2 | |TH sends Read Request Message to DUT with
EventRequests set to a specific event from a specific cluster on all
endpoints on a specific node that is, [Node = Specific, Endpoint =
Wildcard, Cluster = Specific, Event = Specific]. |Verify TH receives
Report Data Message with the data for specific event in Read Request
Message.

|5 |8.4.2.1/8.9.3.2 | |TH sends Read Request Message to DUT with
EventRequests set to all events from a specific cluster on all endpoints
on a specific node that is, [Node = Specific, Endpoint = Wildcard,
Cluster = Specific, Event = Wildcard]. |Verify TH receives Report Data
Message with the data for events in Read Request Message.

|6 |8.4.2.1/8.9.3.2 | |TH sends Read Request Message to DUT with
EventRequests set to all events from all clusters on all endpoints on a
specific node that is, [Node = Specific, Endpoint = Wildcard, Cluster =
Wildcard, Event = Wildcard]. |Verify TH receives Report Data Message
with the data for events in Read Request Message.

|7 |8.4.3.2 | |TH sends Read Request Message to DUT with EventRequests
set to path which indicates a cluster event that is not supported.
|Verify TH receives Report Data Message for the event with EventStatusIB
generated with the UNSUPPORTED_EVENT Status Code.

|8 |8.4.3.2 | |TH sends Read Request Message to DUT with EventRequests
set to path which requires a privilege that is not granted for the
cluster in the path. |Verify TH receives Report Data Message for the
event with EventStatusIB generated with the UNSUPPORTED_ACCESS Status
Code 0x7e.

|9 |8.4.3.2 | |TH sends Read Request Message to DUT with EventRequests
set to Wildcard path where reading an event in the path requires a
privilege that is not granted for the cluster in the path. |Verify TH
receives Report Data Message with no entry for that event in
EventReports list.

|10 |8.4.3.2/8.9.3.1 | |TH sends a Read Request Message to the DUT to
read back events. +
Note down the largest event number received in the report data message
sent back from the DUT. +
TH sends Read Request Message to DUT with the EventMin field set to a
number less than what was received in the previous step. |Verify TH
receives Report Data Message with EventReports for event numbers higher
than or equal to the EventMin field.

|11 |8.4.3.2/8.9.3.1 | |TH sends a Read Request Message to the DUT to
read back events. +
Note down the largest event number received in the report data message
sent back from the DUT. +
TH sends Read Request Message to DUT with the EventMin field set to a
number much greater than what was received in the previous step. |Verify
TH receives Report Data Message with empty EventReports, or if Events
are present, then verify that it contains EventReports with event
numbers bigger than the one provided.

|12 |8.4.3.2/8.9.3.1 | |[Testing Chunked Event Data] TH sends Read
Request Message to DUT with EventRequests set to all events so as to
create a very large event data. +
For every chunked data message received, DUT sends a status response.
|Verify on the TH that the DUT sends a status response back to the TH on
receipt of the report data action for every chunked message. +
The last chunked message should not receive any status response from the
DUT.
|===

[[_notestesting_considerations_88]]
====== link:#_notestesting_considerations_88[]Notes/Testing Considerations

Test Steps 7 and 14 cannot be executed with V1.0 SDK +
'''

[[_tc_idm_6_2_events_subscribe_interaction_from_th_to_dut_dut_as_server]]
===== link:#_tc_idm_6_2_events_subscribe_interaction_from_th_to_dut_dut_as_server[]32.6.2. [TC-IDM-6.2] Events Subscribe Interaction from TH to DUT. [DUT as Server]

[[_category_122]]
====== link:#_category_122[]Category

Protocol

[[_purpose_123]]
====== link:#_purpose_123[]Purpose

This test case will verify the report data messages for events sent from
the DUT are according to specification.

[[_pics_122]]
====== link:#_pics_122[]PICS

* MCORE.IDM.S

[[_required_devices_122]]
====== link:#_required_devices_122[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as Event subscriber - Client
|2 |DUT |DUT as Event publisher - Server.
|===

[[_device_topology_75]]
====== link:#_device_topology_75[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_122]]
====== link:#_test_procedure_122[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.5.2.1/8.9.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to a specific event from a specific cluster on a
specific endpoint on a specific node that is, [Node = Specific, Endpoint
= Specific, Cluster = Specific, Event = Specific]. |Verify TH receives
Report Data Message with SubscriptionId which uniquely identifies this
subscription on the publisher and data for specific event in Subscribe
Request Message.

|2 |8.5.2.1/8.9.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to all events from a specific cluster on a specific
endpoint on a specific node that is, [Node = Specific, Endpoint =
Specific, Cluster = Specific, Event = Wildcard]. |Verify TH receives
Report Data Message with SubscriptionId which uniquely identifies this
subscription on the publisher and data for events in Subscribe Request
Message.

|3 |8.5.2.1/8.9.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to all events from all clusters on a specific endpoint
on a specific node that is, [Node = Specific, Endpoint = Specific,
Cluster = Wildcard, Event = Wildcard]. |Verify TH receives Report Data
Message with SubscriptionId which uniquely identifies this subscription
on the publisher and data for events in Subscribe Request Message.

|4 |8.5.2.1/8.9.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to a specific event from a specific cluster on all
endpoints on a specific node that is, [Node = Specific, Endpoint =
Wildcard, Cluster = Specific, Event = Specific]. |Verify TH receives
Report Data Message with SubscriptionId which uniquely identifies this
subscription on the publisher and data for specific event in Subscribe
Request Message.

|5 |8.5.2.1/8.9.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to all events from a specific cluster on all endpoints
on a specific node that is, [Node = Specific, Endpoint = Wildcard,
Cluster = Specific, Event = Wildcard]. |Verify TH receives Report Data
Message with SubscriptionId which uniquely identifies this subscription
on the publisher and data for events in Subscribe Request Message.

|6 |8.5.2.1/8.9.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to all events from all clusters on all endpoints on a
specific node that is, [Node = Specific, Endpoint = Wildcard, Cluster =
Wildcard, Event = Wildcard]. |Verify TH receives Report Data Message
with SubscriptionId which uniquely identifies this subscription on the
publisher and data for events in Subscribe Request Message.

|7 |8.5.1 | |Activate Event subscription from TH to DUT and trigger the
subscribed event on the DUT before minimum interval. |Verify TH receives
Report Data Message for event only after the minimum interval has
expired.

|8 |8.5.1 | |Activate Event subscription from TH to DUT and and trigger
the subscribed event on the DUT before minimum interval. +
'IsUrgent' flag is set to True for a particular event path in the
EventPathIB in the SubscribeRequestMessage. |Verify TH receives Report
Data Message for all subscribed events, including any queued events
leading up to (and including) the urgent event, after the minimum
interval time.

|9 |8.5.1 | |Activate Event subscription from TH to DUT with no change
in event triggering attribute values before maximum interval. |Verify TH
receives Report Data Message every maximum interval or possibly more
frequently to keep the subscription alive.

|10 |8.5.2.3 | |With an active Event subscription from TH to DUT, TH
sends another Subscribe Request Message to DUT with KeepSubscriptions as
False. |All existing or pending subscriptions on the publisher for this
subscriber shall be terminated. +
Verify TH receives report data message for any event changes for the
second subscribe request sent by the TH.

|11 |8.5.2.1 | |TH sends Subscribe Request Message to DUT + DUT sends
Report Data message to DUT. +
TH sends Status Response Message with a success Status code. |Verify TH
receives Subscribe Response action to activate the subscription with
fields +
SubscriptionId - identifies the subscription (uint32 type). +
MaxInterval - the final maximum interval for the subscription in seconds
(uint16 type).

|12 |8.5.2.1/8.3.1.3 | |TH sends Subscribe Request Message to DUT. +
DUT sends Report Data message to DUT + TH sends Status Response Message
with an error Status. |Verify DUT terminates the Subscribe interaction
and no further Report Data messages are received.

|13 |8.4.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to path which indicates a cluster event that is not
supported. |Verify TH receives Report Data Message for the event with
EventStatusIB generated with the UNSUPPORTED_EVENT Status Code 0xC7.

|14 |8.4.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to path which requires a privilege that is not granted
for the cluster in the path. |Verify TH receives Report Data Message for
the event with EventStatusIB generated with the UNSUPPORTED_ACCESS
Status Code 0x7E.

|16 |8.4.3.2 | |TH sends Subscribe Request Message to DUT with
EventRequests set to Wildcard path where reading an event in the path
requires a privilege that is not granted for the cluster in the path.
|Verify TH receives Report Data Message with no entry for that event in
EventReports list.

|15 |8.4.3.2/8.9.3.1 | |TH sends Subscribe Request Message to DUT with
EventFilterIB Node information field matching the node indicated in the
path and EventMin field. |Verify TH receives Report Data Message with
EventReports for event numbers higher than the EventMin field. +
Verify that the subsequent ReportData actions as part of the
subscription include the latest EventNo associated with each node
generating new events.

|16 |8.4.3.2/8.9.3.1 | |TH sends Subscribe Request Message to DUT with
EventFilterIB Node information field matching the node indicated in the
path and the event number is less than the EventMin field. |Verify TH
receives Report Data Message with empty EventReports. +
Verify that the subsequent ReportData actions as part of the
subscription include the latest EventNo associated with each node
generating new events.

|17 |8.4.3.2/8.9.3.1 | |With an active Event subscription from TH to
DUT, trigger events on DUT multiple times. |Verify that each event
record is assigned a number that is exactly 1 greater than the last
created event record on that Node. +
Verify that for all the events that it has either System/Epoch timestamp
or Delta System/Epoch Timestamp if this is not first event in current
report

|18 |8.4.3.2/8.9.3.1 | |With an active Event subscription from TH to
DUT, change attribute values on DUT to create events multiple times. +
Perform a factory data reset on DUT, re-subscribe to events and continue
to change attribute values on DUT to create events multiple times.
|Verify that each event record is assigned a number that is exactly 1
greater than the last created event record on that Node before factory
data reset. +
Verify that this monotonicity is not preserved across factory data
reset.
|===

[[_notestesting_considerations_89]]
====== link:#_notestesting_considerations_89[]Notes/Testing Considerations

Test Step #14 cannot be executed with V1.0 SDK.

'''''

[[_tc_idm_6_3_events_read_interaction_from_dut_to_th_dut_as_client]]
===== link:#_tc_idm_6_3_events_read_interaction_from_dut_to_th_dut_as_client[]32.6.3. [TC-IDM-6.3] Events Read Interaction from DUT to TH. [DUT as Client]

[[_category_123]]
====== link:#_category_123[]Category

Protocol

[[_purpose_124]]
====== link:#_purpose_124[]Purpose

This test case will verify the report data messages for events sent from
the DUT are according to specification.

[[_pics_123]]
====== link:#_pics_123[]PICS

* MCORE.IDM.C
* MCORE.IDM.C.ReadRequest
* MCORE.IDM.C.ReadEvent

[[_required_devices_123]]
====== link:#_required_devices_123[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as Event reader
|2 |TH |Test harness as Event publisher
|===

[[_device_topology_76]]
====== link:#_device_topology_76[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_123]]
====== link:#_test_procedure_123[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.4.2.1/8.9.3.2 | |DUT sends Read Request Message to the TH for a
supported event. |Verify on the TH that the Read Request Message
received has these fields +
EventRequests - list of request paths to cluster events. Should be a
valid EventPathIB from the Valid Event Paths table and not target a
group. +
EventFilters - list of minimum event numbers per specific node.
(Optional) +
FabricFiltered which is of type bool.
|===

[[_notestesting_considerations_90]]
====== link:#_notestesting_considerations_90[]Notes/Testing Considerations

'''''

[[_tc_idm_6_4_events_subscribe_interaction_from_dut_to_th_dut_as_client]]
===== link:#_tc_idm_6_4_events_subscribe_interaction_from_dut_to_th_dut_as_client[]32.6.4. [TC-IDM-6.4] Events Subscribe Interaction from DUT to TH. [DUT as Client]

[[_category_124]]
====== link:#_category_124[]Category

Protocol

[[_purpose_125]]
====== link:#_purpose_125[]Purpose

This test case will verify the report data messages for events sent from
the DUT are according to specification.

[[_pics_124]]
====== link:#_pics_124[]PICS

* MCORE.IDM.C
* MCORE.IDM.C.SubscribeRequest
* MCORE.IDM.C.SubscribeEvent

[[_required_devices_124]]
====== link:#_required_devices_124[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as Event subscriber
|2 |TH |Test harness as Event publisher
|===

[[_device_topology_77]]
====== link:#_device_topology_77[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_124]]
====== link:#_test_procedure_124[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.5.2.1 | |DUT sends Subscribe Request Message to the TH for a
supported event. |Verify on the TH that the Subscribe Request Message
received has these fields +
KeepSubscriptions which is of type bool. +
MinIntervalFloor which is of type uint16. +
MaxIntervalCeiling which is of type uint16. +
EventRequests - list of request paths to cluster events. Should be a
valid EventPathIB from the Valid Event Paths table and not target a
group. +
EventFilters - list of minimum event numbers per specific node.
(Optional) +
FabricFiltered which is of type bool.

|2 |8.4.3.4 | |DUT sends Subscribe Request Message to the TH. +
TH sends Report Data message to DUT. |Verify that the DUT sends Status
Response Action with a success Status Code.

|3 |8.5.1 | |DUT sends Subscribe Request Message to the TH and TH does
not respond with Report Data message to DUT. |Verify that the Subscribe
interaction is terminated and DUT can send another Subscribe Request
Message for events.

|4 |8.5.3 | |DUT sends Subscribe Request Message to the TH. +
TH sends Report Data message to DUT. +
DUT sends Status Response Message to the TH. +
TH does not respond with Subscribe Response message to DUT. |Verify that
the Subscribe interaction is terminated and DUT can send another
Subscribe Request Message for events.

|5 |8.5.1 | |With an active Event subscription from DUT to TH, TH sends
Report Data message to DUT with an invalid SubscriptionId. |Verify that
the DUT sends Status Response action with an INVALID_SUBSCRIPTION Status
Code.

|6 |8.5.1 | |With an active Event subscription from DUT to TH, TH sends
Report Data message to DUT after the maximum interval from the last
Report Data. |Verify that the DUT sends Status Response action with an
INVALID_SUBSCRIPTION Status Code.
|===

[[_notestesting_considerations_91]]
====== link:#_notestesting_considerations_91[]Notes/Testing Considerations

Steps 3,4,5 and 6 can be optional if they cannot be tested.

'''''

[[_tc_idm_7_1_multi_fabric_subscription_test_cases_dut_as_server]]
===== link:#_tc_idm_7_1_multi_fabric_subscription_test_cases_dut_as_server[]32.6.5. [TC-IDM-7.1] Multi Fabric Subscription Test Cases. [DUT as Server]

[[_category_125]]
====== link:#_category_125[]Category

Protocol

[[_purpose_126]]
====== link:#_purpose_126[]Purpose

This test case will verify the report data messages for subscriptions
requested from devices on different fabrics are handled correctly by the
DUT.

[[_pics_125]]
====== link:#_pics_125[]PICS

* MCORE.IDM.S

[[_required_devices_125]]
====== link:#_required_devices_125[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |RD1 |Reference Device 1 as the commissioner and subscriber
|2 |RD1A |Reference Device 1A as the subscriber
|3 |RD2 |Reference Device 2 as the commissioner and subscriber
|4 |RD3 |Reference Device 3 as the commissioner and subscriber
|5 |RD4 |Reference Device 4 as the commissioner and subscriber
|6 |RD5 |Reference Device 5 as the commissioner and subscriber
|7 |DUT |DUT as the target of the subscription.
|===

[[_device_topology_78]]
====== link:#_device_topology_78[]Device Topology

RD1, RD2, RD3, RD4, RD5 should be on separate, distinct fabrics. RD1 and
RD1A should be on the same fabric. +
DUT should be commissioned onto all fabrics.

[[_test_procedure_125]]
====== link:#_test_procedure_125[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.5.2.1/12.1 | |RD1, RD2, RD3, RD4, RD5 send 3 Subscribe Request
Messages to DUT.(Total - 15 active subscriptions) +
Each subscribe request should contain 3 different paths. +
They can subscribe to different attributes and events. +
Once all subscriptions are active, change the value of all the
attributes that have been subscribed or trigger an action on the DUT to
generate an event. |Verify that all Subscription Requests succeed. +
Verify on each of these Reference Devices that the appropriate attribute
value has been received.

|2 |8.5.2.1/12.1 | |RD1, RD2, RD3, RD4, RD5 send 3 Subscribe Request
Messages to DUT.(Total - 15 active subscriptions) +
Each subscribe requests should contain 3 different paths. +
The subscription request from RD1 should contain 4 paths. + |Verify that
the subscriptions from RD2, RD3, RD4 and RD5 are not affected.

|3 |8.5.2.1/12.1 | |RD2, RD3, RD4, RD5 send 3 Subscribe request messages
each with each of them having 3 different paths. +
Verify that the subscription request messages from all reference devices
succeed. +
Once all the Subscription Requests are activated, RD1 sends 6
subscription request messages with each of them having 3 different
paths. |Verify that the Subscriptions from RD2, RD3, RD4, RD5 are not
affected.

|4 |8.5.2.1/12.1 | |RD1, RD2, RD3, RD4, RD5 send 3 Subscribe request
messages each with each of them having 3 different paths. +
Verify that the subscription request messages from RD1, RD2, RD3, RD4
and RD5 succeed. +
Once all the Subscription Requests are activated, send a Subscribe
request messages having 3 different paths from RD1A to the DUT. |Verify
that the Subscription from RD1A gets INVALID_ACTION and the previous
subscriptions from RD2, RD3, RD4 and RD5 are not affected.
|===

[[_notestesting_considerations_92]]
====== link:#_notestesting_considerations_92[]Notes/Testing Considerations

Test Step #4 cannot be executed with V1.0 SDK.

[[_tc_idm_8_1_fabric_scoped_test_cases_dut_as_server]]
===== link:#_tc_idm_8_1_fabric_scoped_test_cases_dut_as_server[]32.6.6. [TC-IDM-8.1] Fabric scoped Test Cases. [DUT as Server]

[[_category_126]]
====== link:#_category_126[]Category

Protocol

[[_purpose_127]]
====== link:#_purpose_127[]Purpose

This test case will test if the DUT handles fabric scoped/sensitive data
appropriately when it’s part of multiple fabrics.

[[_pics_126]]
====== link:#_pics_126[]PICS

* MCORE.IDM.S

[[_required_devices_126]]
====== link:#_required_devices_126[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |RC1 |Reference Client 1 as client
|2 |RC2 |Reference Client 2 as client
|3 |DUT |Server as the DUT [DUT as Server]
|===

[[_device_topology_79]]
====== link:#_device_topology_79[]Device Topology

RC1 and RC2 should be on separate, distinct fabrics. DUT should be
commissioned onto both fabrics.

[[_test_procedure_126]]
====== link:#_test_procedure_126[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |8.4.2.1 | |Send a Read Request Message from RC1 and RC2 to read the
ACL attribute, which is a fabric scoped list, from the DUT. Fabric
filtered should be set to false. + |Verify that the number of entries
returned by the DUT for both the reads are same. +
Verify that the response to RC1 does not contain fabric sensitive data
belonging to the other fabric. The fabric sensitive fields in the
entries belonging to the other fabric should either be null or contain
default values. +
Verify that the response to RC2 does not contain fabric sensitive data
belonging to the other fabric. The fabric sensitive fields in the
entries belonging to the other fabric should either be null or contain
default values.

|2 |8.7.3.1 | |Use Access control cluster to verify this test case. +
Send a fabric-filtered Read Request Message from each of RC1 and RC2 to
read the ACL attribute, which is a fabric scoped list, from the DUT. +
From RC1 send a Write Request message to the DUT to write to an entry in
the fabric scoped list associated with its own fabric. +
Send a fabric-filtered Read Request Message from each of RC1 and RC2 to
read the fabric scoped list from the DUT. + |Verify that the data
received from DUT after the second read request from RC2 is same as the
data received after the first read request from RC2. +
Verify that the data received from the DUT after the second read request
from RC1 has the correct modifications to the data.

|3 |8.8.2.1 | |Send a Read Request Message to the DUT from RC1 and RC2
to read the fabric scoped list "Fabrics" from
OperationalCredentialsCluster. Fabric filtered should be set to false. +
RC1 sends an Invoke command(UpdateFabricLabel) to update the label of
its fabric. +
Send a non-filtered Read Request Message from RC1 and RC2 to read the
fabric scoped list from the DUT. |Verify that the label only for the
fabric on which RC1 and DUT are present is updated. +
Verify that the label for the other fabric RC2 is on is not modified.

|4 |8.4.3.2 | |Activate the subscription between RC1 and DUT for an
attribute1 whose value is a list of structs which contain some
fabric-sensitive data +
Activate the subscription between RC2 and DUT for the same attribute1
whose value is a list of structs which contain some fabric-sensitive
data. +
Modify attribute1 on the DUT. |Verify that the DUT sends a response to
RC1 and RC2 with the modified attribute values. +
Verify that the response to RC1 does not contain fabric sensitive data
belonging to the other fabric. The fabric sensitive fields in the
entries belonging to the other fabric should either be null or contain
default values. +
Verify that the response to RC2 does not contain fabric sensitive data
belonging to the other fabric. The fabric sensitive fields in the
entries belonging to the other fabric should either be null or contain
default values.

|5 |8.5.1 | |Activate the subscription between RC1 and DUT for an Event1
which is fabric sensitive +
Activate the subscription between RC2 and DUT for the same Event1 which
is fabric sensitive. +
Trigger Event1 on DUT on the fabric where RC1 is present. |Verify that
the DUT sends a response to RC1 and not RC2.

|6 |8.4.3.2 | |RC1 sends Subscribe Request Message to DUT with
EventRequests set to path where an event in the path is fabric-sensitive
and the associated fabric does not match the accessing fabric. |Verify
that the DUT sends a Report Data Message with no entry for that event in
EventReports list.

|7 |8.4.3.2 | |RC1 sends Read Request Message to DUT with EventRequests
set to path where an event in the path is fabric-sensitive and the
associated fabric does not match the accessing fabric. |Verify that the
DUT sends a Report Data Message with no entry for that event in
EventReports list.
|===

[[_notestesting_considerations_93]]
====== link:#_notestesting_considerations_93[]Notes/Testing Considerations

Test Step #6 and #7 cannot be executed with V1.0 SDK.

'''''

[[_tc_idm_9_1_constraint_error_status_response_test_cases_dut_as_server_removed]]
===== link:#_tc_idm_9_1_constraint_error_status_response_test_cases_dut_as_server_removed[]32.6.7. [TC-IDM-9.1] CONSTRAINT_ERROR status response test cases [DUT as Server] - REMOVED

[[_category_127]]
====== link:#_category_127[]Category

Functional

[[_purpose_128]]
====== link:#_purpose_128[]Purpose

This test case will verify that the server sends a status response with
CONSTRAINT_ERROR when a particular field is out of range.

[[_pics_127]]
====== link:#_pics_127[]PICS

* MCORE.IDM.S

[[_required_devices_127]]
====== link:#_required_devices_127[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_80]]
====== link:#_device_topology_80[]Device Topology

DUT and TH are on the same fabric

[[_test_procedure_127]]
====== link:#_test_procedure_127[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |8.7.3.2 |MCORE.IDM.S |Set the data field of a command of data type
uint16 to an out of range value in the Invoke Request message to the DUT
from the TH. Example: Command - OpenCommissioningWindow, data field -
Discriminator, Constraint - 0 to 4095 |Verify on the TH that the DUT
sends a Status Response with a CONSTRAINT_ERROR Status Code.

|1b |8.7.3.2 |MCORE.IDM.S |Set the data field of a command of data type
octstr to an out of range value in the Invoke Request message to the DUT
from the TH. Set the length of the octstr to a value that is larger than
the maximum length allowed. Example: Command - OpenCommissioningWindow,
data field - Salt, Constraint - 16 to 32 |Verify on the TH that the DUT
sends a Status Response with a CONSTRAINT_ERROR Status Code.

|1c |8.7.3.2 |MCORE.IDM.S |Set the data field of a command of data type
octstr to an out of range value in the Invoke Request message to the DUT
from the TH. Set the length of the octstr to a value that is smaller
than the minimum length allowed. Example: Command -
OpenCommissioningWindow, data field - Salt, Constraint - 16 to 32
|Verify on the TH that the DUT sends a Status Response with a
CONSTRAINT_ERROR Status Code.

|1d |8.7.3.2 |MCORE.IDM.S |Set the data field of a command of data type
string to an out of range value in the Invoke Request message to the DUT
from the TH. Set the length of the string to a value that is larger than
the maximum length allowed. Example: Command - SetRegulatoryConfig, data
field - CountryCode, Constraint - 2 |Verify on the TH that the DUT sends
a Status Response with a CONSTRAINT_ERROR Status Code.

|1e |8.7.3.2 |MCORE.IDM.S |Set the data field of a command of data type
string to an out of range value in the Invoke Request message to the DUT
from the TH. Set the length of the string to a value that is smaller
than the minimum length allowed. Example: Command - SetRegulatoryConfig,
data field - CountryCode, Constraint - 2 |Verify on the TH that the DUT
sends a Status Response with a CONSTRAINT_ERROR Status Code.

|2 |8.7.3.2 |MCORE.IDM.S |Read every attribute that is writable with
bounds from all the clusters from all the endpoints. For every writable
attribute read, set the data field to an out of bounds value in the
Write Request message to the DUT from the TH. |Verify on the TH that the
DUT sends a Status Response Action with a CONSTRAINT_ERROR Status Code.
|===

[[_notestesting_considerations_94]]
====== link:#_notestesting_considerations_94[]Notes/Testing Considerations

This TC is removed for Matter 1.2 release. This test case will be
modified for 1.3 +
Step 2 needs to be automated to be run. Please use this as an example
attribute till the automated test is ready. +
Cluster: Basic Information, Attribute name - NodeLabel, type - String,
Constraint max 32

[[_tc_idm_10_1_cluster_requirements_global_attributes_dut_as_server]]
===== link:#_tc_idm_10_1_cluster_requirements_global_attributes_dut_as_server[]32.6.8. [TC-IDM-10.1] Cluster requirements - Global attributes [DUT as Server]

[[_category_128]]
====== link:#_category_128[]Category

[[_purpose_129]]
====== link:#_purpose_129[]Purpose

Tests global attribute presence and AttributeList correctness for every
cluster on every endpoint

[[_pics_128]]
====== link:#_pics_128[]PICS

* MCORE.IDM.S

[[_required_devices_128]]
====== link:#_required_devices_128[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_81]]
====== link:#_device_topology_81[]Device Topology

TH can connect to DUT over PASE or CASE.

[[_test_procedure_128]]
====== link:#_test_procedure_128[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH performs a wildcard read of all attributes and endpoints |

|2 | | | a|
For every cluster on every endpoint verify that the cluster includes all
the mandatory global attributes:

* ClusterRevision
* FeatureMap
* AttributeList
* AcceptedCommandList
* GeneratedCommandList
* EventList

|3 | | | |For every cluster on every endpoint, verify that each
attribute reported in the AttributeList exactly matches the set of
received attributes from the wildcard read. In other words, if an
attribute ID is present in the AttributeList, a report for that path
must have been seen in the read of step 1, and if an attribute path
exists in the read of step 1, its ID must be present in the
AttributeList of the associated cluster within the hierarchy.
|===

[[_tc_idm_11_1_data_types_attribute_strings_dut_as_server_data_model]]
===== link:#_tc_idm_11_1_data_types_attribute_strings_dut_as_server_data_model[]32.6.9. [TC-IDM-11.1] Data types - attribute strings [DUT as Server] - data model

[[_category_129]]
====== link:#_category_129[]Category

[[_purpose_130]]
====== link:#_purpose_130[]Purpose

Tests that no string attributes on the node contain invalid characters.

[[_pics_129]]
====== link:#_pics_129[]PICS

* MCORE.IDM.S

[[_required_devices_129]]
====== link:#_required_devices_129[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_82]]
====== link:#_device_topology_82[]Device Topology

TH can connect to DUT over PASE or CASE.

[[_test_procedure_129]]
====== link:#_test_procedure_129[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH performs a wildcard read of all attributes and endpoints |

|2 | | |For every returned attribute, if the attribute type is string
and the returned value is not Null or empty, ensure the returned value
is a valid UTF-8-encoded string. It is not permitted to have partially
encoded codepoints between the last legally-encoded codepoint and the
end of the string. |All string-type attributes are valid UTF-8.
|===

[[_administrator_commissioning_cluster_test_plan]]
== link:#_administrator_commissioning_cluster_test_plan[]**Administrator Commissioning Cluster Test Plan**

[[_pics_definition_10]]
=== link:#_pics_definition_10[]33. PICS Definition

This section covers the Multiple Fabrics Test Plan related PICS items
that are referenced in the following test cases.

[[_role_6]]
==== link:#_role_6[]33.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CADMIN.S |Does the Device implement the Multi Fabric cluster as a
server? |O |

|CADMIN.C |Does the Device implement the Multi Fabric cluster as a
client? |O |
|===

[[_server_6]]
==== link:#_server_6[]33.2. Server

[[_features_4]]
===== link:#_features_4[]33.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CADMIN.S.F00(BC) |Does the Device support Basic Commissioning Method |O
|
|===

[[_commands_received_6]]
===== link:#_commands_received_6[]33.2.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Does the Device support
Enhanced Commissioning Method (ECM)? |M |

|CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |Does the Device support
Basic Commissioning Method (BCM)? |CADMIN.S.F00(BC) |

|CADMIN.S.C02.Rsp(RevokeCommissioning) |Does the Device support revoking
commissioning window? |M |

|OPCREDS.S.C0a.Rsp(RemoveFabric) |Does the Device implement receiving
the RemoveFabric command? |M |
|===

[[_attributes_7]]
===== link:#_attributes_7[]33.2.3. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.S.A0001(Fabrics) |Does the Device support Fabrics attribute? |M
|

|BINFO.S.A0005(NodeLabel) |Does the Device support NodeLabel attribute?
|M |

|CADMIN.S.A0000(WindowStatus) |Does the Device support WindowStatus
attribute? |M |

|CADMIN.S.A0001(AdminFabricIndex) |Does the Device support
AdminFabricIndex attribute? |M |

|CADMIN.S.A0002(AdminVendorId) |Does the Device support AdminVendorId
attribute? |M |
|===

[[_client_4]]
==== link:#_client_4[]33.3. Client

[[_manual_controllable]]
===== link:#_manual_controllable[]33.3.1. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CADMIN.M.UserInterfaceDisplay |Does the Device support User Interface
Display |O |

|CADMIN.M.AudioInterface |Does the Device support Audio Interface |O |
|===

[[_commands_generated_6]]
===== link:#_commands_generated_6[]33.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CADMIN.C.C00.Tx(OpenCommissioningWindow) |Does the Device support
through Enhanced Commissioning Method (ECM) ? |O |

|CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |Does the Device support
Basic Commissioning Method (BCM) ? |O |

|CADMIN.C.C02.Tx(RevokeCommissioning) |Does the Device support revoking
commissioning window? |O |

|OPCREDS.C.C0a.Tx(RemoveFabric) |Does the Device support RemoveFabric
command? |O |
|===

[[_attributes_8]]
===== link:#_attributes_8[]33.3.3. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPCREDS.C.A0001(Fabrics) |Does the DUT(client) have access privileges
for the Fabrics attribute implemented on the server? |O |

|BINFO.C.A0005(NodeLabel) |Does the DUT(client) have access privileges
for the NodeLabel attribute implemented on the server? |O |

|CADMIN.C.A0000(WindowStatus) |Does the DUT(client) have access
privileges for the WindowStatus attribute implemented on the server? |O
|

|CADMIN.C.A0001(AdminFabricIndex) |Does the DUT(client) have access
privileges for the AdminFabricIndex attribute implemented on the server?
|O |

|CADMIN.C.A0002(AdminVendorId) |Does the DUT(client) have access
privileges for the AdminVendorId attribute implemented on the server? |O
|
|===

[[_pixit_definition_4]]
=== link:#_pixit_definition_4[]34. PIXIT Definition

This section covers the Multiple Fabrics Test Plan related PIXIT items
that are referenced in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.CADMIN.CwDuration |PIXIT of Duration (in seconds) for a
commissioning window which is greater than 179 seconds and less than 901
seconds |M |
|===

[[_test_case_list_9]]
=== link:#_test_case_list_9[]35. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-CADMIN-1.1 |Administrator Behavior using ECM [DUT - Commissioner]

|TC-CADMIN-1.2 |Administrator Behavior using BCM [DUT - Commissioner]

|TC-CADMIN-1.3 |Node Behavior using ECM [DUT - Commissionee]

|TC-CADMIN-1.4 |Node Behavior using BCM [DUT - Commissionee]

|TC-CADMIN-1.5 |Commissioning window handling timeout and revocation
using ECM [DUT - Commissionee]

|TC-CADMIN-1.6 |Commissioning window handling timeout and revocation
using BCM [DUT - Commissionee]

|TC-CADMIN-1.7 |Commissioning window handling timeout and revocation
using ECM [DUT - Commissioner]

|TC-CADMIN-1.8 |Commissioning window handling timeout and revocation
using BCM [DUT - Commissioner]

|TC-CADMIN-1.9 |Device exit commissioning mode after 20 failed
commission attempts [ECM] [DUT - Commissionee]

|TC-CADMIN-1.10 |Device exit commissioning mode after 20 failed
commission attempts [BCM] [DUT - Commissionee]

|TC-CADMIN-1.11 |Open commissioning window on DUT using ECM then BCM
[DUT - Commissionee]

|TC-CADMIN-1.12 |Open commissioning window on DUT using ECM then BCM
[DUT - Commissioner]

|TC-CADMIN-1.13 |Opening of commissioning window twice on DUT using BCM
then ECM [DUT - Commissionee]

|TC-CADMIN-1.14 |Opening of commissioning window twice on DUT using BCM
then ECM [DUT - Commissioner]

|TC-CADMIN-1.15 |Removing Fabrics from DUT and Fabric index enumeration
using ECM [DUT - Commissionee]

|TC-CADMIN-1.16 |Removing Fabrics from DUT and Fabric index enumeration
using BCM [DUT - Commissionee]

|TC-CADMIN-1.17 |Removing Fabrics from DUT and Fabric index enumeration
using ECM [DUT - Commissioner]

|TC-CADMIN-1.18 |Removing Fabrics from DUT and Fabric index enumeration
using BCM [DUT - Commissioner]

|TC-CADMIN-1.19 |max number of CommissionedFabrics and SupportedFabrics
rollover using ECM [DUT - Commissionee]

|TC-CADMIN-1.20 |max number of CommissionedFabrics and SupportedFabrics
rollover using BCM [DUT - Commissionee]

|TC-CADMIN-1.21 |Open commissioning window - durations max and max+ 1
[BCM] [DUT - Commissionee]

|TC-CADMIN-1.22 |Open commissioning window - durations max and max+ 1
[ECM] [DUT - Commissionee]

|TC-CADMIN-1.23 |Open commissioning window - durations min and min-1
[BCM] [DUT - Commissionee]

|TC-CADMIN-1.24 |Open commissioning window - durations min and min-1
[ECM] [DUT - Commissionee]

|TC-CADMIN-1.25 |Subscription to the attributes - verify subscription
response [ECM] [DUT - Commissionee]

|TC-CADMIN-1.26 |Subscription to the attributes - verify subscription
response [BCM] [DUT - Commissionee]
|===

[[_test_cases_9]]
=== link:#_test_cases_9[]36. Test Cases

'''''

[[_multiple_fabrics_test_cases]]
==== link:#_multiple_fabrics_test_cases[]36.1. Multiple Fabrics Test Cases

'''''

[[_tc_cadmin_1_1_administrator_behavior_using_ecm_dut_commissioner]]
===== link:#_tc_cadmin_1_1_administrator_behavior_using_ecm_dut_commissioner[]36.1.1. [TC-CADMIN-1.1] Administrator Behavior using ECM [DUT - Commissioner]

[[_category_130]]
====== link:#_category_130[]Category

Functional

[[_purpose_131]]
====== link:#_purpose_131[]Purpose

This test case verifies Administrators involved in a Multiple Fabrics
scenario are behaving properly by fulfilling:

. The current Node Administrator SHALL allow another Administrator to be
commissioned with that Node.
. The new Commissioner MUST have their own Node Operational Certificate
(NOC) issuing Root Certificate Authority (RCA).
. Once commissioning is completed, the new Administrator has access to
the Node and can perform all administrative tasks.
. An Administrator SHALL support pairing with a device using the
mandatory method described in Section 5.6.3, “Enhanced Commissioning
Method (ECM)”.
. Verification when the Commissioning Timeout parameter of the OCW
command is in the correct range (>=3m and ⇐15m).

[[_pics_130]]
====== link:#_pics_130[]PICS

* CADMIN.C
* CADMIN.C.C00.Tx(OpenCommissioningWindow)

[[_required_devices_130]]
====== link:#_required_devices_130[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR1 |Test harness as Commissioner 1
|3 |DUT_CR2 |DUT as Commissioner 2
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_60]]
====== link:#_preconditions_60[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_83]]
====== link:#_device_topology_83[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR2) that will
create a new, non-conflicting fabric.

[[_test_procedure_130]]
====== link:#_test_procedure_130[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.1 |CADMIN.C |TH_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |TH_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM (Enhanced
Commissioning Method). |TH_CE opens its Commissioning window to allow a
second commissioning

|3.a |12.1.1 |OPCREDS.C.A0001(Fabrics) |TH_CR1 sends command to TH_CE to
read the list of Fabrics |Verify TH_CE reports 1 entry in the Fabrics
list attribute, and that this entry matches the first commissioning’s
information.

|3.b |12.1.1 |CADMIN.M.UserInterfaceDisplay |Introduce dashes and spaces
into the 11 digit Manual Code provided in step 2 and enter it in the
userinterfacedisplay of DUT_CR2 |Verify that Manual Code entered in
DUT_CR2 contains dashes and spaces

|4.a |12.1.1 |CADMIN.C |DUT_CR2 starts a commissioning process with
TH_CE |TH_CE is commissioned by DUT_CR2

|4.b |12.1.1 | |Verify TH_CE is now discoverable over DNS-SD with two
SRV Records |

|4.c |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR2 sends command to TH_CE
to write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|5 |12.1.1 |OPCREDS.C.A0001(Fabrics) |DUT_CR2 sends command to TH_CE to
read the list of Fabrics |Verify TH_CE reports 2 entries in the Fabrics
list attribute, and that these entries match the commissioning state to
date.

|6 |12.1.1 |BINFO.C.A0005(NodeLabel) |TH_CR1 sends command to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|7 |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR2 sends command to TH_CE to
read, write and then read the Basic Information Cluster’s NodeLabel
mandatory attribute |Verify TH_CE successfully receives the read and
write commands. Verify the initial read reflect the value written in the
above step. Verify the subsequent write/read are successful.

|8 |12.1.1 | |Turn off TH_CR1 |Verify no interactions are received by
TH_CE from TH_CR1

|9 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR2 sends
command to TH_CE to open a commissioning window using a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM (Enhanced
Commissioning Method) |Verify TH_CE opens its Commissioning window to
allow a new commissioning

|10 |12.1.4 |CADMIN.C.C02.Tx(RevokeCommissioning) |DUT_CR2 sends command
to TH_CE to revoke the commissioning window using the
`Revoke Commissioning` command |Verify TH_CE closes its commissioning
window

|11 |12.1.4 |CADMIN.C |TH_CR3 attempts to execute a PASE to starts a
commissioning process with TH_CE |Verify that either no `_matterc._udp`
commissionable records exist matching the previously obtained
discriminator, or that TH_CE refuses to allow a PASE with the provided
passcode from the onboarding payload.

|12 |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR2 sends command to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|13 |5.4.2.3 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR2 sends
command to TH_CE to open a commissioning window using ECM |TH_CE opens
its Commissioning window to allow a new commissioning

|14 |5.4.2.3 | |Wait for commissioning window that was opened in step 13
to timeout |Commissioning window opened in the above step should get
closed (Timedout)

|15 |5.4.2.3 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR2 sends
command to TH_CE to open a commissioning window using ECM |TH_CE opens
its Commissioning window to allow a new commissioning

|16 |5.4.2.3 |CADMIN.C |TH_CR1 starts a commissioning process with TH_CE
before the timeout from step 15 |Verify TH_CE shows OperationalCert
error code 9 response "Trying to add a NOC for a fabric that already
exists" as TH_CR1 already commissioned TH_CE in step 1
|===

[[_notestesting_considerations_95]]
====== link:#_notestesting_considerations_95[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_2_administrator_behavior_using_bcm_dut_commissioner]]
===== link:#_tc_cadmin_1_2_administrator_behavior_using_bcm_dut_commissioner[]36.1.2. [TC-CADMIN-1.2] Administrator Behavior using BCM [DUT - Commissioner]

[[_category_131]]
====== link:#_category_131[]Category

Functional

[[_purpose_132]]
====== link:#_purpose_132[]Purpose

This test case verifies Administrators involved in a Multiple Fabrics
scenario are behaving properly by fulfilling:

. The current Node Administrator SHALL allow another Administrator to be
commissioned with that Node.
. The new Commissioner MUST have their own Node Operational Certificate
(NOC) issuing Root Certificate Authority (RCA).
. Once commissioning is completed, the new Administrator has access to
the Node and can perform all administrative tasks.
. An Administrator MAY support pairing with a device using the optional
method described in Section 5.6.2, “Basic Commissioning Method (BCM)”.
. Verification when the Commissioning Timeout parameter of the OCW
command is in the correct range (>=3m and ⇐15m).

[[_pics_131]]
====== link:#_pics_131[]PICS

* CADMIN.C
* CADMIN.C.C01.Tx(OpenBasicCommissioningWindow)

[[_required_devices_131]]
====== link:#_required_devices_131[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR1 |Test harness as Commissioner 1
|3 |DUT_CR2 |DUT as Commissioner 2
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_61]]
====== link:#_preconditions_61[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_84]]
====== link:#_device_topology_84[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR2) that will
create a new, non-conflicting fabric.

[[_test_procedure_131]]
====== link:#_test_procedure_131[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.1 |CADMIN.C |TH_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |TH_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM (Basic
Commissioning Method) |TH_CE opens its Commissioning window to allow a
second commissioning

|3 |12.1.1 |OPCREDS.C.A0001(Fabrics) |TH_CR1 sends command to TH_CE to
read the list of Fabrics |Verify TH_CE reports 1 entry in the Fabrics
list attribute, and that this entry matches the first commissioning’s
information.

|4.a |12.1.1 |CADMIN.C |DUT_CR2 starts a commissioning process with
TH_CE |TH_CE is commissioned by DUT_CR2

|4.b |12.1.1 | |Verify TH_CE is now discoverable over DNS-SD with two
SRV Records |

|4.c |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR2 sends command to TH_CE
to write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|5 |12.1.1 |OPCREDS.C.A0001(Fabrics) |DUT_CR2 sends command to TH_CE to
read the list of Fabrics on TH_CE |Verify TH_CE reports 2 entries in the
Fabrics list attribute, and that these entries match the commissioning
state to date.

|6 |12.1.1 |BINFO.C.A0005(NodeLabel) |TH_CR1 sends command to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|7 |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR2 sends command to TH_CE to
read, write and then read the Basic Information Cluster’s NodeLabel
mandatory attribute |Verify TH_CE successfully receives all the read and
write commands. Verify the initial read reflect the value written in the
above step. Verify the subsequent write/read are successful.

|8 |12.1.1 | |Turn off TH_CR1 |Verify no interactions are received by
TH_CE from TH_CR1

|9 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR2 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM (Basic
Commissioning Method) |TH_CE opens its Commissioning window to allow a
new commissioning

|10 |12.1.4 |CADMIN.C.C02.Tx(RevokeCommissioning) |DUT_CR2 sends command
to TH_CE to revoke the commissioning window using the
`Revoke Commissioning` command |TH_CE closes its commissioning window

|11 |12.1.4 |CADMIN.C |TH_CR3 attempts to execute a PASE to starts a
commissioning process with TH_CE |Verify that either no `_matterc._udp`
commissionable records exist matching the previously obtained
discriminator, or that TH_CE refuses to allow a PASE with the provided
passcode from the onboarding payload.

|12 |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR2 sends command to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|13 |5.4.2.3 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR2
sends command to TH_CE to open a commissioning window using BCM |TH_CE
opens its Commissioning window to allow a new commissioning

|14 |5.4.2.3 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |Wait for
commissioning window that was opened in step 13 to timeout
|Commissioning window opened in the above step should get closed
(Timedout)

|15 |5.4.2.3 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR2
sends command to TH_CE to open a commissioning window using BCM |TH_CE
opens its Commissioning window to allow a new commissioning

|16 |5.4.2.3 |CADMIN.C |TH_CR1 starts a commissioning process with TH_CE
before the timeout from step 15 |Verify TH_CE shows OperationalCert
error code 9 response "Trying to add a NOC for a fabric that already
exists" as TH_CR1 already commissioned TH_CE in step 1
|===

[[_notestesting_considerations_96]]
====== link:#_notestesting_considerations_96[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_3_node_behavior_using_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_3_node_behavior_using_ecm_dut_commissionee[]36.1.3. [TC-CADMIN-1.3] Node Behavior using ECM [DUT - Commissionee]

[[_category_132]]
====== link:#_category_132[]Category

Functional

[[_purpose_133]]
====== link:#_purpose_133[]Purpose

This test case verifies Node behavior in a Multiple Fabrics scenario:

. The Node SHALL host an "Administrator Commissioning Cluster" Section
11.18
. The Cluster exposes a command which enables the entry into
commissioning mode for a prescribed time, and which SHALL be invoked
over a secure channel.
. During this commissioning window, the Node SHALL maintain its existing
configuration, such as its operational network connection and
identities, and SHOULD allow normal interactions from other Nodes.
. Verification when the Commissioning Timeout parameter of the OCW
command is in the correct range (>=3m and ⇐15m).

[[_pics_132]]
====== link:#_pics_132[]PICS

* CADMIN.S

[[_required_devices_132]]
====== link:#_required_devices_132[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_62]]
====== link:#_preconditions_62[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_85]]
====== link:#_device_topology_85[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR1) that will
create a new, non-conflicting fabric.

[[_test_procedure_132]]
====== link:#_test_procedure_132[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 and is assigned a node
ID1, under TH_CR1’s root of trust.

|2.a |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a second commissioning.

|2.b |12.1.4 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=2

|2.c |12.1.4 |BINFO.S.A0005(NodeLabel) |TH_CR1 writes and reads the
Basic Information Cluster’s NodeLabel mandatory attribute of DUT_CE
|Verify DUT_CE responds to both write/read with a success

|3 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2 on Fabric ID2 and is assigned a node
ID2, under TH_CR2’s root of trust.

|4 |12.1.1 | |Verify DUT_CE is now discoverable over DNS-SD with two SRV
Records |

|5 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the read is successful to DUT_CE and verify DUT_CE
reports 2 entries in the `Fabrics` attribute, matching both NOCs
commissioned previously in terms of root of trust, Fabric ID and Node
ID: <TH_CR1’s root, Fabric ID1, Node ID1> and <TH_CR2’s root, Fabric
ID2, Node ID2>.

|6 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR2 reads the list of Fabrics
on DUT_CE |Verify the read is successful to DUT_CE and verify DUT_CE
reports 2 entries in the `Fabrics` attribute, matching both NOCs
commissioned previously in terms of root of trust, Fabric ID and Node
ID: <TH_CR1’s root, Fabric ID1, Node ID1> and <TH_CR2’s root, Fabric
ID2, Node ID2>.

|7 |12.1.1 |BINFO.S.A0005(NodeLabel) |TH_CR1 writes and reads the Basic
Information Cluster’s NodeLabel mandatory attribute of DUT_CE |Verify
DUT_CE responds to both write/read with a success

|8 |12.1.1 |BINFO.S.A0005(NodeLabel) |TH_CR2 reads, writes and then
reads the Basic Information Cluster’s NodeLabel mandatory attribute of
DUT_CE |Verify the initial read reflect the value written in the above
step. Verify DUT_CE responds to both write/read with a success

|9 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR2 opens a
commissioning window on DUT_CE using ECM |DUT_CE opens its Commissioning
window to allow a new commissioning

|10 |5.4.2.3 | |Wait for the commissioning window in step 9 to timeout |

|11 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR2 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed

|12 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR2 opens a
commissioning window on DUT_CE using ECM |DUT_CE opens its Commissioning
window to allow a new commissioning

|13 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
before the timeout from step 12 |Since DUT_CE was already commissioned
by TH_CR1 in step 1, AddNOC fails with NOCResponse with StatusCode field
set to FabricConflict (9)
|===

[[_notestesting_considerations_97]]
====== link:#_notestesting_considerations_97[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_4_node_behavior_using_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_4_node_behavior_using_bcm_dut_commissionee[]36.1.4. [TC-CADMIN-1.4] Node Behavior using BCM [DUT - Commissionee]

[[_category_133]]
====== link:#_category_133[]Category

Functional

[[_purpose_134]]
====== link:#_purpose_134[]Purpose

This test case verifies Node behavior in a Multiple Fabrics scenario:

. The Node SHALL host a Section 11.22, “Administrator Commissioning
Cluster”.
. The Cluster exposes a command which enables the entry into
commissioning mode for a prescribed time, and which SHALL be invoked
over a secure channel.
. During this commissioning window, the Node SHALL maintain its existing
configuration, such as its operational network connection and
identities, and SHOULD allow normal interactions from other Nodes.
. Verification when the Commissioning Timeout parameter of the OCW
command is in the correct range (>=3m and ⇐15m).

[[_pics_133]]
====== link:#_pics_133[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_133]]
====== link:#_required_devices_133[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_63]]
====== link:#_preconditions_63[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_86]]
====== link:#_device_topology_86[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR1) that will
create a new, non-conflicting fabric.

[[_test_procedure_133]]
====== link:#_test_procedure_133[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2.a |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a second commissioning

|2.b |12.1.4 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=1

|2.c |12.1.4 |BINFO.S.A0005(NodeLabel) |TH_CR1 writes and reads the
Basic Information Cluster’s NodeLabel mandatory attribute of DUT_CE
|Verify DUT_CE responds to both write/read with a success

|3 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2 on Fabric ID2 and is assigned a node
ID2, under TH_CR2’s root of trust.

|4 |12.1.1 | |Verify DUT_CE is now discoverable over DNS-SD with two SRV
Records |

|5 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the read is successful to DUT_CE and verify DUT_CE
reports 2 entries in the `Fabrics` attribute, matching both NOCs
commissioned previously in terms of root of trust, Fabric ID and Node
ID: <TH_CR1’s root, Fabric ID1, Node ID1> and <TH_CR2’s root, Fabric
ID2, Node ID2>.

|6 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR2 reads the list of Fabrics
on DUT_CE |Verify the read is successful to DUT_CE and verify DUT_CE
reports 2 entries in the `Fabrics` attribute, matching both NOCs
commissioned previously in terms of root of trust, Fabric ID and Node
ID: <TH_CR1’s root, Fabric ID1, Node ID1> and <TH_CR2’s root, Fabric
ID2, Node ID2>.

|7 |12.1.4 |BINFO.S.A0005(NodeLabel) |TH_CR1 writes and reads the Basic
Information Cluster’s NodeLabel mandatory attribute of DUT_CE |Verify
DUT_CE responds to both write/read with a success

|8 |12.1.1 |BINFO.S.A0005(NodeLabel) |TH_CR2 reads, writes and then
reads the Basic Information Cluster’s NodeLabel mandatory attribute of
TH_CE |Verify the initial read reflect the value written in the above
step. Verify DUT_CE responds to both write/read with a success

|9 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR2
opens a commissioning window on DUT_CE using BCM |DUT_CE opens its
Commissioning window to allow a new commissioning

|10 |5.4.2.3 | |Wait for the commissioning window in step 9 to timeout |

|11 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR2 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed

|12 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR2
opens a commissioning window on DUT_CE using BCM |DUT_CE opens its
Commissioning window to allow a new commissioning

|13 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
before the timeout from step 12 |Since DUT_CE was already commissioned
by TH_CR1 in step 1, AddNOC fails with NOCResponse with StatusCode field
set to FabricConflict (9)
|===

[[_notestesting_considerations_98]]
====== link:#_notestesting_considerations_98[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_5_commissioning_window_handling_timeout_and_revocation_using_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_5_commissioning_window_handling_timeout_and_revocation_using_ecm_dut_commissionee[]36.1.5. [TC-CADMIN-1.5] Commissioning window handling timeout and revocation using ECM [DUT - Commissionee]

[[_category_134]]
====== link:#_category_134[]Category

Functional

[[_purpose_135]]
====== link:#_purpose_135[]Purpose

This test case verifies the commissioning windows is open only during
the expected time and can be revoked at any time.

[[_pics_134]]
====== link:#_pics_134[]PICS

* CADMIN.S

[[_required_devices_134]]
====== link:#_required_devices_134[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT_CE - Commissionee
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_64]]
====== link:#_preconditions_64[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_87]]
====== link:#_device_topology_87[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR1) that will
create a new, non-conflicting fabric.

[[_test_procedure_134]]
====== link:#_test_procedure_134[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.1 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=2

|4 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR2 starts a
commissioning process with DUT_CE after PIXIT.CADMIN.CwDuration (that
was given in step 2) + 10 seconds |Verify DUT_CE is NOT commissioned by
TH_CR2 since the commissioning process started after the timeout

|5 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
new commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |Verify DUT_CE opens its
Commissioning window to allow a second commissioning

|6 |12.1.4 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 revokes the
commissioning window on DUT_CE using RevokeCommissioning command |Verify
DUT_CE closes its Commissioning window

|7 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|Verify DUT_CE is NOT commissioned by TH_CR2

|8 |12.1.4 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 revokes the
commissioning window on DUT_CE using RevokeCommissioning command |Verify
DUT_CE does not crash and no actions are done on DUT_CE due to this
command

|9 |12.1.1 |BINFO.S.A0005(NodeLabel) |TH_CR1 writes and reads the Basic
Information Cluster’s NodeLabel mandatory attribute of DUT_CE |Verify
DUT_CE responds to both write/read with a success

|10 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
new commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM but with wrong PakeVerifier
value |Verify DUT_CE fails to open Commissioning window with status code
3 (PakeParameterError)

|11 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
new commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |Verify DUT_CE opens its
Commissioning window to allow a second commissioning

|12 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens
another commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |Verify DUT_CE fails to open
Commissioning window with status code 2 (Busy)

|13 |12.1.1 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|14 |12.1.4 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 tries to
revoke the commissioning window on DUT_CE using RevokeCommissioning
command |Verify DUT_CE fails to revoke giving status code 4
(WindowNotOpen) as there was no window open

|15 |12.1.1 |CADMIN.S |TH_CR3 starts a commissioning process with DUT_CE
|TH_CR3 fails to establish PASE with DUT_CE since in step 10 after a
successful commissioning the DUT_CE needs to end its commissioning
window
|===

[[_notestesting_considerations_99]]
====== link:#_notestesting_considerations_99[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_6_commissioning_window_handling_timeout_and_revocation_using_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_6_commissioning_window_handling_timeout_and_revocation_using_bcm_dut_commissionee[]36.1.6. [TC-CADMIN-1.6] Commissioning window handling timeout and revocation using BCM [DUT - Commissionee]

[[_category_135]]
====== link:#_category_135[]Category

Functional

[[_purpose_136]]
====== link:#_purpose_136[]Purpose

This test case verifies the commissioning windows is open only during
the expected time and can be revoked at any time.

[[_pics_135]]
====== link:#_pics_135[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_135]]
====== link:#_required_devices_135[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_65]]
====== link:#_preconditions_65[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_88]]
====== link:#_device_topology_88[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR1) that will
create a new, non-conflicting fabric.

[[_test_procedure_135]]
====== link:#_test_procedure_135[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.1 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=1

|4 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR2
starts a commissioning process with DUT_CE after PIXIT.CADMIN.CwDuration
(that was given in step 2) + 10 seconds |Verify DUT_CE is NOT
commissioned by TH_CR2 since the commissioning process started after the
timeout

|5 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a new commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |Verify DUT_CE opens its
Commissioning window to allow a second commissioning

|6 |12.1.4 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 revokes the
commissioning window on DUT_CE using RevokeCommissioning command |Verify
DUT_CE closes its Commissioning window

|7 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|Verify DUT_CE is NOT commissioned by TH_CR2

|8 |12.1.4 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 revokes the
commissioning window on DUT_CE using RevokeCommissioning command |Verify
DUT_CE does not crash and no actions are done on DUT_CE due to this
command

|9 |12.1.1 |BINFO.S.A0005(NodeLabel) |TH_CR1 writes and reads the Basic
Information Cluster’s NodeLabel mandatory attribute of DUT_CE |Verify
DUT_CE responds to both write/read with a success

|10 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a new commissioning window on DUT_CE using a commissioning timeout
of PIXIT.CADMIN.CwDuration seconds using BCM |Verify DUT_CE opens its
Commissioning window to allow a second commissioning

|11 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens another commissioning window on DUT_CE using a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |Verify DUT_CE
fails to open commissioning window with status code 2 (Busy)

|12 |12.1.1 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|13 |12.1.4 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 tries to
revoke the commissioning window on DUT_CE using RevokeCommissioning
command |Verify DUT_CE fails to revoke with status code 4
(WindowNotOpen) as there was not window open

|14 |12.1.1 |CADMIN.S |TH_CR3 starts a commissioning process with DUT_CE
|TH_CR3 fails to establish PASE with DUT_CE since in step 10 after a
successful commissioning the DUT_CE needs to end its commissioning
window
|===

[[_notestesting_considerations_100]]
====== link:#_notestesting_considerations_100[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_7_commissioning_window_handling_timeout_and_revocation_using_ecm_dut_commissioner]]
===== link:#_tc_cadmin_1_7_commissioning_window_handling_timeout_and_revocation_using_ecm_dut_commissioner[]36.1.7. [TC-CADMIN-1.7] Commissioning window handling timeout and revocation using ECM [DUT - Commissioner]

[[_category_136]]
====== link:#_category_136[]Category

Functional

[[_purpose_137]]
====== link:#_purpose_137[]Purpose

This test case verifies the commissioning windows is open only during
the expected time and can be revoked at any time.

[[_pics_136]]
====== link:#_pics_136[]PICS

* CADMIN.C
* CADMIN.C.C00.Tx(OpenCommissioningWindow)

[[_required_devices_136]]
====== link:#_required_devices_136[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CR1 |DUT - Commissioner 1
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_66]]
====== link:#_preconditions_66[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_89]]
====== link:#_device_topology_89[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR2) that will
create a new, non-conflicting fabric.

[[_test_procedure_136]]
====== link:#_test_procedure_136[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.C |DUT_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by DUT_CR1

|2 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow a second commissioning

|3.a |12.1.1 |CADMIN.M.UserInterfaceDisplay |A User Consent screen pops
up asking for User’s permission to allow second commissioner to control
TH_CE |Verify if the User Consent screen pops up asking for permission.
Verify the pop up window closes after User gives permission and proceeds
with opening commissioning window.

|3.b |12.1.1 |CADMIN.M.UserInterfaceDisplay |11 digit Manual Code is
displayed on the screen in textual format for User to see |Verify that
the displayed Manual Code is 11 digits long and doesn’t contain
Vendor_ID or Product_ID.

|3.c |12.1.1 |CADMIN.M.AudioInterface |A voice prompt of the Manual Code
format should be heard |Verify that a voice prompt saying the Manual
Code should be uttered in hearable sound. Verify that the user can ask
to repeat the Manual Code and it should be repeated.

|4 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
after PIXIT.CADMIN.CwDuration (that was given in step 2) + 10 seconds
|Verify TH_CE is NOT commissioned by TH_CR2 since the commissioning
process started after the timeout

|5 |12.1.4 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a new commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |Verify TH_CE opens
its Commissioning window to allow a second commissioning

|6 |12.1.4 |CADMIN.C.C02.Tx(RevokeCommissioning) |DUT_CR1 sends command
to TH_CE to revoke the commissioning window |Verify TH_CE closes its
Commissioning window

|7 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|Verify TH_CE is NOT commissioned by TH_CR2

|8 |12.1.4 |CADMIN.C.C02.Tx(RevokeCommissioning) |DUT_CR1 sends command
to TH_CE to revoke the commissioning window |Verify no actions are done
on TH_CE due to this command

|9 |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR1 sends commands to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|10 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |Verify TH_CE opens
its Commissioning window to allow a second commissioning

|11 |12.1.1 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR2

|12 |12.1.1 |CADMIN.C |TH_CR3 starts a commissioning process with TH_CE
|TH_CE fails the commissioning process with TH_CR3 since in step 10
after a successful commissioning the commissioning window has been
closed
|===

[[_notestesting_considerations_101]]
====== link:#_notestesting_considerations_101[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_8_commissioning_window_handling_timeout_and_revocation_using_bcm_dut_commissioner]]
===== link:#_tc_cadmin_1_8_commissioning_window_handling_timeout_and_revocation_using_bcm_dut_commissioner[]36.1.8. [TC-CADMIN-1.8] Commissioning window handling timeout and revocation using BCM [DUT - Commissioner]

[[_category_137]]
====== link:#_category_137[]Category

Functional

[[_purpose_138]]
====== link:#_purpose_138[]Purpose

This test case verifies the commissioning windows is open only during
the expected time and can be revoked at any time.

[[_pics_137]]
====== link:#_pics_137[]PICS

* CADMIN.C
* CADMIN.C.C01.Tx(OpenBasicCommissioningWindow)

[[_required_devices_137]]
====== link:#_required_devices_137[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CR1 |DUT - Commissioner 1
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_67]]
====== link:#_preconditions_67[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_90]]
====== link:#_device_topology_90[]Device Topology

An existing Fabric should exist, with a Commissioner (TH_CR2) that will
create a new, non-conflicting fabric.

[[_test_procedure_137]]
====== link:#_test_procedure_137[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.C |DUT_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by DUT_CR1

|2 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |TH_CE opens its
Commissioning window to allow a second commissioning

|3.a |12.1.1 |CADMIN.M.UserInterfaceDisplay |A User Consent screen pops
up asking for User’s permission to allow second commissioner to control
TH_CE |Verify if the User Consent screen pops up asking for permission.
Verify the pop up window closes after User gives permission and proceeds
with opening commissioning window.

|3.b |12.1.1 |CADMIN.M.UserInterfaceDisplay |11 digit Manual Code is
displayed on the screen in textual format for User to see |Verify that
the displayed Manual Code is 11 digits long and doesn’t contain
Vendor_ID or Product_ID.

|3.c |12.1.1 |CADMIN.M.AudioInterface |A voice prompt of the Manual Code
format should be heard |Verify that a voice prompt saying the Manual
Code should be uttered in hearable sound. Verify that the user can ask
to repeat the Manual Code and it should be repeated.

|4 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
after PIXIT.CADMIN.CwDuration (that was given in step 2) + 10 seconds
|Verify TH_CE is NOT commissioned by TH_CR2 since the commissioning
process started after the timeout

|5 |12.1.4 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a new commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |Verify TH_CE opens
its Commissioning window to allow a second commissioning

|6 |12.1.4 |CADMIN.C.C02.Tx(RevokeCommissioning) |DUT_CR1 sends command
to TH_CE to revoke the commissioning window |Verify TH_CE closes its
Commissioning window

|7 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|Verify TH_CE is NOT commissioned by TH_CR2

|8 |12.1.4 |CADMIN.C.C02.Tx(RevokeCommissioning) |DUT_CR1 sends command
to TH_CE to revoke the commissioning window |Verify no actions are done
on TH_CE due to this command

|9 |12.1.1 |BINFO.C.A0005(NodeLabel) |DUT_CR1 sends commands to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify TH_CE successfully receives the read and write
commands

|10 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1
sends command to TH_CE to open a new commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using BCM
|Verify TH_CE opens its Commissioning window to allow a second
commissioning

|11 |12.1.1 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR2

|12 |12.1.1 |CADMIN.C |TH_CR3 starts a commissioning process with TH_CE
|TH_CE fails the commissioning process with TH_CR3 since in step 10
after a successful commissioning the commissioning window has been
closed
|===

[[_notestesting_considerations_102]]
====== link:#_notestesting_considerations_102[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_9_device_exit_commissioning_mode_after_20_failed_commission_attempts_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_9_device_exit_commissioning_mode_after_20_failed_commission_attempts_ecm_dut_commissionee[]36.1.9. [TC-CADMIN-1.9] Device exit commissioning mode after 20 failed commission attempts [ECM] [DUT - Commissionee]

[[_category_138]]
====== link:#_category_138[]Category

Functional

[[_purpose_139]]
====== link:#_purpose_139[]Purpose

This test case verifies the DUT exits its commissioning window after the
20 failed commissioning attempts.

[[_pics_138]]
====== link:#_pics_138[]PICS

* CADMIN.S

[[_required_devices_138]]
====== link:#_required_devices_138[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_68]]
====== link:#_preconditions_68[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_91]]
====== link:#_device_topology_91[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_138]]
====== link:#_test_procedure_138[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.1 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=2

|4 |12.1.4 |CADMIN.S |Before the expiration of PIXIT.CADMIN.CwDuration
set in step 2, Set up a TH_CR2 to start attempting to do PASE to DUT_CE
and failing 20 times. This can be done using a valid onboarding payload
with an incorrect setupcode |Verify that DUT_CE fails to get
commissioned by TH_CR2 in all the 20 attempts

|5 |12.1.4 |CADMIN.S |Before the expiration of PIXIT.CADMIN.CwDuration
set in step 2, TH_CR2 attempts to do PASE to DUT_CE using the correct
onboarding payload |Verify that after 20 unsuccessful attempts in the
previous step, DUT_CE has exited commissioning mode and this attempt
shows that you can’t begin PASE (failure at PBKDFRequest, not obtaining
a PBKDFResponse).

|6 |12.1.4 |CADMIN.S |TH_CR3 starts a commissioning process with DUT_CE
using the correct PAKEVerifier |Verify commissioning flow fails since
the commissioning window must be closed after step 4.
|===

[[_notestesting_considerations_103]]
====== link:#_notestesting_considerations_103[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_10_device_exit_commissioning_mode_after_20_failed_commission_attempts_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_10_device_exit_commissioning_mode_after_20_failed_commission_attempts_bcm_dut_commissionee[]36.1.10. [TC-CADMIN-1.10] Device exit commissioning mode after 20 failed commission attempts [BCM] [DUT - Commissionee]

[[_category_139]]
====== link:#_category_139[]Category

Functional

[[_purpose_140]]
====== link:#_purpose_140[]Purpose

This test case verifies the DUT exits its commissioning window after the
20 failed commissioning attempts.

[[_pics_139]]
====== link:#_pics_139[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_139]]
====== link:#_required_devices_139[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_69]]
====== link:#_preconditions_69[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_92]]
====== link:#_device_topology_92[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_139]]
====== link:#_test_procedure_139[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.1 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=1

|4 |12.1.4 |CADMIN.S |Before the expiration of PIXIT.CADMIN.CwDuration
set in step 2, set up a TH_CR2 to start attempting to do PASE to DUT_CE
and failing 20 times. This can be done using a valid onboarding payload
with an incorrect setupcode |Verify that DUT_CE fails to get
commissioned by TH_CR2 in all the 20 attempts

|5 |12.1.4 |CADMIN.S |Before the expiration of PIXIT.CADMIN.CwDuration
set in step 2, TH_CR2 attempts to do PASE to DUT_CE using the correct
onboarding payload |Verify that after 20 unsuccessful attempts in the
previous step, DUT_CE has exited commissioning mode and this attempt
shows that you can’t begin PASE (failure at PBKDFRequest, not obtaining
a PBKDFResponse).
|===

[[_notestesting_considerations_104]]
====== link:#_notestesting_considerations_104[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_11_open_commissioning_window_on_dut_twice_using_ecm_then_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_11_open_commissioning_window_on_dut_twice_using_ecm_then_bcm_dut_commissionee[]36.1.11. [TC-CADMIN-1.11] Open commissioning window on DUT twice using ECM then BCM [DUT - Commissionee]

[[_category_140]]
====== link:#_category_140[]Category

Functional

[[_purpose_141]]
====== link:#_purpose_141[]Purpose

This test case verifies DUT successfully rejects the OCW when it is
already available for commissioning during PIXIT.CADMIN.CwDuration.

[[_pics_140]]
====== link:#_pics_140[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_140]]
====== link:#_required_devices_140[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_70]]
====== link:#_preconditions_70[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_93]]
====== link:#_device_topology_93[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_140]]
====== link:#_test_procedure_140[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a commissioning

|3 |12.1.4 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=2

|4 |12.1.4 |CADMIN.S |TH_CR3 Commissions with DUT_CE |Verify DUT_CE is
commissioned to TH_CR3 on Fabric ID3 with Node ID3

|5 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM and TH_CR2 Commissions with
DUT_CE |Verify DUT_CE is commissioned to TH_CR2 on Fabric ID2 with Node
ID2

|6 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a commissioning

|7 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds which was set in step 5,
TH_CR1 opens a 2nd commissioning window on DUT_CE using a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |Verify DUT_CE
rejects this second commissioning session with a failure response of
"Busy" (Value = 2)

|8 |12.1.4 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list of Fabrics only includes Fabric ID1, Fabric
ID3, Fabric ID2

|9 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration seconds
that was set in step 6 |

|10 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
re-opens a commissioning window on DUT_CE using a commissioning timeout
of PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a commissioning

|11 |12.1.1 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=1

|12 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that was set in step 10,
TH_CR3 opens a 2nd commissioning window on DUT_CE using a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |Verify DUT_CE
rejects the BCM commissioning session with a failure response of "Busy"
(Value = 2)

|13 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that was set in step 10 |

|14 |12.1.4 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list of Fabrics only includes Fabric ID1, Fabric
ID3, Fabric ID2

|15 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a commissioning

|16 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that was set in step 14,
TH_CR2 opens a second commissioning window on DUT_CE using a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using BCM
|DUT_CE rejects this second commissioning session with a failure
response of "Busy" (Value = 2)
|===

[[_notestesting_considerations_105]]
====== link:#_notestesting_considerations_105[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_12_open_commissioning_window_on_dut_twice_using_ecm_then_bcm_dut_commissioner]]
===== link:#_tc_cadmin_1_12_open_commissioning_window_on_dut_twice_using_ecm_then_bcm_dut_commissioner[]36.1.12. [TC-CADMIN-1.12] Open commissioning window on DUT twice using ECM then BCM [DUT - Commissioner]

[[_category_141]]
====== link:#_category_141[]Category

Functional

[[_purpose_142]]
====== link:#_purpose_142[]Purpose

This test case verifies DUT successfully handle rejections on the OCW
and reading attributes windowstatus, adminfabricindex, adminvendorid

[[_pics_141]]
====== link:#_pics_141[]PICS

* CADMIN.C
* CADMIN.C.C00.Tx(OpenCommissioningWindow)
* CADMIN.C.C01.Tx(OpenBasicCommissioningWindow)

[[_required_devices_141]]
====== link:#_required_devices_141[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CR1 |DUT - Commissioner 1
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_71]]
====== link:#_preconditions_71[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_94]]
====== link:#_device_topology_94[]Device Topology

TH_CE and DUT_CR1 on the same Fabric

[[_test_procedure_141]]
====== link:#_test_procedure_141[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.C |DUT_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by DUT_CR1

|2 |12.1.4 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM and TH_CR3
Commissions with TH_CE |Verify that TH_CE is commissioned to TH_CR3

|3 |12.1.4 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM and TH_CR2
Commissions with TH_CE |Verify that TH_CE is commissioned to TH_CR2

|4 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow commissioning

|5 |12.1.1 |CADMIN.C.A0000(WindowStatus) |Before the expiration of
PIXIT.CADMIN.CwDuration seconds that is set in step 4, DUT_CR1 sends
command to TH_CE to read WindowStatus attribute |TH_CE successfully
reads the WindowStatus

|6 |12.1.4 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that was set in step 4,
DUT_CR1 sends command to TH_CE to open a 2nd commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using ECM
|Verify TH_CE rejects the ECM commissioning session with a failure
response of "Busy" (Value = 2)

|7 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration seconds
that was set in step 4 |

|8 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to re-opens a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |TH_CE opens its
Commissioning window to allow commissioning

|9 |12.1.1 |CADMIN.C.A0000(WindowStatus) |Before the expiration of
PIXIT.CADMIN.CwDuration seconds that is set in step 8, DUT_CR1 sends
command to TH_CE to read WindowStatus attribute |TH_CE successfully
reads the WindowStatus

|10 |12.1.4 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that was set in step 8,
TH_CR3 sends command to TH_CE to open a 2nd commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using BCM
|Verify TH_CE rejects the BCM commissioning session with a failure
response of "Busy" (Value = 2)

|11 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that was set in step 8 |

|12 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1
sends command to TH_CE to open a commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using BCM
|TH_CE opens its Commissioning window to allow commissioning

|13 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that was set in step 12,
TH_CR2 sends command to open a second commissioning window on TH_CE
using a commissioning timeout of PIXIT.CADMIN.CwDuration seconds using
BCM |Verify TH_CE rejects the BCM commissioning session with a failure
response of "Busy" (Value = 2)

|14 |12.1.1 |CADMIN.C.A0000(WindowStatus) |DUT_CR1 sends command to
TH_CE to read WindowStatus attribute |TH_CE successfully reads
WindowStatus

|15 |12.1.1 |CADMIN.C.A0001(AdminFabricIndex) |DUT_CR1 sends command to
TH_CE to read AdminFabricIndex attribute |TH_CE successfully reads
AdminFabricIndex

|16 |12.1.1 |CADMIN.C.A0002(AdminVendorId) |DUT_CR1 sends command to
TH_CE to read AdminVendorId attribute |TH_CE successfully reads
AdminVendorId
|===

[[_notestesting_considerations_106]]
====== link:#_notestesting_considerations_106[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_13_open_commissioning_window_twice_on_dut_using_bcm_then_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_13_open_commissioning_window_twice_on_dut_using_bcm_then_ecm_dut_commissionee[]36.1.13. [TC-CADMIN-1.13] Open commissioning window twice on DUT using BCM then ECM [DUT - Commissionee]

[[_category_142]]
====== link:#_category_142[]Category

Functional

[[_purpose_143]]
====== link:#_purpose_143[]Purpose

This test case verifies DUT successfully rejects the OCW when it is
already available for commissioning during PIXIT.CADMIN.CwDuration.

[[_pics_142]]
====== link:#_pics_142[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_142]]
====== link:#_required_devices_142[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_72]]
====== link:#_preconditions_72[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_95]]
====== link:#_device_topology_95[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_142]]
====== link:#_test_procedure_142[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a commissioning

|3 |12.1.1 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads WindowStatus
attribute from DUT_CE |Verify TH_CR1 reads the WindowStatus value
successfully and verify the value to be 2

|4 |12.1.1 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR1 reads
AdminFabricIndex attribute from DUT_CE |Verify TH_CR1 reads the
AdminFabricIndex value successfully and verify the value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric

|5 |12.1.1 |CADMIN.S.A0002(AdminVendorId) |TH_CR1 reads AdminVendorId
attribute from DUT_CE |Verify TH_CR1 reads the AdminVendorId value
successfully and verify this value to be the same as the Vendor ID field
of Fabrics attribute list entry corresponding to TH_CR1’s fabric

|6 |12.1.4 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=1

|7 |12.1.4 |CADMIN.S |TH_CR3 Commissions with DUT_CE |Verify DUT_CE is
commissioned to TH_CR3 on Fabric ID3 with Node ID3

|8 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM and TH_CR2 Commissions with
DUT_CE |Verify DUT_CE is commissioned to TH_CR2 on Fabric ID2 with Node
ID2

|9 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a commissioning

|10 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that is set in step 9,
TH_CR1 opens a 2nd commissioning window on DUT_CE using a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |Verify DUT_CE
rejects this second commissioning session with a failure response of
"Busy" (Value = 2)

|11 |12.1.4 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list of Fabrics includes Fabric ID1, Fabric ID3,
Fabric ID2

|12 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that was set in step 9 |

|13 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 re-opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a commissioning

|14 |12.1.1 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR1 reads WindowStatus
attribute from DUT_CE |Verify the value to be 1

|15 |12.1.1 | |DNS-SD records shows DUT_CE advertising |Verify that the
DNS-SD advertisement shows CM=2

|16 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that is set in step 13,
TH_CR3 opens a 2nd commissioning window on DUT_CE using a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |Verify DUT_CE
rejects the ECM commissioning session with a failure response of "Busy"
(Value = 2)

|17 |12.1.4 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list of Fabrics only includes Fabric ID1, Fabric
ID3, Fabric ID2

|18 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 13 |

|19 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a commissioning

|20 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that is set in step 19,
TH_CR2 opens a second commissioning window on DUT_CE using a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using ECM
|DUT_CE rejects this second commissioning session with a failure
response of "Busy" (Value = 2)

|21 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 19 |

|22 |12.1.1 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads WindowStatus
attribute from DUT_CE |Verify TH_CR1 reads the WindowStatus value
successfully and verify the value to be 0

|23 |12.1.1 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR1 reads
AdminFabricIndex attribute from DUT_CE |Verify TH_CR1 reads the
AdminFabricIndex value successfully and verify the value to be null

|24 |12.1.1 |CADMIN.S.A0002(AdminVendorId) |TH_CR1 reads AdminVendorId
attribute from DUT_CE |Verify TH_CR1 reads the AdminVendorId value
successfully and verify the value to be null
|===

[[_notestesting_considerations_107]]
====== link:#_notestesting_considerations_107[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_14_open_commissioning_window_twice_on_dut_using_bcm_then_ecm_dut_commissioner]]
===== link:#_tc_cadmin_1_14_open_commissioning_window_twice_on_dut_using_bcm_then_ecm_dut_commissioner[]36.1.14. [TC-CADMIN-1.14] Open commissioning window twice on DUT using BCM then ECM [DUT - Commissioner]

[[_category_143]]
====== link:#_category_143[]Category

Functional

[[_purpose_144]]
====== link:#_purpose_144[]Purpose

This test case verifies DUT as commissioner successfully handles OCW
operation and reading attributes windowstatus, adminfabricindex,
adminvendorid

[[_pics_143]]
====== link:#_pics_143[]PICS

* CADMIN.C
* CADMIN.C.C01.Tx(OpenBasicCommissioningWindow)
* CADMIN.C.C00.Tx(OpenCommissioningWindow)

[[_required_devices_143]]
====== link:#_required_devices_143[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CR1 |DUT - Commissioner 1
|4 |TH_CR3 |Test harness as Commissioner 3
|===

[[_preconditions_73]]
====== link:#_preconditions_73[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_96]]
====== link:#_device_topology_96[]Device Topology

TH_CE and DUT_CR1 on the same Fabric

[[_test_procedure_143]]
====== link:#_test_procedure_143[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.C |DUT_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by DUT_CR1

|2 |12.1.4 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM and TH_CR3
Commissions with TH_CE |Verify TH_CE is commissioned to TH_CR3

|3 |12.1.4 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM and TH_CR2
Commissions with TH_CE |Verify TH_CE is commissioned to TH_CR2

|4 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |TH_CE opens its
Commissioning window to allow commissioning

|5 |12.1.1 |CADMIN.C.A0000(WindowStatus) |Before the expiration of
PIXIT.CADMIN.CwDuration seconds that is set in step 4, DUT_CR1 sends
command to TH_CE to read WindowStatus attribute |TH_CE successfully
reads the WindowStatus

|6 |12.1.4 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that is set in step 4,
DUT_CR1 sends command to TH_CE to open a 2nd commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using ECM
|Verify TH_CE rejects the BCM commissioning session with a failure
response of "Busy" (Value = 2)

|7 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration seconds
that is set in step 4 |

|8 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to re-opens a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow commissioning

|9 |12.1.1 |CADMIN.C.A0000(WindowStatus) |Before the expiration of
PIXIT.CADMIN.CwDuration seconds that is set in step 8, DUT_CR1 sends
command to TH_CE to read WindowStatus attribute |TH_CE successfully
reads the WindowStatus

|10 |12.1.4 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that is set in step 8,
TH_CR3 sends command to TH_CE to open a 2nd commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using ECM
|Verify TH_CE rejects the ECM commissioning session with a failure
response of "Busy" (Value = 2)

|11 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 8 |

|12 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow commissioning

|13 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |Before the
expiration of PIXIT.CADMIN.CwDuration seconds that is set in step 12,
TH_CR2 sends command to TH_CE to open a second commissioning window with
a commissioning timeout of PIXIT.CADMIN.CwDuration seconds using ECM
|Verify TH_CE rejects the ECM commissioning session with a failure
response of "Busy" (Value = 2)

|14 |12.1.4 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 12 |

|15 |12.1.1 |CADMIN.C.A0000(WindowStatus) |DUT_CR1 sends command to
TH_CE to read WindowStatus attribute |TH_CE successfully reads
WindowStatus

|16 |12.1.1 |CADMIN.C.A0001(AdminFabricIndex) |DUT_CR1 sends command to
TH_CE to read AdminFabricIndex attribute |TH_CE successfully reads
AdminFabricIndex

|17 |12.1.1 |CADMIN.C.A0002(AdminVendorId) |DUT_CR1 sends command to
TH_CE to read AdminVendorId attribute |TH_CE successfully reads
AdminVendorId
|===

[[_notestesting_considerations_108]]
====== link:#_notestesting_considerations_108[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_15_removing_fabrics_from_dut_and_fabric_index_enumeration_using_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_15_removing_fabrics_from_dut_and_fabric_index_enumeration_using_ecm_dut_commissionee[]36.1.15. [TC-CADMIN-1.15] Removing Fabrics from DUT and Fabric index enumeration using ECM [DUT - Commissionee]

[[_category_144]]
====== link:#_category_144[]Category

Functional

[[_purpose_145]]
====== link:#_purpose_145[]Purpose

This test case verifies the removal of Fabrics.

[[_pics_144]]
====== link:#_pics_144[]PICS

* CADMIN.S

[[_required_devices_144]]
====== link:#_required_devices_144[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |TH_CR3 |Test harness as Commissioner 3
|4 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_74]]
====== link:#_preconditions_74[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_97]]
====== link:#_device_topology_97[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_144]]
====== link:#_test_procedure_144[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|4 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow commissioning

|5 |12.1.4 |CADMIN.S |TH_CR3 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR3

|6 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR2 reads the list of Fabrics
on DUT_CE |Verify the list shows FabricIndex=1, FabricIndex=2,
FabricIndex=3

|7 |12.1.4 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH_CR2 sends _RemoveFabric_
with `FabricIndex = 2` command to DUT_CE |Verify DUT_CE responses with
_NOCResponse_ with a StatusCode OK (note that expecting OK should ONLY
work if an administrator/commissioner on another fabric than the one
being removed is invoking RemoveFabric).

|8 |12.1.4 |BINFO.S.A0005(NodeLabel) |TH_CR2 writes and reads the Basic
Information Cluster’s NodeLabel mandatory attribute of DUT_CE |Verify
read/write commands fail as expected since the DUT_CE is no longer on
the network

|9 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list shows FabricIndex=1, FabricIndex=3

|10 |12.1.1 | | |Verify DUT_CE is now discoverable over DNS-SD with 2
Operational service records (_matter._tcp SRV records).

|11 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a second commissioning

|12 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|13 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list shows FabricIndex=1, FabricIndex=3,
FabricIndex=4
|===

[[_notestesting_considerations_109]]
====== link:#_notestesting_considerations_109[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_16_removing_fabrics_from_dut_and_fabric_index_enumeration_using_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_16_removing_fabrics_from_dut_and_fabric_index_enumeration_using_bcm_dut_commissionee[]36.1.16. [TC-CADMIN-1.16] Removing Fabrics from DUT and Fabric index enumeration using BCM [DUT - Commissionee]

[[_category_145]]
====== link:#_category_145[]Category

Functional

[[_purpose_146]]
====== link:#_purpose_146[]Purpose

This test case verifies the removal of Fabrics.

[[_pics_145]]
====== link:#_pics_145[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_145]]
====== link:#_required_devices_145[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |TH_CR3 |Test harness as Commissioner 3
|4 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_75]]
====== link:#_preconditions_75[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_98]]
====== link:#_device_topology_98[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_145]]
====== link:#_test_procedure_145[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|4 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow commissioning

|5 |12.1.4 |CADMIN.S |TH_CR3 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR3

|6 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR2 reads the list of Fabrics
on DUT_CE |Verify the list shows FabricIndex=1, FabricIndex=2,
FabricIndex=3

|7 |12.1.4 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH_CR2 sends _RemoveFabric_
with `FabricIndex = 2` command to DUT_CE |Verify DUT_CE responses with
_NOCResponse_ with a StatusCode OK (note that expecting OK should ONLY
work if an administrator/commissioner on another fabric than the one
being removed is invoking RemoveFabric).

|8 |12.1.4 |BINFO.S.A0005(NodeLabel) |TH_CR2 writes and reads the Basic
Information Cluster’s NodeLabel mandatory attribute of DUT_CE |Verify
read/write commands fail as expected since the DUT_CE is no longer on
the network

|9 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list shows FabricIndex=1, FabricIndex=3

|10 |12.1.1 | | |Verify DUT_CE is now discoverable over DNS-SD with 2
Operational service records (_matter._tcp SRV records).

|11 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a second commissioning

|12 |12.1.4 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|13 |12.1.1 |OPCREDS.S.A0001(Fabrics) |TH_CR1 reads the list of Fabrics
on DUT_CE |Verify the list shows FabricIndex=1, FabricIndex=3,
FabricIndex=4
|===

[[_notestesting_considerations_110]]
====== link:#_notestesting_considerations_110[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_17_removing_fabrics_from_dut_and_fabric_index_enumeration_using_ecm_dut_commissioner]]
===== link:#_tc_cadmin_1_17_removing_fabrics_from_dut_and_fabric_index_enumeration_using_ecm_dut_commissioner[]36.1.17. [TC-CADMIN-1.17] Removing Fabrics from DUT and Fabric index enumeration using ECM [DUT - Commissioner]

[[_category_146]]
====== link:#_category_146[]Category

Functional

[[_purpose_147]]
====== link:#_purpose_147[]Purpose

This test case verifies the removal of Fabrics.

[[_pics_146]]
====== link:#_pics_146[]PICS

* CADMIN.C
* CADMIN.C.C00.Tx(OpenCommissioningWindow)

[[_required_devices_146]]
====== link:#_required_devices_146[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |TH_CR3 |Test harness as Commissioner 3
|4 |DUT_CR1 |DUT - Commissioner 1
|===

[[_preconditions_76]]
====== link:#_preconditions_76[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_99]]
====== link:#_device_topology_99[]Device Topology

TH_CE and DUT_CR1 on the same Fabric

[[_test_procedure_146]]
====== link:#_test_procedure_146[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.C |DUT_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by DUT_CR1

|2 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR2

|4 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow commissioning

|5 |12.1.4 |CADMIN.C |TH_CR3 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR3

|6 |12.1.1 |OPCREDS.C.A0001(Fabrics) |DUT_CR1 sends command to TH_CE to
read the list of Fabrics |Verify TH_CE receives and processes the
command successfully

|7 |12.1.4 |OPCREDS.C.C0a.Tx(RemoveFabric) |DUT_CR1 sends _RemoveFabric_
with `FabricIndex = 2` command to TH_CE |Verify TH_CE responses with
"RemoveFabric successful" and "Expiring all sessions for fabric 0x2"

|8 |12.1.4 |BINFO.C.A0005(NodeLabel) |TH_CR2 sends command to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify read/write commands fail as expected since the TH_CR2
is no longer on the network

|9 |12.1.1 |OPCREDS.C.A0001(Fabrics) |DUT_CR1 sends command to TH_CE to
read the list of Fabrics on TH_CE |Verify TH_CE receives and processes
the command successfully

|10 |12.1.1 | | |Verify TH_CE is now discoverable over DNS-SD with 2
Operational service records (_matter._tcp SRV records).

|11 |12.1.1 |CADMIN.C.C00.Tx(OpenCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using ECM |TH_CE opens its
Commissioning window to allow a second commissioning and verify success
response on DUT_CR1

|12 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR2

|13 |12.1.1 |OPCREDS.C.A0001(Fabrics) |TH_CR2 sends command to TH_CE to
read the list of Fabrics on TH_CE |Verify TH_CE receives and processes
the command successfully
|===

[[_notestesting_considerations_111]]
====== link:#_notestesting_considerations_111[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_18_removing_fabrics_from_dut_and_fabric_index_enumeration_using_bcm_dut_commissioner]]
===== link:#_tc_cadmin_1_18_removing_fabrics_from_dut_and_fabric_index_enumeration_using_bcm_dut_commissioner[]36.1.18. [TC-CADMIN-1.18] Removing Fabrics from DUT and Fabric index enumeration using BCM [DUT - Commissioner]

[[_category_147]]
====== link:#_category_147[]Category

Functional

[[_purpose_148]]
====== link:#_purpose_148[]Purpose

This test case verifies the removal of Fabrics.

[[_pics_147]]
====== link:#_pics_147[]PICS

* CADMIN.C
* CADMIN.C.C01.Tx(OpenBasicCommissioningWindow)

[[_required_devices_147]]
====== link:#_required_devices_147[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CE |Test harness as Commissionee
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |TH_CR3 |Test harness as Commissioner 3
|4 |DUT_CR1 |DUT - Commissioner 1
|===

[[_preconditions_77]]
====== link:#_preconditions_77[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_100]]
====== link:#_device_topology_100[]Device Topology

TH_CE and DUT_CR1 on the same Fabric

[[_test_procedure_147]]
====== link:#_test_procedure_147[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.C |DUT_CR1 starts a commissioning process with TH_CE
|TH_CE is commissioned by DUT_CR1

|2 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |TH_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR2

|4 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1 sends
command to TH_CE to open a commissioning window with a commissioning
timeout of PIXIT.CADMIN.CwDuration seconds using BCM |TH_CE opens its
Commissioning window to allow commissioning

|5 |12.1.4 |CADMIN.C |TH_CR3 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR3

|6 |12.1.1 |OPCREDS.C.A0001(Fabrics) |DUT_CR1 sends command to TH_CE to
read the list of Fabrics on TH_CE |Verify TH_CE receives and processes
the command successfully

|7 |12.1.4 |OPCREDS.C.C0a.Tx(RemoveFabric) |DUT_CR1 sends _RemoveFabric_
with `FabricIndex = 2` command to TH_CE |Verify TH_CE responses with
"RemoveFabric successful" and "Expiring all sessions for fabric 0x2"

|8 |12.1.4 |BINFO.C.A0005(NodeLabel) |TH_CR2 sends command to TH_CE to
write and read the Basic Information Cluster’s NodeLabel mandatory
attribute |Verify read/write commands fail as expected since the TH_CR2
is no longer on the network

|9 |12.1.1 |OPCREDS.C.A0001(Fabrics) |DUT_CR1 sends command to TH_CE to
read the list of Fabrics |Verify TH_CE receives and processes the
command successfully

|10 |12.1.1 | | |Verify TH_CE is now discoverable over DNS-SD with 2
Operational service records (_matter._tcp SRV records).

|11 |12.1.1 |CADMIN.C.C01.Tx(OpenBasicCommissioningWindow) |DUT_CR1
sends command to TH_CE to open a commissioning window with a
commissioning timeout of PIXIT.CADMIN.CwDuration seconds using BCM
|TH_CE opens its Commissioning window to allow a second commissioning

|12 |12.1.4 |CADMIN.C |TH_CR2 starts a commissioning process with TH_CE
|TH_CE is commissioned by TH_CR2

|13 |12.1.1 |OPCREDS.C.A0001(Fabrics) |TH_CR2 sends command to TH_CE to
read the list of Fabrics |Verify TH_CE receives and processes the
command successfully
|===

[[_notestesting_considerations_112]]
====== link:#_notestesting_considerations_112[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_19_max_number_of_commissioned_fabrics_and_supportedfabrics_rollover_using_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_19_max_number_of_commissioned_fabrics_and_supportedfabrics_rollover_using_ecm_dut_commissionee[]36.1.19. [TC-CADMIN-1.19] max number of Commissioned Fabrics and SupportedFabrics rollover using ECM [DUT - Commissionee]

[[_category_148]]
====== link:#_category_148[]Category

Functional, Automation Required

[[_purpose_149]]
====== link:#_purpose_149[]Purpose

This test case verifies the max number of CommissionedFabrics based on
SupportedFabrics. +
If the device already has the CommissionedFabrics attribute equal to the
SupportedFabrics attribute, then the device’s operational credentials
table is considered full and the device SHALL process the error by
responding with a StatusCode of TableFull as described in Section
11.17.7.7.2, “Handling Errors”.

[[_pics_148]]
====== link:#_pics_148[]PICS

* CADMIN.S

[[_required_devices_148]]
====== link:#_required_devices_148[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |THn |Test harness as Commissioner n
|3 |THn_1 |Test harness as Commissioner (SupportedFabrics+1)
|4 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_78]]
====== link:#_preconditions_78[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_101]]
====== link:#_device_topology_101[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_148]]
====== link:#_test_procedure_148[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |12.1.1 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using ECM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.4 |CADMIN.S |THn starts a commissioning process with DUT_CE
|DUT_CE is commissioned by THn on Fabric IDn and is assigned a node IDn

|4 |12.1.4 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |Repeat Step 3 and
Step 4 an additional (SupportedFabrics - 2) times to reach an index
value of SupportedFabrics on DUT_CE |Verify DUT_CE has reached an
attribute value of CommissionedFabrics=SupportedFabrics

|5 |12.1.4 |CADMIN.S |THn_1 starts a commissioning process and opens a
commissioning window with DUT_CE |Verify DUT_CE responds with
NOCResponse with a StatusCode field value of TableFull(5)

|6 |12.1.4 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH_CR1 removes FabricIndex1
|Verify CommissionedFabrics=SupportedFabrics-1
|===

[[_notestesting_considerations_113]]
====== link:#_notestesting_considerations_113[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_20_max_number_of_commissioned_fabrics_and_supportedfabrics_rollover_using_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_20_max_number_of_commissioned_fabrics_and_supportedfabrics_rollover_using_bcm_dut_commissionee[]36.1.20. [TC-CADMIN-1.20] max number of Commissioned Fabrics and SupportedFabrics rollover using BCM [DUT - Commissionee]

[[_category_149]]
====== link:#_category_149[]Category

Functional, Automation Required

[[_purpose_150]]
====== link:#_purpose_150[]Purpose

This test case verifies the max number of CommissionedFabrics based on
SupportedFabrics. +
If the device already has the CommissionedFabrics attribute equal to the
SupportedFabrics attribute, then the device’s operational credentials
table is considered full and the device SHALL process the error by
responding with a StatusCode of TableFull as described in Section
11.17.7.7.2, “Handling Errors”.

[[_pics_149]]
====== link:#_pics_149[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_149]]
====== link:#_required_devices_149[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |THn |Test harness as Commissioner n
|3 |THn_1 |Test harness as Commissioner (SupportedFabrics+1)
|4 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_79]]
====== link:#_preconditions_79[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_102]]
====== link:#_device_topology_102[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_149]]
====== link:#_test_procedure_149[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |12.1.4 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |12.1.1 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1 opens
a commissioning window on DUT_CE using a commissioning timeout of
PIXIT.CADMIN.CwDuration seconds using BCM |DUT_CE opens its
Commissioning window to allow a second commissioning

|3 |12.1.4 |CADMIN.S |THn starts a commissioning process with DUT_CE
|DUT_CE is commissioned by THn on Fabric IDn and is assigned a node IDn

|4 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |Repeat Step
3 and Step 4 an additional (SupportedFabrics - 2) times to reach an
index value of SupportedFabrics on DUT_CE |Verify DUT_CE has reached an
attribute value of CommissionedFabrics=SupportedFabrics

|5 |12.1.4 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |THn_1 starts
a commissioning process and opens a commissioning window with DUT_CE
|Verify DUT_CE responds with NOCResponse with a StatusCode field value
of TableFull(5)

|6 |12.1.4 |OPCREDS.S.C0a.Rsp(RemoveFabric) |TH_CR1 removes FabricIndex1
|Verify CommissionedFabrics=SupportedFabrics-1
|===

[[_notestesting_considerations_114]]
====== link:#_notestesting_considerations_114[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_21_open_commissioning_window_durations_max_and_max1_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_21_open_commissioning_window_durations_max_and_max1_bcm_dut_commissionee[]36.1.21. [TC-CADMIN-1.21] Open commissioning window - durations max and max+1 [BCM] [DUT - Commissionee]

[[_category_150]]
====== link:#_category_150[]Category

Functional

[[_purpose_151]]
====== link:#_purpose_151[]Purpose

This test case verifies when the Commissioning Timeout parameter of the
OCW command is NOT set to less than the allowed maximum (15 minutes)
therefore supporting 15 minutes.

[[_pics_150]]
====== link:#_pics_150[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_150]]
====== link:#_required_devices_150[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner
|2 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_80]]
====== link:#_preconditions_80[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_103]]
====== link:#_device_topology_103[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_150]]
====== link:#_test_procedure_150[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.4.2.3 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using BCM with a value of 900
seconds |DUT_CE opens its Commissioning window to allow a second
commissioning

|3 |5.4.2.3 | |Wait 901 seconds for commissioning Window to be closed |

|4 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed

|5 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using BCM with a value of 901
seconds |DUT_CE does not open its Commissioning window to allow a second
commissioning. DUT_CE shows 'Failed to open commissioning window. Global
status 0x85'

|6 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed
|===

[[_notestesting_considerations_115]]
====== link:#_notestesting_considerations_115[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_22_open_commissioning_window_durations_max_and_max1_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_22_open_commissioning_window_durations_max_and_max1_ecm_dut_commissionee[]36.1.22. [TC-CADMIN-1.22] Open commissioning window - durations max and max+1 [ECM] [DUT - Commissionee]

[[_category_151]]
====== link:#_category_151[]Category

Functional

[[_purpose_152]]
====== link:#_purpose_152[]Purpose

This test case verifies when the Commissioning Timeout parameter of the
OCW command is NOT set to less than the allowed maximum (15 minutes)
therefore supporting 15 minutes.

[[_pics_151]]
====== link:#_pics_151[]PICS

* CADMIN.S

[[_required_devices_151]]
====== link:#_required_devices_151[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner
|2 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_81]]
====== link:#_preconditions_81[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_104]]
====== link:#_device_topology_104[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_151]]
====== link:#_test_procedure_151[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.4.2.3 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using ECM with a value of 900 seconds
|DUT_CE opens its Commissioning window to allow a second commissioning

|3 |5.4.2.3 | |Wait 901 seconds for commissioning Window to be closed |

|4 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed

|5 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using ECM with a value of 901 seconds
|DUT_CE does not open its Commissioning window to allow a second
commissioning. DUT_CE shows 'Failed to open commissioning window. Global
status 0x85'

|6 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed
|===

[[_notestesting_considerations_116]]
====== link:#_notestesting_considerations_116[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_23_open_commissioning_window_durations_min_and_min_1_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_23_open_commissioning_window_durations_min_and_min_1_bcm_dut_commissionee[]36.1.23. [TC-CADMIN-1.23] Open commissioning window - durations min and min-1 [BCM] [DUT - Commissionee]

[[_category_152]]
====== link:#_category_152[]Category

Functional

[[_purpose_153]]
====== link:#_purpose_153[]Purpose

This test case verifies when the Commissioning Timeout parameter of the
OCW command is shorter to the minimum value (3m or 180s).

[[_pics_152]]
====== link:#_pics_152[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_152]]
====== link:#_required_devices_152[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner
|2 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_82]]
====== link:#_preconditions_82[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_105]]
====== link:#_device_topology_105[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_152]]
====== link:#_test_procedure_152[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.4.2.3 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using BCM with a value of 180
seconds |DUT_CE opens its Commissioning window to allow a second
commissioning

|3 |5.4.2.3 | |Wait for 181 seconds for commissioning Window to be
closed |

|4 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed

|5 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using BCM with a value of 179
seconds |DUT_CE does not open its Commissioning window to allow a second
commissioning. DUT_CE shows 'Failed to open commissioning window. Global
status 0x85'

|6 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed
|===

[[_notestesting_considerations_117]]
====== link:#_notestesting_considerations_117[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_24_open_commissioning_window_durations_min_and_min_1_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_24_open_commissioning_window_durations_min_and_min_1_ecm_dut_commissionee[]36.1.24. [TC-CADMIN-1.24] Open commissioning window - durations min and min-1 [ECM] [DUT - Commissionee]

[[_category_153]]
====== link:#_category_153[]Category

Functional

[[_purpose_154]]
====== link:#_purpose_154[]Purpose

This test case verifies when the Commissioning Timeout parameter of the
OCW command is shorter to the minimum value (3m or 180s).

[[_pics_153]]
====== link:#_pics_153[]PICS

* CADMIN.S

[[_required_devices_153]]
====== link:#_required_devices_153[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner
|2 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_83]]
====== link:#_preconditions_83[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_106]]
====== link:#_device_topology_106[]Device Topology

TH_CR1 and DUT_CE on the same Fabric

[[_test_procedure_153]]
====== link:#_test_procedure_153[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.4.2.3 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1 on Fabric ID1 with Node ID1

|2 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using ECM with a value of 180 seconds
|DUT_CE opens its Commissioning window to allow a second commissioning

|3 |5.4.2.3 | |Wait for 181 seconds for commissioning Window to be
closed |

|4 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed

|5 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using ECM with a value of 179 seconds
|DUT_CE does not open its Commissioning window to allow a second
commissioning. DUT_CE shows 'Failed to open commissioning window. Global
status 0x85'

|6 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads the window
status to verify the DUT_CE window is closed |DUT_CE windows status
shows the window is closed
|===

[[_notestesting_considerations_118]]
====== link:#_notestesting_considerations_118[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_25_subscription_to_the_attributes_verify_subscription_response_ecm_dut_commissionee]]
===== link:#_tc_cadmin_1_25_subscription_to_the_attributes_verify_subscription_response_ecm_dut_commissionee[]36.1.25. [TC-CADMIN-1.25] Subscription to the attributes - verify subscription response [ECM] [DUT - Commissionee]

[[_category_154]]
====== link:#_category_154[]Category

Functional

[[_purpose_155]]
====== link:#_purpose_155[]Purpose

This test case verifies response to the Subscription to attributes when
commissioning window is opened or closed

[[_pics_154]]
====== link:#_pics_154[]PICS

* CADMIN.S

[[_required_devices_154]]
====== link:#_required_devices_154[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_84]]
====== link:#_preconditions_84[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_107]]
====== link:#_device_topology_107[]Device Topology

TH_CR1, TH_CR2 and DUT_CE on the same Fabric

[[_test_procedure_154]]
====== link:#_test_procedure_154[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.4.2.3 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 subscribes to
WindowStatus attribute on DUT_CE |Verify TH_CR1 receives WindowStatus
subscription notification

|3 |5.4.2.3 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR1 subscribes to
AdminFabricIndex attribute on DUT_CE |Verify TH_CR1 receives
AdminFabricIndex subscription notification

|4 |5.4.2.3 |CADMIN.S.A0002(AdminVendorId) |TH_CR1 subscribes to
AdminVendorId attribute on DUT_CE |Verify TH_CR1 receives AdminVendorId
subscription notification

|5 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using ECM with commissioning timeout of
PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its Commissioning window
to allow a second commissioning

|6 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR1’s fabric |

|7 |5.4.2.3 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|8 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|9 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR2 subscribes to
WindowStatus attribute on DUT_CE |Verify TH_CR2 receives WindowStatus
subscription notification

|10 |5.4.2.3 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR2 subscribes to
AdminFabricIndex attribute on DUT_CE |Verify TH_CR2 receives
AdminFabricIndex subscription notification

|11 |5.4.2.3 |CADMIN.S.A0002(AdminVendorId) |TH_CR2 subscribes to
AdminVendorId attribute on DUT_CE |Verify TH_CR2 receives AdminVendorId
subscription notification

|12 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR1 opens a
commissioning window on DUT_CE using ECM with commissioning timeout of
PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its Commissioning window
to allow a third commissioning

|13 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR1’s fabric |

|14 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR1’s fabric |

|15 |5.4.2.3 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 revokes the
commissioning window on DUT_CE using RevokeCommissioning command |Verify
DUT_CE closes its Commissioning window

|16 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|17 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|18 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR2 opens a
commissioning window on DUT_CE using ECM with commissioning timeout of
PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its Commissioning window
to allow a third commissioning

|19 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|20 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|21 |5.4.2.3 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 18 |

|22 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|23 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|24 |5.4.2.3 |CADMIN.S.C00.Rsp(OpenCommissioningWindow) |TH_CR2 opens a
commissioning window on DUT_CE using ECM with commissioning timeout of
PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its Commissioning window
to allow a third commissioning

|25 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|26 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 1, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|27 |12.1.4 |OPCREDS.S.C0a.Rsp(RemoveFabric) |Before expiration of
PIXIT.CADMIN.CwDuration seconds set in step 24, TH_CR1 sends
_RemoveFabric_ command to DUT_CE with FabricIndex set to the fabric
index of TH_CR2’s fabric |Verify DUT_CE responses with _NOCResponse_
with a StatusCode OK (note that expecting OK should ONLY work if an
administrator/commissioner on another fabric than the one being removed
is invoking RemoveFabric).

|28 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show AdminFabricIndex value to be null |

|29 |12.1.1 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads WindowStatus
attribute from DUT_CE |verify the value to be 1 indicating the window is
still open

|30 |12.1.1 |CADMIN.S.A0002(AdminVendorId) |TH_CR1 reads AdminVendorID
attribute from DUT_CE |verify the value to be the same as the Fabric
Index of the Fabrics attribute list entry corresponding to TH_CR2’s
fabric

|31 |5.4.2.3 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 24 |

|32 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminVendorId to be null |
|===

[[_notestesting_considerations_119]]
====== link:#_notestesting_considerations_119[]Notes/Testing Considerations

'''''

[[_tc_cadmin_1_26_subscription_to_the_attributes_verify_subscription_response_bcm_dut_commissionee]]
===== link:#_tc_cadmin_1_26_subscription_to_the_attributes_verify_subscription_response_bcm_dut_commissionee[]36.1.26. [TC-CADMIN-1.26] Subscription to the attributes - verify subscription response [BCM] [DUT - Commissionee]

[[_category_155]]
====== link:#_category_155[]Category

Functional

[[_purpose_156]]
====== link:#_purpose_156[]Purpose

This test case verifies response to the Subscription to attributes when
commissioning window is opened or closed

[[_pics_155]]
====== link:#_pics_155[]PICS

* CADMIN.S
* CADMIN.S.F00(BC)

[[_required_devices_155]]
====== link:#_required_devices_155[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH_CR1 |Test harness as Commissioner 1
|2 |TH_CR2 |Test harness as Commissioner 2
|3 |DUT_CE |DUT - Commissionee
|===

[[_preconditions_85]]
====== link:#_preconditions_85[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Reset Devices to factory defaults |
|===

[[_device_topology_108]]
====== link:#_device_topology_108[]Device Topology

TH_CR1, TH_CR2 and DUT_CE on the same Fabric

[[_test_procedure_155]]
====== link:#_test_procedure_155[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.4.2.3 |CADMIN.S |TH_CR1 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR1

|2 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR1 subscribes to
WindowStatus attribute on DUT_CE |Verify TH_CR1 receives WindowStatus
subscription notification

|3 |5.4.2.3 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR1 subscribes to
AdminFabricIndex attribute on DUT_CE |Verify TH_CR1 receives
AdminFabricIndex subscription notification

|4 |5.4.2.3 |CADMIN.S.A0002(AdminVendorId) |TH_CR1 subscribes to
AdminVendorId attribute on DUT_CE |Verify TH_CR1 receives AdminVendorId
subscription notification

|5 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using BCM with commissioning
timeout of PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its
Commissioning window to allow a second commissioning

|6 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR1’s fabric |

|7 |5.4.2.3 |CADMIN.S |TH_CR2 starts a commissioning process with DUT_CE
|DUT_CE is commissioned by TH_CR2

|8 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|9 |5.4.2.3 |CADMIN.S.A0000(WindowStatus) |TH_CR2 subscribes to
WindowStatus attribute on DUT_CE |Verify TH_CR2 receives WindowStatus
subscription notification

|10 |5.4.2.3 |CADMIN.S.A0001(AdminFabricIndex) |TH_CR2 subscribes to
AdminFabricIndex attribute on DUT_CE |Verify TH_CR2 receives
AdminFabricIndex subscription notification

|11 |5.4.2.3 |CADMIN.S.A0002(AdminVendorId) |TH_CR2 subscribes to
AdminVendorId attribute on DUT_CE |Verify TH_CR2 receives AdminVendorId
subscription notification

|12 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR1
opens a commissioning window on DUT_CE using BCM with commissioning
timeout of PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its
Commissioning window to allow a third commissioning

|13 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR1’s fabric |

|14 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR1’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR1’s fabric |

|15 |5.4.2.3 |CADMIN.S.C02.Rsp(RevokeCommissioning) |TH_CR1 revokes the
commissioning window on DUT_CE using RevokeCommissioning command |Verify
DUT_CE closes its Commissioning window

|16 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|17 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|18 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR2
opens a commissioning window on DUT_CE using BCM with commissioning
timeout of PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its
Commissioning window to allow a third commissioning

|19 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|20 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|21 |5.4.2.3 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 18 |

|22 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|23 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 0, AdminFabricIndex value to be null,
AdminVendorId to be null |

|24 |5.4.2.3 |CADMIN.S.C01.Rsp(OpenBasicCommissioningWindow) |TH_CR2
opens a commissioning window on DUT_CE using BCM with commissioning
timeout of PIXIT.CADMIN.CwDuration seconds |DUT_CE opens its
Commissioning window to allow a third commissioning

|25 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|26 |5.4.2.3 | |Verify TH_CR2 receives subscription notifications which
show WindowStatus value to be 2, AdminFabricIndex value to be the same
as the Fabric Index of the Fabrics attribute list entry corresponding to
TH_CR2’s fabric, AdminVendorId to be the same as the Vendor ID field of
Fabrics attribute list entry corresponding to TH_CR2’s fabric |

|27 |12.1.4 |OPCREDS.S.C0a.Rsp(RemoveFabric) |Before expiration of
PIXIT.CADMIN.CwDuration seconds set in step 24, TH_CR1 sends
_RemoveFabric_ command to DUT_CE with FabricIndex set to the fabric
index of TH_CR2’s fabric |Verify DUT_CE responses with _NOCResponse_
with a StatusCode OK (note that expecting OK should ONLY work if an
administrator/commissioner on another fabric than the one being removed
is invoking RemoveFabric).

|28 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show AdminFabricIndex value to be null |

|29 |12.1.1 |CADMIN.S.A0000(WindowStatus) |TH_CR1 reads WindowStatus
attribute from DUT_CE |verify the value to be 2 indicating the window is
still open

|30 |12.1.1 |CADMIN.S.A0002(AdminVendorId) |TH_CR1 reads AdminVendorID
attribute from DUT_CE |verify the value to be the same as the Fabric
Index of the Fabrics attribute list entry corresponding to TH_CR2’s
fabric

|31 |5.4.2.3 | |Wait for the expiration of PIXIT.CADMIN.CwDuration
seconds that is set in step 24 |

|32 |5.4.2.3 | |Verify TH_CR1 receives subscription notifications which
show WindowStatus value to be 0, AdminVendorId to be null |
|===

[[_notestesting_considerations_120]]
====== link:#_notestesting_considerations_120[]Notes/Testing Considerations

[[_bridge_test_plan]]
== link:#_bridge_test_plan[]**Bridge Test Plan**

[[_pics_definition_11]]
=== link:#_pics_definition_11[]37. PICS Definition

This section covers the bridge related PICS items that are referenced in
the following test cases. Support for an item is considered as "true"
for conditional statements within the test case steps.

[[_dut_server]]
==== link:#_dut_server[]37.1. DUT server

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.BRIDGE |Does the DUT implement a Bridge |Optional |

|MCORE.BRIDGE.BatInfo |Does the DUT have information on battery level of
(at least some of) of its bridged devices |MCORE.BRIDGE:Optional |

|MCORE.BRIDGE.OtherControl |Does the DUT have means to change the state
of (at least some of) of its bridged devices, e.g. through a
manufacturer-provided app |MCORE.BRIDGE:Optional |

|MCORE.BRIDGE.AllowDeviceRename |Does the DUT have means to change the
name of (at least some of) of its bridged devices, e.g. through a
manufacturer-provided app |MCORE.BRIDGE:Optional |
|===

[[_dut_client]]
==== link:#_dut_client[]37.2. DUT client

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.BRIDGECLIENT |Does the DUT support a Bridge |O |

|MCORE.DEVLIST.UseDevices |Does the DUT support to maintain a list of
connected devices |O |

|MCORE.DEVLIST.UseDeviceName |Does the DUT support to maintain the names
of connected devices |O |

|MCORE.DEVLIST.UseDeviceState |Does the DUT support to maintain the
state of connected devices |O |

|MCORE.DEVLIST.UseBatInfo |Does the DUT support maintaining information
on battery level of connected devices |O |
|===

[[_test_case_list_10]]
=== link:#_test_case_list_10[]38. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-BR-1 |Basics of bridging (DUT server)
|TC-BR-2 |Changing the set of bridged devices (DUT server)
|TC-BR-3 |Changing name and state of a bridged device (DUT server)
|TC-BR-4 |DUT client handling of bridges
|===

[[_test_cases_10]]
=== link:#_test_cases_10[]39. Test Cases

'''''

[[_bridge_test_cases]]
==== link:#_bridge_test_cases[]39.1. Bridge Test Cases

'''''

[[ref_TC-BR-1]]
===== link:#ref_TC-BR-1[]39.1.1. [TC-BR-1] Basics of bridging (DUT server)

[[_category_156]]
====== link:#_category_156[]Category

Conformance, Functional

[[_purpose_157]]
====== link:#_purpose_157[]Purpose

This test case verifies the basic principles of bridging.

[[_pics_156]]
====== link:#_pics_156[]PICS

* MCORE.BRIDGE

[[_precondition_9]]
====== link:#_precondition_9[]Precondition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT (bridge) has been commissioned to TH |

|2 | |Two or more bridged devices of a supported type connected via
non-Matter network/protocol to DUT (bridge). +
If the bridge supports both actuator and sensor/switch devices, use at
least one of each type |
|===

[[_required_devices_156]]
====== link:#_required_devices_156[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Administrator, Controller
|2 |DUT |DUT (bridge with some bridged devices)
|===

[[_device_topology_109]]
====== link:#_device_topology_109[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_60]]
====== link:#_test_setup_60[]Test Setup

Manufacturer has provided bridge as DUT with some devices it can bridge,
along +
with means to setup the bridge (e.g. add/remove/rename/group bridged
devices).

[[_test_procedure_156]]
====== link:#_test_procedure_156[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1: check exposed device types

1a

9.13.2

MCORE.BRIDGE

Read attribute DeviceTypeList of the Descriptor cluster on endpoint 0

Verify this attribute contains (at least) device type Root Node

1b

Read attribute PartsList of the Descriptor cluster on endpoint 0

Result will be used in next step

1c

For each of the endpoints read in step 1b, read attribute DeviceTypeList
of the Descriptor cluster on that endpoint

Track which of those endpoints have a DeviceTypeList containing (at
least) device type Aggregator. +
Verify that the DeviceTypeList on such endpoints does not contain any
Application Device Type.

1d

IF 0 endpoints found in step 1c, FAIL the test (no Aggregator device
type found) +
ELSE Execute test steps 2a..7d for each of the endpoints found in step
1c (i.e. for each of the Aggregator device types)

2: check present endpoints, and search bridged devices

2a

9.13.2

MCORE.BRIDGE

Read attribute PartsList of the Descriptor cluster on endpoint found in
step 1c

2b

For each of the endpoints found in this PartsList attribute, read the
DeviceTypeList attribute in the Descriptor cluster on such endpoint, and
select those endpoints which have (at least) a device type of Bridged
Node in their DeviceTypeList

Verify at least two of such endpoints are found - matching the bridged
devices supplied by the bridge manufacturer with the DUT

3: check Bridged Device Basic Information cluster

3a

9.13.2

MCORE.BRIDGE

For each of the endpoints for the bridged devices found in step 2b, read
attribute PartsList of the Descriptor cluster.

If PartsList is empty verify the following +
* Verify that both the Bridged Node and one or more application device
types are supported on the same endpoint (following application device
type rules). +
* Verify that the Endpoint composition SHALL conform to the application
device type(s) definition. +
If PartsList is not empty verify the following +
* Verify that all application device types are supported on separate
endpoints, and not on the Bridged Node endpoint. +
* Verify that the Bridged Node endpoint’s Descriptor cluster PartsList
attribute SHALL indicate a flat list of all endpoints representing the
functionality of the bridged node, including the endpoints supporting
the application device types.

3b

9.13.2

MCORE.BRIDGE

For each of the endpoints for the bridged devices found in step 2b, +
perform the link:#ref_testplan_BridgedDeviceBasicInformation[tests for
Bridged Device Basic Information cluster]

4: check battery information for bridged devices

4

9.13.2

MCORE.BRIDGE & MCORE.BRIDGE.BatInfo

For each of the endpoints found in step 2b, +
if a Power Source Configuration cluster is present on this endpoint,
perform the link:#testplan_PowerSourceConfiguration[tests] for this
Power Source Configuration cluster +
plus the link:#testplan_PowerSource[tests] for the Power Source clusters
at the endpoint(s) which this Power Source Configuration cluster refers
to

5: collect device types of bridged devices

5

9.13.2

MCORE.BRIDGE

For each of the endpoints found in step 2b, from the DeviceTypeList
attribute in their Descriptor +
cluster, derive the (application) device type(s) of the bridged device

Verify this matches with the functionality of the bridged device
provided for the test

6: Set the state of a bridged device (actuator)

6a

9.13.4.1

MCORE.BRIDGE

From the list acquired in step 5, choose one of the bridged devices
which is an actuator (e.g. light, window covering)

6b

Read the state of this bridged device (through Matter), e.g. on/off,
brightness

Verify that these values match the actual state of the bridged device

6c

Change the state of this bridged device (through Matter), e.g. change
its brightness or toggle its on/off state

Verify that the actual state of the bridged device changes accordingly

6d

Read the state of this bridged device (through Matter), as in 6b

Verify that these values match with what was set in 6c

7: Read the state of a bridged device (sensor/switch)

7a

9.13.4.2

MCORE.BRIDGE

From the list acquired in step 5, choose one of the bridged devices
which is a sensor (e.g. occupancy sensor, contact sensor, temperature
sensor) or switch

7b

Read the state of this bridged device (through Matter), e.g. occupancy
status, contact status, current temperature

Verify that this matches the actual physical state of the sensor

7c

Change the state of this sensor (e.g. cover the occupancy sensor, open
the contact sensor, heat the temperature sensor)

7d

Read the state of this bridged device again, as in 7b

Verify that the state has changed (different from reading in 7b) and
that it matches the actual physical state of the sensor

[[_notestesting_considerations_121]]
== link:#_notestesting_considerations_121[]Notes/Testing Considerations

'''''

[[ref_TC-BR-2]]
== link:#ref_TC-BR-2[]39.1.2. [TC-BR-2] Changing the set of bridged devices (DUT server)

[[_category_157]]
=== link:#_category_157[]Category

Conformance, Functional

[[_purpose_158]]
=== link:#_purpose_158[]Purpose

This test case verifies the functionality of the bridge when bridged
devices +
are being added or deleted.

[[_pics_157]]
=== link:#_pics_157[]PICS

* MCORE.BRIDGE

[[_precondition_10]]
=== link:#_precondition_10[]Precondition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT has been commissioned to TH |

|2 | |Two or more bridged devices of a supported type connected via
non-Matter network/protocol to DUT (bridge) |
|===

[[_required_devices_157]]
=== link:#_required_devices_157[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Administrator, Controller
|2 |DUT |DUT (bridge with some bridged devices)
|===

[[_device_topology_110]]
=== link:#_device_topology_110[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_61]]
=== link:#_test_setup_61[]Test Setup

Manufacturer has provided bridge as DUT with some devices it can bridge,
along +
with means to setup the bridge (e.g. add/remove/rename/group bridged
devices).

[[_test_procedure_157]]
=== link:#_test_procedure_157[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1: preparation

1a

9.13.6

MCORE.BRIDGE

* Read PartsList and DeviceTypeList attributes of the Descriptor cluster
of endpoint 0
* For each endpoint listed in the PartsList attribute of the Descriptor
cluster of endpoint 0:
+
** read the PartsList and DeviceTypeList attributes of the Descriptor
cluster at that endpoint

(these results will be used in later steps)

1b

By inspecting the DeviceTypeList attributes read in step 1a, determine
which of those endpoints has a device type of Aggregator

* FAIL if no such endpoint(s) found
* result will be used in later steps

2: add a bridged device

2a

9.13.6

MCORE.BRIDGE

Add a bridged device (using a method indicated by the manufacturer)

2b

Read the PartsList and DeviceTypeList attributes of the Descriptor
cluster on endpoint 0

* Verify that DeviceTypeList has not changed compared to step 1a
* Verify that PartsList contains exactly one endpoint which previously
was +
not present
* Verify that this new endpoint number is higher than the previously
used highest +
endpoint number
* Verify that the endpoint numbers for the previously present bridged
devices did not +
change

2c

Repeat step 2b for endpoint found in step 1b (the Aggregator EP)

similar check as 2b

2d

Read PartsList and DeviceTypeList attributes of the Descriptor cluster
of all other endpoints listed in the PartsList attribute in the
Descriptor cluster of endpoint 0

Verify that the contents of these attributes have not changed relative
to step 1a (for those endpoints that were present at that stage)

3: check newly added bridged device

3

9.13.6

MCORE.BRIDGE

Perform step 6 (for an actuator) resp. step 7 (for a sensor/switch) of
link:#ref_TC-BR-1[TC-BR-1] for the bridged device added in step 2

4: remove a bridged device

4a

9.13.6

MCORE.BRIDGE

Remove one of the bridged devices (but not the one which was added in
step 2) (using a method indicated by the manufacturer)

4b

Read the PartsList and DeviceTypeList attributes in the Descriptor
cluster on endpoint 0

* Verify that DeviceTypeList has not changed compared to step 1a
* Verify that PartsList lacks exactly one endpoint which previously was
present +
and which corresponds to the removed device

4c

Repeat step 4b for endpoint found in step 1b (the Aggregator EP)

same as 4b

4d

Read PartsList and DeviceTypeList attributes of the Descriptor cluster
of all other endpoints listed in the PartsList attribute in the
Descriptor cluster of endpoint 0

Verify that the contents did not change (i.e. equal to result from step
1a for the original set of bridged devices resp. result from step 2 for
the device added in step 2)

restart DUT to check if endpoint allocation does not get impacted by
that

4z

MCORE.BRIDGE

restart the DUT

5: re-add a bridged device

5a

9.13.6

MCORE.BRIDGE

Re-add the bridged device which was removed in the previous +
step (using a method indicated by the manufacturer)

5b

Read the PartsList and DeviceTypeList attributes in the Descriptor
cluster on endpoint 0

* Verify that DeviceTypeList has not changed compared to step 1a
* Verify that PartsList contains exactly one endpoint which previously
(4b) was not present
* Verify the new endpoint is higher than the previously used highest
endpoint number, +
and different from the endpoint previously (in step 1) assigned to this
bridged device
* Verify that the endpoints for the other previously present bridged
devices have not +
changed

5c

Repeat step 5b for endpoint found in step 1b (the Aggregator EP)

similar as 5b (compare to results from 4c)

5d

Read PartsList and DeviceTypeList attributes of the Descriptor cluster
of all other endpoints listed in the PartsList attribute in the
Descriptor cluster of endpoint 0

Verify that the contents did not change (i.e. equal to result from step
1 for the original set of bridged devices resp. result from step 2 for
the device added in step 2; for the device removed in step 4 and
re-added in step 5, only verify that the DeviceTypeList attribute did
not change, even though it is now at the new endpoint)

[[_notestesting_considerations_122]]
== link:#_notestesting_considerations_122[]Notes/Testing Considerations

'''''

[[ref_TC-BR-3]]
== link:#ref_TC-BR-3[]39.1.3. [TC-BR-3] Changing name and state of a bridged device (DUT server)

[[_category_158]]
=== link:#_category_158[]Category

Conformance, Functional

[[_purpose_159]]
=== link:#_purpose_159[]Purpose

This test case verifies the functionality of the bridge when bridged
devices +
are renamed or operated using non-Matter means.

[[_pics_158]]
=== link:#_pics_158[]PICS

* MCORE.BRIDGE

[[_precondition_11]]
=== link:#_precondition_11[]Precondition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT has been commissioned to TH |

|2 | |Two or more bridged devices of a supported type connected via
non-Matter network/protocol to DUT (bridge) |
|===

[[_required_devices_158]]
=== link:#_required_devices_158[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Administrator, Controller
|2 |DUT |DUT (bridge with some bridged devices)
|===

[[_device_topology_111]]
=== link:#_device_topology_111[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_62]]
=== link:#_test_setup_62[]Test Setup

Manufacturer has provided bridge as DUT with some devices it can bridge,
along +
with means to setup to bridge (e.g. add/remove/rename/group bridged
devices).

[[_test_procedure_158]]
=== link:#_test_procedure_158[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1: Rename a bridged device

1a

9.13.3, 9.13.7

MCORE.BRIDGE & MCORE.BRIDGE.AllowDeviceRename

Get the name of a bridged device: +
Read the NodeLabel attribute of the Bridged Device Basic Information +
cluster on the applicable endpoint

(Retrieved name will be used in 1c.)

1b

Using manufacturer provided means (i.e. NOT using Matter protocol),
update the name of this bridged device

1c

Read the NodeLabel attribute of the Bridged Device Basic Information +
cluster on the same endpoint as in 1a

Verify that the name has changed accordingly (i.e. matching what was
entered in 1b and not equal to what was read in 1a)

2: Change the state of a bridged device by other means

2a

9.13.4

MCORE.BRIDGE & MCORE.BRIDGE.OtherControl

Choose a bridged device for which the state can be changed through a
non-Matter interface (example: bridge manufacturer provides an app which
can change the state of the bridged devices, e.g. change a light’s
brightness)

2b

Read the state (e.g. on/off, brightness) of that bridged device

(retrieved result will be used in 2d)

2c

Change the state (e.g. on/off, brightness) of that bridged device with
this "other" interface.

2d

Read the state of that bridged device again (as in 2b)

Verify that the state has changed accordingly (i.e. matching what was
set in 2c and not equal to what was retrieved in 2b)

[[_notestesting_considerations_123]]
== link:#_notestesting_considerations_123[]Notes/Testing Considerations

'''''

[[ref_TC-BR-4]]
== link:#ref_TC-BR-4[]39.1.4. [TC-BR-4] DUT client handling of bridges (DUT client)

[[_category_159]]
=== link:#_category_159[]Category

Conformance, Functional

[[_purpose_160]]
=== link:#_purpose_160[]Purpose

This test case verifies the basic principles of bridging - including the
handling of DUT of composed devices, and changes in endpoints being
exposed.

[[_pics_159]]
=== link:#_pics_159[]PICS

* MCORE.BRIDGECLIENT

[[_precondition_12]]
=== link:#_precondition_12[]Precondition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT (client) has been not yet been commissioned to TH |
|===

[[_required_devices_159]]
=== link:#_required_devices_159[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*

|1 |TH |Test Harness simulating a bridge with some bridged devices; can
use the `bridge-app` for this purpose

|2 |DUT |DUT (client and commissioner)
|===

[[_device_topology_112]]
=== link:#_device_topology_112[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_63]]
=== link:#_test_setup_63[]Test Setup

TH simulates a bridge with some bridged devices; can use the
`bridge-app` for this purpose. +
`bridge-app` is provided with in the `examples` folder of the repo
https://github.com/project-chip/connectedhomeip.

[[_test_procedure_159]]
=== link:#_test_procedure_159[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1: verify DUT client gathers, uses and maintains information about
endpoints

1a

* Start bridge-app on TH.
* Commission TH to DUT.
* Monitor traffic between DUT and TH.

Verify DUT reads relevant information from the various endpoints of TH:

* DUT is expected to read DeviceTypeList and PartsList from all
available endpoints
* Default setup of `bridge-app` has endpoints 1..13:
+
** EP 1 = aggregator
** EP 3,10,11,12,13 = On/Off light (5 lights in total)
** EP 4,5 = Temperature Sensor
** EP 6..9 = composed
+
*** EP 6 = top of composed device (battery powered device with two
temperature sensors)
*** EP 7,8 = Temperature Sensor
*** EP 9 = Power Source (battery indication)

1b

MCORE.DEVLIST.UseDevices

* Verify DUT contains the (supported) devices from the above list

1c

MCORE.DEVLIST.UseDeviceName

* Verify DUT has (during step 1a) read the NodeLabel attribute from the
Bridged Device Basic Information cluster on various endpoints
* Verify DUT contains the names for the (supported) devices from the
above list

1d

MCORE.DEVLIST.UseDeviceState

* Verify DUT has read or reads OnOff attribute from the On/Off cluster
for the various endpoints containing an On/Off light
* Verify DUT contains the state for the (supported) devices from the
above list

1e

MCORE.DEVLIST.UseDeviceState

Use TH/`bridge-app` to change the on/off state of one or more of the
bridged On/Off lights +
(use key 'c' in the console to `bridge-app`)

* Verify DUT has read or reads OnOff attribute from the On/Off cluster
for the various endpoints containing an On/Off light (or receives
updates because of a previously set up subscription)
* Verify DUT contains the updated state for the (supported) devices from
the above list

1f

MCORE.DEVLIST.UseDeviceState

* Verify DUT has read or reads MeasuredValue attribute from the
Temperature Measurement cluster for the various endpoints containing a
Temperature Sensor (or receives updates because of a previously set up
subscription)
* Verify DUT contains the state for the (supported) device from the
above list

1g

MCORE.DEVLIST.UseDeviceState

Use TH/`bridge-app` to change the simulated temperature level of the
simulated temperature sensors +
(use key 't' in the console to `bridge-app`)

* Verify DUT has read or reads MeasuredValue attribute from the
Temperature Measurement cluster for the various endpoints containing a
Temperature Sensor (or receives updates because of a previously set up
subscription)
* Verify DUT contains the updated state for the (supported) device from
the above list

1h

MCORE.DEVLIST.UseBatInfo

* Verify DUT has read or reads BatChargeLevel attribute from the Power
Source cluster from the relevant endpoint (or receives updates because
of a previously set up subscription)
* Verify DUT contains the state of the battery of the (supported)
devices from the above list

2: verify DUT can control actuator devices

2a

Use the DUT to change the on/off state of one or more of the bridged
On/Off lights

* Verify the DUT sends On command (On/Off cluster)
* Verify that simulated light in TH changes state
+
** the change of light state (due to DUT command) is shown in log output
of bridge-app

3: verify DUT can process changes in set of exposed devices, and changes
in names

3a

MCORE.DEVLIST.UseDeviceName

Use TH/`bridge-app` to rename a bridged light +
(use key 'b' in the console to `bridge-app` to rename `Light 1` to
`Light 1b`)

* Verify DUT reads (or gets the update via a previously set up
subscription) an updated version of the NodeLabel attribute in the
Bridged Device Basic Information cluster of the bridged device that got
renamed

3b

MCORE.DEVLIST.UseDeviceName

* Verify DUT contains the updated name for the renamed device

3c

Use TH/`bridge-app` to add a bridged light +
(use key '2' in the console to `bridge-app` to add `Light 2`)

* Verify DUT reads (or gets the update via a previously set up
subscription) an updated version of the PartsList attribute in the
Descriptor cluster on endpoint 0 and the endpoint of the Aggregator
device type to be aware of the added device
* Verify DUT reads PartsList and DeviceType attribute of the newly added
endpoint

3d

MCORE.DEVLIST.UseDevices

* Verify DUT contains the added device in the list of devices

3e

Use TH/`bridge-app` to remove a bridged light +
(use key '4' in the console to `bridge-app` to remove `Light 1b`)

* Verify DUT reads (or gets the update via a previously set up
subscription) an updated version of the PartsList attribute in the
Descriptor cluster on endpoint 0 and the endpoint of the Aggregator
device type to be aware of the removed device

3f

MCORE.DEVLIST.UseDevices

* Verify DUT no longer contains the removed device in the list of
devices

[[_notestesting_considerations_124]]
== link:#_notestesting_considerations_124[]Notes/Testing Considerations

[[_bulk_data_exchange_protocol_test_plan]]
== link:#_bulk_data_exchange_protocol_test_plan[]**Bulk Data Exchange Protocol Test Plan**

[[_pics_definition_12]]
=== link:#_pics_definition_12[]40. PICS Definition

This section covers the Bulk Data Exchange Protocol related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*
|MCORE.BDX.Sender |Does the DUT support the BDX Sender role? |Optional |

|MCORE.BDX.Receiver |Does the DUT support the BDX Receiver role?
|Optional |

|MCORE.BDX.SynchronousSender |Does the DUT support the BDX Sender role
in Synchronous mode? |Optional |

|MCORE.BDX.SynchronousReceiver |Does the DUT support the BDX Receiver
role in Synchronous mode? |Optional |

|MCORE.BDX.AsynchronousSender |Does the DUT support the BDX Sender role
in Asynchronous mode? |Optional |

|MCORE.BDX.AsynchronousReceiver |Does the DUT support the BDX Receiver
role in Asynchronous mode? |Optional |

|MCORE.BDX.Driver |Does the DUT control the rate of the BDX transfer ?
|Optional |

|MCORE.BDX.Initiator |Is the DUT an Initiator of the BDX transfer?
|Optional |

|MCORE.BDX.Responder |Is the DUT a Responder of the BDX transfer?
|Optional |

|MCORE.BDX.BlockQueryWithSkip |Does the DUT support sending the
BlockQueryWithSkip message? |Optional |
|===

[[_test_case_list_11]]
=== link:#_test_case_list_11[]41. Test Case List

[width="100%",cols="50%,50%",options="header",]
|===
|*TC UUID* |*Test Case Name*
|TC-BDX-1.1 |Sender Initiated BDX Transfer Session - REMOVED

|TC-BDX-1.2 |Receiver Initiated BDX Transfer Session

|TC-BDX-1.3 |Response to Sender Initiated BDX Transfer Session - REMOVED

|TC-BDX-1.4 |Response to Receiver Initiated BDX Transfer Session

|TC-BDX-1.5 |Response to Sender Initiated BDX Transfer Session -
Negative scenario - REMOVED

|TC-BDX-1.6 |Response to Receiver Initiated BDX Transfer Session -
Negative scenario - REMOVED

|TC-BDX-2.1 |Synchronous File Sending

|TC-BDX-2.2 |Synchronous File Receiving

|TC-BDX-2.3 |Restart Synchronous File Receiving - REMOVED

|TC-BDX-2.4 |Asynchronous File Sending - REMOVED

|TC-BDX-2.5 |Asynchronous File Receiving - REMOVED
|===

[[_test_cases_11]]
=== link:#_test_cases_11[]42. Test Cases

'''''

[[_transfer_management_test_cases]]
==== link:#_transfer_management_test_cases[]42.1. Transfer Management Test Cases

'''''

[[_tc_bdx_1_1_sender_initiated_bdx_transfer_session_removed]]
===== link:#_tc_bdx_1_1_sender_initiated_bdx_transfer_session_removed[]42.1.1. [TC-BDX-1.1] Sender Initiated BDX Transfer Session - REMOVED

[[_category_160]]
====== link:#_category_160[]Category

Conformance

[[_purpose_161]]
====== link:#_purpose_161[]Purpose

This test case verifies that the SendInit message contains the necessary
information to initiate the BDX transfer session.

[[_pics_160]]
====== link:#_pics_160[]PICS

* MCORE.BDX.Sender
* MCORE.BDX.Initiator

[[_required_devices_160]]
====== link:#_required_devices_160[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Responder and Receiver.
|2 |DUT |DUT as BDX Initiator and Sender.
|===

[[_device_topology_113]]
====== link:#_device_topology_113[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_160]]
====== link:#_test_procedure_160[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.1 | |DUT sends a SendInit message to TH. |Verify that the
SendInit message has the following mandatory fields. +
Proposed Transfer Control - At least one of the PTC[RECEIVER_DRIVE] or
PTC[SENDER_DRIVE] field bits shall be set. +
Range Control. +
Proposed Max Block Size. +
Start Offset - Optional. +
Proposed Max Length - Optional. +
File Designator Length. +
File Designator. +
Metadata - Optional.
|===

[[_notestesting_considerations_125]]
====== link:#_notestesting_considerations_125[]Notes/Testing Considerations

This test can be verified using TC-DIAGLOG-1.1 from the Diagnostic Logs
cluster section. +
This test cannot be executed with V1.0 SDK.

'''''

[[_tc_bdx_1_2_receiver_initiated_bdx_transfer_session]]
===== link:#_tc_bdx_1_2_receiver_initiated_bdx_transfer_session[]42.1.2. [TC-BDX-1.2] Receiver Initiated BDX Transfer Session

[[_category_161]]
====== link:#_category_161[]Category

Conformance

[[_purpose_162]]
====== link:#_purpose_162[]Purpose

This test case verifies that the ReceiveInit message contains the
necessary information to initiate the BDX transfer session.

[[_pics_161]]
====== link:#_pics_161[]PICS

* MCORE.BDX.Receiver
* MCORE.BDX.Initiator

[[_required_devices_161]]
====== link:#_required_devices_161[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Responder and Sender.
|2 |DUT |DUT as BDX Initiator and Receiver.
|===

[[_device_topology_114]]
====== link:#_device_topology_114[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_161]]
====== link:#_test_procedure_161[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.1 | |DUT sends a ReceiveInit message to TH. |Verify that the
ReceiveInit message has the following mandatory fields. +
Proposed Transfer Control - At least one of the PTC[RECEIVER_DRIVE] or
PTC[SENDER_DRIVE] field bits shall be set. +
Range Control. +
Proposed Max Block Size. +
Start Offset - Optional. +
Proposed Max Length - Optional. +
File Designator Length. +
File Designator. +
Metadata - Optional.
|===

[[_notestesting_considerations_126]]
====== link:#_notestesting_considerations_126[]Notes/Testing Considerations

This test can be verified using TC-SU-2.3 from the OTA Software Update
section.

'''''

[[_tc_bdx_1_3_response_to_sender_initiated_bdx_transfer_session_removed]]
===== link:#_tc_bdx_1_3_response_to_sender_initiated_bdx_transfer_session_removed[]42.1.3. [TC-BDX-1.3] Response to Sender Initiated BDX Transfer Session - REMOVED

[[_category_162]]
====== link:#_category_162[]Category

Conformance

[[_purpose_163]]
====== link:#_purpose_163[]Purpose

This test case verifies that the SendAccept message contains the
necessary information to initiate the BDX transfer session.

[[_pics_162]]
====== link:#_pics_162[]PICS

* MCORE.BDX.Receiver
* MCORE.BDX.Responder

[[_required_devices_162]]
====== link:#_required_devices_162[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Initiator and Sender.
|2 |DUT |DUT as BDX Responder and Receiver.
|===

[[_device_topology_115]]
====== link:#_device_topology_115[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_162]]
====== link:#_test_procedure_162[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.4 | |TH sends a SendInit message to DUT + DUT sends a
SendAccept message back to TH. |Verify that the SendAccept message has
the following mandatory fields. +
Transfer Control - Exactly one mode shall be chosen out of the original
proposed transfer methods sent by the Initiator, and version shall be
the newest version supported by Responder that is not newer than the
proposed version sent by the Initiator. +
Max Block Size - Must be less than or equal to the proposed max block
size. +
Metadata - Optional.
|===

[[_notestesting_considerations_127]]
====== link:#_notestesting_considerations_127[]Notes/Testing Considerations

This test can be verified using TC-DIAGLOG-1.3 from the Diagnostic Logs
cluster section. +
This test cannot be executed with V1.0 SDK.

'''''

[[_tc_bdx_1_4_response_to_receiver_initiated_bdx_transfer_session]]
===== link:#_tc_bdx_1_4_response_to_receiver_initiated_bdx_transfer_session[]42.1.4. [TC-BDX-1.4] Response to Receiver Initiated BDX Transfer Session

[[_category_163]]
====== link:#_category_163[]Category

Conformance

[[_purpose_164]]
====== link:#_purpose_164[]Purpose

This test case verifies that the ReceiveAccept message contains the
necessary information to initiate the BDX transfer session.

[[_pics_163]]
====== link:#_pics_163[]PICS

* MCORE.BDX.Sender
* MCORE.BDX.Responder

[[_required_devices_163]]
====== link:#_required_devices_163[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Initiator and Receiver
|2 |DUT |DUT as BDX Responder and Sender
|===

[[_device_topology_116]]
====== link:#_device_topology_116[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_163]]
====== link:#_test_procedure_163[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.4 | |TH sends a ReceiveInit message to DUT + DUT sends a
ReceiveAccept message back to TH. |Verify that the ReceiveAccept message
has the following mandatory fields. +
Transfer Control - Exactly one mode shall be chosen out of the original
proposed transfer methods sent by the Initiator, and version shall be
the newest version supported by Responder that is not newer than the
proposed version sent by the Initiator. +
Range Control. +
Max Block Size - Must be less than or equal to the proposed max block
size. +
Length - If this field is present, and the Initiator indicated a
definite length, this length shall either be: * equal to the proposed
definite length, if the remaining data in the file beyond the Start
Offset is larger or equal to the proposed length; * smaller than the
proposed definite length, if the remaining data in the file beyond the
Start Offset is smaller than the proposed length. +
Metadata - Optional.
|===

[[_notestesting_considerations_128]]
====== link:#_notestesting_considerations_128[]Notes/Testing Considerations

This test can be verified using TC-SU-3.3 from the OTA Software Update
section.

'''''

[[_tc_bdx_1_5_response_to_sender_initiated_bdx_transfer_session_negative_scenario_removed]]
===== link:#_tc_bdx_1_5_response_to_sender_initiated_bdx_transfer_session_negative_scenario_removed[]42.1.5. [TC-BDX-1.5] Response to Sender Initiated BDX Transfer Session - Negative Scenario - REMOVED

[[_category_164]]
====== link:#_category_164[]Category

Conformance

[[_purpose_165]]
====== link:#_purpose_165[]Purpose

This test case verifies that the DUT aborts the BDX transfer session
with an appropriate error.

[[_pics_164]]
====== link:#_pics_164[]PICS

* MCORE.BDX.Receiver
* MCORE.BDX.Responder

[[_required_devices_164]]
====== link:#_required_devices_164[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Initiator and Sender
|2 |DUT |DUT as BDX Responder and Receiver
|===

[[_device_topology_117]]
====== link:#_device_topology_117[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_164]]
====== link:#_test_procedure_164[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.1 | |TH sends a SendInit message to DUT with a file
designator not supported by DUT. |Verify that the DUT sends back
StatusReport message to TH with Error FILE_DESIGNATOR_UNKNOWN.

|2 |11.21.5.1 | |TH sends a SendInit message to DUT with an invalid
start offset or one that is not supported by DUT. |Verify that the DUT
sends back StatusReport message to TH with Error
START_OFFSET_NOT_SUPPORTED.

|3 |11.21.5.1 | |TH sends a SendInit message to DUT with definite length
field too large for DUT. |Verify that the DUT sends back StatusReport
message to TH with Error LENGTH_TOO_LARGE.

|4 |11.21.5.1 | |TH sends a SendInit message to DUT with definite length
field too short for DUT. |Verify that the DUT sends back StatusReport
message to TH with Error LENGTH_TOO_SHORT.

|5 |11.21.5.1 | |TH sends a SendInit message to DUT with a missing
definite length field. |Verify that the DUT sends back StatusReport
message to TH with Error LENGTH_REQUIRED.

|6 |11.21.5.1 | |TH sends a SendInit message to DUT with proposed
transfer control method not supported by DUT. |Verify that the DUT sends
back StatusReport message to TH with Error
TRANSFER_METHOD_NOT_SUPPORTED.

|7 |11.21.5.1 | |TH sends a SendInit message to DUT when the DUT is too
busy to process another transfer. |Verify that the DUT sends back
StatusReport message to TH with Error RESPONDER_BUSY.
|===

[[_notestesting_considerations_129]]
====== link:#_notestesting_considerations_129[]Notes/Testing Considerations

This test cannot be executed with V1.0 SDK.

'''''

[[_tc_bdx_1_6_response_to_receiver_initiated_bdx_transfer_session_negative_scenario_removed]]
===== link:#_tc_bdx_1_6_response_to_receiver_initiated_bdx_transfer_session_negative_scenario_removed[]42.1.6. [TC-BDX-1.6] Response to Receiver Initiated BDX Transfer Session - Negative Scenario - REMOVED

[[_category_165]]
====== link:#_category_165[]Category

Conformance

[[_purpose_166]]
====== link:#_purpose_166[]Purpose

This test case verifies that the DUT aborts the BDX transfer session
with an appropriate error.

[[_pics_165]]
====== link:#_pics_165[]PICS

* MCORE.BDX.Sender
* MCORE.BDX.Responder

[[_required_devices_165]]
====== link:#_required_devices_165[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Initiator and Receiver
|2 |DUT |DUT as BDX Responder and Sender
|===

[[_device_topology_118]]
====== link:#_device_topology_118[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_165]]
====== link:#_test_procedure_165[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.1 | |TH sends a ReceiveInit message to DUT with a file
designator not supported by DUT. |Verify that the DUT sends back
StatusReport message to TH with Error FILE_DESIGNATOR_UNKNOWN.

|2 |11.21.5.1 | |TH sends a ReceiveInit message to DUT with an invalid
start offset or one that is not supported by DUT. |Verify that the DUT
sends back StatusReport message to TH with Error
START_OFFSET_NOT_SUPPORTED.

|3 |11.21.5.1 | |TH sends a ReceiveInit message to DUT with definite
length field too large for DUT. |Verify that the DUT sends back
StatusReport message to TH with Error LENGTH_TOO_LARGE.

|4 |11.21.5.1 | |TH sends a ReceiveInit message to DUT with a missing
definite length field. |Verify that the DUT sends back StatusReport
message to TH with Error LENGTH_REQUIRED.

|5 |11.21.5.1 | |TH sends a ReceiveInit message to DUT with proposed
transfer control method not supported by DUT. |Verify that the DUT sends
back StatusReport message to TH with Error
TRANSFER_METHOD_NOT_SUPPORTED.

|6 |11.21.5.1 | |TH sends a ReceiveInit message to DUT when the DUT is
too busy to process another transfer. |Verify that the DUT sends back
StatusReport message to TH with Error RESPONDER_BUSY.
|===

[[_notestesting_considerations_130]]
====== link:#_notestesting_considerations_130[]Notes/Testing Considerations

This test cannot be executed with V1.0 SDK.

'''''

[[_data_transfer_test_cases]]
==== link:#_data_transfer_test_cases[]42.2. Data Transfer Test Cases

'''''

[[_tc_bdx_2_1_synchronous_file_sending]]
===== link:#_tc_bdx_2_1_synchronous_file_sending[]42.2.1. [TC-BDX-2.1] Synchronous File Sending

[[_category_166]]
====== link:#_category_166[]Category

Conformance

Example: Conformance, Performance, Reliability, Functional, Protocol,
Physical Conformance

[[_purpose_167]]
====== link:#_purpose_167[]Purpose

This test case verifies that the DUT can successfully send files in
Synchronous mode.

[[_pics_166]]
====== link:#_pics_166[]PICS

* MCORE.BDX.SynchronousSender

[[_required_devices_166]]
====== link:#_required_devices_166[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Receiver
|2 |DUT |DUT as BDX Sender
|===

[[_device_topology_119]]
====== link:#_device_topology_119[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_64]]
====== link:#_test_setup_64[]Test Setup

DUT can initiate a BDX transfer with a SendInit message to TH or TH can
initiate a BDX transfer with a ReceiveInit message to DUT.

[[_test_procedure_166]]
====== link:#_test_procedure_166[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.6.4 | |DUT sends the first Block message to TH + TH sends a
BlockAck message back to DUT. |Verify that the Block message has the
following mandatory fields +
Block Counter - Must start at 0 at the start of the transfer. +
Data - The length must be in the range [0 < Length ⇐ Max Block Size],
where Max Block Size is the negotiated Max Block Size matching the
SendAccept message that initiated the transfer.

|2 |11.21.6.4 | |DUT sends further Block messages to TH + TH sends
BlockAck messages back to DUT. |Verify that the Blocks are sent in
ascending and sequential block counter order.

|3 |11.21.6.5 | |DUT sends a BlockEOF message to TH + TH sends a
BlockAckEOF message back to DUT. |Verify that the BlockEOF message has
the following mandatory fields. +
Block Counter. +
Data - The length must be in the range [0 ⇐ Length ⇐ Max Block Size],
where Max Block Size is the negotiated Max Block Size matching the
SendAccept message that initiated the transfer. +
Verify that the pre-negotiated file size was transferred, if a definite
size had been given.
|===

[[_notestesting_considerations_131]]
====== link:#_notestesting_considerations_131[]Notes/Testing Considerations

This test can be verified using TC-SU-3.3 from the OTA Software Update
section or TC-DIAGLOG-1.1 from the Diagnostic Logs cluster section.

'''''

[[_tc_bdx_2_2_synchronous_file_receiving]]
===== link:#_tc_bdx_2_2_synchronous_file_receiving[]42.2.2. [TC-BDX-2.2] Synchronous File Receiving

[[_category_167]]
====== link:#_category_167[]Category

Conformance

[[_purpose_168]]
====== link:#_purpose_168[]Purpose

This test case verifies that the DUT can successfully receive files in
Synchronous mode.

[[_pics_167]]
====== link:#_pics_167[]PICS

* MCORE.BDX.SynchronousReceiver

[[_required_devices_167]]
====== link:#_required_devices_167[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Sender
|2 |DUT |DUT as BDX Receiver
|===

[[_device_topology_120]]
====== link:#_device_topology_120[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_65]]
====== link:#_test_setup_65[]Test Setup

TH can initiate a BDX transfer with a SendInit message to TH or DUT can
initiate a BDX transfer with a ReceiveInit message to DUT.

[[_test_procedure_167]]
====== link:#_test_procedure_167[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.6.6 | |TH sends the first Block message to DUT + DUT sends a
BlockAck message back to TH. |Verify that the BlockAck message has the
following mandatory fields. +
Block Counter - Must correspond to the Block Counter which was embedded
in the Block being acknowledged.

|2 |11.21.6.2 |MCORE.BDX.Driver |DUT sends the first BlockQuery message
to TH + TH sends a Block message back to DUT. |Verify that the
BlockQuery message has the following mandatory fields. +
Block Counter - Must start at 0 at the start of the transfer.

|3 |11.21.6.2 |MCORE.BDX.Driver |DUT sends further BlockQuery messages
to TH + TH sends further Block messages back to DUT. |Verify that the
BlockQuery messages are sent in ascending and sequential block counter
order.

|4 |11.21.6.3 |MCORE.BDX.BlockQueryWithSkip |DUT sends a
BlockQueryWithSkip message to TH + TH sends a Block message back to DUT.
|Verify that the BlockQueryWithSkip message has the following mandatory
fields. +
Block Counter. +
BytesToSkip.

|5 |11.21.6.7 | |TH sends a BlockEOF message to DUT + DUT sends a
BlockAckEOF message back to TH |Verify that the BlockAckEOF message has
the following mandatory fields. +
Block Counter - Must correspond to the Block Counter which was embedded
in the BlockEOF being acknowledged.
|===

[[_notestesting_considerations_132]]
====== link:#_notestesting_considerations_132[]Notes/Testing Considerations

This test can be verified using TC-SU-2.3 from the OTA Software Update
section or TC-DIAGLOG-1.3 from the Diagnostic Logs cluster section. +
Test Step #4 cannot be executed with V1.0 SDK.

'''''

[[_tc_bdx_2_3_restart_synchronous_file_receiving_removed]]
===== link:#_tc_bdx_2_3_restart_synchronous_file_receiving_removed[]42.2.3. [TC-BDX-2.3] Restart Synchronous File Receiving - REMOVED

[[_category_168]]
====== link:#_category_168[]Category

Conformance

[[_purpose_169]]
====== link:#_purpose_169[]Purpose

This test case verifies that the DUT can successfully restart receiving
files in Synchronous mode.

[[_pics_168]]
====== link:#_pics_168[]PICS

* MCORE.BDX.SynchronousReceiver

[[_required_devices_168]]
====== link:#_required_devices_168[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Sender
|2 |DUT |DUT as BDX Receiver
|===

[[_device_topology_121]]
====== link:#_device_topology_121[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_66]]
====== link:#_test_setup_66[]Test Setup

DUT sends a ReceiveInit message to TH + TH sends a ReceiveAccept message
back to DUT + TH sends a Block message to DUT + DUT sends a BlockAck
message back to TH. After a while, TH stops sending Blocks which leads
to idle timeout and abort transfer session.

[[_test_procedure_168]]
====== link:#_test_procedure_168[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.6.4 | |DUT sends a ReceiveInit message to TH + TH sends a
ReceiveAccept message back to DUT. |Verify that the that the ReceiveInit
message has the following fields. +
Proposed Transfer Control - At least one of the PTC[RECEIVER_DRIVE] or
PTC[SENDER_DRIVE] field bits shall be set. +
Range Control. +
Proposed Max Block Size. +
Start Offset - Should be set to the offset of the first byte desired in
the first block transferred. +
Proposed Max Length - Optional. +
File Designator Length. +
File Designator. +
Metadata - Optional.

|2 |11.21.6.4 | |TH sends a Block message to DUT + DUT sends a BlockAck
message back to TH. |Verify that the BlockAck message has the following
mandatory fields. +
Block Counter - Must correspond to the Block Counter which was embedded
in the Block being acknowledged.

|3 |11.21.6.7 | |TH sends a BlockEOF message to DUT + DUT sends a
BlockAckEOF message back to TH. |Verify that the BlockAckEOF message has
the following mandatory fields. +
Block Counter - Must correspond to the Block Counter which was embedded
in the BlockEOF being acknowledged.
|===

[[_notestesting_considerations_133]]
====== link:#_notestesting_considerations_133[]Notes/Testing Considerations

This test can be verified using TC-SU-2.3 from the OTA Software Update
section. +
This test cannot be executed with V1.0 SDK.

'''''

[[_tc_bdx_2_4_asynchronous_file_sending_removed]]
===== link:#_tc_bdx_2_4_asynchronous_file_sending_removed[]42.2.4. [TC-BDX-2.4] Asynchronous File Sending - REMOVED

[[_category_169]]
====== link:#_category_169[]Category

Conformance

[[_purpose_170]]
====== link:#_purpose_170[]Purpose

This test case verifies that the DUT can successfully send files in
Asynchronous mode.

[[_pics_169]]
====== link:#_pics_169[]PICS

* MCORE.BDX.AsynchronousSender

[[_required_devices_169]]
====== link:#_required_devices_169[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Receiver
|2 |DUT |DUT as BDX Sender
|===

[[_device_topology_122]]
====== link:#_device_topology_122[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_169]]
====== link:#_test_procedure_169[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.6.4 | |DUT sends a SendInit message to TH + TH sends a
SendAccept message back to DUT + DUT sends a Block message to TH.
|Verify that the Block message has the following mandatory fields. +
Block Counter - Must start at 0 at the start of the transfer. +
Data - The length must be in the range [0 < Length ⇐ Max Block Size],
where Max Block Size is the negotiated Max Block Size matching the
SendAccept message that initiated the transfer.

|2 |11.21.6.4 | |DUT sends a Block message to TH. |Verify that the
Blocks are sent in ascending and sequential block counter order.

|3 |11.21.6.4 | |DUT sends a BlockEOF message to TH + TH sends a
BlockAckEOF message back to DUT. |Verify that the BlockEOF message has
the following mandatory fields +
Block Counter. +
Data - The length must be in the range [0 ⇐ Length ⇐ Max Block Size],
where Max Block Size is the negotiated Max Block Size matching the
SendAccept message that initiated the transfer. +
Verify that the pre-negotiated file size was transferred, if a definite
size had been given.
|===

[[_notestesting_considerations_134]]
====== link:#_notestesting_considerations_134[]Notes/Testing Considerations

This test can be initiated from OTA Software Update section or
Diagnostic Logs cluster section. This test can also be verified with TH
sending a ReceiveInit message to the DUT. +
This test cannot be executed with V1.0 SDK.

'''''

[[_tc_bdx_2_5_asynchronous_file_receiving_removed]]
===== link:#_tc_bdx_2_5_asynchronous_file_receiving_removed[]42.2.5. [TC-BDX-2.5] Asynchronous File Receiving - REMOVED

[[_category_170]]
====== link:#_category_170[]Category

Conformance

[[_purpose_171]]
====== link:#_purpose_171[]Purpose

This test case verifies that the DUT can successfully receive files in
Asynchronous mode.

[[_pics_170]]
====== link:#_pics_170[]PICS

* MCORE.BDX.AsynchronousReceiver

[[_required_devices_170]]
====== link:#_required_devices_170[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as BDX Sender
|2 |DUT |DUT as BDX Receiver
|===

[[_device_topology_123]]
====== link:#_device_topology_123[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_170]]
====== link:#_test_procedure_170[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.21.5.1 | |DUT sends a ReceiveInit message to TH + TH sends a
ReceiveAccept message back to DUT + TH sends a Block message to DUT.
|Verify that the ReceiveInit message has the following fields. +
Proposed Transfer Control - PTC[ASYNC] field bit shall be set.

|2 |11.21.6.7 | |TH sends a BlockEOF message to DUT + DUT sends a
BlockAckEOF message back to TH. |Verify that the BlockAckEOF message has
the following mandatory fields. +
Block Counter - Must correspond to the Block Counter which was embedded
in the BlockEOF being acknowledged.
|===

[[_notestesting_considerations_135]]
====== link:#_notestesting_considerations_135[]Notes/Testing Considerations

This test can be initiated from OTA Software Update section or
Diagnostic Logs cluster section. This test can also be verified with TH
sending a SendInit message to the DUT. +
This test cannot be executed with V1.0 SDK.

'''''

[[_ota_software_update_test_plan]]
== link:#_ota_software_update_test_plan[]**OTA Software Update Test Plan**

[[_pics_definition_13]]
=== link:#_pics_definition_13[]43. PICS Definition

This section covers the Software Update Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.OTA.Requestor |Does the DUT implement the OTA Requestor Device
Type? |O |

|MCORE.OTA.Provider |Does the DUT implement the OTA Provider Device
Type? |O |

|MCORE.OTA.HTTPS |Does the DUT support the HTTPS Protocol for OTA image
download? |O |

|MCORE.OTA.RequestorConsent |Does the DUT support obtaining user consent
for OTA application by virtue of built-in user interface capabilities?
|O |

|MCORE.OTA.Resume |Does the DUT support resumption of a transfer
previously aborted? |O |

|MCORE.OTA.VendorSpecific |Does the DUT support Vendor specific OTA
implementation? |O |

|MCORE.ACL.Administrator |Does the DUT have Administer privilege over
the Access Control of another node? |O |

|MCORE.OTA.Retry |Does the Requestor DUT support querying a different
Provider in its OTA Provider List when it hits error conditions in
invoking the QueryImage command? |O |

|OTAP.S.M.DelayedActionTime |Does the DUT support sending the
DelayedActionTime field in _QueryImageResponse_ Command? |O |

|OTAP.S.M.UserConsentNeeded |Does the DUT support sending the
UserConsentNeeded field in _QueryImageResponse_ Command? |O |

|OTAR.C.M.AnnounceOTAProvider |Does the DUT support sending the
_AnnounceOTAProvider_ Command? |O |

|OTAR.C.M.NotifyUpdateApplied |Does the DUT support sending the
_NotifyUpdateApplied_ Command? |O |
|===

[[_test_case_list_12]]
=== link:#_test_case_list_12[]44. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*

|1 |TC-SU-1.1 |Invoke AnnounceOTAProvider from Admin(DUT) to OTA-R

|2 |TC-SU-2.1 |QueryImage Command from DUT to OTA-P

|3 |TC-SU-2.2 |Handling different QueryImageResponse scenarios on
Requestor

|4 |TC-SU-2.3 |Transfer of Software Update Images between OTA-R(DUT) and
OTA-P

|5 |TC-SU-2.4 |ApplyUpdateRequest command from DUT to OTA-P

|6 |TC-SU-2.5 |Handling different ApplyUpdateResponse scenarios on
Requestor

|7 |TC-SU-2.6 |NotifyUpdateApplied Command from DUT to OTA-P

|8 |TC-SU-2.7 |Verifying Events on OTA-R(DUT)

|9 |TC-SU-2.8 |OTA functionality in Multi Fabric scenario

|10 |TC-SU-3.1 |QueryImageResponse from DUT to OTA-R

|11 |TC-SU-3.2 |Handling different QueryImageResponse scenarios on
Provider

|12 |TC-SU-3.3 |Transfer of Software Update Images between OTA-R and
OTA-P(DUT)

|13 |TC-SU-3.4 |Handling different ApplyUpdateResponse scenarios on
Provider

|14 |TC-SU-4.1 |Verifying cluster attributes on OTA-R(DUT)

|15 |TC-SU-4.2 |Verifying cluster attributes from Admin(DUT)
|===

[[_test_cases_12]]
=== link:#_test_cases_12[]45. Test Cases

'''''

[[_ota_provider_discovery]]
==== link:#_ota_provider_discovery[]45.1. OTA Provider Discovery

'''''

[[_tc_su_1_1_invoke_announceotaprovider_from_admindut_to_ota_r]]
===== link:#_tc_su_1_1_invoke_announceotaprovider_from_admindut_to_ota_r[]45.1.1. [TC-SU-1.1] Invoke AnnounceOTAProvider from Admin(DUT) to OTA-R

[[_category_171]]
====== link:#_category_171[]Category

Functional

[[_purpose_172]]
====== link:#_purpose_172[]Purpose

This test case verifies that the DUT is able to invoke the
_AnnounceOTAProvider_ command on the OTA-R.

[[_pics_171]]
====== link:#_pics_171[]PICS

* MCORE.ACL.Administrator

[[_required_devices_171]]
====== link:#_required_devices_171[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as administrator.
|2 |TH |Test harness 1 as OTA-R device type.
|3 |TH2 |Test harness 2 as OTA-P device type.
|===

[[_device_topology_124]]
====== link:#_device_topology_124[]Device Topology

TH, TH2 and DUT are on the same fabric.

[[_test_setup_67]]
====== link:#_test_setup_67[]Test Setup

OTA-R/TH and DUT are on the same fabric. OTA-P/TH2 is commissioned later
as part of the test step.

[[_test_procedure_171]]
====== link:#_test_procedure_171[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.19.7.7 |OTAR.C.M.AnnounceOTAProvider |Commission OTA-P/TH2 to
DUT/same fabric as in test setup. |Verify that the DUT invokes
_AnnounceOTAProvider_ command on the OTA-R. +
Verify that the command received contains the following mandatory
fields. +
ProviderNodeID of the OTA-P/TH2 on the accessing fabric. +
Vendor Id of the node invoking this command. Should be same as it
appears in the Node’s Basic Information Cluster. +
AnnouncementReason - Should be SimpleAnnouncement. +
MetadataForNode - Optional. +
Endpoint number of the OTA-P/TH2 on the ProviderNodeID.
|===

[[_notestesting_considerations_136]]
====== link:#_notestesting_considerations_136[]Notes/Testing Considerations

Vendor needs to mention steps on how to trigger the
_AnnounceOTAProvider_ Command.

'''''

[[_querying_the_ota_provider]]
==== link:#_querying_the_ota_provider[]45.2. Querying the OTA Provider

'''''

[[_tc_su_2_1_queryimage_command_from_dut_to_ota_p]]
===== link:#_tc_su_2_1_queryimage_command_from_dut_to_ota_p[]45.2.1. [TC-SU-2.1] QueryImage Command from DUT to OTA-P

[[_category_172]]
====== link:#_category_172[]Category

Functional

[[_purpose_173]]
====== link:#_purpose_173[]Purpose

This test case verifies that the DUT is able to successfully send a
_QueryImage_ command to the OTA-P

[[_pics_172]]
====== link:#_pics_172[]PICS

* MCORE.OTA.Requestor

[[_required_devices_172]]
====== link:#_required_devices_172[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness as OTA-P device type.
|3 |TH2 |Test harness 2 as Administrator.
|===

[[_device_topology_125]]
====== link:#_device_topology_125[]Device Topology

TH, TH2 and DUT are on the same fabric.

[[_test_setup_68]]
====== link:#_test_setup_68[]Test Setup

TH, TH2 and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

[[_test_procedure_172]]
====== link:#_test_procedure_172[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.19.6.7 | |DUT sends a _QueryImage_ command to the TH/OTA-P
|Verify the _QueryImage_ command received on the server has the
following mandatory fields +
VendorID - Should match the value reported by the Basic Information
Cluster _VendorID_ attribute of the DUT. +
ProductID - Should match the value reported by the Basic Information
Cluster _ProductID_ attribute of the DUT. +
SoftwareVersion - Should match the value reported by the Basic
Information Cluster _SoftwareVersion_ attribute of the DUT. +
Verify the field ProtocolsSupported lists the BDX Synchronous
protocol. +
IF (MCORE.OTA.HTTPS) HTTPS protocol should be listed. +
HardwareVersion - If present, verify that it matches the value reported
by the Basic Information Cluster _HardwareVersion_ attribute of the
DUT. +
If the Location field is present, verify that the value is same as Basic
Information Cluster _Location_ Attribute of the DUT. +
IF (MCORE.OTA.RequestorConsent) RequestorCanConsent field should be set
to True. Otherwise it should be False. +
MetadataForProvider - Optional.

|2 |11.19.3.2 | |DUT sends a _QueryImage_ command to the TH/OTA-P. +
Wait for 2 minutes. |On the TH/OTA-P verify that the _QueryImage_
command is sent only once in that 2 minutes interval.

|3 |11.19.7.7 | |TH2/Administrator sends an _AnnounceOTAProvider_
command to the DUT. |Verify that the DUT queries the indicated OTA
Provider at the ProviderLocation at its next upcoming OTA Provider
query.
|===

[[_notestesting_considerations_137]]
====== link:#_notestesting_considerations_137[]Notes/Testing Considerations

Triggering OTA on the DUT is vendor specific. This is applicable for all
devices which are triggering OTA.

'''''

[[_tc_su_2_2_handling_different_queryimageresponse_scenarios_on_requestor]]
===== link:#_tc_su_2_2_handling_different_queryimageresponse_scenarios_on_requestor[]45.2.2. [TC-SU-2.2] Handling Different QueryImageResponse Scenarios on Requestor

[[_category_173]]
====== link:#_category_173[]Category

Functional

[[_purpose_174]]
====== link:#_purpose_174[]Purpose

This test case verifies that the DUT behaves according to the spec on
different scenarios of the _QueryImageResponse_ Command from the OTA-P.

[[_pics_173]]
====== link:#_pics_173[]PICS

* MCORE.OTA.Requestor

[[_required_devices_173]]
====== link:#_required_devices_173[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness as OTA-P device type.
|===

[[_device_topology_126]]
====== link:#_device_topology_126[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_69]]
====== link:#_test_setup_69[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

[[_test_procedure_173]]
====== link:#_test_procedure_173[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.19.6.8 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable". Set ImageURI to the location where the image is
located. |Verify that there is a transfer of the software image from the
TH/OTA-P to the DUT.

|2 |11.19.6.8 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"Busy", DelayedActionTime is set to 60 seconds. |Verify that the DUT
does not send a _QueryImage_ command before the minimum interval defined
by spec which is 2 minutes (120 seconds) from the last _QueryImage_
command.

|3 |11.19.6.8 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"NotAvailable". |Verify that the DUT does not send a _QueryImage_
command before the minimum interval defined by spec which is 2 minutes
(120 seconds) from the last _QueryImage_ command.

|4 |11.19.6.8 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
Busy, Set DelayedActionTime to 3 minutes. On the subsequent _QueryImage_
command, TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus
is set to "UpdateAvailable". |Verify that the DUT waits for at least the
time mentioned in the DelayedActionTime (3 minutes) before issuing
another _QueryImage_ command to the TH/OTA-P. +
Verify that there is a transfer of the software image after the second
_QueryImageResponse_ with UpdateAvailable status from the TH/OTA-P to
the DUT.

|5 |11.19.6.8 |MCORE.OTA.HTTPS |DUT sends a _QueryImage_ command to the
TH/OTA-P. TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus
is set to "UpdateAvailable", ImageURI should have the https url from
where the image can be downloaded. |Verify that the DUT queries the
https url and downloads the software image.

|6 |11.19.3.2 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable", Software Version should be set to the same or an
older (numerically lower) version. |Verify that the DUT does not start
transferring the software image.

|7 |11.19.3.2 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable", ImageURI field contains an invalid BDX ImageURI.
|Verify that the DUT does not start transferring the software image.
|===

[[_notestesting_considerations_138]]
====== link:#_notestesting_considerations_138[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_transfer_of_software_update_images]]
==== link:#_transfer_of_software_update_images[]45.3. Transfer of Software Update Images

'''''

[[_tc_su_2_3_transfer_of_software_update_images_between_dut_and_thota_p]]
===== link:#_tc_su_2_3_transfer_of_software_update_images_between_dut_and_thota_p[]45.3.1. [TC-SU-2.3] Transfer of Software Update Images between DUT and TH/OTA-P

[[_category_174]]
====== link:#_category_174[]Category

Functional

[[_purpose_175]]
====== link:#_purpose_175[]Purpose

This test case verifies that the DUT behaves according to the spec when
it is transferring images from the TH/OTA-P.

[[_pics_174]]
====== link:#_pics_174[]PICS

* MCORE.OTA.Requestor

[[_required_devices_174]]
====== link:#_required_devices_174[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness as OTA-P device type.
|===

[[_device_topology_127]]
====== link:#_device_topology_127[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_70]]
====== link:#_test_setup_70[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

[[_test_procedure_174]]
====== link:#_test_procedure_174[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.19.6.6 |MCORE.OTA.RequestorConsent |DUT sends a _QueryImage_
command to the TH/OTA-P. RequestorCanConsent is set to True by DUT.
OTA-P/TH responds with a _QueryImageResponse_ with UserConsentNeeded
field set to True. |Verify that the DUT obtains the User Consent from
the user prior to transfer of software update image. This step is vendor
specific.

|2 |11.19.3.5 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable". Set ImageURI to the location where the image is
located. |Verify that there is a transfer of the software image from the
TH/OTA-P to the DUT. Verify that the Maximum Block Size requested by DUT
should be +
- no larger than 1024 (2^10) bytes over non-TCP transports. +
- no larger than 8192 (2^13) bytes over TCP transport.

|3 |11.19.3.5 |MCORE.OTA.HTTPS |DUT sends a _QueryImage_ command to the
TH/OTA-P. TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus
is set to "UpdateAvailable". Set ImageURI with the https url of the
software image. |Verify that there is a transfer of the software image
from the TH/OTA-P to the DUT from the https url and not from the OTA-P.

|4 |11.19.3.5 | |During the transfer of the image to the DUT, force fail
the transfer before it completely transfers the image. Wait for the Idle
timeout so that reading the _UpdateState_ Attribute of the OTA Requestor
returns the value as Idle. Initiate another _QueryImage_ Command from
DUT to the TH/OTA-P. |Verify that the BDX Idle timeout should be no less
than 5 minutes. +
Verify that the DUT starts a new transfer of software image when sending
another _QueryImage_ request.

|5 |11.19.3.5 |MCORE.OTA.Resume |During the transfer of the image to the
DUT, force fail the transfer before it completely transfers the image.
Initiate another _QueryImage_ Command from DUT to the TH/OTA-P. Set the
RC[STARTOFS] bit and associated STARTOFS field in the ReceiveInit
Message to indicate the resumption of a transfer previously aborted.
|Verify that the DUT starts receiving the rest of the software image
after resuming the image transfer.

|6 | |MCORE.OTA.VendorSpecific |Perform the OTA Update on DUT using
vendor specific mechanism. |Verify that there is a transfer of the
software image to the DUT.
|===

[[_notestesting_considerations_139]]
====== link:#_notestesting_considerations_139[]Notes/Testing Considerations

Requestor User Consent is specific to vendor implementation. +
Test Step #3 cannot be executed with V1.0 SDK. +
Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_applying_a_software_update]]
==== link:#_applying_a_software_update[]45.4. Applying a Software Update

'''''

[[_tc_su_2_4_applyupdaterequest_command_from_dut_to_ota_p]]
===== link:#_tc_su_2_4_applyupdaterequest_command_from_dut_to_ota_p[]45.4.1. [TC-SU-2.4] ApplyUpdateRequest Command from DUT to OTA-P

[[_category_175]]
====== link:#_category_175[]Category

Functional

[[_purpose_176]]
====== link:#_purpose_176[]Purpose

This test case verifies that the DUT behaves according to the spec when
it is applying the software update.

[[_pics_175]]
====== link:#_pics_175[]PICS

* MCORE.OTA.Requestor

[[_required_devices_175]]
====== link:#_required_devices_175[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness as OTA-P device type.
|===

[[_device_topology_128]]
====== link:#_device_topology_128[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_71]]
====== link:#_test_setup_71[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

[[_test_procedure_175]]
====== link:#_test_procedure_175[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.6.10 | |DUT sends a _QueryImage_ command to the TH/OTA-P.
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable". Set ImageURI to the location where the image is
located. After the DUT transfers the image, the DUT should send
_ApplyUpdateRequest_ to the OTA-P. |Verify that the request received on
the OTA-P has the following mandatory fields. +
UpdateToken - verify that it is same as the one sent in the
_QueryImageResponse_. +
NewVersion - verify that this is the same as the software version that
was downloaded.
|===

[[_notestesting_considerations_140]]
====== link:#_notestesting_considerations_140[]Notes/Testing Considerations

Vendor needs to provide instructions on how to trigger the DUT/OTA-R to
send the _ApplyUpdateRequest_.

'''''

[[_tc_su_2_5_handling_different_applyupdateresponse_scenarios_on_requestor]]
===== link:#_tc_su_2_5_handling_different_applyupdateresponse_scenarios_on_requestor[]45.4.2. [TC-SU-2.5] Handling Different ApplyUpdateResponse Scenarios on Requestor

[[_category_176]]
====== link:#_category_176[]Category

Functional

[[_purpose_177]]
====== link:#_purpose_177[]Purpose

This test case verifies that the DUT behaves according to the spec when
it is applying the software update.

[[_pics_176]]
====== link:#_pics_176[]PICS

* MCORE.OTA.Requestor

[[_required_devices_176]]
====== link:#_required_devices_176[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness as OTA-P device type.
|===

[[_device_topology_129]]
====== link:#_device_topology_129[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_72]]
====== link:#_test_setup_72[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

DUT sends a _QueryImage_ command to the TH/OTA-P. TH/OTA-P sends a
_QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable". Set ImageURI to the location where the image is
located. After the DUT transfers the image, the DUT should send
_ApplyUpdateRequest_ to the OTA-P.

[[_test_procedure_176]]
====== link:#_test_procedure_176[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.6.11 | |OTA-P/TH sends the _ApplyUpdateResponse_ Command to
the DUT. Action field is set to "Proceed", DelayedActionTime is set to
0. |Verify that the DUT starts updating its software. +
Once the update is finished, verify the _SoftwareVersion_ attribute from
the Basic Information cluster on the DUT to match the version downloaded
for the software update. +
Verify on the OTA-P/TH that there is no other _ApplyUpdateRequest_ from
the DUT.

|2 |11.19.6.11 | |OTA-P/TH sends the _ApplyUpdateResponse_ Command to
the DUT. Action field is set to "Proceed", DelayedActionTime is set to 3
minutes. |Verify that the DUT starts updating its software after 3
minutes. Once the update is finished, verify the _SoftwareVersion_
attribute from the Basic Information cluster on the DUT to match the
version downloaded for the software update.

|3 |11.19.6.11 | |OTA-P/TH sends the _ApplyUpdateResponse_ Command to
the DUT. Action field is set to "AwaitNextAction", DelayedActionTime is
set to 1 minute. |Verify that the DUT waits for the minimum interval
defined by spec which is 2 minutes before re-sending the
_ApplyUpdateRequest_ to the OTA-P. +
Verify that the DUT does not apply the software update within this time.

|4 |11.19.6.11 | |OTA-P/TH sends the _ApplyUpdateResponse_ Command to
the DUT. Action field is set to "AwaitNextAction", DelayedActionTime is
set to 3 minutes. On the subsequent _ApplyUpdateRequest_ command,
TH/OTA-P sends the _ApplyUpdateResponse_ back to DUT. Action field is
set to "Proceed". |Verify that the DUT waits for 3 minutes before
sending the _ApplyUpdateRequest_ to the OTA-P. +
Verify that the DUT starts updating its software after the second
_ApplyUpdateResponse_ with Proceed action. +
Once the update is finished, verify the _SoftwareVersion_ attribute from
the Basic Information cluster on the DUT to match the version downloaded
for the software update.

|5 |11.19.6.11 | |OTA-P/TH sends the _ApplyUpdateResponse_ Command to
the DUT. Action field is set to "Discontinue". |Verify that the DUT
clears its previously downloaded software image, and resets the
_UpdateState_ Attribute to Idle. +
Verify that the DUT does not send the _NotifyUpdateApplied_ within a
reasonable time. +
Verify the _SoftwareVersion_ attribute from the Basic Information
cluster of the DUT to be the same as it was previously.

|6 | |MCORE.OTA.VendorSpecific |Apply the OTA Update on DUT using vendor
specific mechanism. |Verify that the DUT starts updating its software. +
Once the update is finished, verify the _SoftwareVersion_ attribute from
the Basic Information cluster on the DUT to match the version downloaded
for the software update.
|===

[[_notestesting_considerations_141]]
====== link:#_notestesting_considerations_141[]Notes/Testing Considerations

Software version can be verified by querying the Basic Information
cluster.

'''''

[[_tc_su_2_6_notifyupdateapplied_command_from_dut_to_ota_p]]
===== link:#_tc_su_2_6_notifyupdateapplied_command_from_dut_to_ota_p[]45.4.3. [TC-SU-2.6] NotifyUpdateApplied Command from DUT to OTA-P

[[_category_177]]
====== link:#_category_177[]Category

Functional

[[_purpose_178]]
====== link:#_purpose_178[]Purpose

This test case verifies that the DUT behaves according to the spec when
it is applying the software update.

[[_pics_177]]
====== link:#_pics_177[]PICS

* MCORE.OTA.Requestor

[[_required_devices_177]]
====== link:#_required_devices_177[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness as OTA-P device type.
|===

[[_device_topology_130]]
====== link:#_device_topology_130[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_73]]
====== link:#_test_setup_73[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

DUT sends a _QueryImage_ command to the TH/OTA-P. TH/OTA-P sends a
_QueryImageResponse_ back to DUT. QueryStatus is set to
"UpdateAvailable". Set ImageURI to the location where the image is
located.After the DUT transfers the image, the DUT should send
_ApplyUpdateRequest_ to the OTA-P. +
OTA-P/TH sends the _ApplyUpdateResponse_ Command to the DUT. +
Action field is set to "Proceed"

[[_test_procedure_177]]
====== link:#_test_procedure_177[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.6.12 |OTAR.C.M.NotifyUpdateApplied |DUT sends the
_NotifyUpdateApplied_ Command to the OTA-P after installing the software
update. |Verify that the _NotifyUpdateApplied_ message received on the
OTA-P has the following fields. +
UpdateToken - verify that it is the same as the one provided by the OTA
provider in the _QueryImageResponse_. +
SoftwareVersion - verify the software version on the DUT to match the
version downloaded for the software update.
|===

[[_notestesting_considerations_142]]
====== link:#_notestesting_considerations_142[]Notes/Testing Considerations

'''''

[[_requestor_cluster_events]]
==== link:#_requestor_cluster_events[]45.5. Requestor Cluster Events

'''''

[[_tc_su_2_7_verifying_events_on_ota_rdut]]
===== link:#_tc_su_2_7_verifying_events_on_ota_rdut[]45.5.1. [TC-SU-2.7] Verifying Events on OTA-R(DUT)

[[_category_178]]
====== link:#_category_178[]Category

Functional

[[_purpose_179]]
====== link:#_purpose_179[]Purpose

This test case verifies that the DUT behaves according to the spec when
events are generated.

[[_pics_178]]
====== link:#_pics_178[]PICS

* MCORE.OTA.Requestor

[[_required_devices_178]]
====== link:#_required_devices_178[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*

|1 |DUT |OTA-R device type.

|2 |TH |OTA-P device type

|3 |OTA-Subscriber |any device which has subscribed to the OTA events
from the DUT.
|===

[[_device_topology_131]]
====== link:#_device_topology_131[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_74]]
====== link:#_test_setup_74[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle. +
OTA-SUB should be setup such that it is subscribing to the OTA events
from the DUT

[[_test_procedure_178]]
====== link:#_test_procedure_178[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.7.8 | |Perform a software update on the DUT. |Verify that the
OTA-Subscriber receives a _StateTransition_ event notification for all
the state changes i.e. Querying, Downloading, Applying, Idle (optional).

|2 |11.19.7.8 | |DUT sends a _QueryImage_ command to the TH/OTA-P. +
TH/OTA-P sends a _QueryImageResponse_ back to DUT. QueryStatus is set to
"Busy". |Verify that the OTA-Subscriber receives a _StateTransition_
event notification for the state change to DelayedOnQuery.

|3 |11.19.7.8 | |DUT sends a _QueryImage_ command to the TH/OTA-P. +
TH/OTA-P does not respond back to DUT. |Verify that the OTA-Subscriber
receives a _StateTransition_ event notification for the state change to
Idle.

|4 |11.19.7.8 |MCORE.OTA.RequestorConsent |DUT sends a _QueryImage_
command to the TH/OTA-P. RequestorCanConsent is set to True by DUT.
OTA-P/TH responds with a _QueryImageResponse_ with UserConsentNeeded
field set to True. |Verify that the OTA-Subscriber receives a
_StateTransition_ event notification for the state change to
DelayedOnUserConsent.

|5 |11.19.7.8 | |Force an error during the download of the OTA image to
the DUT. Wait for the Idle timeout which should be no less than 5
minutes. |Verify that the OTA-Subscriber receives a _StateTransition_
event notification for the state change to Idle. +
Verify that the OTA-Subscriber receives a _DownloadError_ event
notification on BDX Idle timeout. +
Verify that the data in this event has the following. +
SoftwareVersion - Set to the value of the SoftwareVersion being
downloaded. +
BytesDownloaded - Number of bytes that have been downloaded. +
ProgressPercent - Nearest Integer percent value reflecting how far
within the transfer the failure occurred. IF the total length of the
transfer is unknown, the value can be NULL. +
PlatformCode - Internal product-specific error code or NULL.

|6 |11.19.7.8 | |After the OTA image is transferred, DUT sends
_ApplyUpdateRequest_ to the OTA-P. OTA-P/TH sends the
_ApplyUpdateResponse_ Command to the DUT. Action field is set to
"AwaitNextAction". |Verify that the OTA-Subscriber receives a
_StateTransition_ event notification for the state change to
DelayedOnApply.

|7 |11.19.7.8 | |DUT successfully finishes applying a software update,
and the new software image version is being executed on the DUT.
OTA-Subscriber sends a read request to read the _VersionApplied_ event
from the DUT. |Verify that the _VersionApplied_ event is generated
whenever a new version starts executing after being applied due to a
software update. +
Verify that the data in this event has the following. +
SoftwareVersion - Same as the one available in the _SoftwareVersion_
attribute of the Basic Information Cluster for the newly executing
version. +
ProductID - Same as what is available in the _ProductID_ attribute of
the Basic Information Cluster.
|===

[[_notestesting_considerations_143]]
====== link:#_notestesting_considerations_143[]Notes/Testing Considerations

'''''

[[_multiple_fabrics]]
==== link:#_multiple_fabrics[]45.6. Multiple Fabrics

'''''

[[_tc_su_2_8_ota_functionality_in_multi_fabric_scenario]]
===== link:#_tc_su_2_8_ota_functionality_in_multi_fabric_scenario[]45.6.1. [TC-SU-2.8] OTA Functionality in Multi Fabric Scenario

[[_category_179]]
====== link:#_category_179[]Category

Functional

[[_purpose_180]]
====== link:#_purpose_180[]Purpose

This test case verifies that the DUT is able to successfully send a
_QueryImage_ command to the OTA-P in multi fabric scenario.

[[_pics_179]]
====== link:#_pics_179[]PICS

* MCORE.OTA.Requestor

[[_required_devices_179]]
====== link:#_required_devices_179[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH1 |Test harness 1 as OTA-P device type.
|3 |TH2 |Test harness 2 as OTA-P device type.
|===

[[_device_topology_132]]
====== link:#_device_topology_132[]Device Topology

Commission TH1 and TH2 on different fabrics and DUT to both these
fabrics.

[[_test_setup_75]]
====== link:#_test_setup_75[]Test Setup

Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
_DefaultOTAProviders_ Attribute is set by Administrators, either during
Commissioning or at a later time, to set the Provider Location for the
default OTA Provider Node to use for software updates on a given Fabric.
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

[[_test_procedure_179]]
====== link:#_test_procedure_179[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.19.3.1 | |DUT sends a _QueryImage_ command to TH1/OTA-P. |Verify
the _QueryImage_ command received on the server has the following
mandatory fields +
VendorId - Should match the value reported by the Basic Information
Cluster _VendorID_ attribute of the DUT. +
ProductId - Should match the value reported by the Basic Information
Cluster _ProductID_ attribute of the DUT. +
HardwareVersion - If present, verify that it matches the value reported
by the Basic Information Cluster _HardwareVersion_ attribute of the
DUT. +
SoftwareVersion - Should match the value reported by the Basic
Information Cluster _SoftwareVersion_ attribute of the DUT. +
Verify the field ProtocolsSupported lists the BDX Synchronous
protocol. +
IF (MCORE.OTA.HTTPS_Supported) HTTPS protocol should be listed. +
Verify the default value of RequestorCanConsent is set to False unless
DUT sets it to True. +
If the Location field is present, verify that the value is same as Basic
Information Cluster _Location_ Attribute of the DUT.

|2 |11.19.3.1 |MCORE.OTA.Retry |DUT sends a _QueryImage_ command to
TH1/OTA-P. TH1/OTA-P does not respond with _QueryImageResponse_. |Verify
that the DUT sends a _QueryImage_ command to TH2/OTA-P when failing to
reach out to TH1/OTA-P after a finite number of unsuccessful attempts.

|3 |11.19.7.7 | |DUT sends a _QueryImage_ command to TH2/OTA-P.
TH2/OTA-P sends a _QueryImageResponse_ back to the DUT. Status is set to
UpdateAvailable. |Verify that there is a transfer of the software image
from TH2/OTA-P to the DUT.
|===

[[_notestesting_considerations_144]]
====== link:#_notestesting_considerations_144[]Notes/Testing Considerations

Triggering OTA on the DUT is vendor specific. This is applicable for all
devices which are triggering OTA.

'''''

[[_querying_the_ota_provider_2]]
==== link:#_querying_the_ota_provider_2[]45.7. Querying the OTA Provider

'''''

[[_tc_su_3_1_queryimageresponse_from_dut_to_ota_r]]
===== link:#_tc_su_3_1_queryimageresponse_from_dut_to_ota_r[]45.7.1. [TC-SU-3.1] QueryImageResponse from DUT to OTA-R

[[_category_180]]
====== link:#_category_180[]Category

Functional

[[_purpose_181]]
====== link:#_purpose_181[]Purpose

This test case verifies that the DUT behaves according to the spec when
it receives a QueryImageRequest from the OTA-R.

[[_pics_180]]
====== link:#_pics_180[]PICS

* MCORE.OTA.Provider

[[_required_devices_180]]
====== link:#_required_devices_180[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-P device type.
|2 |TH |Test harness as OTA-R device type.
|===

[[_device_topology_133]]
====== link:#_device_topology_133[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_76]]
====== link:#_test_setup_76[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
There is no ongoing OTA process, and reading the _UpdateState_ Attribute
of the OTA Requestor should return the value as Idle.

[[_test_procedure_180]]
====== link:#_test_procedure_180[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.6.7 | |OTA-R/TH sends a _QueryImage_ Command to the DUT. +
UserConsentNeeded field is set to False. |Verify that the DUT is able to
query the server where the software update image is located. DUT should
obtain the User Consent from the user. DUT should respond with the
_QueryImageResponse_ to the OTA-R/TH.
|===

[[_notestesting_considerations_145]]
====== link:#_notestesting_considerations_145[]Notes/Testing Considerations

Test Step #1 - User Consent is obtained from the user and is specific to
vendor implementation.

'''''

[[_tc_su_3_2_handling_different_queryimageresponse_scenarios_on_provider]]
===== link:#_tc_su_3_2_handling_different_queryimageresponse_scenarios_on_provider[]45.7.2. [TC-SU-3.2] Handling Different QueryImageResponse Scenarios on Provider

[[_category_181]]
====== link:#_category_181[]Category

Functional

[[_purpose_182]]
====== link:#_purpose_182[]Purpose

This test case verifies that the DUT behaves according to the spec in
sending the correct _QueryImageResponse_ to the OTA-R.

[[_pics_181]]
====== link:#_pics_181[]PICS

* MCORE.OTA.Provider

[[_required_devices_181]]
====== link:#_required_devices_181[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-P device type.
|2 |TH |Test harness as OTA-R device type.
|===

[[_device_topology_134]]
====== link:#_device_topology_134[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_77]]
====== link:#_test_setup_77[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
DUT should be able to get user consent prior to _QueryImageResponse_
when needed.

[[_test_procedure_181]]
====== link:#_test_procedure_181[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.6.8 | |OTA-R/TH sends a _QueryImage_ Command to the DUT. +
RequestorCanConsent field can be set to either True or False in the
_QueryImage_ Command. +
DUT responds with the _QueryImageResponse_ to the OTA-R/TH. |Verify that
the DUT sends a _QueryImageResponse_ Command to the OTA-R/TH. +
Verify if the following fields are populated correctly. +
Status - UpdateAvailable - Mandatory. +
ImageURI - Mandatory - contain a URI where the OTA Requestor SHOULD
download a Software Image. +
SoftwareVersion - Mandatory - Verify this is the same as the new
software image version. +
SoftwareVersionString - Mandatory - This is the string type of the
Software version. +
UpdateToken - verify it is within 8-32 bytes. +
UserConsentNeeded if present should be of type bool. +
MetadataForRequestor - Optional.

|2 |11.19.6.8 | |There should not be any new software update available
for the OTA-R/TH. OTA-R/TH sends a _QueryImage_ Command to the DUT. +
DUT responds with the _QueryImageResponse_ to the OTA-R/TH. |Verify that
the DUT sends a _QueryImageResponse_ Command to the OTA-R/TH. +
Verify if the following fields are populated correctly. +
Status - NotAvailable - Mandatory. +
Rest of the fields are optional.

|3 |11.19.6.8 | |OTA-R/TH sends a _QueryImage_ Command to the DUT. +
ProtocolSupported field should list BDX. DUT responds with the
_QueryImageResponse_ to the OTA-R/TH. |Verify that the DUT sends a
_QueryImageResponse_ Command to the OTA-R/TH. +
Verify the following fields in the image URI field. +
Verify the URI’s scheme field is “bdx” in lowercase characters. +
Verify the URI’s authority field contains only the string representation
of the Operational Node ID of the Node where to proceed with the
download. +
Verify that the encoding of the Node ID in the host field uses an
uppercase hexadecimal format, using exactly 16 characters to encode the
network byte order value of the NodeID. +
Verify that the Operational Node ID in the host field matches with the
NodeID of the OTA Provider responding with the _QueryImageResponse_. +
Verify that the the user section of the authority field is absent. +
Verify that the URI does not contain +
Query field. +
Fragment field. +
Verify that the path field has the absolute path to the software
image. +
Verify that the path has only valid URI characters. +
Verify that the URI is 24 characters or longer. +
Verify the presence of prefix 'bdx://'.

|4 |11.19.6.8 | |OTA-R/TH sends a _QueryImage_ Command to the DUT.
ProtocolSupported field should list "https". DUT responds with a
_QueryImageResponse_ to the OTA-R/TH. |Verify the URI should be a valid
https string.

|5 |11.19.6.8 |OTAP.S.M.DelayedActionTime |OTA-R/TH sends a _QueryImage_
Command to the DUT. +
DUT responds with the _QueryImageResponse_ with QueryStatus set to
"Busy", DelayedActionTime set to 3 minutes. On the subsequent
_QueryImage_ command, DUT sends a _QueryImageResponse_ back to OTA-R/TH.
QueryStatus is set to "UpdateAvailable". |Verify that the DUT sends a
_QueryImageResponse_ Command to the OTA-R/TH +
Verify if the following fields are populated correctly. +
Status - Busy. +
DelayedActionTime - 3 minutes. +
Verify that the OTA-R/TH starts the download from the DUT after the
second _QueryImageResponse_ with UpdateAvailable status. +
Verify that the Image downloaded by the OTA-R/TH is valid and is the
same image that was supposed to be downloaded.
|===

[[_notestesting_considerations_146]]
====== link:#_notestesting_considerations_146[]Notes/Testing Considerations

Other than Test Case #2 all test cases assume that the software update
image is available. +
Test Step #2 - The DUT should not have any cached image already
downloaded. +
Verification of Test Case #3 can be done with Test Case #1. +
Test Step #4 cannot be executed with V1.0 SDK.

'''''

[[_transfer_of_software_update_images_2]]
==== link:#_transfer_of_software_update_images_2[]45.8. Transfer of Software Update Images

'''''

[[_tc_su_3_3_transfer_of_software_update_images_between_dut_and_ota_r]]
===== link:#_tc_su_3_3_transfer_of_software_update_images_between_dut_and_ota_r[]45.8.1. [TC-SU-3.3] Transfer of Software Update Images between DUT and OTA-R

[[_category_182]]
====== link:#_category_182[]Category

Functional

[[_purpose_183]]
====== link:#_purpose_183[]Purpose

This test case verifies that the DUT behaves according to the spec when
it is transferring images to the TH/OTA-R.

[[_pics_182]]
====== link:#_pics_182[]PICS

* MCORE.OTA.Provider

[[_required_devices_182]]
====== link:#_required_devices_182[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-P device type.
|2 |TH |Test harness as OTA-R device type.
|===

[[_device_topology_135]]
====== link:#_device_topology_135[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_78]]
====== link:#_test_setup_78[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
DUT should be able to get user consent prior to _QueryImageResponse_
when needed.

[[_test_procedure_182]]
====== link:#_test_procedure_182[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.3.5 | |OTA-R/TH sends a _QueryImage_ Command to the DUT.
Protocol supported should only list "BDX". DUT responds with the
_QueryImageResponse_ to the OTA-R/TH. |Verify that the OTA-R/TH starts
the download from the DUT. Verify that the DUT uses +
- Receiver-Drive mode for transfers on non-TCP transport. +
- Asynchronous mode for transfers on TCP transport. +
Verify that the Actual Block Size should the negotiated Maximum Block
Size for every block except the last one. +
Verify that the Maximum Block sizes constraints are followed as below +
- should be a power of two if OTA-R/TH requests larger than 128 bytes. +
- should be exact requested value for value between 16 and 128 bytes. +
- support at least 1024 bytes over non-TCP transports. +
- support at least 4096 (2^12) bytes over TCP transports. +
Verify that the Image downloaded by the OTA-R/TH is valid and is the
same image that was supposed to be downloaded.

|2 |11.19.6.6 |OTAP.S.M.UserConsentNeeded |TH sends a _QueryImage_
command to the DUT. +
RequestorCanConsent is set to True by TH. DUT responds with a
_QueryImageResponse_ with UserConsentNeeded field set to True. |Verify
that the DUT does not try to obtain User Consent from the user prior to
transfer of software update image.

|3 |11.19.6.6 |OTAP.S.M.UserConsentNeeded |TH sends a _QueryImage_
command to the DUT. RequestorCanConsent is set to True by TH. DUT
responds with a _QueryImageResponse_ with UserConsentNeeded field set to
False. |Verify that the DUT tries to obtain User Consent from the user
prior to transfer of software update image.

|4 |11.19.3.5 | |During the transfer of the image from the DUT, force
fail the transfer before it completely transfers the image. Wait for the
Idle timeout. Initiate another _QueryImage_ Command from OTA-R/TH to the
DUT. |Verify that the DUT stops sending the image and can restart
sending from the beginning when a new _QueryImage_ request is received.
Verify that the BDX Idle timeout should be no less than 5 minutes.

|5 |11.19.3.5 | |During the transfer of the image from the DUT, force
fail the transfer before it completely transfers the image. Initiate
another _QueryImage_ Command from OTA-R/TH to the DUT. Set the
RC[STARTOFS] bit and associated STARTOFS field in the ReceiveInit
Message sent from the TH to indicate the resumption of a transfer
previously aborted. |Verify that the DUT resumes the previously aborted
transfer. +
Verify that the DUT finishes sending the image to the TH.

|6 | |MCORE.OTA.VendorSpecific |Perform the OTA Update from DUT using
vendor specific mechanism. |Verify that there is a transfer of the
software image from the DUT.
|===

[[_notestesting_considerations_147]]
====== link:#_notestesting_considerations_147[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_applying_a_software_update_2]]
==== link:#_applying_a_software_update_2[]45.9. Applying a Software Update

'''''

[[_tc_su_3_4_handling_different_applyupdateresponse_scenarios_on_provider]]
===== link:#_tc_su_3_4_handling_different_applyupdateresponse_scenarios_on_provider[]45.9.1. [TC-SU-3.4] Handling Different ApplyUpdateResponse Scenarios on Provider

[[_category_183]]
====== link:#_category_183[]Category

Functional

[[_purpose_184]]
====== link:#_purpose_184[]Purpose

This test case verifies that the DUT behaves according to the spec on
when a software update should be applied by the OTA-R.

[[_pics_183]]
====== link:#_pics_183[]PICS

* MCORE.OTA.Provider

[[_required_devices_183]]
====== link:#_required_devices_183[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-P device type.
|2 |TH |Test harness as OTA-R device type.
|===

[[_device_topology_136]]
====== link:#_device_topology_136[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_79]]
====== link:#_test_setup_79[]Test Setup

TH and DUT are on the same fabric. +
Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric. +
DUT should be able to get user consent prior to _QueryImageResponse_
when needed.

[[_test_procedure_183]]
====== link:#_test_procedure_183[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.6.11 | |OTA-R/TH on completion of image download sends an
_ApplyUpdateRequest_ Command to the DUT. |Verify that the DUT sends an
_ApplyUpdateResponse_ Command to the OTA Requestor. +
Verify that the following fields are non empty +
Action - Proceed. +
DelayedActionTime - Zero or non zero.

|2 |11.19.6.11 | |OTA-R/TH on completion of image download sends an
_ApplyUpdateRequest_ command to the DUT. DUT responds with the
_ApplyUpdateResponse_ with Action set to "AwaitNextAction",
DelayedActionTime set to 3 minutes. On the subsequent
_ApplyUpdateRequest_ command, DUT sends a _ApplyUpdateResponse_ back to
DUT. Action is set to Proceed. |Verify that the DUT sends an
_ApplyUpdateResponse_ Command to the OTA-R/TH +
Verify if the following fields are populated correctly. +
Action - AwaitNextAction. +
DelayedActionTime - 3 minutes.

|3 |11.19.6.11 | |OTA-R/TH on completion of image download sends an
_ApplyUpdateRequest_ command to the DUT. DUT responds with the
_ApplyUpdateResponse_ with Action set to "Discontinue". Initiate another
_QueryImage_ Command from OTA-R/TH to the DUT. |Verify that the DUT
sends an _ApplyUpdateResponse_ Command to the OTA Requestor with
"Discontinue" in the action field of the response. +
Verify that the entire OTA process is restarted on DUT when OTA-R/TH
sends another _QueryImage_ Request.
|===

[[_notestesting_considerations_148]]
====== link:#_notestesting_considerations_148[]Notes/Testing Considerations

Test Cases where the DUT needs to be forced to send a certain response
might not be testable.

'''''

[[_requestor_cluster_attributes]]
==== link:#_requestor_cluster_attributes[]45.10. Requestor Cluster Attributes

'''''

[[_tc_su_4_1_verifying_cluster_attributes_on_ota_rdut]]
===== link:#_tc_su_4_1_verifying_cluster_attributes_on_ota_rdut[]45.10.1. [TC-SU-4.1] Verifying Cluster Attributes on OTA-R(DUT)

[[_category_184]]
====== link:#_category_184[]Category

Functional

[[_purpose_185]]
====== link:#_purpose_185[]Purpose

This test case verifies that the DUT behaves according to the spec with
the Cluster attributes.

[[_pics_184]]
====== link:#_pics_184[]PICS

* MCORE.OTA.Requestor

[[_required_devices_184]]
====== link:#_required_devices_184[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as OTA-R device type.
|2 |TH |Test harness1 as Administrator to perform read/write operations.
|3 |TH2 |Test harness2 as OTA-P on first fabric.
|4 |TH3 |Test harness3 as OTA-P on second fabric.
|5 |TH4 |Test harness4 as second OTA-P on first fabric.
|===

[[_device_topology_137]]
====== link:#_device_topology_137[]Device Topology

TH2 and TH4 are on the same fabric and TH3 is on a different fabric. +
DUT is commissioned to both these fabrics. +
TH can be on either fabric depending on the test.

[[_test_setup_80]]
====== link:#_test_setup_80[]Test Setup

Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric.

[[_test_procedure_184]]
====== link:#_test_procedure_184[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.7.5 | |TH sends a write request for the _DefaultOTAProviders_
Attribute on the first fabric to the DUT. TH2 is set as the default
Provider for the fabric. |Verify that the write operation for the
attribute works and DUT does not respond with any errors.

|2 |11.19.7.5 | |TH sends a read request to read the
_DefaultOTAProviders_ Attribute on the first fabric to the DUT. |Verify
that the attribute value is set to TH2 as the default OTA provider for
the fabric.

|3 |11.19.7.5 | |TH sends a write request for the _DefaultOTAProviders_
Attribute on the second fabric to the DUT. TH3 is set as the default
Provider for the fabric. |Verify that the write operation for the
attribute works and DUT does not respond with any errors.

|4 |11.19.7.5 | |TH sends a read request to read the
_DefaultOTAProviders_ Attribute on the first and second fabric to the
DUT. |Verify that the attribute value is set to TH2 as the default OTA
provider for the first fabric and TH3 for the second fabric.

|5 |11.19.7.5 | |TH sends a write request for the _DefaultOTAProviders_
Attribute on the first fabric to the DUT. TH4 is the first Provider
location and TH2 is the second Provider location in the same write
request on the first fabric. TH sends a read request to read the
_DefaultOTAProviders_ Attribute on the first and second fabric to the
DUT. |Verify that the write operation fails with CONSTRAINT_ERROR status
code 0x87. +
Verify that the attribute value is set to TH3 as the default OTA
provider for the second fabric and either of TH2 or TH4 for the first
fabric.

|6 |11.19.7.5 | |TH sends a write request for the _DefaultOTAProviders_
Attribute with an empty provider list on the second fabric to the DUT.
TH sends a read request to read the _DefaultOTAProviders_ Attribute on
the first and second fabric to the DUT. |Verify that the write operation
for the attribute works and DUT does not respond with any errors. +
Verify that the attribute value is set to TH4 as the default OTA
provider for the first fabric and none for the second fabric.

|7 |11.19.7.5 | |TH sends a read request to read the _UpdatePossible_
attribute from the DUT. |Verify that the attribute value is set to True
when there is an update possible.

|8 |11.19.7.5 | |TH sends a read request to read the _UpdateState_
Attribute from the DUT. |Verify that the attribute value is set to one
of the following values. +
Unknown, Idle, Querying, DelayedOnQuery, Downloading, Applying,
DelayedOnApply, RollingBack, DelayedOnUserConsent.

|9 |11.19.7.5 | |DUT should start initiating the Software update
process. While the DUT is downloading the image, TH sends a read request
to read the _UpdateStateProgress_ attribute from the DUT. |Verify that
the attribute value is a percentage value of the download progress.
|===

[[_notestesting_considerations_149]]
====== link:#_notestesting_considerations_149[]Notes/Testing Considerations

'''''

[[_tc_su_4_2_verifying_cluster_attributes_from_admindut]]
===== link:#_tc_su_4_2_verifying_cluster_attributes_from_admindut[]45.10.2. [TC-SU-4.2] Verifying Cluster Attributes from Admin(DUT)

[[_category_185]]
====== link:#_category_185[]Category

Functional

[[_purpose_186]]
====== link:#_purpose_186[]Purpose

This test case verifies that the DUT behaves according to the spec with
the Cluster attributes.

[[_pics_185]]
====== link:#_pics_185[]PICS

* MCORE.ACL.Administrator

[[_required_devices_185]]
====== link:#_required_devices_185[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as Administrator.
|2 |TH |Test harness as OTA-R device type.
|===

[[_device_topology_138]]
====== link:#_device_topology_138[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_81]]
====== link:#_test_setup_81[]Test Setup

Commissioner or Administrator should install necessary ACL entries at
commissioning time or later to enable processing of _QueryImage_
commands from OTA Requestors on their fabric.

[[_test_procedure_185]]
====== link:#_test_procedure_185[]Test Procedure

[width="100%",cols="10%,10%,20%,30%,30%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.19.7.5 | |DUT sends a write request for the _DefaultOTAProviders_
Attribute to the TH. |TH receives the write command and does not reject
the value as invalid.

|2 |11.19.7.5 | |DUT sends a read request to read the
_DefaultOTAProviders_ Attribute to the TH. |TH receives the read command
and knows this attribute for the OTA Software Update Requestor cluster.

|3 |11.19.7.5 | |DUT sends a read request to read the _UpdatePossible_
attribute from the TH. |TH receives the read command and knows this
attribute for the OTA Software Update Requestor cluster.

|4 |11.19.7.5 | |DUT sends a read request to read the _UpdateState_
Attribute from the TH. |TH receives the read command and knows this
attribute for the OTA Software Update Requestor cluster.

|5 |11.19.7.5 | |TH should start initiating the Software update process.
While the TH is downloading the image, DUT sends a read request to read
the _UpdateStateProgress_ attribute from the TH. |TH receives the read
command and knows this attribute for the OTA Software Update Requestor
cluster.
|===

[[_notestesting_considerations_150]]
====== link:#_notestesting_considerations_150[]Notes/Testing Considerations

[[_access_control_enforcement_test_plan]]
== link:#_access_control_enforcement_test_plan[]**Access Control Enforcement Test Plan**

[[_pics_definition_14]]
=== link:#_pics_definition_14[]46. PICS Definition

This section covers the Access Control Enforcement Test Plan related
PICS items that are referenced in the following test cases.

[[_role_7]]
==== link:#_role_7[]46.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACL.S |Does the device implement the Access Control cluster cluster as
a server? |O |

|ACL.C |Does the device implement the Access Control cluster cluster as
a client? |O |

|APPDEVICE.S |Does the device implement an Application Device Type on
any endpoint |O |
|===

[[_server_7]]
==== link:#_server_7[]46.2. Server

[[_attributes_9]]
===== link:#_attributes_9[]46.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACL.S.A0000(ACL) |Does the DUT support the ACL attribute? |M |
|===

[[_pixit_definition_5]]
=== link:#_pixit_definition_5[]47. PIXIT Definition

This section covers the Access Control Enforcement Test Plan related
PIXIT items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.ACE.APPENDPOINT |Endpoint that the device implements the
Application Device Type on |APPDEVICE.S |

|PIXIT.ACE.APPDEVTYPEID |Application Device type ID that the DUT
implements on PIXIT.ACE.APPENDPOINT |APPDEVICE.S |

|PIXIT.ACE.APPCLUSTER |Server cluster implemented on
PIXIT.ACE.APPENDPOINT (must include at least one attribute) |APPDEVICE.S
|

|PIXIT.ACE.APPATTRIBUTE |Attribute from PIXIT.ACE.APPCLUSTER to use for
ACE tests |APPDEVICE.S |
|===

[[_test_case_list_13]]
=== link:#_test_case_list_13[]48. Test Case List

[width="99%",cols="18%,16%,66%",options="header",]
|===
|# |TC UUID |Test Case Name
|1 |TC-ACE-1.1 |Privileges [DUT-Commissionee]
|2 |TC-ACE-1.2 |Subscriptions [DUT-Commissionee]
|3 |TC-ACE-1.3 |Subjects [DUT-Commissionee]
|4 |TC-ACE-1.4 |Targets [DUT-Commissionee]
|5 |TC-ACE-1.5 |Multi-fabric [DUT-Commissionee]
|6 |TC-ACE-1.6 |Group auth mode [DUT-Commissionee]
|===

[[_test_cases_13]]
=== link:#_test_cases_13[]49. Test Cases

[[_cluster_attribute_test_cases]]
==== link:#_cluster_attribute_test_cases[]49.1. Cluster Attribute test cases

[[_tc_ace_1_1_privileges]]
===== link:#_tc_ace_1_1_privileges[]49.1.1. [TC-ACE-1.1] Privileges

[[_category_186]]
====== link:#_category_186[]Category

Functional conformance

[[_purpose_187]]
====== link:#_purpose_187[]Purpose

. Verify that access control is correctly enforced for reading
attributes.
. Verify that access control is correctly enforced for writing
attributes.
. Verify that access control is correctly enforced for invoking
commands.
. Verify that access control is correctly enforced for reading events.
. Verify that access control is correctly enforced when existing
privileges are removed.

[[_pics_186]]
====== link:#_pics_186[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_32]]
====== link:#_pre_conditions_32[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|===

[[_required_devices_186]]
====== link:#_required_devices_186[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH |Commissioner - uses node ID `N1`
|===

[[_test_setup_82]]
====== link:#_test_setup_82[]Test Setup

[[_test_procedure_186]]
====== link:#_test_procedure_186[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | |TH1 commissions DUT using admin node ID `N1` |DUT is
commissioned on TH1 fabric

|2 | | a|
TH writes the ACL attribute with a list of AccessControlEntryStruct
entries containing 1 elements, granting itself administer privileges on
all of Endpoint 0:

. struct
+
* Fabric Index: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: null, Endpoint: 0, DeviceType: null}]

|Result is SUCCESS

|3 | | |TH reads the NOCs attribute from the Node Operational
Credentials cluster using a fabric-scoped read (requires administer
privilege) |DUT returns a list of NOCs containing 1 entry

|4 | | |TH writes the Location attribute in the Basic Information
cluster with "XX" (requires administer privilege) |Result is SUCCESS

|5 | | |TH sends the UpdateFabricLabel command to the Node Operational
Credentials cluster with the Label field set to "TestFabric" (requires
administer privilege) |Result is SUCCESS

|[#manage-success-start]####6 | | |TH writes the NodeLabel attribute in
the Basic Information cluster with the string "TestNode" (requires
manage privilege) |Result is SUCCESS

|7 | | |TH sends the TestEventTrigger command to the General Diagnostics
cluster with the EnableKey set to 0 and the EventTrigger set to 0
(requires manage privilege). Note that this will cause an error to be
returned because the EnableKey is invalid, but still indicates that the
TH passed the ACL check. |Result is CONSTRAINT_ERROR

|[#view-success]####8 | | |TH reads the VendorID attribute from the
Basic Information cluster (requires view privilege) |Result is SUCCESS

|9 | | a|
TH writes the ACL attribute with a list of AccessControlEntryStruct
entries containing 2 elements, giving itself administer privilege only
on the Access Control cluster and manage privilege on everything else on
EP0.

. struct
+
* Fabric Index: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: 0x001F, Endpoint: 0}]
. struct
+
* Fabric Index: 1
* Privilege field: Manage (4)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|[#administer-fail-start]####10 | | |TH reads the NOCs attribute from
the Node Operational Credentials cluster using a fabric-filtered read
(requires administer privilege) |Result is UNSUPPORTED_ACCESS (0x7e)

|11 | | |TH writes the Location attribute in the Basic Information
cluster with "XX" (requires administer privilege) |Result is
UNSUPPORTED_ACCESS (0x7e)

|[#administer-fail-end]####12 | | |TH sends the UpdateFabricLabel
command to the operational credentials cluster with the Label field set
to "TestFabric" (requires administer privilege) |Result is
UNSUPPORTED_ACCESS (0x7e)

|13 | | |Repeat steps link:#manage-success-start[6] to
link:#view-success[8] to confirm that TH still has access associated
with manage and view privileges |

|14 | | a|
TH writes the ACL attribute with a list of AccessControlEntryStruct
entries containing 2 elements, giving itself administer privilege only
on the Access Control cluster and operate privilege on everything else
on EP0.

. struct
+
* Fabric Index: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: 0x001F, Endpoint: 0}]
. struct
+
* Fabric Index: 1
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|15 | | |Repeat steps link:#administer-fail-start[10] to
link:#administer-fail-end[12] to confirm that TH still does not have
administer privileges |

|[#manage-fail-start]####16 | | a|
TH writes the NodeLabel attribute in the Basic Information cluster with
the string "TestNode" (requires manage privilege)

|Result is UNSUPPORTED_ACCESS (0x7e)

|[#manage-fail-end]####17 | | a|
TH sends the TestEventTrigger command to the General Diagnostics cluster
with the EnableKey set to 0 and the EventTrigger set to 0. (requires
manage privilege)

|Result is UNSUPPORTED_ACCESS (0x7e)

|18 | | |Repeat step link:#view-success[8] to confirm that the TH still
has view privileges |

|19 | | a|
TH1 writes the ACL attribute with a list of AccessControlEntryStruct
entries containing 2 elements, giving itself administer privilege only
on the Access Control cluster and view privilege on everything else on
EP0.

. struct
+
* Fabric Index: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: 0x001F, Endpoint: 0}]
. struct
+
* Fabric Index: 1
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|20 | | |Repeat steps link:#administer-fail-start[10] to
link:#administer-fail-end[12] to confirm that TH still does not have
administer privileges |

|21 | | |Repeat steps link:#manage-fail-start[16] to
link:#manage-fail-end[17] to confirm that TH still does not have manage
privileges |

|22 | | |Repeat step link:#view-success[8] to confirm that the TH still
has view privileges |

|23 | | a|
TH writes the ACL attribute with a list of AccessControlEntryStruct
entries containing a single element, granting Administer privilege on
only the Access Control cluster and no other access.

. struct
+
* Fabric Index: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: 0x001F, Endpoint: 0}]

|Result is SUCCESS

|24 | | |Repeat steps link:#administer-fail-start[10] to
link:#administer-fail-end[12] to confirm that TH still does not have
administer privileges |

|25 | | |Repeat steps link:#manage-fail-start[16] to
link:#manage-fail-end[17] to confirm that TH still does not have manage
privileges |

|26 | | |TH reads the VendorID attribute from the Basic Information
cluster (requires view privilege) |Result is UNSUPPORTED_ACCESS (0x7e)

|27 | | |TH writes the ACL attribute with a list of
AccessControlEntryStruct entries containing a single element, restoring
full access to the node. +
. struct +
- Fabric Index: 1 +
- Privilege field: Administer (5) +
- AuthMode field: CASE (2) +
- Subjects field: [`N1`] +
- Targets field: null |Result is SUCCESS
|===

[[_tc_ace_1_2_subscriptions]]
===== link:#_tc_ace_1_2_subscriptions[]49.1.2. [TC-ACE-1.2] Subscriptions

[[_category_187]]
====== link:#_category_187[]Category

Functional conformance

[[_purpose_188]]
====== link:#_purpose_188[]Purpose

. Verify that access control is correctly enforced for new
subscriptions.
. Verify that access control is correctly enforced for existing
subscriptions when privileges change.

[[_pics_187]]
====== link:#_pics_187[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_33]]
====== link:#_pre_conditions_33[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|===

[[_required_devices_187]]
====== link:#_required_devices_187[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner - uses node ID `N1`
|3 |TH2 |Administrator (client) - uses node ID `N2`, same fabric as `N1`
|===

[[_test_setup_83]]
====== link:#_test_setup_83[]Test Setup

[[_test_procedure_187]]
====== link:#_test_procedure_187[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | |TH1 commissions DUT |DUT is commissioned on TH1 fabric

|2 |9.10.5.3 | a|
TH1 writes AccessControl cluster ACL attribute, +
value is a list of AccessControlEntryStruct containing 1 element:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, `N2`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|[#subscribe-view-success]####3 |9.10.5.3 | |TH2 subscribes to the
General Commissioning cluster Breadcrumb attribute, +
min interval 1, max interval 30, keep subscriptions false. |Result is
SUCCESS, save SubscriptionId as `subscription_breadcrumb`

|4 |11.17.6.1 | |TH2 subscribes to the Access Control cluster ACL
attribute, +
min interval 1, max interval 5, keep subscriptions false,
fabric-filtered false. |Result is SUCCESS, save SubscriptionId as
`subscription_acl`

|5 |9.10.7.1 | |TH2 subscribes to the Access Control cluster
AccessControlEntryChanged event, +
min interval 1, max interval 5, keep subscriptions true, fabric-filtered
false. |Result is SUCCESS, save SubscriptionId as `subscription_ace`

|6 |11.17.6.1 | a|
TH1 selects a node id `N_unused` that is different than `N1` and `N2`.
This node ID does not +
need to correspond to an actual node, it is used as a placeholder to
allow changing the +
ACL attribute without affecting the access of `N1` and `N2`. +
TH1 writes Access Control cluster ACL attribute, +
value is a list of AccessControlEntryStruct Containing 1 element:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, `N2`, `N_unused`]
* Targets field: [\{Endpoint: 0}]

|

|7 |8.4.3.1 | |TH2 waits for a subscription report from the DUT on
`subscription_acl` |TH2 receives a report from the DUT for
`subscription_ace`. The AttributeReports list contains an entry with
AttributeData field present. That should contain a Path to the Access
Control cluster AccessControlEntryStruct event.

|8 |8.4.3.1 | |TH2 waits for a subscription report from the DUT on
`subscription_ace` |TH2 receives a report from the DUT for
`subscription_ace`. The EventReports list contains an entry with
EventData field present. That should contain a Path to the Access
Control cluster AccessControlEntryStruct event.

|[#breadcrumb-start]####9 |11.9.6.1 | |TH1 writes the Breadcrumb
attribute on the General Commissioning cluster, setting the value to 1 |

|[#breadcrumb-end]####10 |8.4.3.1 | |TH2 waits for a subscription report
from the DUT |TH2 receives a report from the DUT for
`subscription_breadcrumb`. The AttributeReports list contains an entry
with the AttributeData field present. That should contain a Path to the
General Commissioning cluster Breadcrumb attribute.

|11 |9.10.5.3 | a|
TH1 writes AccessControl cluster ACL attribute, +
value is a list of AccessControlEntryStruct containing 2 elements:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]
. struct
+
* Privilege field: Manage (4)
* AuthMode field: CASE (2)
* Subjects field: [`N2`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|12 | | |Repeat steps link:#breadcrumb-start[9] to
link:#breadcrumb-end[10], incrementing the Breadcrumb value from the
last write, to verify that TH2 can still receive view-privilege
attribute reports. |

|[#subscribe-admin-failure-start]####13 |11.17.6.1 | |TH2 subscribes to
the Access Control cluster ACL attribute, +
min interval 1, max interval 5, keep subscriptions false,
fabric-filtered false. |Result is INVALID_ACTION

|[#subscribe-admin-failure-end]####14 |9.10.7.1 | |TH2 subscribes to the
Access Control cluster AccessControlEntryChanged event, +
min interval 1, max interval 5, keep subscriptions false |Result is
INVALID_ACTION

|[#subscribe-view-success]####15 |9.10.5.3 | |TH2 subscribes to the
General Commissioning cluster Breadcrumb attribute, +
min interval 1, max interval 5, keep subscriptions false |Result is
SUCCESS, save SubscriptionId as `subscription_breadcrumb`

|16 | | |Repeat steps link:#breadcrumb-start[9] to
link:#breadcrumb-end[10], incrementing the Breadcrumb value from the
last write, to verify that TH2 can still receive view-privilege
attribute reports. |

|17 |9.10.5.3 | a|
TH1 writes AccessControl cluster ACL attribute, +
value is a list of AccessControlEntryStruct containing 2 elements:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [`N2`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|18 | | |Repeat steps link:#breadcrumb-start[9] to
link:#breadcrumb-end[10], incrementing the Breadcrumb value from the
last write, to verify that TH2 can still receive view-privilege
attribute reports. |

|19 | | |Repeat steps link:#subscribe-admin-failure-start[13] to
link:#subscribe-admin-failure-end[14] to ensure TH2 still does not have
permissions to subscribe to administer-privilege attributes and events |

|20 | | |Repeat step link:#subscribe-view-success[3] to ensure TH2 can
still subscribe to view events |

|21 | | |Repeat steps link:#breadcrumb-start[9] to
link:#breadcrumb-end[10], incrementing the Breadcrumb value from the
last write, to verify that TH2 can still receive view-privilege
attribute reports. |

|22 |9.10.5.3 | a|
TH1 writes AccessControl cluster ACL attribute, +
value is a list of AccessControlEntryStruct containing 2 elements:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N2`]
* Targets field: [\{Endpoint: 0}]

|Result is SUCCESS

|23 | | |Repeat steps link:#breadcrumb-start[9] to
link:#breadcrumb-end[10], incrementing the Breadcrumb value from the
last write, to verify that TH2 can still receive view-privilege
attribute reports. |

|24 | | |Repeat steps link:#subscribe-admin-failure-start[13] to
link:#subscribe-admin-failure-end[14] to ensure TH2 still does not have
permissions to subscribe to administer-privilege attributes and events |

|25 | | |Repeat step link:#subscribe-view-success[3] to ensure TH2 can
still subscribe to view events |

|26 | | |Repeat steps link:#breadcrumb-start[9] to
link:#breadcrumb-end[10], incrementing the Breadcrumb value from the
last write, to verify that TH2 can still receive view-privilege
attribute reports. |

|27 |9.10.5.3 | a|
TH1 writes AccessControl cluster ACL attribute, +
value is a list of AccessControlEntryStruct containing 1 element

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: []

|Result is SUCCESS

|28 | | |Repeat steps link:#subscribe-admin-failure-start[13] to
link:#subscribe-admin-failure-end[14] to ensure TH2 still does not have
permissions to subscribe to administer-privilege attributes and events |

|29 |9.10.5.3 | |TH2 subscribes to the General Commissioning cluster
Breadcrumb attribute, +
min interval 1, max interval 5, keep subscriptions false |Result is
INVALID_ACTION
|===

[[_tc_ace_1_3_subjects]]
===== link:#_tc_ace_1_3_subjects[]49.1.3. [TC-ACE-1.3] Subjects

[[_category_188]]
====== link:#_category_188[]Category

Functional conformance

[[_purpose_189]]
====== link:#_purpose_189[]Purpose

. Verify that access control is correctly enforced for wildcard
subjects.
. Verify that access control is correctly enforced for node ID subjects.
. Verify that access control is correctly enforced for CAT subjects
(including ID and version).
. Verify that access control is correctly enforced for multiple
subjects.

[[_pics_188]]
====== link:#_pics_188[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_34]]
====== link:#_pre_conditions_34[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |TH0, TH1, TH2, TH3 are on the same fabric

|2 | | |`N0` is the node ID of TH0

|3 | | |`N1` is the node ID of TH1

|4 | | |`N2` is the node ID of TH2

|5 | | |`N3` is the node ID of TH3

|6 | | |DUT is commissioned by TH0

|7 | | |`CAT1v1` is a version 1 CAT

|8 | | |`CAT1v2` is a version 2 CAT with the same ID as `CAT1v1`

|9 | | |`CAT1v3` is a version 3 CAT with the same ID as `CAT1v2`

|10 | | |`CAT2v1` is a version 1 CAT with a different ID from `CAT1v1`

|11 | | |`CAT2v2` is a version 2 CAT with the same ID as `CAT2v1`

|12 | | |`CAT2v3` is a version 3 CAT with the same ID as `CAT2v2`

|13 | | |`CAT1v1_subject` is the ACL subject for `CAT1v1`
(0xFFFF_FFFD_0000_0000 | `CAT1v1`)

|14 | | |`CAT1v2_subject` is the ACL subject for `CAT1v2`
(0xFFFF_FFFD_0000_0000 | `CAT1v2`)

|15 | | |`CAT1v3_subject` is the ACL subject for `CAT1v3`
(0xFFFF_FFFD_0000_0000 | `CAT1v3`)

|16 | | |`CAT2v1_subject` is the ACL subject for `CAT2v1`
(0xFFFF_FFFD_0000_0000 | `CAT2v1`)

|17 | | |`CAT2v2_subject` is the ACL subject for `CAT2v2`
(0xFFFF_FFFD_0000_0000 | `CAT2v2`)

|18 | | |`CAT2v3_subject` is the ACL subject for `CAT2v3`
(0xFFFF_FFFD_0000_0000 | `CAT2v3`)

|19 | | |TH1 has credentials for `CAT1v3`

|20 | | |TH2 has credentials for `CAT1v2` and `CAT2v1`

|21 | | |TH3 has credentials for `CAT1v1` and `CAT2v2`
|===

[[_required_devices_188]]
====== link:#_required_devices_188[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Controller
|4 |TH3 |Controller
|===

[[_test_setup_84]]
====== link:#_test_setup_84[]Test Setup

[[_test_procedure_188]]
====== link:#_test_procedure_188[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
Precondition: TH0 commissions DUT using admin node ID `N0`

a|
DUT is commissioned on TH0 fabric

|2 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|3 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|4 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|5 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|6 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|7 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|8 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|9 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|10 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N2`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|11 |9.10.5.3 | a|
TH1 reads DUT Endpoint 1 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|12 |9.10.5.3 | a|
TH2 reads DUT Endpoint 1 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|13 |9.10.5.3 | a|
TH3 reads DUT Endpoint 1 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|14 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N3`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|15 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|16 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|17 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|18 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, `N2`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|19 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|20 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|21 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|22 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, `N3`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|23 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|24 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|25 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|26 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N2`, `N3`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|27 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|28 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|29 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|30 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, `N2`, `N3`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|31 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|32 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|33 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|34 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`CAT1v1_subject`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|35 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|36 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|37 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|38 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`CAT1v2_subject`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|39 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|40 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|41 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|42 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`CAT1v3_subject`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|43 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|44 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|45 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|46 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`CAT2v1_subject`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|47 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|48 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|49 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|50 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`CAT2v2_subject`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|51 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|52 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|53 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|54 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [`CAT2v3_subject`]
* Targets field: [\{Endpoint: 0}]

a|
Result is SUCCESS

|55 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|56 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|57 |9.10.5.3 | a|
TH3 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|58 | | a|
TH0 writes DUT Endpoint 0 AccessControl cluster ACL attribute to reset +
it back to the default State. +
Value is list of AccessControlEntryStruct containing 1 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N0`]
* Targets field: null

a|
Result is SUCCESS

|===

[[_tc_ace_1_4_targets]]
===== link:#_tc_ace_1_4_targets[]49.1.4. [TC-ACE-1.4] Targets

[[_category_189]]
====== link:#_category_189[]Category

Functional conformance

[[_purpose_190]]
====== link:#_purpose_190[]Purpose

. Verify that access control is correctly enforced for wildcard targets.
. Verify that access control is correctly enforced for cluster targets.
. Verify that access control is correctly enforced for endpoint targets.
. Verify that access control is correctly enforced for device type
targets.
. Verify that access control is correctly enforced for cluster plus
endpoint targets.
. Verify that access control is correctly enforced for cluster plus
device type targets.
. Verify that access control is correctly enforced for multiple targets.
. Verify that access control is correctly enforced for wildcard reads,
and returns correct status.

[[_pics_189]]
====== link:#_pics_189[]PICS

* MCORE.ROLE.COMMISSIONEE

[[_pre_conditions_35]]
====== link:#_pre_conditions_35[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|2 | | |`AppClusterId` is the cluster ID of PIXIT.ACE.APPCLUSTER
|3 | | |`AppAttributeId` is the attribute ID of PIXIT.ACE.APPATTRIBUTE
|===

[[_required_devices_189]]
====== link:#_required_devices_189[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_85]]
====== link:#_test_setup_85[]Test Setup

[[_test_procedure_189]]
====== link:#_test_procedure_189[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: null

a|
Result is SUCCESS

|3 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|4 |9.10.5.3 | a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is SUCCESS

|5 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|6 | | a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: Descriptor (0x001d)}]

a|
Result is SUCCESS

|7 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|8 |9.10.5.3 | a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is SUCCESS

|9 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|10 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: PIXIT.ACE.APPCLUSTER (`AppClusterId`)}]

a|
Result is SUCCESS

|11 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|12 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|13 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|14 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: Descriptor (0x001d), Endpoint:
PIXIT.ACE.APPENDPOINT}]

a|
Result is SUCCESS

|15 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|16 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is SUCCESS

|17 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|18 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: PIXIT.ACE.APPCLUSTER (`AppClusterId`),
Endpoint: PIXIT.ACE.APPENDPOINT}]

a|
Result is SUCCESS

|19 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|20 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|21 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|22 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Endpoint: PIXIT.ACE.APPENDPOINT}]

a|
Result is SUCCESS

|23 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|24 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is SUCCESS

|25 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|26 | | a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{DeviceType: RootNode (0x0016)}]

a|
Result is SUCCESS

|27 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|28 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|29 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|30 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{DeviceType: PIXIT.ACE.APPDEVTYPEID}]

a|
Result is SUCCESS

|31 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|32 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is SUCCESS

|33 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|34 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: Descriptor (0x001d), DeviceType:
PIXIT.ACE.APPDEVTYPEID}]

a|
Result is SUCCESS

|35 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|36 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is SUCCESS

|37 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|38 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: PIXIT.ACE.APPCLUSTER (`AppClusterId`),
DeviceType: PIXIT.ACE.APPDEVTYPEID}]

a|
Result is SUCCESS

|39 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|40 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|41 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|42 | |APPDEVICE.S a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: Descriptor (0x001d), Endpoint: 0}, +
\{Cluster: PIXIT.ACE.APPCLUSTER (`AppClusterId`), Endpoint:
PIXIT.ACE.APPENDPOINT}]

a|
Result is SUCCESS

|43 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|44 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT Endpoint PIXIT.ACE.APPENDPOINT Descriptor cluster
DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|45 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT attribute PIXIT.ACE.APPATTRIBUTE from cluster
PIXIT.ACE.APPCLUSTER on endpoint PIXIT.ACE.APPENDPOINT

a|
Result is SUCCESS

|46 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT wildcard Endpoint Descriptor cluster DeviceTypeList
attribute

a|
Result is

* Endpoint 0: SUCCESS
* Endpoint PIXIT.ACE.APPENDPOINT: MUST NOT report any status, not even
UNSUPPORTED_ACCESS

|47 |9.10.5.3 |APPDEVICE.S a|
TH1 reads DUT wildcard Endpoint PIXIT.ACE.APPCLUSTER cluster
PIXIT.ACE.APPATTRIBUTE attribute

a|
Result is

* Endpoint 0: MUST NOT report any status
* Endpoint PIXIT.ACE.APPENDPOINT: SUCCESS

|48 | | a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute to reset +
it back to the default State. +
Value is list of AccessControlEntryStruct containing 1 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null

a|
Result is SUCCESS

|===

[[_tc_ace_1_5_multi_fabric]]
===== link:#_tc_ace_1_5_multi_fabric[]49.1.5. [TC-ACE-1.5] Multi-fabric

[[_category_190]]
====== link:#_category_190[]Category

Functional conformance

[[_purpose_191]]
====== link:#_purpose_191[]Purpose

. Verify that access control is correctly enforced using only ACLs from
appropriate fabric.

[[_pics_190]]
====== link:#_pics_190[]PICS

* MCORE.ROLE.COMMISSIONEE
* APPDEVICE.S

[[_pre_conditions_36]]
====== link:#_pre_conditions_36[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1 on fabric `F1`
|2 | | |`N2` is the node ID of TH2 on fabric `F2`
|===

[[_required_devices_190]]
====== link:#_required_devices_190[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Commissioner
|===

[[_test_setup_86]]
====== link:#_test_setup_86[]Test Setup

[[_test_procedure_190]]
====== link:#_test_procedure_190[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 opens the commissioning window on the DUT

|
|3 | | a|
TH2 commissions DUT using admin node ID `N2`

a|
DUT is commissioned on TH2 fabric

|4 | | a|
TH2 reads its fabric index from the Operational Credentials cluster +
CurrentFabricIndex attribute

|Read successful, save as `th2FabricIndex`
|5 |9.10.5.3 | a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* FabricIndex: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* FabricIndex: 1
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: Descriptor (0x001d), Endpoint: 0}]

a|
Result is SUCCESS

|6 |9.10.5.3 | a|
TH2 writes DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 2 elements

. struct
+
* FabricIndex: `th2FabricIndex`
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N2`]
* Targets field: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
. struct
+
* FabricIndex: `th2FabricIndex`
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: Basic (0x0028), Endpoint: 0}]

a|
Result is SUCCESS

|7 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is SUCCESS

|8 |9.10.5.3 | a|
TH1 reads DUT Endpoint 0 Basic cluster VendorID attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|9 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Descriptor cluster DeviceTypeList attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|10 |9.10.5.3 | a|
TH2 reads DUT Endpoint 0 Basic cluster VendorID attribute

a|
Result is SUCCESS

|11 |9.10.5.3 | a|
TH1 resets the ACLs to the default value by +
writing DUT Endpoint 0 AccessControl cluster ACL attribute, +
value is list of AccessControlEntryStruct containing 1 elements

. struct
+
* FabricIndex: 1
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null

a|
Result is SUCCESS

|12 |11.17.7.12 | a|
TH1 removes the TH2 fabric by sending the RemoveFabric command +
to the DUT with the FabricIndex set to `th2FabricIndex`

a|
Result is SUCCESS

|===

[[_tc_ace_1_6_group_auth_mode]]
===== link:#_tc_ace_1_6_group_auth_mode[]49.1.6. [TC-ACE-1.6] Group auth mode

[[_category_191]]
====== link:#_category_191[]Category

Functional conformance

[[_purpose_192]]
====== link:#_purpose_192[]Purpose

. Verify that access control is correctly enforced during group
messaging +
using only ACLs with group auth mode.

[[_pics_191]]
====== link:#_pics_191[]PICS

* MCORE.ROLE.COMMISSIONEE
* G.S

[[_pre_conditions_37]]
====== link:#_pre_conditions_37[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|2 | | |`PIXIT.G.ENDPOINT` is an endpoint with a groups cluster
|===

[[_required_devices_191]]
====== link:#_required_devices_191[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH |Commissioner
|===

[[_test_setup_87]]
====== link:#_test_setup_87[]Test Setup

[[_test_procedure_191]]
====== link:#_test_procedure_191[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a3
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: 0xd0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: 0xd1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: 0xd2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify that the DUT sends SUCCESS response

|2 |CoreSpec-11.2.7.2 | a|
TH binds GroupIds 0x0103, 0x0104, 0x0105 with GroupKeySetID 0x01a3 in
the GroupKeyMap attribute list on GroupKeyManagement cluster by writing
the GroupKeyMap attribute with three entries as follows:

* List item 1:
+
** GroupId: 0x0103
** GroupKeySetId: 0x01a3
* List item 2:
+
** GroupId: 0x0104
** GroupKeySetId: 0x01a3
* List item 3:
+
** GroupId: 0x0105
** GroupKeySetId: 0x01a3

|Verify that the DUT sends SUCCESS response.

|3 |AppSpec-1.3.7.2 | |TH sends a AddGroup Command to the Groups cluster
on Endpoint PIXIT.G.ENDPOINT over CASE with the GroupID field set to
0x0103 and the GroupName set to an empty string |DUT responds with
SUCCESS

|4 |CoreSpec-9.10.5.3 | a|
TH writes The ACL attribute in the Access Control cluster to add Manage
privileges for group 0x0103 and maintain the current administrative
privileges for the TH on the Access Control cluster. The following
access control list shall be used:

* List item 1 (TH admin):
+
** Privilege: Administer (5)
** AuthMode: CASE (2)
** Subjects: [`N1`]
** Targets: [\{Cluster: AccessControl (0x001f), Endpoint: 0}]
* List item 2 (group Manage access):
+
** Privilege: Manage (4)
** AuthMode: Group (3)
** Subjects: group 0x0103 ([0x0103])
** Targets: \{Cluster: Groups (0x0004), Endpoint: PIXIT.G.ENDPOINT}

|Verify that the DUT sends SUCCESS response.

|5 |AppSpec-1.3.7.2 | |TH sends a AddGroup Command to the Groups cluster
on Endpoint PIXIT.G.ENDPOINT over CASE with the GroupID field set to
0x0104 and the GroupName set to an empty string |DUT responds with
UNSUPPORTED_ACCESS

|[#add_group_over_groups]####6 |AppSpec-1.3.7.2 | |TH sends a AddGroup
Command to the Groups cluster with the GroupID field set to 0x0104 and
the GroupName set to an empty string. The command is sent as a group
command using GroupID 0x0103 |

|[#add_group_over_groups2]####7 |AppSpec-1.3.7.2 | |TH sends a AddGroup
Command to the Groups cluster with the GroupID field set to 0x0105 and
the GroupName set to an empty string. The command is sent as a group
command using GroupID 0x0104 |

|8 |CoreSpec-9.10.5.3 | a|
TH writes The ACL attribute in the Access Control cluster to revoke
groups Management access and restore full access over CASE by setting
the following ACL list items:

* List item 1 (TH admin):
+
** Privilege: Administer (5)
** AuthMode: CASE (2)
** Subjects: [`N1`]
** Targets: null

|Verify that the DUT sends SUCCESS response.

|9 |AppSpec-1.3.7.2 | |TH sends a ViewGroup Command to the Groups
cluster on Endpoint PIXIT.G.ENDPOINT over CASE with the GroupID set to
0x0104 to confirm that the AddGroup command from step
link:#add_group_over_groups[6] was successful |DUT responds with SUCCESS

|10 |AppSpec-1.3.7.2 | |TH sends a ViewGroup Command to the Groups
cluster on Endpoint PIXIT.G.ENDPOINT over CASE with the GroupID set to
0x0105 to confirm that the AddGroup command from step
link:#add_group_over_groups2[7] was not successful |DUT responds with
NOT_FOUND

|[#add_group_over_groups3]####11 |AppSpec-1.3.7.2 | |TH sends a AddGroup
Command to the Groups cluster with the GroupID field set to 0x0105 and
the GroupName set to an empty string. The command is sent as a group
command using GroupID 0x0103 |

|12 |AppSpec-1.3.7.2 | |TH sends a ViewGroup Command to the Groups
cluster on Endpoint PIXIT.G.ENDPOINT over CASE with the GroupID set to
0x0105 to confirm that the AddGroup command from step
link:#add_group_over_groups3[11] was not successful |DUT responds with
NOT_FOUND

|13 |AppSpec-1.3.7.5 | |TH sends the RemoveAllGroups Command to the
Groups cluster on Endpoint PIXIT.G.ENDPOINT over CASE |DUT responds with
SUCCESS

|14 |CoreSpec-11.2.7.2 | |TH resets the GroupKeyMap attribute list on
GroupKeyManagement cluster by writing the GroupKeyMap attribute with an
empty list |Verify that the DUT sends SUCCESS response.

|15 |CoreSpec-11.2.8.4 | a|
TH resets the key set by sending the KeySetRemove command to the
GroupKeyManagement cluster over CASE with the following fields:

* GroupKeySetID: 0x01a3

|Verify that the DUT sends SUCCESS response.
|===

[[_minimal_resource_requirements_test_plan]]
== link:#_minimal_resource_requirements_test_plan[]**Minimal Resource Requirements Test Plan**

[[_test_case_list_14]]
=== link:#_test_case_list_14[]50. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-RR-1.1 |Minimal Resource Requirements for Matter Node
|===

[[_test_cases_14]]
=== link:#_test_cases_14[]51. Test Cases

'''''

[[_minimal_resource_requirements_test_cases]]
==== link:#_minimal_resource_requirements_test_cases[]51.1. Minimal Resource Requirements Test Cases

'''''

[[_tc_rr_1_1_minimal_resource_requirements_for_matter_node]]
===== link:#_tc_rr_1_1_minimal_resource_requirements_for_matter_node[]51.1.1. [TC-RR-1.1] Minimal Resource Requirements for Matter Node

[[_category_192]]
====== link:#_category_192[]Category

Conformance

[[_purpose_193]]
====== link:#_purpose_193[]Purpose

This test case verifies that the device meets the minimal requirements
for each resource type from the list of various resources required by a
Matter Node implementation.

PICS

* MCORE.ROLE.COMMISSIONEE

[[_required_devices_192]]
====== link:#_required_devices_192[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_139]]
====== link:#_device_topology_139[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_192]]
====== link:#_test_procedure_192[]Test Procedure

[width="100%",cols="4%,6%,10%,65%,15%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |11.17.6, 6.1.3 | |TH begins the process of commissioning the DUT.
After receiving the CSRResponse TH obtains or generates a NOC, the Root
CA Certificate, ICAC and IPK. +
The certificates shall have their subjects padded with additional data
such that they are each the maximum certificate size of 400 bytes when
encoded in the MatterCertificateEncoding. |

|1b |11.17.6, 6.1.3 | |TH sends AddNOC command with CaseAdminSubject as
0xFFFF_FFFD_0001_0001, IpkValue with 3 Epoch Keys and NOC must have CAT
0x0001_0001. |

|1c |11.17.6, 6.1.3 | |TH then reads the unfiltered list of fabrics on
the DUT and removes any fabric found that isn’t the one the TH just
commissioned. |Ensure that only 1 fabric remains on the device and is
the TH’s before continuing.

|1d |11.17.6, 6.1.3 | |Repeat the process to commission DUT to 5
different fabrics. If, for a given fabric, it is not possible for all
certificates in the chain to be of length 400 bytes, then at least 1 of
the set must be larger or equal to 370 bytes and at least one of the set
must be larger or equal to 350 bytes, and at least one must be exactly
400 bytes. All certificate chains have to be valid. |Verify that the
device can be commissioned to the minimum value of _SupportedFabrics_
Attribute on the Node Operational Credentials Cluster which is 5.

|2 |11.17.5.3, 11.1.6.3 | |TH writes the user-visible Label field for
Fabrics to maximum size of 32 characters. TH writes the _NodeLabel_
Attribute to maximum size of 32 characters. |Verify that the device
supports minimum constraints of Fabric Label and _NodeLabel_ Attribute
as mentioned in spec.

|3 |9.10.5 | a|
Add 4 Access Control entries on DUT with a list of 4 Subjects and 3
Targets with the following parameters:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [0xFFFF_FFFD_0001_0001, 0x2000_0000_0000_0001,
0x2000_0000_0000_0002, 0x2000_0000_0000_0003]
* Targets field: [\{Endpoint: 0}, \{Cluster: 0xFFF1_FC00, DeviceType:
0xFFF1_BC30}, \{Cluster: 0xFFF1_FC00, DeviceType: 0xFFF1_BC31}]
. struct
+
* Privilege field: Manage (4)
* AuthMode field: CASE (2)
* Subjects field: [0x1000_0000_0000_0001, 0x1000_0000_0000_0002,
0x1000_0000_0000_0003, 0x1000_0000_0000_0004]
* Targets field: [\{Cluster: 0xFFF1_FC00, DeviceType: 0xFFF1_BC20},
\{Cluster: 0xFFF1_FC01, DeviceType: 0xFFF1_BC21}, \{Cluster:
0xFFF1_FC02, DeviceType: 0xFFF1_BC22}]
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [0x3000_0000_0000_0001, 0x3000_0000_0000_0002,
0x3000_0000_0000_0003, 0x3000_0000_0000_0004]
* Targets field: [\{Cluster: 0xFFF1_FC40, DeviceType: 0xFFF1_BC20},
\{Cluster: 0xFFF1_FC41, DeviceType: 0xFFF1_BC21}, \{Cluster:
0xFFF1_FC02, DeviceType: 0xFFF1_BC42}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [0x4000_0000_0000_0001, 0x4000_0000_0000_0002,
0x4000_0000_0000_0003, 0x4000_0000_0000_0004]
* Targets field: [\{Cluster: 0xFFF1_FC80, DeviceType: 0xFFF1_BC20},
\{Cluster: 0xFFF1_FC81, DeviceType: 0xFFF1_BC21}, \{Cluster:
0xFFF1_FC82, DeviceType: 0xFFF1_BC22}]

Repeat the process for all 5 fabrics.

|Verify that the Subjects have access control privilege on the Targets
according to the ACL entries for each fabric and the device supports
minimum constraints for each of _AccessControlEntriesPerFabric_
Attribute, _SubjectsPerAccessControlEntry_ Attribute and
_TargetsPerAccessControlEntry_ Attribute on the Access Control Cluster.

|4 |4.13.2.8 | |Initiate CASE sessions from 3 different client nodes per
fabric to DUT for a total of 15 sessions. |Verify that the device
supports minimum constraints of 3 CASE session contexts per fabric.

|5 |2.11.2.2 | |Each client subscribes to 3 different attribute/events
paths which includes the _NodeLabel_ Attribute on each fabric to DUT.
|Verify that the device supports minimum constraints of Subscribe
Interaction Limits as mentioned in spec.

|6 |2.11.2.1 | |Send Read Request Message containing 9 separate paths to
cover the first 9 attributes (IDs 0 through 8) of the Basic Information
cluster on Endpoint which includes the _NodeLabel_ Attribute, from all
clients on each fabric to DUT. Record Local and peer session ID for each
client for later use. |Verify that the device supports minimum
constraints of Read Interaction Limits as mentioned in spec.

|7 |2.11.2.2 | |TH writes the _NodeLabel_ Attribute to a different value
than the one used in Step 2. |Verify that all the other clients on all
fabrics receive Report Data message for this value change.

|8 |2.11.2.1 | |Send Read Request Message for the _NodeLabel_ Attribute
from all clients on each fabric to DUT. Record peer session ID for each
client. |Verify that the Local and peer session ID used for each read,
for each client, must have remained the same from Step 7.

|9 |9.7.5.1, 9.9.4.1 |ULABEL.S.A0000(LabelList) |TH writes 4 entries per
endpoint where LabelList is supported with both Label and Value fields
set to max 16 characters. |Verify that the device supports minimum
constraints of _LabelList_ Attribute as mentioned in spec.

|10 |9.10.5 | a|
Add 4 Access Control entries on DUT with a list of 4 Subjects and 3
Targets. Note this is different from above ACL as we are allowing the
group cluster to be read across all endpoints in order for the next step
to run properly. Use the following parameters:

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [0xFFFF_FFFD_0001_0001, 0x2000_0000_0000_0001,
0x2000_0000_0000_0002, 0x2000_0000_0000_0003]
* Targets field: [\{Endpoint: 0}, \{Cluster: 0x0000_0004}, \{Cluster:
0xFFF1_FC00, DeviceType: 0xFFF1_BC31}]
. struct
+
* Privilege field: Manage (4)
* AuthMode field: CASE (2)
* Subjects field: [0x1000_0000_0000_0001, 0x1000_0000_0000_0002,
0x1000_0000_0000_0003, 0x1000_0000_0000_0004]
* Targets field: [\{Cluster: 0xFFF1_FC00, DeviceType: 0xFFF1_BC20},
\{Cluster: 0xFFF1_FC01, DeviceType: 0xFFF1_BC21}, \{Cluster:
0xFFF1_FC02, DeviceType: 0xFFF1_BC22}]
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [0x3000_0000_0000_0001, 0x3000_0000_0000_0002,
0x3000_0000_0000_0003, 0x3000_0000_0000_0004]
* Targets field: [\{Cluster: 0xFFF1_FC40, DeviceType: 0xFFF1_BC20},
\{Cluster: 0xFFF1_FC41, DeviceType: 0xFFF1_BC21}, \{Cluster:
0xFFF1_FC02, DeviceType: 0xFFF1_BC42}]
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [0x4000_0000_0000_0001, 0x4000_0000_0000_0002,
0x4000_0000_0000_0003, 0x4000_0000_0000_0004]
* Targets field: [\{Cluster: 0xFFF1_FC80, DeviceType: 0xFFF1_BC20},
\{Cluster: 0xFFF1_FC81, DeviceType: 0xFFF1_BC21}, \{Cluster:
0xFFF1_FC82, DeviceType: 0xFFF1_BC22}]

Repeat the process for all 5 fabrics.

|Verify that the Subjects have access control privilege on the Targets
according to the ACL entries for each fabric and the device supports
minimum constraints for each of _AccessControlEntriesPerFabric_
Attribute, _SubjectsPerAccessControlEntry_ Attribute and
_TargetsPerAccessControlEntry_ Attribute on the Access Control Cluster.

|11 |2.11.1.2, 11.2, 9.5.4 | |TH counts all Groups cluster entries
(cluster ID 0x0004) in every Descriptor’s `ServerList` instance within
every endpoint found in all 'PartsList' instances. TH records Groups
cluster instances counted as `counted_groups_clusters`. |Verify the
value of `MaxGroupsPerFabric` read from the Group Key Management Cluster
is no less than the Group Limits requirements of 4 (groups) *
`counted_groups_clusters`.

|12 |2.11.1.2, 11.2 | |If `counted_groups_clusters` equals 0, TH skips
this step. TH reads `MaxGroupKeysPerFabric` from the Group Key
Management Cluster. |Verify the value of `MaxGroupKeysPerFabric` is no
less than 3, which is the minimum of group key sets per fabric required
by the Group Limits.

|13 |2.11.1.2, 11.2 | |If `counted_groups_clusters` equals 0, TH skips
this step. TH writes `MaxGroupKeysPerFabric-1` valid and unique group
key sets per fabric to the Group Key Management Cluster, which is the
minimum number of group key sets required, notwithstanding the reserved
Identity Protection Key (IPK) key set. |Verify that a
`KeySetReadAllIndicesResponse` is received and that its `GroupKeySetIDs`
list has `MaxGroupKeysPerFabric` entries present that match the written
values.

|14 |11.2 | |If `counted_groups_clusters` equals 0, TH skips this step.
TH writes `MaxGroupsPerFabric` valid and unique entries per fabric into
`GroupKeyMap` referring to the key sets from step 12. |After all data is
written, verify the contents of `GroupKeyMap` match the values written
and quantity of entries written.

|15 |11.2 | a|
If `counted_groups_clusters` equals 0, TH skips this step. TH adds
`MaxGroupsPerFabric` valid and unique groups per fabric. TH distributes
the groups across all endpoints as follows:

. TH iterates over all 5 fabrics.
+
[loweralpha]
.. TH stores the remainder when calculating
`MaxGroupsPerFabric / counted_groups_clusters` as `groups_remainder`.
.. TH iterates over all endpoints.
+
[lowerroman]
... If no Groups cluster is found in the endpoint’s `ServerList`, TH
continues to the next endpoint.
... TH adds `floor(MaxGroupsPerFabric / counted_groups_clusters)` valid
and unique groups by invoking the `AddGroup` command on the Groups
cluster.
... If `groups_remainder` equals 0, TH continues to the next endpoint.
... TH adds 1 more valid and unique group by invoking the `AddGroup`
command on the Groups cluster.
... TH decreases the value of `groups_remainder` by 1.

|Verify the entries in `GroupTable` contain all groups added. Verify the
`Endpoints` list of each `GroupTable` entry contains a single entry
equal to the endpoint that the the `AddGroup` command was invoked on.
|===

[[_notestesting_considerations_151]]
====== link:#_notestesting_considerations_151[]Notes/Testing Considerations

'''''

[[_system_model_test_plan]]
== link:#_system_model_test_plan[]**System Model Test Plan**

[[_pics_definition_15]]
=== link:#_pics_definition_15[]52. PICS Definition

This section covers the System Model Test Plan related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.SM.S |Is the device a Server |O |
|===

[[_test_case_list_15]]
=== link:#_test_case_list_15[]53. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-SM-1.1 |Device composition - Root Node [DUT as Server]
|TC-SM-1.2 |Device composition - Topology [DUT as Server]
|===

[[_test_cases_15]]
=== link:#_test_cases_15[]54. Test Cases

'''''

[[_device_composition_tests]]
==== link:#_device_composition_tests[]54.1. Device composition tests

'''''

[[_tc_sm_1_1_device_composition_root_node_dut_as_server]]
===== link:#_tc_sm_1_1_device_composition_root_node_dut_as_server[]54.1.1. [TC-SM-1.1] Device composition - Root Node [DUT as Server]

[[_category_193]]
====== link:#_category_193[]Category

[[_purpose_194]]
====== link:#_purpose_194[]Purpose

Tests root node requirements

[[_pics_192]]
====== link:#_pics_192[]PICS

* MCORE.SM.S

[[_required_devices_193]]
====== link:#_required_devices_193[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_140]]
====== link:#_device_topology_140[]Device Topology

TH can connect to DUT over PASE or CASE.

[[_test_procedure_193]]
====== link:#_test_procedure_193[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH performs a wildcard read of all attributes and endpoints |

|2 |C.2.10 | | |Verify that endpoint 0 exists in the returned data

|3 |C.2.10 | | |Verify that the endpoint 0 descriptor cluster
DeviceTypeList includes the Root Node device type id (0x0016)

|4 |\{REF_SM_ENDPOINT} | | |For each of the non-root endpoints, verify
that the descriptor cluster DeviceTypeList does NOT include the Root
Node device type id (0x0016)

|5 |C.2.10 | | |Validate all the mandatory clusters for the Root Node
Device Type exist on the Root Node endpoint.
|===

[[_tc_sm_1_2_device_composition_topology_dut_as_server]]
===== link:#_tc_sm_1_2_device_composition_topology_dut_as_server[]54.1.2. [TC-SM-1.2] Device composition - Topology [DUT as Server]

[[_category_194]]
====== link:#_category_194[]Category

[[_purpose_195]]
====== link:#_purpose_195[]Purpose

Tests that the topology indicated by the descriptor cluster PartsList
matches the requirements in \{REF_SM_ENDPOINT}.

[[_pics_193]]
====== link:#_pics_193[]PICS

* MCORE.IDM.S

[[_required_devices_194]]
====== link:#_required_devices_194[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_141]]
====== link:#_device_topology_141[]Device Topology

TH can connect to DUT over PASE or CASE.

[[_test_procedure_194]]
====== link:#_test_procedure_194[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH performs a wildcard read of all attributes on all endpoints |

|2 | | | |Verify the Descriptor cluster PartsList on endpoint 0 exactly
lists all the other (non-0) endpoints on the DUT - i.e. the endpoints
returned in step 1 (except EP 0) must be listed in the PartsList, and
all endpoints listed in the PartsList must be amongst the endpoint(s)
returned in step 1

|4 | | | |For each endpoint on the DUT (including EP 0), verify the
PartsList in the Descriptor cluster on that endpoint does not include
itself

|5 | | | a|
Create two empty list variables `flat` and `tree`

....
For each non-root endpoint on the DUT
....

* If the DeviceTypeList attribute in the Descriptor cluster for that
endpoint includes the Aggregator device type(0x000e), add the endpoint
id to the `flat` list
* Otherwise, add the endpoint id to the `tree` list

|6 | | | |For each endpoint `e` in the `tree` list, walk the entire
PartsList tree and ensure `e` does not appear in any descendants.

|7 | | | a|
For each endpoint `e` in the `flat` list: +
* for each endpoint id `sub_id` present in the in the PartsList of `e`,
ensure that every id listed in the PartsList for endpoint `sub_id`
appears in the PartsList of `e`

|===

[[_device_types_test_plan]]
== link:#_device_types_test_plan[]**Device Types Test Plan**

[[_pics_definition_16]]
=== link:#_pics_definition_16[]55. PICS Definition

This section covers the Device Types Test Plan related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MCORE.DT.S |Is the device a Server |O |
|===

[[_test_case_list_16]]
=== link:#_test_case_list_16[]56. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-DT-1.1 |Base Device type [DUT as Server]
|===

[[_test_cases_16]]
=== link:#_test_cases_16[]57. Test Cases

'''''

[[_device_composition_tests_2]]
==== link:#_device_composition_tests_2[]57.1. Device composition tests

'''''

[[_tc_dt_1_1_base_device_type_dut_as_server]]
===== link:#_tc_dt_1_1_base_device_type_dut_as_server[]57.1.1. [TC-DT-1.1] Base Device Type [DUT as Server]

[[_category_195]]
====== link:#_category_195[]Category

[[_purpose_196]]
====== link:#_purpose_196[]Purpose

Tests that every device type conforms to the requirements of the base
device type

[[_pics_194]]
====== link:#_pics_194[]PICS

* MCORE.DT.S

[[_required_devices_195]]
====== link:#_required_devices_195[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_142]]
====== link:#_device_topology_142[]Device Topology

TH can connect to DUT over PASE or CASE.

[[_test_procedure_195]]
====== link:#_test_procedure_195[]Test Procedure

[width="100%",cols="10%,8%,16%,33%,33%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |TH performs a wildcard read of all attributes and endpoints |
|2 | | | |Verify that each endpoint includes a Descriptor cluster
|===

[[footer]]
[[footer-text]]
Version master d055a55 +
Last updated 2023-08-18 23:56:16 UTC
