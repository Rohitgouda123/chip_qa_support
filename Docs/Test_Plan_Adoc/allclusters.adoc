[[header]]
== Matter Application Clusters Test Plan

[#revnumber]#version master d055a55,# [#revdate]#2023-08-18 16:55:59
-0700# +
[#revremark]#Draft#

[[toc]]
[[toctitle]]
Table of Contents

* link:#_notice_of_use_and_disclosure[Notice of Use and Disclosure]
* link:#_participants[Participants]
* link:#_document_control[Document Control]
* link:#_document_history[Document History]
** link:#_csa_reference_documents[CSA Reference Documents]
** link:#_external_reference_documents[External Reference Documents]
* link:#_onoff_cluster_test_plan[*On/Off Cluster Test Plan*]
** link:#_pics_definition[1. PICS Definition]
*** link:#_role[1.1. Role]
*** link:#_server[1.2. Server]
**** link:#_features[1.2.1. Features]
**** link:#_attributes[1.2.2. Attributes]
**** link:#_manual_controllable[1.2.3. Manual controllable]
**** link:#_commands_received[1.2.4. Commands received]
*** link:#_client[1.3. Client]
**** link:#_commands_generated[1.3.1. Commands generated]
** link:#_pixit_definition[2. PIXIT Definition]
** link:#_test_case_list[3. Test Case List]
*** link:#_notestesting_considerations[3.1. Notes/Testing
Considerations]
** link:#_test_cases[4. Test Cases]
*** link:#_generic_test_cases[4.1. Generic test cases]
**** link:#_tc_oo_1_1_global_attributes_with_dut_as_server[4.1.1.
[TC-OO-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut[4.2. Server as DUT]
**** link:#_tc_oo_2_1_attributes_with_server_as_dut[4.2.1. [TC-OO-2.1]
Attributes with server as DUT]
**** link:#_tc_oo_2_2_primary_functionality_with_server_as_dut[4.2.2.
[TC-OO-2.2] Primary functionality with server as DUT]
**** link:#_tc_oo_2_3_secondary_functionality_with_server_as_dut[4.2.3.
[TC-OO-2.3] Secondary functionality with server as DUT]
**** link:#_tc_oo_2_4_startup_functionality_with_server_as_dut[4.2.4.
[TC-OO-2.4] Startup functionality with server as DUT]
*** link:#_client_as_dut[4.3. Client as DUT]
**** link:#_tc_oo_3_2_functionality_with_client_as_dut[4.3.1.
[TC-OO-3.2] Functionality with client as DUT]
* link:#_temperature_measurement_cluster_test_plan[*Temperature
Measurement Cluster Test Plan*]
** link:#_pics_definition_2[5. PICS Definition]
*** link:#_role_2[5.1. Role]
*** link:#_server_2[5.2. Server]
**** link:#_attributes_2[5.2.1. Attributes]
**** link:#_manual_controllable_2[5.2.2. Manual controllable]
** link:#_test_case_list_2[6. Test Case List]
** link:#_test_cases_2[7. Test Cases]
*** link:#_generic_test_cases_2[7.1. Generic test cases]
**** link:#_tc_tmp_1_1_global_attributes_with_server_as_dut[7.1.1.
[TC-TMP-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_2[7.2. Server as DUT]
**** link:#_tc_tmp_2_1_attributes_with_server_as_dut[7.2.1. [TC-TMP-2.1]
Attributes with server as DUT]
**** link:#_tc_tmp_2_2_primary_functionality_with_server_as_dut[7.2.2.
[TC-TMP-2.2] Primary functionality with server as DUT]
* link:#_relative_humidity_measurement_cluster_test_plan[*Relative
Humidity Measurement Cluster Test Plan*]
** link:#_pics_definition_3[8. PICS Definition]
*** link:#_role_3[8.1. Role]
*** link:#_server_3[8.2. Server]
**** link:#_attributes_3[8.2.1. Attributes]
**** link:#_manual_controllable_3[8.2.2. Manual controllable]
** link:#_test_case_list_3[9. Test Case List]
** link:#_test_cases_3[10. Test Cases]
*** link:#_generic_test_cases_3[10.1. Generic test cases]
**** link:#_tc_rh_1_1_global_attributes_with_server_as_dut[10.1.1.
[TC-RH-1.1] Global Attributes with Server as DUT]
*** link:#_server_as_dut_3[10.2. Server as DUT]
**** link:#_tc_rh_2_1_attributes_with_server_as_dut[10.2.1. [TC-RH-2.1]
Attributes with Server as DUT]
**** link:#_tc_rh_2_2_primary_functionality_with_server_as_dut[10.2.2.
[TC-RH-2.2] Primary Functionality with Server as DUT]
* link:#_thermostat_user_configuration_cluster_test_plan[*Thermostat
User Configuration Cluster Test Plan*]
** link:#_pics_definition_4[11. PICS Definition]
*** link:#_role_4[11.1. Role]
*** link:#_server_4[11.2. Server]
**** link:#_attributes_4[11.2.1. Attributes]
** link:#_test_case_list_4[12. Test Case List]
** link:#_test_cases_4[13. Test Cases]
*** link:#_generic_test_cases_4[13.1. Generic test cases]
**** link:#_tc_tsuic_1_1_global_attributes_with_dut_as_server[13.1.1.
[TC-TSUIC-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_4[13.2. Server as DUT]
**** link:#_tc_tsuic_2_1_attributes_with_server_as_dut[13.2.1.
[TC-TSUIC-2.1] Attributes with server as DUT]
**** link:#_tc_tsuic_2_2_primary_functionality_with_server_as_dut[13.2.2.
[TC-TSUIC-2.2] Primary functionality with server as DUT]
* link:#_pump_configuration_and_control_cluster_test_plan[*Pump
Configuration and Control Cluster Test Plan*]
** link:#_pics_definition_5[14. PICS Definition]
*** link:#_role_5[14.1. Role]
*** link:#_server_5[14.2. Server]
**** link:#_features_2[14.2.1. Features]
**** link:#_attributes_5[14.2.2. Attributes]
**** link:#_events[14.2.3. Events]
** link:#_test_case_list_5[15. Test Case List]
** link:#_test_cases_5[16. Test Cases]
*** link:#_generic_test_cases_5[16.1. Generic Test Cases]
**** link:#_tc_pcc_1_1_global_attributes_with_dut_as_server[16.1.1.
[TC-PCC-1.1] Global Attributes with DUT as Server]
*** link:#_dut_as_server[16.2. DUT as Server]
**** link:#_tc_pcc_2_1_attributes_with_server_as_dut[16.2.1.
[TC-PCC-2.1] Attributes with Server as DUT]
**** link:#_tc_pcc_2_2_operation_mode_with_server_as_dut[16.2.2.
[TC-PCC-2.2] Operation Mode with Server as DUT]
**** link:#_tc_pcc_2_3_control_mode_with_server_as_dut[16.2.3.
[TC-PCC-2.3] Control Mode with Server as DUT]
**** link:#_tc_pcc_2_4_life_time_counters_with_server_as_dut[16.2.4.
[TC-PCC-2.4] Life Time Counters with Server as DUT]
* link:#_media_cluster_test_plan[*Media Cluster Test Plan*]
** link:#_pics_definition_6[17. PICS Definition]
*** link:#_role_6[17.1. Role]
*** link:#_server_6[17.2. Server]
**** link:#_features_3[17.2.1. Features]
**** link:#_manual_controllable_4[17.2.2. Manual controllable]
**** link:#_attributes_6[17.2.3. Attributes]
**** link:#_commands_received_2[17.2.4. Commands received]
*** link:#_client_2[17.3. Client]
**** link:#_commands_generated_2[17.3.1. Commands generated]
** link:#_test_case_list_6[18. Test Case List]
** link:#_test_cases_6[19. Test Cases]
*** link:#_global_attribute_test_cases[19.1. Global Attribute test
cases]
**** link:#_tc_lowpower_1_1_global_attributes_low_power_cluster_dut_as_server[19.1.1.
[TC-LOWPOWER-1.1] Global attributes - Low Power Cluster (DUT as Server)]
**** link:#_tc_keypadinput_1_2_global_attributes_keypad_input_cluster_dut_as_server[19.1.2.
[TC-KEYPADINPUT-1.2] Global attributes - Keypad Input Cluster (DUT as
Server)]
**** link:#_tc_applauncher_1_3_global_attributes_application_launcher_cluster_dut_as_server[19.1.3.
[TC-APPLAUNCHER-1.3] Global attributes - Application Launcher Cluster
(DUT as Server)]
**** link:#_tc_mediainput_1_4_global_attributes_media_input_cluster_dut_as_server[19.1.4.
[TC-MEDIAINPUT-1.4] Global attributes - Media Input Cluster (DUT as
Server)]
**** link:#_tc_wakeonlan_1_5_global_attributes_wake_on_lan_cluster_dut_as_server[19.1.5.
[TC-WAKEONLAN-1.5] Global attributes - Wake on LAN Cluster (DUT as
Server)]
**** link:#_tc_channel_1_6_global_attributes_channel_cluster_dut_as_server[19.1.6.
[TC-CHANNEL-1.6] Global attributes - Channel Cluster (DUT as Server)]
**** link:#_tc_mediaplayback_1_7_global_attributes_media_playback_cluster_dut_as_server[19.1.7.
[TC-MEDIAPLAYBACK-1.7] Global attributes - Media Playback Cluster (DUT
as Server)]
**** link:#_tc_audiooutput_1_8_global_attributes_audio_output_cluster_dut_as_server[19.1.8.
[TC-AUDIOOUTPUT-1.8] Global attributes - Audio Output Cluster (DUT as
Server)]
**** link:#_tc_tgtnav_1_9_global_attributes_target_navigator_cluster_dut_as_server[19.1.9.
[TC-TGTNAV-1.9] Global attributes - Target Navigator Cluster (DUT as
Server)]
**** link:#_tc_apbsc_1_10_global_attributes_application_basic_cluster_dut_as_server[19.1.10.
[TC-APBSC-1.10] Global attributes - Application Basic Cluster (DUT as
Server)]
**** link:#_tc_contentlauncher_1_11_global_attributes_content_launcher_cluster_dut_as_server[19.1.11.
[TC-CONTENTLAUNCHER-1.11] Global attributes - Content Launcher Cluster
(DUT as Server)]
**** link:#_tc_alogin_1_12_global_attributes_account_login_cluster_dut_as_server[19.1.12.
[TC-ALOGIN-1.12] Global attributes - Account Login Cluster (DUT as
Server)]
*** link:#_low_power_cluster_test_cases[19.2. Low Power Cluster Test
Cases]
**** link:#_tc_lowpower_2_1_low_power_mode_verification_dut_as_server[19.2.1.
[TC-LOWPOWER-2.1] Low Power Mode Verification (DUT as Server)]
**** link:#_tc_lowpower_2_2_low_power_mode_verification_dut_as_client[19.2.2.
[TC-LOWPOWER-2.2] Low Power Mode Verification (DUT as Client)]
*** link:#_keypad_input_cluster_test_cases[19.3. KeyPad Input Cluster
Test Cases]
**** link:#_tc_keypadinput_3_1_send_key_command_verification_dut_as_client[19.3.1.
[TC-KEYPADINPUT-3.1] Send Key Command Verification (DUT as Client)]
**** link:#_tc_keypadinput_3_2_location_keys_verification[19.3.2.
[TC-KEYPADINPUT-3.2] Location Keys Verification]
**** link:#_tc_keypadinput_3_3_number_keys_verification[19.3.3.
[TC-KEYPADINPUT-3.3] Number Keys Verification]
*** link:#_application_launcher_cluster_test_cases[19.4. Application
Launcher Cluster Test Cases]
**** link:#_tc_applauncher_3_5_catalog_list_verification[19.4.1.
[TC-APPLAUNCHER-3.5] Catalog List Verification]
**** link:#_tc_applauncher_3_6_current_app_verification[19.4.2.
[TC-APPLAUNCHER-3.6] Current App Verification]
**** link:#_tc_applauncher_3_7_launch_application_verification[19.4.3.
[TC-APPLAUNCHER-3.7] Launch Application Verification]
**** link:#_tc_applauncher_3_7_1_launch_application_verification_dut_as_client[19.4.4.
[TC-APPLAUNCHER-3.7.1] Launch Application Verification (DUT as Client)]
**** link:#_tc_applauncher_3_8_stop_application_verification[19.4.5.
[TC-APPLAUNCHER-3.8] Stop Application Verification]
**** link:#_tc_applauncher_3_8_1_stop_application_verification_dut_as_client[19.4.6.
[TC-APPLAUNCHER-3.8.1] Stop Application Verification (DUT as Client)]
**** link:#_tc_applauncher_3_9_hide_application_verification[19.4.7.
[TC-APPLAUNCHER-3.9] Hide Application Verification]
**** link:#_tc_applauncher_3_9_1_hide_application_verification_dut_as_client[19.4.8.
[TC-APPLAUNCHER-3.9.1] Hide Application Verification (DUT as Client)]
*** link:#_media_input_cluster_test_cases[19.5. Media Input Cluster Test
Cases]
**** link:#_tc_mediainput_3_10_input_list_verification[19.5.1.
[TC-MEDIAINPUT-3.10] Input List Verification]
**** link:#_tc_mediainput_3_11_select_input_verification[19.5.2.
[TC-MEDIAINPUT-3.11] Select Input Verification]
**** link:#_tc_mediainput_3_12_show_and_hide_input_status_verification[19.5.3.
[TC-MEDIAINPUT-3.12] Show and Hide Input Status Verification]
**** link:#_tc_mediainput_3_13_rename_input_verification[19.5.4.
[TC-MEDIAINPUT-3.13] Rename Input Verification]
**** link:#_tc_mediainput_3_14_select_input_verification_dut_as_client[19.5.5.
[TC-MEDIAINPUT-3.14] Select Input Verification (DUT as Client)]
**** link:#_tc_mediainput_3_15_show_input_status_verification_dut_as_client[19.5.6.
[TC-MEDIAINPUT-3.15] Show Input Status Verification (DUT as Client)]
**** link:#_tc_mediainput_3_16_hide_input_status_verification_dut_as_client[19.5.7.
[TC-MEDIAINPUT-3.16] Hide Input Status Verification (DUT as Client)]
**** link:#_tc_mediainput_3_17_rename_input_verification_dut_as_client[19.5.8.
[TC-MEDIAINPUT-3.17] Rename Input Verification (DUT as Client)]
*** link:#_wake_on_lan_test_cases[19.6. Wake-On LAN Test Cases]
**** link:#_tc_wakeonlan_4_1_wake_on_lan_verification[19.6.1.
[TC-WAKEONLAN-4.1] Wake-On LAN Verification]
*** link:#_tv_channel_test_cases[19.7. TV Channel Test Cases]
**** link:#_tc_channel_5_1_list_tv_channels_verification[19.7.1.
[TC-CHANNEL-5.1] List TV Channels Verification]
**** link:#_tc_channel_5_2_change_channel_by_number_verification[19.7.2.
[TC-CHANNEL-5.2] Change Channel by Number Verification]
**** link:#_tc_channel_5_3_skip_channel_verification[19.7.3.
[TC-CHANNEL-5.3] Skip Channel Verification]
**** link:#_tc_channel_5_4_change_channel_verification_dut_as_client[19.7.4.
[TC-CHANNEL-5.4] Change Channel Verification (DUT as Client)]
**** link:#_tc_channel_5_5_change_channel_by_number_verification_dut_as_client[19.7.5.
[TC-CHANNEL-5.5] Change Channel By Number Verification (DUT as Client)]
**** link:#_tc_channel_5_6_skip_channel_verification_dut_as_client[19.7.6.
[TC-CHANNEL-5.6] Skip Channel Verification (DUT as Client)]
*** link:#_media_playback_test_cases[19.8. Media Playback Test Cases]
**** link:#_tc_mediaplayback_6_1_mandatory_media_playback_verification[19.8.1.
[TC-MEDIAPLAYBACK-6.1] Mandatory Media Playback Verification]
**** link:#_tc_mediaplayback_6_2_optional_media_playback_verification[19.8.2.
[TC-MEDIAPLAYBACK-6.2] Optional Media Playback Verification]
**** link:#_tc_mediaplayback_6_3_advanced_seek_media_playback_verification[19.8.3.
[TC-MEDIAPLAYBACK-6.3] Advanced Seek Media Playback Verification]
**** link:#_tc_mediaplayback_6_4_variable_speed_media_playback_verification[19.8.4.
[TC-MEDIAPLAYBACK-6.4] Variable Speed Media Playback Verification]
**** link:#_tc_mediaplayback_6_5_mandatory_media_playback_verification_dut_as_client[19.8.5.
[TC-MEDIAPLAYBACK-6.5] Mandatory Media Playback Verification (DUT as
Client)]
**** link:#_tc_mediaplayback_6_7_optional_media_playback_verification_dut_as_client[19.8.6.
[TC-MEDIAPLAYBACK-6.7] Optional Media Playback Verification (DUT as
Client)]
*** link:#_audio_output_test_cases[19.9. Audio Output Test Cases]
**** link:#_tc_audiooutput_7_1_select_output_verification[19.9.1.
[TC-AUDIOOUTPUT-7.1] Select Output Verification]
**** link:#_tc_audiooutput_7_2_rename_output_verification[19.9.2.
[TC-AUDIOOUTPUT-7.2] Rename Output Verification]
**** link:#_tc_audiooutput_7_3_select_output_verification_dut_as_client[19.9.3.
[TC-AUDIOOUTPUT-7.3] Select Output Verification (DUT as Client)]
**** link:#_tc_audiooutput_7_4_rename_output_verification_dut_as_client[19.9.4.
[TC-AUDIOOUTPUT-7.4] Rename Output Verification (DUT as Client)]
*** link:#_target_navigator_cluster_test_cases[19.10. Target Navigator
Cluster Test Cases]
**** link:#_tc_tgtnav_8_1_navigate_target_verification[19.10.1.
[TC-TGTNAV-8.1] Navigate Target Verification]
**** link:#_tc_tgtnav_8_2_navigate_target_verification_dut_as_client[19.10.2.
[TC-TGTNAV-8.2] Navigate Target Verification (DUT as Client)]
*** link:#_application_basic_cluster_test_cases[19.11. Application Basic
Cluster Test Cases]
**** link:#_tc_apbsc_9_1_application_basic_attribute_verification[19.11.1.
[TC-APBSC-9.1] Application Basic Attribute Verification]
*** link:#_content_launcher_cluster_test_cases[19.12. Content Launcher
Cluster Test Cases]
**** link:#_tc_contentlauncher_10_1_read_content_launcher_attributes[19.12.1.
[TC-CONTENTLAUNCHER-10.1] Read Content Launcher Attributes]
**** link:#_tc_contentlauncher_10_3_launch_content_verification[19.12.2.
[TC-CONTENTLAUNCHER-10.3] Launch Content Verification]
**** link:#_tc_contentlauncher_10_4_launch_content_verification_dut_as_client[19.12.3.
[TC-CONTENTLAUNCHER-10.4] Launch Content Verification (DUT as Client)]
**** link:#_tc_contentlauncher_10_5_launch_url_verification[19.12.4.
[TC-CONTENTLAUNCHER-10.5] Launch URL Verification]
**** link:#_tc_contentlauncher_10_6_launch_url_verification_dut_as_client[19.12.5.
[TC-CONTENTLAUNCHER-10.6] Launch URL Verification (DUT as Client)]
**** link:#_tc_contentlauncher_10_7_content_search_verification[19.12.6.
[TC-CONTENTLAUNCHER-10.7] Content Search Verification]
*** link:#_casting_video_player_test_cases[19.13. Casting Video Player
Test Cases]
**** link:#_tc_mc_11_1_casting_video_player_via_user_directed_commissioning_verification_dut_as_server[19.13.1.
[TC-MC-11.1] Casting Video Player via User-Directed Commissioning
Verification (DUT as Server)]
**** link:#_tc_mc_11_2_casting_video_player_via_ux_screen_with_pin_verification_dut_as_server[19.13.2.
[TC-MC-11.2] Casting Video Player via UX Screen with PIN Verification
(DUT as Server)]
*** link:#_account_login_cluster_player_test_cases[19.14. Account Login
Cluster Player Test Cases]
**** link:#_tc_alogin_12_1_account_login_verification[19.14.1.
[TC-ALOGIN-12.1] Account Login Verification]
**** link:#_tc_alogin_12_2_account_login_verification_dut_as_client[19.14.2.
[TC-ALOGIN-12.2] Account Login Verification (DUT as Client)]
* link:#_level_control_cluster_test_plan[*Level Control Cluster Test
Plan*]
** link:#_pics_definition_7[20. PICS Definition]
*** link:#_role_7[20.1. Role]
*** link:#_server_7[20.2. Server]
**** link:#_features_4[20.2.1. Features]
**** link:#_attributes_7[20.2.2. Attributes]
**** link:#_commands_received_3[20.2.3. Commands received]
**** link:#_manual_controllable_5[20.2.4. Manual controllable]
** link:#_test_case_list_7[21. Test Case List]
** link:#_test_cases_7[22. Test Cases]
*** link:#_generic_test_cases_6[22.1. Generic test cases]
**** link:#_tc_lvl_1_1_global_attributes_with_server_as_dut[22.1.1.
[TC-LVL-1.1] Global attributes with server as DUT]
*** link:#_cluster_attribute_test_cases[22.2. Cluster Attribute test
cases]
**** link:#_tc_lvl_2_1_read_cluster_attributes_dut_as_server[22.2.1.
[TC-LVL-2.1] Read cluster attributes (DUT as Server)]
**** link:#_tc_lvl_2_2_write_cluster_attributes_dut_as_server[22.2.2.
[TC-LVL-2.2] Write cluster attributes (DUT as Server)]
*** link:#_movetolevel_test_cases[22.3. MoveToLevel Test Cases]
**** link:#_tc_lvl_3_1_movetolevel_verification_dut_as_server[22.3.1.
[TC-LVL-3.1] MoveToLevel Verification (DUT as Server)]
*** link:#_move_test_cases[22.4. Move Test Cases]
**** link:#_tc_lvl_4_1_move_verification_dut_as_server[22.4.1.
[TC-LVL-4.1] Move Verification (DUT as Server)]
*** link:#_step_test_cases[22.5. Step Test Cases]
**** link:#_tc_lvl_5_1_step_verification_dut_as_server[22.5.1.
[TC-LVL-5.1] Step Verification (DUT as Server)]
*** link:#_stop_test_cases[22.6. Stop Test Cases]
**** link:#_tc_lvl_6_1_stop_verification_dut_as_server[22.6.1.
[TC-LVL-6.1] Stop Verification (DUT as Server)]
**** link:#_tc_lvl_7_1_verification_of_movetoclosestfrequency_command_dut_as_server[22.6.2.
[TC-LVL-7.1] Verification of MoveToClosestFrequency command (DUT as
Server)]
* link:#_color_control_cluster_test_plan[*Color Control Cluster Test
Plan*]
** link:#_pics_definition_8[23. PICS Definition]
*** link:#_role_8[23.1. Role]
*** link:#_server_8[23.2. Server]
**** link:#_features_5[23.2.1. Features]
**** link:#_attributes_8[23.2.2. Attributes]
**** link:#_commands_received_4[23.2.3. Commands received]
*** link:#_client_3[23.3. Client]
**** link:#_features_6[23.3.1. Features]
**** link:#_attributes_9[23.3.2. Attributes]
**** link:#_commands_generated_3[23.3.3. Commands generated]
** link:#_pixit_definition_2[24. PIXIT Definition]
** link:#_test_case_list_8[25. Test Case List]
** link:#_test_cases_8[26. Test Cases]
*** link:#_global_attributes[26.1. Global Attributes]
**** link:#_tc_cc_1_1_global_attributes_with_server_as_dut[26.1.1.
[TC-CC-1.1] Global attributes with server as DUT]
*** link:#_cluster_attributes[26.2. Cluster Attributes]
**** link:#_tc_cc_2_1_attributes_with_server_as_dut[26.2.1. [TC-CC-2.1]
Attributes with server as DUT]
*** link:#_functional_test_cases[26.3. Functional test cases]
**** link:#_tc_cc_3_1_hue_moveto_functionality_with_server_as_dut[26.3.1.
[TC-CC-3.1] Hue MoveTo functionality with server as DUT]
**** link:#_tc_cc_3_2_hue_move_functionality_with_server_as_dut[26.3.2.
[TC-CC-3.2] Hue Move functionality with server as DUT]
**** link:#_tc_cc_3_3_hue_step_functionality_with_server_as_dut[26.3.3.
[TC-CC-3.3] Hue Step functionality with server as DUT]
**** link:#_tc_cc_3_4_hue_functionality_with_client_as_dut[26.3.4.
[TC-CC-3.4] Hue functionality with client as DUT]
**** link:#_tc_cc_4_1_saturation_moveto_functionality_with_server_as_dut[26.3.5.
[TC-CC-4.1] Saturation MoveTo functionality with server as DUT]
**** link:#_tc_cc_4_2_saturation_move_functionality_with_server_as_dut[26.3.6.
[TC-CC-4.2] Saturation Move functionality with server as DUT]
**** link:#_tc_cc_4_3_saturation_step_functionality_with_server_as_dut[26.3.7.
[TC-CC-4.3] Saturation Step functionality with server as DUT]
**** link:#_tc_cc_4_4_movetohueandsaturation_functionality_with_server_as_dut[26.3.8.
[TC-CC-4.4] MoveToHueAndSaturation functionality with server as DUT]
**** link:#_tc_cc_4_5_saturation_functionality_with_client_as_dut[26.3.9.
[TC-CC-4.5] Saturation functionality with client as DUT]
**** link:#_tc_cc_5_1_color_moveto_functionality_with_server_as_dut[26.3.10.
[TC-CC-5.1] Color MoveTo functionality with server as DUT]
**** link:#_tc_cc_5_2_color_move_functionality_with_server_as_dut[26.3.11.
[TC-CC-5.2] Color Move functionality with server as DUT]
**** link:#_tc_cc_5_3_color_step_functionality_with_server_as_dut[26.3.12.
[TC-CC-5.3] Color Step functionality with server as DUT]
**** link:#_tc_cc_5_4_color_functionality_with_client_as_dut[26.3.13.
[TC-CC-5.4] Color functionality with client as DUT]
**** link:#_tc_cc_6_1_color_temperature_moveto_functionality_with_server_as_dut[26.3.14.
[TC-CC-6.1] Color Temperature MoveTo functionality with server as DUT]
**** link:#_tc_cc_6_2_color_temperature_move_functionality_with_server_as_dut[26.3.15.
[TC-CC-6.2] Color Temperature Move functionality with server as DUT]
**** link:#_tc_cc_6_3_color_temperature_step_functionality_with_server_as_dut[26.3.16.
[TC-CC-6.3] Color Temperature Step functionality with server as DUT]
**** link:#_tc_cc_6_4_color_temperature_functionality_with_client_as_dut[26.3.17.
[TC-CC-6.4] Color Temperature functionality with client as DUT]
**** link:#_tc_cc_6_5_color_temperature_startupcolortemperaturemireds_functionality_with_server_as_dut[26.3.18.
[TC-CC-6.5] Color Temperature StartUpColorTemperatureMireds
functionality with server as DUT]
**** link:#_tc_cc_7_1_enhanced_movetohue_functionality_with_server_as_dut[26.3.19.
[TC-CC-7.1] Enhanced MoveToHue functionality with server as DUT]
**** link:#_tc_cc_7_2_enhanced_movehue_functionality_with_server_as_dut[26.3.20.
[TC-CC-7.2] Enhanced MoveHue functionality with server as DUT]
**** link:#_tc_cc_7_3_enhanced_step_functionality_with_server_as_dut[26.3.21.
[TC-CC-7.3] Enhanced Step functionality with server as DUT]
**** link:#_tc_cc_7_4_movetoenhancedhueandsaturation_functionality_with_server_as_dut[26.3.22.
[TC-CC-7.4] MoveToEnhancedHueAndSaturation functionality with server as
DUT]
**** link:#_tc_cc_7_5_enhanced_hue_functionality_with_client_as_dut[26.3.23.
[TC-CC-7.5] Enhanced Hue functionality with client as DUT]
**** link:#_tc_cc_8_1_stopmovestep_functionality_with_server_as_dut[26.3.24.
[TC-CC-8.1] StopMoveStep functionality with server as DUT]
**** link:#_tc_cc_9_1_colorloopset_validation[26.3.25. [TC-CC-9.1]
ColorLoopSet Validation]
**** link:#_tc_cc_9_2_colorloopset_validation_change_direction_without_stop[26.3.26.
[TC-CC-9.2] ColorLoopSet Validation - change Direction without Stop]
**** link:#_tc_cc_9_3_colorloopset_validation_change_time_without_stop[26.3.27.
[TC-CC-9.3] ColorLoopSet Validation - change Time without Stop]
**** link:#_tc_cc_9_4_colorloopset_validation_with_client_as_dut[26.3.28.
[TC-CC-9.4] ColorLoopSet Validation with client as DUT]
* link:#_occupancy_sensing_cluster_test_plan[*Occupancy Sensing Cluster
Test Plan*]
** link:#_pics_definition_9[27. PICS Definition]
*** link:#_role_9[27.1. Role]
*** link:#_server_9[27.2. Server]
**** link:#_attributes_10[27.2.1. Attributes]
**** link:#_manual_controllable_6[27.2.2. Manual controllable]
*** link:#_client_4[27.3. Client]
**** link:#_attributes_11[27.3.1. Attributes]
** link:#_test_case_list_9[28. Test Case List]
** link:#_test_cases_9[29. Test Cases]
*** link:#_global_attributes_2[29.1. Global Attributes]
**** link:#_tc_occ_1_1_global_attributes_with_server_as_dut[29.1.1.
[TC-OCC-1.1] Global attributes with server as DUT]
*** link:#_cluster_attributes_2[29.2. Cluster Attributes]
**** link:#_tc_occ_2_1_attributes_with_server_as_dut[29.2.1.
[TC-OCC-2.1] Attributes with server as DUT]
*** link:#_functional_tests[29.3. Functional Tests]
**** link:#_tc_occ_2_3_occupancysensortypebitmap_and_occupancysensortype_interdependency_with_server_as_dut[29.3.1.
[TC-OCC-2.3] OccupancySensorTypeBitmap and OccupancySensorType
interdependency with server as DUT]
**** link:#_tc_occ_2_4_occupancysensortypebitmap_and_occupancysensortype_interdependency_with_client_as_dut[29.3.2.
[TC-OCC-2.4] OccupancySensorTypeBitmap and OccupancySensorType
interdependency with client as DUT]
**** link:#_tc_occ_3_1_primary_functionality_with_server_as_dut[29.3.3.
[TC-OCC-3.1] Primary functionality with server as DUT]
* link:#_flow_measurement_cluster_test_plan[*Flow Measurement Cluster
Test Plan*]
** link:#_pics_definition_10[30. PICS Definition]
*** link:#_role_10[30.1. Role]
*** link:#_server_10[30.2. Server]
**** link:#_attributes_12[30.2.1. Attributes]
**** link:#_manual_controllable_7[30.2.2. Manual controllable]
** link:#_test_case_list_10[31. Test Case List]
** link:#_test_cases_10[32. Test Cases]
*** link:#_generic_test_cases_7[32.1. Generic Test Cases]
**** link:#_tc_flw_1_1_global_attributes_with_dut_as_server[32.1.1.
[TC-FLW-1.1] Global Attributes with DUT as Server]
*** link:#_dut_as_server_2[32.2. DUT as Server]
**** link:#_tc_flw_2_1_attributes_with_server_as_dut[32.2.1.
[TC-FLW-2.1] Attributes with Server as DUT]
**** link:#_tc_flw_2_2_primary_functionality_with_server_as_dut[32.2.2.
[TC-FLW-2.2] Primary Functionality with Server as DUT]
* link:#_pressure_measurement_cluster_test_plan[*Pressure Measurement
Cluster Test Plan*]
** link:#_pics_definition_11[33. PICS Definition]
*** link:#_role_11[33.1. Role]
*** link:#_server_11[33.2. Server]
**** link:#_features_7[33.2.1. Features]
**** link:#_attributes_13[33.2.2. Attributes]
**** link:#_manual_controllable_8[33.2.3. Manual controllable]
** link:#_test_case_list_11[34. Test Case List]
** link:#_test_cases_11[35. Test Cases]
*** link:#_generic_test_cases_8[35.1. Generic Test Cases]
**** link:#_tc_prs_1_1_global_attributes_with_dut_as_server[35.1.1.
[TC-PRS-1.1] Global Attributes with DUT as Server]
*** link:#_dut_as_server_3[35.2. DUT as Server]
**** link:#_tc_prs_2_1_attributes_with_server_as_dut[35.2.1.
[TC-PRS-2.1] Attributes with Server as DUT]
**** link:#_tc_prs_2_2_primary_functionality_with_server_as_dut[35.2.2.
[TC-PRS-2.2] Primary Functionality with Server as DUT]
* link:#_window_covering_cluster_test_plan[*Window Covering Cluster Test
Plan*]
** link:#_pics_definition_12[36. PICS Definition]
*** link:#_role_12[36.1. Role]
*** link:#_server_12[36.2. Server]
**** link:#_features_8[36.2.1. Features]
**** link:#_manual_controllable_9[36.2.2. Manual controllable]
**** link:#_attributes_14[36.2.3. Attributes]
**** link:#_commands_received_5[36.2.4. Commands received]
*** link:#_client_5[36.3. Client]
**** link:#_attributes_15[36.3.1. Attributes]
**** link:#_commands_generated_4[36.3.2. Commands generated]
** link:#_pixit_definition_3[37. PIXIT Definition]
** link:#_test_case_list_12[38. Test Case List]
** link:#_test_cases_12[39. Test Cases]
*** link:#_generic_test_cases_9[39.1. Generic Test Cases]
**** link:#_tc_wncv_1_1_global_attributes_dut_as_server[39.1.1.
[TC-WNCV-1.1] Global attributes [DUT as Server]]
*** link:#_cluster_attributes_test_cases[39.2. Cluster Attributes Test
Cases]
**** link:#_tc_wncv_2_1_attributes_dut_as_server[39.2.1. [TC-WNCV-2.1]
Attributes [DUT as Server]]
**** link:#_tc_wncv_2_2_configstatus_attribute_dut_as_server[39.2.2.
[TC-WNCV-2.2] ConfigStatus attribute [DUT as Server]]
**** link:#_tc_wncv_2_3_mode_attribute_dut_as_server[39.2.3.
[TC-WNCV-2.3] Mode attribute [DUT as Server]]
**** link:#_tc_wncv_2_4_type_attribute_dut_as_server[39.2.4.
[TC-WNCV-2.4] Type attribute [DUT as Server]]
**** link:#_tc_wncv_2_5_endproducttype_attribute_dut_as_server[39.2.5.
[TC-WNCV-2.5] EndProductType attribute [DUT as Server]]
*** link:#_basic_commands_test_cases[39.3. Basic Commands Test Cases]
**** link:#_tc_wncv_3_1_uporopen_command_operationalstatus_attribute_verification_dut_as_server[39.3.1.
[TC-WNCV-3.1] UpOrOpen command & OperationalStatus attribute
Verification [DUT as Server]]
**** link:#_tc_wncv_3_2_downorclose_command_operationalstatus_attribute_verification_dut_as_server[39.3.2.
[TC-WNCV-3.2] DownOrClose command & OperationalStatus attribute
Verification [DUT as Server]]
**** link:#_tc_wncv_3_3_stopmotion_command_operationalstatus_attribute_verification_dut_as_server[39.3.3.
[TC-WNCV-3.3] StopMotion command & OperationalStatus attribute
Verification [DUT as Server]]
**** link:#_tc_wncv_3_4_uporopen_command_long_run_verification_dut_as_server[39.3.4.
[TC-WNCV-3.4] UpOrOpen command Long-Run Verification [DUT as Server]]
**** link:#_tc_wncv_3_5_downorclose_command_long_run_verification_dut_as_server[39.3.5.
[TC-WNCV-3.5] DownOrClose command Long-Run Verification [DUT as Server]]
*** link:#_advanced_commands_test_cases[39.4. Advanced Commands Test
Cases]
**** link:#_tc_wncv_4_1_gotoliftpercentage_command_long_run_verification_dut_as_server[39.4.1.
[TC-WNCV-4.1] GoToLiftPercentage command Long-Run Verification [DUT as
Server]]
**** link:#_tc_wncv_4_2_gototiltpercentage_command_long_run_verification_dut_as_server[39.4.2.
[TC-WNCV-4.2] GoToTiltPercentage command Long-Run Verification [DUT as
Server]]
**** link:#_tc_wncv_4_3_gotoliftpercentage_command_limits_verification_dut_as_server[39.4.3.
[TC-WNCV-4.3] GoToLiftPercentage command Limits Verification [DUT as
Server]]
**** link:#_tc_wncv_4_4_gototiltpercentage_command_limits_verification_dut_as_server[39.4.4.
[TC-WNCV-4.4] GoToTiltPercentage command Limits Verification [DUT as
Server]]
**** link:#_tc_wncv_4_5_positions_storage_verification_dut_as_server[39.4.5.
[TC-WNCV-4.5] Positions Storage Verification [DUT as Server]]
**** link:#_tc_wncv_5_1_mandatory_attributes_verification_dut_as_client[39.4.6.
[TC-WNCV-5.1] Mandatory Attributes Verification [DUT as Client]]
**** link:#_tc_wncv_6_1_basic_commands_verification_dut_as_client[39.4.7.
[TC-WNCV-6.1] Basic Commands Verification [DUT as Client]]
**** link:#_tc_wncv_7_1_gotopercentage_commands_verification_dut_as_client[39.4.8.
[TC-WNCV-7.1] GoToPercentage Commands Verification [DUT as Client]]
* link:#_thermostat_cluster_test_plan[*Thermostat Cluster Test Plan*]
** link:#_pics_definition_13[40. PICS Definition]
*** link:#_role_13[40.1. Role]
*** link:#_server_13[40.2. Server]
**** link:#_features_9[40.2.1. Features]
**** link:#_manual_controllable_10[40.2.2. Manual controllable]
**** link:#_attributes_16[40.2.3. Attributes]
**** link:#_commands_received_6[40.2.4. Commands received]
**** link:#_commands_generated_5[40.2.5. Commands generated]
*** link:#_client_6[40.3. Client]
**** link:#_commands_received_7[40.3.1. Commands received]
**** link:#_commands_generated_6[40.3.2. Commands generated]
** link:#_test_case_list_13[41. Test Case List]
** link:#_test_cases_13[42. Test Cases]
*** link:#_generic_test_cases_10[42.1. Generic test cases]
**** link:#_tc_tstat_1_1_global_attributes_with_server_as_dut[42.1.1.
[TC-TSTAT-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_5[42.2. Server as DUT]
**** link:#_tc_tstat_2_1_attributes_with_server_as_dut[42.2.1.
[TC-TSTAT-2.1] Attributes with server as DUT]
**** link:#_tc_tstat_2_2_setpoint_test_cases_with_server_as_dut[42.2.2.
[TC-TSTAT-2.2] Setpoint Test Cases with server as DUT]
*** link:#_client_as_dut_2[42.3. Client as DUT]
**** link:#_tc_tstat_3_2_functionality_with_client_as_dut[42.3.1.
[TC-TSTAT-3.2] Functionality with client as DUT]
* link:#_software_diagnostics_cluster_test_plan[*Software Diagnostics
Cluster Test Plan*]
** link:#_pics_definition_14[43. PICS Definition]
*** link:#_role_14[43.1. Role]
*** link:#_server_14[43.2. Server]
**** link:#_features_10[43.2.1. Features]
**** link:#_attributes_17[43.2.2. Attributes]
**** link:#_events_2[43.2.3. Events]
**** link:#_commands_received_8[43.2.4. Commands received]
*** link:#_client_7[43.3. Client]
**** link:#_commands_generated_7[43.3.1. Commands generated]
** link:#_test_case_list_14[44. Test Case List]
** link:#_test_cases_14[45. Test Cases]
*** link:#_generic_test_cases_11[45.1. Generic Test Cases]
**** link:#_tc_dgsw_1_1_global_attributes_with_dut_as_server[45.1.1.
[TC-DGSW-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut_6[45.2. Server as DUT]
**** link:#_tc_dgsw_2_1_attributes_dut_sever[45.2.1. [TC-DGSW-2.1]
Attributes [\{DUT_Sever}]]
**** link:#_tc_dgsw_2_2_event_functionality_dut_sever[45.2.2.
[TC-DGSW-2.2] Event Functionality [\{DUT_Sever}]]
**** link:#_tc_dgsw_2_3_command_received_dut_sever[45.2.3. [TC-DGSW-2.3]
Command Received [\{DUT_Sever}]]
*** link:#_client_as_dut_3[45.3. Client as DUT]
**** link:#_tc_dgsw_3_2_commands_generated_dut_as_client[45.3.1.
[TC-DGSW-3.2] Commands Generated [DUT as Client]]
* link:#_ethernet_network_diagnostics_cluster_test_plan[*Ethernet
Network Diagnostics Cluster Test Plan*]
** link:#_pics_definition_15[46. PICS Definition]
*** link:#_role_15[46.1. Role]
*** link:#_server_15[46.2. Server]
**** link:#_features_11[46.2.1. Features]
**** link:#_attributes_18[46.2.2. Attributes]
**** link:#_commands_received_9[46.2.3. Commands received]
*** link:#_client_8[46.3. Client]
**** link:#_commands_generated_8[46.3.1. Commands generated]
** link:#_test_case_list_15[47. Test Case List]
** link:#_test_cases_15[48. Test Cases]
*** link:#_generic_test_cases_12[48.1. Generic Test Cases]
**** link:#_tc_dgeth_1_1_global_attributes_with_dut_as_server[48.1.1.
[TC-DGETH-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut_7[48.2. Server as DUT]
**** link:#_tc_dgeth_2_1_attributes_dut_as_server[48.2.1. [TC-DGETH-2.1]
Attributes [DUT as Server]]
**** link:#_tc_dgeth_2_2_command_received_dut_as_server[48.2.2.
[TC-DGETH-2.2] Command Received [DUT as Server]]
**** link:#_tc_dgeth_3_2_command_generated_dut_as_client[48.2.3.
[TC-DGETH-3.2] Command Generated DUT as Client]]
* link:#_thread_network_diagnostics_cluster_test_plan[*Thread Network
Diagnostics Cluster Test Plan*]
** link:#_pics_definition_16[49. PICS Definition]
*** link:#_role_16[49.1. Role]
*** link:#_server_16[49.2. Server]
**** link:#_features_12[49.2.1. Features]
**** link:#_attributes_19[49.2.2. Attributes]
**** link:#_events_3[49.2.3. Events]
**** link:#_commands_received_10[49.2.4. Commands received]
*** link:#_client_9[49.3. Client]
**** link:#_attributes_20[49.3.1. Attributes]
**** link:#_commands_generated_9[49.3.2. Commands generated]
** link:#_test_case_list_16[50. Test Case List]
** link:#_test_cases_16[51. Test Cases]
*** link:#_generic_test_cases_13[51.1. Generic Test Cases]
**** link:#_tc_dgthread_1_1_global_attributes_with_dut_as_server[51.1.1.
[TC-DGTHREAD-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut_8[51.2. Server as DUT]
**** link:#_tc_dgthread_2_1_attributes_dut_server[51.2.1.
[TC-DGTHREAD-2.1] Attributes [DUT- Server]]
**** link:#_tc_dgthread_2_2_attributes_tx_dut_server[51.2.2.
[TC-DGTHREAD-2.2] Attributes-Tx [DUT- Server]]
**** link:#_tc_dgthread_2_3_attributes_rx_dut_server[51.2.3.
[TC-DGTHREAD-2.3] Attributes-Rx [DUT- Server]]
**** link:#_tc_dgthread_2_4_resetcounts_commanddut_server[51.2.4.
[TC-DGTHREAD-2.4] ResetCounts Command[DUT- Server]]
**** link:#_tc_dgthread_2_5_thread_network_diagnostics_cluster_eventsdut_server_removed[51.2.5.
[TC-DGTHREAD-2.5] Thread Network Diagnostics Cluster Events[DUT-Server]
- REMOVED]
*** link:#_client_as_dut_4[51.3. Client as DUT]
**** link:#_tc_dgthread_3_4_resetcounts_commanddut_client[51.3.1.
[TC-DGTHREAD-3.4] ResetCounts Command[DUT-Client]]
* link:#_wi_fi_network_diagnostics_cluster_test_plan[*Wi-Fi Network
Diagnostics Cluster Test Plan*]
** link:#_pics_definition_17[52. PICS Definition]
*** link:#_role_17[52.1. Role]
*** link:#_server_17[52.2. Server]
**** link:#_features_13[52.2.1. Features]
**** link:#_attributes_21[52.2.2. Attributes]
**** link:#_events_4[52.2.3. Events]
**** link:#_commands_received_11[52.2.4. Commands received]
*** link:#_client_10[52.3. Client]
**** link:#_commands_generated_10[52.3.1. Commands generated]
** link:#_test_case_list_17[53. Test Case List]
** link:#_test_cases_17[54. Test Cases]
*** link:#_generic_test_cases_14[54.1. Generic Test Cases]
**** link:#_tc_dgwifi_1_1_global_attributes_dut_as_server[54.1.1.
[TC-DGWIFI-1.1] Global Attributes [DUT as Server]]
*** link:#_server_as_dut_9[54.2. Server as DUT]
**** link:#_tc_dgwifi_2_1_attributes_dut_as_server[54.2.1.
[TC-DGWIFI-2.1] Attributes [DUT as Server]]
**** link:#_tc_dgwifi_2_2_event_functionality_dut_as_server[54.2.2.
[TC-DGWIFI-2.2] Event Functionality [DUT as Server]]
**** link:#_tc_dgwifi_2_3_command_received_dut_as_server[54.2.3.
[TC-DGWIFI-2.3] Command Received [DUT as Server]]
*** link:#_client_as_dut_5[54.3. Client as DUT]
**** link:#_tc_dgwifi_3_2_command_generated_dut_as_client[54.3.1.
[TC-DGWIFI-3.2] Command Generated [DUT as Client]]
* link:#_diagnostics_logs_cluster_test_plan[*Diagnostics Logs Cluster
Test Plan*]
** link:#_pics_definition_18[55. PICS Definition]
*** link:#_role_18[55.1. Role]
*** link:#_server_18[55.2. Server]
**** link:#_commands_received_12[55.2.1. Commands received]
**** link:#_commands_generated_11[55.2.2. Commands generated]
*** link:#_client_11[55.3. Client]
**** link:#_commands_received_13[55.3.1. Commands received]
**** link:#_commands_generated_12[55.3.2. Commands generated]
** link:#_test_case_list_18[56. Test Case List]
** link:#_test_cases_18[57. Test Cases]
*** link:#_generic_test_cases_15[57.1. Generic test cases]
**** link:#_tc_dlog_1_1_global_attributes_with_dut_as_server_removed[57.1.1.
[TC-DLOG-1.1] Global Attributes with DUT as Server - REMOVED]
*** link:#_server_as_dut_10[57.2. Server as DUT]
**** link:#_tc_dlog_2_1_diagnostic_logs_cluster_commands_checks_with_bdx_dut_server_removed[57.2.1.
[TC-DLOG-2.1] Diagnostic Logs Cluster Commands Checks with BDX
[DUT-Server] - REMOVED]
**** link:#_tc_dlog_2_2_diagnostic_logs_cluster_commands_checks_without_bdx_dut_server_removed[57.2.2.
[TC-DLOG-2.2] Diagnostic Logs Cluster Commands Checks without BDX
[DUT-Server] - REMOVED]
*** link:#_client_as_dut_6[57.3. Client as DUT]
**** link:#_tc_dlog_3_1_diagnostic_logs_cluster_commands_checksdut_client_removed[57.3.1.
[TC-DLOG-3.1] Diagnostic Logs Cluster Commands Checks[DUT-Client] -
REMOVED]
* link:#_identify_cluster_test_plan[*Identify Cluster Test Plan*]
** link:#_pics_definition_19[58. PICS Definition]
*** link:#_role_19[58.1. Role]
*** link:#_server_19[58.2. Server]
**** link:#_features_14[58.2.1. Features]
**** link:#_attributes_22[58.2.2. Attributes]
**** link:#_commands_received_14[58.2.3. Commands received]
**** link:#_commands_generated_13[58.2.4. Commands generated]
*** link:#_client_12[58.3. Client]
**** link:#_commands_generated_14[58.3.1. Commands generated]
**** link:#_commands_received_15[58.3.2. Commands received]
** link:#_test_case_list_19[59. Test Case List]
** link:#_test_cases_19[60. Test Cases]
*** link:#_generic_test_cases_16[60.1. Generic test cases]
**** link:#_tc_i_1_1_global_attributes_with_server_as_dut[60.1.1.
[TC-I-1.1] Global Attributes with Server as DUT]
*** link:#_server_as_dut_11[60.2. Server as DUT]
**** link:#_tc_i_2_1_attributes_with_server_as_dut[60.2.1. [TC-I-2.1]
Attributes with Server as DUT]
**** link:#_tc_i_2_2_primary_functionality_with_server_as_dut[60.2.2.
[TC-I-2.2] Primary Functionality with Server as DUT]
**** link:#_tc_i_2_3_secondary_functionality_with_server_as_dut[60.2.3.
[TC-I-2.3] Secondary Functionality with Server as DUT]
*** link:#_client_as_dut_7[60.3. Client as DUT]
**** link:#_tc_i_3_2_functionality_with_client_as_dut[60.3.1. [TC-I-3.2]
Functionality with Client as DUT]
* link:#_power_source_cluster_test_plan[*Power Source Cluster Test
Plan*]
** link:#testplan_PowerSource[61. PICS Definition]
*** link:#_role_20[61.1. Role]
*** link:#_server_20[61.2. Server]
**** link:#_features_15[61.2.1. Features]
**** link:#_attributes_23[61.2.2. Attributes]
**** link:#_manual_controllable_11[61.2.3. Manual controllable]
**** link:#_events_5[61.2.4. Events]
** link:#_test_case_list_20[62. Test Case List]
** link:#_test_cases_20[63. Test Cases]
*** link:#_generic_test_cases_17[63.1. Generic test cases]
**** link:#_tc_ps_1_1_global_attributes_with_server_as_dut[63.1.1.
[TC-PS-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_12[63.2. Server as DUT]
**** link:#_tc_ps_2_1_attributes_with_server_as_dut[63.2.1. [TC-PS-2.1]
Attributes with server as DUT]
**** link:#_tc_ps_2_2_event_reporting_with_server_as_dut_removed[63.2.2.
[TC-PS-2.2] Event reporting with server as DUT - REMOVED]
**** link:#_tc_ps_3_1_endpoint_composition_and_endpointlist[63.2.3.
[TC-PS-3.1] Endpoint composition and EndpointList]
* link:#_power_source_configuration_cluster_test_plan[*Power Source
Configuration Cluster Test Plan*]
** link:#testplan_PowerSourceConfiguration[64. PICS Definition]
*** link:#_role_21[64.1. Role]
*** link:#_server_21[64.2. Server]
**** link:#_attributes_24[64.2.1. Attributes]
** link:#_test_case_list_21[65. Test Case List]
** link:#_test_cases_21[66. Test Cases]
*** link:#_generic_test_cases_18[66.1. Generic test cases]
**** link:#_tc_pscfg_1_1_global_attributes_with_server_as_dut[66.1.1.
[TC-PSCFG-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_13[66.2. Server as DUT]
**** link:#_tc_pscfg_2_1_attributes_with_server_as_dut[66.2.1.
[TC-PSCFG-2.1] Attributes with server as DUT]
**** link:#_tc_pscfg_2_2_primary_functionality_with_server_as_dut[66.2.2.
[TC-PSCFG-2.2] Primary functionality with server as DUT]
* link:#_boolean_state_cluster_test_plan[*Boolean State Cluster Test
Plan*]
** link:#_pics_definition_20[67. PICS Definition]
*** link:#_role_22[67.1. Role]
*** link:#_server_22[67.2. Server]
**** link:#_attributes_25[67.2.1. Attributes]
**** link:#_manual_controllable_12[67.2.2. Manual controllable]
**** link:#_events_6[67.2.3. Events]
** link:#_test_case_list_22[68. Test Case List]
** link:#_test_cases_22[69. Test Cases]
*** link:#_generic_test_cases_19[69.1. Generic test cases]
**** link:#_tc_bool_1_1_global_attributes_with_server_as_dut[69.1.1.
[TC-BOOL-1.1] Global Attributes with Server as DUT]
*** link:#_server_as_dut_14[69.2. Server as DUT]
**** link:#_tc_bool_2_1_attributes_with_server_as_dut[69.2.1.
[TC-BOOL-2.1] Attributes with Server as DUT]
**** link:#_tc_bool_2_2_primary_functionality_with_server_as_dut[69.2.2.
[TC-BOOL-2.2] Primary Functionality with Server as DUT]
* link:#_illuminance_measurement_cluster_test_plan[*Illuminance
Measurement Cluster Test Plan*]
** link:#_pics_definition_21[70. PICS Definition]
*** link:#_role_23[70.1. Role]
*** link:#_server_23[70.2. Server]
**** link:#_attributes_26[70.2.1. Attributes]
** link:#_test_case_list_23[71. Test Case List]
** link:#_test_cases_23[72. Test Cases]
*** link:#_generic_test_cases_20[72.1. Generic test cases]
**** link:#_tc_ill_1_1_global_attributes_with_server_as_dut[72.1.1.
[TC-ILL-1.1] Global Attributes with Server as DUT]
*** link:#_server_as_dut_15[72.2. Server as DUT]
**** link:#_tc_ill_2_1_attributes_with_server_as_dut[72.2.1.
[TC-ILL-2.1] Attributes with Server as DUT]
**** link:#_tc_ill_2_2_primary_functionality_with_server_as_dut[72.2.2.
[TC-ILL-2.2] Primary Functionality with Server as DUT]
* link:#_switch_cluster_test_plan[*Switch Cluster Test Plan*]
** link:#_pics_definition_22[73. PICS Definition]
*** link:#_role_24[73.1. Role]
*** link:#_server_24[73.2. Server]
**** link:#_features_16[73.2.1. Features]
*** link:#_client_13[73.3. Client]
**** link:#_features_17[73.3.1. Features]
**** link:#_manual_controllable_13[73.3.2. Manual controllable]
** link:#_test_case_list_24[74. Test Case List]
** link:#_test_cases_24[75. Test Cases]
*** link:#_generic_test_cases_21[75.1. Generic test cases]
**** link:#_tc_swtch_1_1_global_attributes_with_server_as_dut[75.1.1.
[TC-SWTCH-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_16[75.2. Server as DUT]
**** link:#_tc_swtch_2_1_attributes_with_server_as_dut[75.2.1.
[TC-SWTCH-2.1] Attributes with server as DUT]
**** link:#_tc_swtch_2_2_primary_functionality_with_server_as_dut[75.2.2.
[TC-SWTCH-2.2] Primary functionality with server as DUT]
*** link:#_client_14[75.3. Client]
**** link:#_tc_swtch_3_2_primary_functionality_with_client_as_dut[75.3.1.
[TC-SWTCH-3.2] Primary functionality with client as DUT]
* link:#_actions_cluster_test_plan[*Actions Cluster Test Plan*]
** link:#_pics_definition_23[76. PICS Definition]
*** link:#_role_25[76.1. Role]
*** link:#_server_25[76.2. Server]
**** link:#_attributes_27[76.2.1. Attributes]
**** link:#_manual_controllable_14[76.2.2. Manual controllable]
**** link:#_commands_received_16[76.2.3. Commands received]
*** link:#_client_15[76.3. Client]
**** link:#_commands_generated_15[76.3.1. Commands generated]
** link:#_test_case_list_25[77. Test Case List]
** link:#_test_cases_25[78. Test Cases]
*** link:#_generic_test_cases_22[78.1. Generic test cases]
**** link:#_tc_act_1_1_global_attributes_with_server_as_dut[78.1.1.
[TC-ACT-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_17[78.2. Server as DUT]
**** link:#_tc_act_2_1_attributes_with_server_as_dut[78.2.1.
[TC-ACT-2.1] Attributes with server as DUT]
**** link:#_tc_act_2_2_primary_functionality_with_server_as_dut[78.2.2.
[TC-ACT-2.2] Primary functionality with server as DUT]
**** link:#_tc_act_3_2_functionality_with_client_as_dut[78.2.3.
[TC-ACT-3.2] Functionality with client as DUT]
* link:#_mode_select_cluster_test_plan[*Mode Select Cluster Test Plan*]
** link:#_pics_definition_24[79. PICS Definition]
*** link:#_role_26[79.1. Role]
*** link:#_server_26[79.2. Server]
**** link:#_features_18[79.2.1. Features]
**** link:#_attributes_28[79.2.2. Attributes]
**** link:#_commands_received_17[79.2.3. Commands received]
*** link:#_client_16[79.3. Client]
**** link:#_attributes_29[79.3.1. Attributes]
**** link:#_commands_generated_16[79.3.2. Commands generated]
** link:#_test_case_list_26[80. Test Case List]
** link:#_test_cases_26[81. Test Cases]
*** link:#_attribute_test_cases[81.1. Attribute test cases]
**** link:#_tc_mod_1_1_global_attributes_with_server_as_dut[81.1.1.
[TC-MOD-1.1] Global attributes with server as DUT]
**** link:#_tc_mod_1_2_cluster_attributes_with_server_as_dut[81.1.2.
[TC-MOD-1.2] Cluster attributes with server as DUT]
**** link:#_tc_mod_1_3_attributes_with_client_as_dut[81.1.3.
[TC-MOD-1.3] Attributes with client as DUT]
*** link:#_changetomode_test_cases[81.2. ChangeToMode Test Cases]
**** link:#_tc_mod_2_1_changetomode_verification_dut_as_server[81.2.1.
[TC-MOD-2.1] ChangeToMode Verification (DUT as Server)]
**** link:#_tc_mod_2_2_changetomode_verification_dut_as_client[81.2.2.
[TC-MOD-2.2] ChangeToMode Verification (DUT as Client)]
*** link:#_onoff_and_startup_mode_test_cases[81.3. On/Off and StartUp
Mode Test Cases]
**** link:#_tc_mod_3_1_onmode_verification_dut_as_server[81.3.1.
[TC-MOD-3.1] OnMode Verification (DUT as Server)]
**** link:#_tc_mod_3_2_startupmode_verification_dut_as_server[81.3.2.
[TC-MOD-3.2] StartUpMode Verification (DUT as Server)]
**** link:#_tc_mod_3_3_ota_mode_verification_dut_as_server[81.3.3.
[TC-MOD-3.3] OTA Mode Verification (DUT as Server)]
**** link:#_tc_mod_3_4_onmode_overwriting_startupmode_dut_as_server[81.3.4.
[TC-MOD-3.4] OnMode Overwriting StartUpMode (DUT as Server)]
** link:#_rvc_run_cluster_test_plan[82. RVC Run Cluster Test Plan]
* link:#_rvc_run_mode_cluster_test_plan[*RVC Run Mode Cluster Test
Plan*]
** link:#_rvc_run_mode_cluster_testing_overview[83. RVC Run Mode Cluster
Testing Overview]
** link:#_pics_definition_25[84. PICS Definition]
*** link:#_role_27[84.1. Role]
*** link:#_server_27[84.2. Server]
**** link:#_features_19[84.2.1. Features]
**** link:#_attributes_30[84.2.2. Attributes]
**** link:#_commands_received_18[84.2.3. Commands received]
**** link:#_commands_generated_17[84.2.4. Commands generated]
**** link:#_manual_controllable_15[84.2.5. Manual controllable]
** link:#_pixit_definition_4[85. PIXIT Definition]
** link:#_test_case_list_27[86. Test Case List]
** link:#_test_cases_27[87. Test Cases]
*** link:#_generic_test_cases_23[87.1. Generic Test Cases]
**** link:#_tc_rvcrunm_1_1_global_attributes_with_dut_as_server[87.1.1.
[TC-RVCRUNM-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_18[87.2. Server as DUT]
**** link:#_tc_rvcrunm_1_2_cluster_attributes_with_dut_as_server[87.2.1.
[TC-RVCRUNM-1.2] Cluster attributes with DUT as Server]
*** link:#_changetomode_test_cases_2[87.3. ChangeToMode Test Cases]
**** link:#_tc_rvcrunm_2_1_change_to_mode_functionality_with_dut_as_server[87.3.1.
[TC-RVCRUNM-2.1] Change to Mode functionality with DUT as Server]
*** link:#_onoff_and_startup_mode_test_cases_2[87.4. On/Off and StartUp
Mode Test Cases]
**** link:#_tc_rvcrunm_3_1_on_mode_functionality_with_dut_as_server[87.4.1.
[TC-RVCRUNM-3.1] On Mode functionality with DUT as Server]
**** link:#_tc_rvcrunm_3_2_startup_mode_functionality_with_dut_as_server[87.4.2.
[TC-RVCRUNM-3.2] Startup Mode functionality with DUT as Server]
**** link:#_tc_rvcrunm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[87.4.3.
[TC-RVCRUNM-3.3] On Mode and Startup Mode functionality with DUT as
Server]
* link:#_rvc_clean_mode_cluster_test_plan[*RVC Clean Mode Cluster Test
Plan*]
** link:#_rvc_clean_mode_cluster_testing_overview[88. RVC Clean Mode
Cluster Testing Overview]
** link:#_pics_definition_26[89. PICS Definition]
*** link:#_role_28[89.1. Role]
*** link:#_server_28[89.2. Server]
**** link:#_features_20[89.2.1. Features]
**** link:#_attributes_31[89.2.2. Attributes]
**** link:#_commands_received_19[89.2.3. Commands received]
**** link:#_commands_generated_18[89.2.4. Commands generated]
**** link:#_manual_controllable_16[89.2.5. Manual controllable]
** link:#_pixit_definition_5[90. PIXIT Definition]
** link:#_test_case_list_28[91. Test Case List]
** link:#_test_cases_28[92. Test Cases]
*** link:#_generic_test_cases_24[92.1. Generic Test Cases]
**** link:#_tc_rvccleanm_1_1_global_attributes_with_dut_as_server[92.1.1.
[TC-RVCCLEANM-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_19[92.2. Server as DUT]
**** link:#_tc_rvccleanm_1_2_cluster_attributes_with_dut_as_server[92.2.1.
[TC-RVCCLEANM-1.2] Cluster attributes with DUT as Server]
*** link:#_changetomode_test_cases_3[92.3. ChangeToMode Test Cases]
**** link:#_tc_rvccleanm_2_1_change_to_mode_functionality_with_dut_as_server[92.3.1.
[TC-RVCCLEANM-2.1] Change to Mode functionality with DUT as Server]
*** link:#_onoff_and_startup_mode_test_cases_3[92.4. On/Off and StartUp
Mode Test Cases]
**** link:#_tc_rvccleanm_3_1_on_mode_functionality_with_dut_as_server[92.4.1.
[TC-RVCCLEANM-3.1] On Mode functionality with DUT as Server]
**** link:#_tc_rvccleanm_3_2_startup_mode_functionality_with_dut_as_server[92.4.2.
[TC-RVCCLEANM-3.2] Startup Mode functionality with DUT as Server]
**** link:#_tc_rvccleanm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[92.4.3.
[TC-RVCCLEANM-3.3] On Mode and Startup Mode functionality with DUT as
Server]
* link:#_descriptor_cluster_testplan[*Descriptor Cluster TestPlan*]
** link:#_pics_definition_27[93. PICS Definition]
*** link:#_role_29[93.1. Role]
*** link:#_server_29[93.2. Server]
**** link:#_features_21[93.2.1. Features]
**** link:#_attributes_32[93.2.2. Attributes]
** link:#_pixit_definition_6[94. PIXIT Definition]
** link:#_test_case_list_29[95. Test Case List]
** link:#_test_cases_29[96. Test Cases]
*** link:#_generic_test_cases_25[96.1. Generic test cases]
**** link:#_tc_desc_1_1_global_attributes_with_dut_as_server[96.1.1.
[TC-DESC-1.1] Global Attributes with DUT as Server]
*** link:#_cluster_attribute_test_cases_2[96.2. Cluster Attribute test
cases]
**** link:#_tc_desc_2_1_descriptor_cluster_attributes_dut_server[96.2.1.
[TC-DESC-2.1] Descriptor Cluster Attributes [DUT-Server]]
* link:#_general_diagnostics_cluster_test_plan[*General Diagnostics
Cluster Test Plan*]
** link:#_pics_definition_28[97. PICS Definition]
*** link:#_role_30[97.1. Role]
*** link:#_server_30[97.2. Server]
**** link:#_attributes_33[97.2.1. Attributes]
**** link:#_commands_received_20[97.2.2. Commands received]
**** link:#_events_7[97.2.3. Events]
*** link:#_client_17[97.3. Client]
**** link:#_commands_generated_19[97.3.1. Commands generated]
** link:#_pixit_definition_7[98. PIXIT Definition]
** link:#_test_case_list_30[99. Test Case List]
** link:#_test_cases_30[100. Test Cases]
*** link:#_generic_test_cases_26[100.1. Generic Test Cases]
**** link:#_tc_dggen_1_1_global_attributes_with_dut_as_server[100.1.1.
[TC-DGGEN-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut_20[100.2. Server as DUT]
**** link:#_tc_dggen_2_1_attributes_dut_as_server[100.2.1.
[TC-DGGEN-2.1] Attributes [DUT as Server]]
**** link:#_tc_dggen_2_2_event_functionality_dut_as_server[100.2.2.
[TC-DGGEN-2.2] Event Functionality [DUT as Server]]
**** link:#_tc_dggen_2_3_command_received_dut_as_server[100.2.3.
[TC-DGGEN-2.3] Command Received [DUT as Server]]
* link:#_general_commissioning_cluster_test_plan[*General Commissioning
Cluster Test Plan*]
** link:#_pics_definition_29[101. PICS Definition]
*** link:#_role_31[101.1. Role]
*** link:#_server_31[101.2. Server]
**** link:#_attributes_34[101.2.1. Attributes]
**** link:#_commands_received_21[101.2.2. Commands received]
**** link:#_commands_generated_20[101.2.3. Commands generated]
** link:#_pixit_definition_8[102. PIXIT Definition]
** link:#_test_case_list_31[103. Test Case List]
** link:#_test_cases_31[104. Test Cases]
*** link:#_generic_test_cases_27[104.1. Generic test cases]
**** link:#_tc_cgen_1_1_global_attributes_dut_server[104.1.1.
[TC-CGEN-1.1] Global Attributes [DUT-Server]]
*** link:#_dut_as_server_4[104.2. DUT as Server]
**** link:#_tc_cgen_2_1_breadcrumb_basiccommissioninginfo_regulatoryconfig_locationcapability_and_supportsconcurrentconnection_attributes_dut_server[104.2.1.
[TC-CGEN-2.1] Breadcrumb, BasicCommissioningInfo, RegulatoryConfig,
LocationCapability and SupportsConcurrentConnection attributes [DUT -
Server]]
**** link:#_tc_cgen_2_2_armfailsafe_command_verification_dut_server[104.2.2.
[TC-CGEN-2.2] ArmFailSafe command verification [DUT - Server]]
**** link:#_tc_cgen_2_4_verification_for_commissioningerror_on_response_message_dut_server[104.2.3.
[TC-CGEN-2.4] Verification For CommissioningError on response message
[DUT - Server]]
* link:#_user_label_cluster_test_plan[*User Label Cluster Test Plan*]
** link:#_pics_definition_30[105. PICS Definition]
*** link:#_role_32[105.1. Role]
*** link:#_server_32[105.2. Server]
**** link:#_attributes_35[105.2.1. Attributes]
** link:#_test_case_list_32[106. Test Case List]
** link:#_test_cases_32[107. Test Cases]
*** link:#_generic_test_cases_28[107.1. Generic test cases]
**** link:#_tc_ulabel_1_1_global_attributes_with_dut_as_server[107.1.1.
[TC-ULABEL-1.1] Global Attributes with DUT as Server]
*** link:#_dut_as_server_5[107.2. DUT as Server]
**** link:#_tc_ulabel_2_1_user_label_cluster_read_verification_dut_server[107.2.1.
[TC-ULABEL-2.1] User label cluster read verification [DUT-server]]
**** link:#_tc_ulabel_2_2_user_label_cluster_write_verification_dut_server[107.2.2.
[TC-ULABEL-2.2] User Label cluster write verification [DUT-server]]
**** link:#_tc_ulabel_2_3_user_label_cluster_constraint_error_verification_dut_server[107.2.3.
[TC-ULABEL-2.3] User Label cluster constraint_error verification
[DUT-server]]
**** link:#_tc_ulabel_2_4_user_label_cluster_empty_entry_verification_dut_server[107.2.4.
[TC-ULABEL-2.4] User Label cluster empty entry verification
[DUT-server]]
* link:#_fixed_label_cluster_test_plan[*Fixed Label Cluster Test Plan*]
** link:#_pics_definition_31[108. PICS Definition]
*** link:#_role_33[108.1. Role]
*** link:#_server_33[108.2. Server]
**** link:#_attributes_36[108.2.1. Attributes]
** link:#_test_case_list_33[109. Test Case List]
** link:#_test_cases_33[110. Test Cases]
*** link:#_generic_test_cases_29[110.1. Generic test cases]
**** link:#_tc_flabel_1_1_global_attributes_with_dut_as_server[110.1.1.
[TC-FLABEL-1.1] Global Attributes with DUT as Server]
*** link:#_dut_server[110.2. DUT-server]
**** link:#_tc_flabel_2_1_fixed_label_cluster_dut_server[110.2.1.
[TC-FLABEL-2.1] Fixed Label cluster [DUT-server]]
* link:#_localization_configuration_cluster_test_plan[*Localization
Configuration Cluster Test Plan*]
** link:#_pics_definition_32[111. PICS Definition]
*** link:#_role_34[111.1. Role]
*** link:#_server_34[111.2. Server]
**** link:#_attributes_37[111.2.1. Attributes]
** link:#_test_case_list_34[112. Test Case List]
** link:#_test_cases_34[113. Test Cases]
*** link:#_generic_test_case[113.1. Generic test case]
**** link:#_tc_lcfg_1_1_global_attributes_dut_server[113.1.1.
[TC-LCFG-1.1] Global Attributes [DUT-Server]]
*** link:#_server_as_dut_21[113.2. Server as DUT]
**** link:#_tc_lcfg_2_1_localization_configuration_cluster_attributesdut_server[113.2.1.
[TC-LCFG-2.1] Localization Configuration Cluster Attributes[DUT-Server]]
* link:#_unit_localization_cluster_test_plan[*Unit Localization Cluster
Test Plan*]
** link:#_pics_definition_33[114. PICS Definition]
*** link:#_role_35[114.1. Role]
*** link:#_server_35[114.2. Server]
**** link:#_features_22[114.2.1. Features]
**** link:#_attributes_38[114.2.2. Attributes]
**** link:#_enums_values[114.2.3. Enums & Values]
** link:#_test_case_list_35[115. Test Case List]
** link:#_test_cases_35[116. Test Cases]
*** link:#_generic_test_cases_30[116.1. Generic test cases]
**** link:#_tc_lunit_1_2_global_attributes_dut_as_server[116.1.1.
[TC-LUNIT-1.2] Global Attributes [DUT as Server]]
*** link:#_dut_as_server_6[116.2. DUT as Server]
**** link:#_tc_lunit_3_1_read_and_write_unit_localization_cluster_attributes_dut_as_server[116.2.1.
[TC-LUNIT-3.1] Read and Write Unit Localization Cluster Attributes [DUT
as Server]]
* link:#_time_format_localization_cluster_test_plan[*Time Format
Localization Cluster Test Plan*]
** link:#_pics_definition_34[117. PICS Definition]
*** link:#_role_36[117.1. Role]
*** link:#_server_36[117.2. Server]
**** link:#_attributes_39[117.2.1. Attributes]
**** link:#_specific_attribute_features[117.2.2. Specific Attribute
Features]
** link:#_pixit_definition_9[118. PIXIT Definition]
** link:#_test_case_list_36[119. Test Case List]
** link:#_test_cases_36[120. Test Cases]
*** link:#_generic_test_cases_31[120.1. Generic test cases]
**** link:#_tc_ltime_1_2_global_attributes_dut_as_server[120.1.1.
[TC-LTIME-1.2] Global Attributes [DUT as Server]]
*** link:#_dut_as_server_7[120.2. DUT as Server]
**** link:#_tc_ltime_3_1_read_and_write_time_format_localization_cluster_attributes_dut_as_server[120.2.1.
[TC-LTIME-3.1] Read and Write Time Format Localization Cluster
Attributes [DUT as Server]]
* link:#_door_lock_test_plan[*Door lock Test Plan*]
** link:#_pics_definition_35[121. PICS Definition]
*** link:#_role_37[121.1. Role]
*** link:#_server_37[121.2. Server]
**** link:#_manual_controllable_17[121.2.1. Manual controllable]
**** link:#_attributes_40[121.2.2. Attributes]
**** link:#_write_attributes[121.2.3. Write Attributes]
**** link:#_events_8[121.2.4. Events]
**** link:#_features_23[121.2.5. Features]
**** link:#_commands_received_22[121.2.6. Commands received]
**** link:#_commands_generated_21[121.2.7. Commands generated]
*** link:#_client_18[121.3. Client]
**** link:#_features_24[121.3.1. Features]
**** link:#_commands_generated_22[121.3.2. Commands generated]
**** link:#_commands_received_23[121.3.3. Commands received]
** link:#_pixit_definition_10[122. PIXIT Definition]
** link:#_test_case_list_37[123. Test Case List]
** link:#_test_cases_37[124. Test Cases]
*** link:#_generic_test_cases_32[124.1. Generic test cases]
**** link:#_tc_drlk_1_1_global_attributes_dut_server[124.1.1.
[TC-DRLK-1.1] Global Attributes [DUT-Server]]
*** link:#_server_as_dut_22[124.2. Server as DUT]
**** link:#_tc_drlk_2_1_attributes_check_dut_server[124.2.1.
[TC-DRLK-2.1] Attributes check [DUT - Server]]
**** link:#_tc_drlk_2_2_verification_for_door_lock_commanddut_server[124.2.2.
[TC-DRLK-2.2] Verification for Door lock command[DUT-Server]]
**** link:#_tc_drlk_2_3_verification_for_unlock_door_command_dut_server[124.2.3.
[TC-DRLK-2.3] Verification for Unlock Door command [DUT-Server]]
**** link:#_tc_drlk_2_4_verification_for_unlock_with_timeout_command_dut_server[124.2.4.
[TC-DRLK-2.4] Verification for Unlock with Timeout command [DUT-Server]]
**** link:#_tc_drlk_2_5_verification_for_the_following_commands_set_week_day_schedule_get_week_day_schedule_get_week_day_schedule_response_clear_week_day_schedule_dut_server[124.2.5.
[TC-DRLK-2.5] Verification for the following Commands - Set Week Day
Schedule, Get Week Day Schedule , Get Week Day Schedule Response, Clear
Week Day Schedule [DUT-Server]]
**** link:#_tc_drlk_2_6_verification_for_the_following_commands_set_holiday_schedule_get_holiday_schedule_get_holiday_schedule_response_clear_holiday_schedule_dut_server[124.2.6.
[TC-DRLK-2.6] Verification for the following Commands - Set Holiday
Schedule, Get Holiday Schedule, Get Holiday Schedule Response , Clear
Holiday Schedule [DUT-Server]]
**** link:#_tc_drlk_2_7_verification_for_the_following_commands_set_year_schedule_get_year_schedule_get_year_day_schedule_response_and_clear_year_day_scheduledut_server[124.2.7.
[TC-DRLK-2.7] Verification for the following Commands - Set Year
Schedule, Get Year Schedule, Get Year Day Schedule Response and Clear
Year Day Schedule[DUT-Server]]
**** link:#_tc_drlk_2_8_verification_for_the_following_commands_set_user_get_user_get_user_response_clear_user_dut_server[124.2.8.
[TC-DRLK-2.8] Verification for the following Commands - Set User, Get
User, Get User Response, Clear User [DUT-Server]]
**** link:#_tc_drlk_2_9_verification_for_the_following_commands_set_credential_set_credential_response_get_credential_status_get_credential_status_response_clear_credential_dut_server[124.2.9.
[TC-DRLK-2.9] Verification for the following Commands - Set Credential ,
Set Credential Response, Get Credential Status, Get Credential Status
Response, Clear Credential [DUT-Server]]
**** link:#_tc_drlk_2_10_verification_for_the_door_lock_events_dut_server[124.2.10.
[TC-DRLK-2.10] Verification for the Door Lock Events [DUT-Server]]
**** link:#_tc_drlk_2_11_verification_for_multiple_credential_types_dut_server[124.2.11.
[TC-DRLK-2.11] Verification for multiple credential types [DUT-Server]]
**** link:#_tc_drlk_2_12_verification_for_unbolt_door_command_dut_server[124.2.12.
[TC-DRLK-2.12] Verification for Unbolt Door command [DUT-Server]]
*** link:#_client_as_dut_8[124.3. Client as DUT]
**** link:#_tc_drlk_3_2_commands_dut_client[124.3.1. [TC-DRLK-3.2]
Commands [DUT - Client]]
* link:#_binding_cluster_test_plan[*Binding Cluster Test Plan*]
** link:#_pics_definition_36[125. PICS Definition]
*** link:#_role_38[125.1. Role]
*** link:#_server_38[125.2. Server]
**** link:#_attributes_41[125.2.1. Attributes]
*** link:#_client_19[125.3. Client]
**** link:#_attributes_42[125.3.1. Attributes]
**** link:#_commands_generated_23[125.3.2. Commands generated]
** link:#_test_case_list_38[126. Test Case List]
** link:#_test_cases_38[127. Test Cases]
*** link:#_generic_test_case_2[127.1. Generic Test Case]
**** link:#_tc_bind_1_1_global_attributes_with_dut_as_server[127.1.1.
[TC-BIND-1.1] Global Attributes with DUT as Server]
*** link:#_binding_cluster_test_case[127.2. Binding Cluster Test Case]
**** link:#_tc_bind_2_1_binding_cluster_attributes_node_dut_controller[127.2.1.
[TC-BIND-2.1] Binding Cluster Attributes-Node [DUT-Controller]]
**** link:#_tc_bind_2_2_binding_cluster_attributes_dut_handles_its_groups_settings_dut_controller[127.2.2.
[TC-BIND-2.2] Binding Cluster Attributes-DUT handles its Groups settings
[DUT-Controller]]
**** link:#_tc_bind_2_3_binding_cluster_attributes_th1_enables_dut_to_handle_its_group_settings_dut_controller[127.2.3.
[TC-BIND-2.3] Binding Cluster Attributes-TH1 enables DUT to handle its
Group settings [DUT-Controller]]
* link:#_groups_cluster_test_plan[*Groups Cluster Test Plan*]
** link:#_pics_definition_37[128. PICS Definition]
*** link:#_role_39[128.1. Role]
*** link:#_server_39[128.2. Server]
**** link:#_features_25[128.2.1. Features]
**** link:#_attributes_43[128.2.2. Attributes]
**** link:#_commands_received_24[128.2.3. Commands received]
**** link:#_commands_generated_24[128.2.4. Commands generated]
*** link:#_client_20[128.3. Client]
**** link:#_commands_generated_25[128.3.1. Commands generated]
** link:#_pixit_definition_11[129. PIXIT Definition]
** link:#_test_case_list_39[130. Test Case List]
** link:#_test_cases_39[131. Test Cases]
*** link:#_generic_test_cases_33[131.1. Generic test cases]
**** link:#_tc_g_1_1_global_attributes_dut_server[131.1.1. [TC-G-1.1]
Global Attributes [DUT-Server]]
*** link:#_server_as_dut_23[131.2. Server as DUT]
**** link:#_tc_g_2_1_attributes_dut_server[131.2.1. [TC-G-2.1]
Attributes [DUT-Server]]
**** link:#_tc_g_2_2_commands_addgroup_viewgroup_removegroup_removeallgroups_dut_server[131.2.2.
[TC-G-2.2] Commands - AddGroup, ViewGroup, RemoveGroup, RemoveAllGroups
[DUT-Server]]
**** link:#_tc_g_2_3_commands_getgroupmembership_addgroupifidentifying_dut_server[131.2.3.
[TC-G-2.3] Commands - GetGroupMembership, AddGroupIfIdentifying
[DUT-Server]]
**** link:#_tc_g_2_4_commands_addgroup_command_with_same_groupid_on_multiple_endpoint_dut_server[131.2.4.
[TC-G-2.4] Commands - AddGroup Command with same GroupID on Multiple
Endpoint [DUT-Server]]
*** link:#_client_as_dut_9[131.3. Client as DUT]
**** link:#_tc_g_3_2_commands_dut_client[131.3.1. [TC-G-3.2] Commands
[DUT-Client]]
* link:#_scenes_cluster_test_plan[*Scenes Cluster Test Plan*]
** link:#_pixit_items[132. PIXIT items]
** link:#_pics_definition_38[133. PICS Definition]
*** link:#_role_40[133.1. Role]
*** link:#_server_40[133.2. Server]
**** link:#_features_26[133.2.1. Features]
**** link:#_attributes_44[133.2.2. Attributes]
**** link:#_commands_received_25[133.2.3. Commands received]
**** link:#_commands_generated_26[133.2.4. Commands generated]
*** link:#_client_21[133.3. Client]
**** link:#_commands_generated_27[133.3.1. Commands generated]
** link:#_test_case_list_40[134. Test Case List]
*** link:#_testing_tolerances[134.1. Testing tolerances]
*** link:#_test_steps_manipulating_attributes[134.2. Test steps
manipulating attributes]
** link:#_test_cases_40[135. Test Cases]
*** link:#_generic_test_cases_34[135.1. Generic test cases]
**** link:#_tc_s_1_1_global_attributes_with_dut_as_server[135.1.1.
[TC-S-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_24[135.2. Server as DUT]
**** link:#_tc_s_2_1_attributes_with_dut_as_server[135.2.1. [TC-S-2.1]
Attributes with DUT as Server]
**** link:#_tc_s_2_2_primary_functionality_with_dut_as_server[135.2.2.
[TC-S-2.2] Primary functionality with DUT as Server]
**** link:#_tc_s_2_3_secondary_functionality_with_dut_as_server[135.2.3.
[TC-S-2.3] Secondary functionality with DUT as Server]
**** link:#_tc_s_2_4_recall_scene_with_transition_time_functionality_with_dut_as_server[135.2.4.
[TC-S-2.4] Recall scene with transition time functionality with DUT as
Server]
**** link:#_tc_s_2_5_remainingcapacity_functionality_with_dut_as_server[135.2.5.
[TC-S-2.5] RemainingCapacity functionality with DUT as Server]
**** link:#_tc_s_2_6_remainingcapacity_functionality_with_dut_as_server_multi_fabric[135.2.6.
[TC-S-2.6] RemainingCapacity functionality with DUT as Server -
Multi-Fabric]
* link:#_access_control_cluster[*Access Control cluster*]
** link:#_pics_definition_39[136. PICS Definition]
*** link:#_role_41[136.1. Role]
*** link:#_server_41[136.2. Server]
**** link:#_attributes_45[136.2.1. Attributes]
**** link:#_events_9[136.2.2. Events]
** link:#_test_case_list_41[137. Test Case List]
** link:#_test_cases_41[138. Test Cases]
*** link:#_generic_test_cases_35[138.1. Generic test cases]
**** link:#_tc_acl_1_1_global_attributes_with_dut_as_server[138.1.1.
[TC-ACL-1.1] Global Attributes with DUT as Server]
*** link:#_cluster_attribute_test_cases_3[138.2. Cluster Attribute test
cases]
**** link:#_tc_acl_2_1_simple_attributes[138.2.1. [TC-ACL-2.1] Simple
attributes]
**** link:#_tc_acl_2_2_cluster_endpoint[138.2.2. [TC-ACL-2.2] Cluster
endpoint]
**** link:#_tc_acl_2_3_extension_attribute[138.2.3. [TC-ACL-2.3]
Extension attribute]
**** link:#_tc_acl_2_4_acl_attribute[138.2.4. [TC-ACL-2.4] ACL
attribute]
**** link:#_tc_acl_2_5_accesscontrolextensionchanged_event[138.2.5.
[TC-ACL-2.5] AccessControlExtensionChanged event]
**** link:#_tc_acl_2_6_accesscontrolentrychanged_event[138.2.6.
[TC-ACL-2.6] AccessControlEntryChanged event]
**** link:#_tc_acl_2_7_extension_multi_fabric[138.2.7. [TC-ACL-2.7]
Extension multi-fabric]
**** link:#_tc_acl_2_8_acl_multi_fabric[138.2.8. [TC-ACL-2.8] ACL
multi-fabric]
**** link:#_tc_acl_2_9_cluster_access[138.2.9. [TC-ACL-2.9] Cluster
access]
**** link:#_tc_acl_2_10_persistence[138.2.10. [TC-ACL-2.10] Persistence]
* link:#_bridged_device_basic_information_test_plan[*Bridged Device
Basic Information Test Plan*]
** link:#_pics_definition_40[139. PICS Definition]
*** link:#_role_42[139.1. Role]
*** link:#_server_42[139.2. Server]
**** link:#_attributes_46[139.2.1. Attributes]
**** link:#_events_10[139.2.2. Events]
** link:#ref_testplan_BridgedDeviceBasicInformation[140. PIXIT
Definition]
** link:#_test_case_list_42[141. Test Case List]
** link:#_test_cases_42[142. Test Cases]
*** link:#_generic_test_cases_36[142.1. Generic Test Cases]
**** link:#_tc_brbinfo_1_1_global_attributes_with_dut_as_server[142.1.1.
[TC-BRBINFO-1.1] Global Attributes with DUT as Server]
*** link:#_bridged_device_basic_information_cluster_cluster_test_cases[142.2.
Bridged Device Basic Information Cluster Cluster Test Cases]
**** link:#_tc_brbinfo_2_1_attributes_dut_server[142.2.1.
[TC-BRBINFO-2.1] Attributes [DUT-Server]]
**** link:#_tc_brbinfo_2_2_events_dut_server[142.2.2. [TC-BRBINFO-2.2]
Events [DUT-Server]]
**** link:#_tc_brbinfo_3_1_appearance_attribute_dut_as_server[142.2.3.
[TC-BRBINFO-3.1] Appearance Attribute DUT as Server]
* link:#_time_synchronization_cluster_test_plan[*Time Synchronization
Cluster Test Plan*]
** link:#_pics_definition_41[143. PICS Definition]
*** link:#_role_43[143.1. Role]
*** link:#_server_43[143.2. Server]
**** link:#_features_27[143.2.1. Features]
**** link:#_attributes_47[143.2.2. Attributes]
**** link:#_commands_received_26[143.2.3. Commands received]
**** link:#_commands_generated_28[143.2.4. Commands generated]
**** link:#_events_11[143.2.5. Events]
** link:#_test_case_list_43[144. Test Case List]
** link:#_test_cases_43[145. Test Cases]
*** link:#_generic_test_cases_37[145.1. Generic test cases]
**** link:#_tc_timesync_1_1_global_attributes_with_dut_as_server[145.1.1.
[TC-TIMESYNC-1.1] Global attributes with DUT as Server]
*** link:#_server_44[145.2. Server]
**** link:#_tc_timesync_2_1_attributes_with_dut_as_server[145.2.1.
[TC-TIMESYNC-2.1] Attributes with DUT as Server]
**** link:#_tc_timesync_2_2_setutctime_command_with_dut_as_server[145.2.2.
[TC-TIMESYNC-2.2] SetUTCTime command with DUT as Server]
**** link:#_tc_timesync_2_3_settrustedtimesource_command_with_dut_as_server[145.2.3.
[TC-TIMESYNC-2.3] SetTrustedTimeSource command with DUT as Server]
**** link:#_tc_timesync_2_4_settimezone_command_with_dut_as_server[145.2.4.
[TC-TIMESYNC-2.4] SetTimeZone command with DUT as Server]
**** link:#_tc_timesync_2_5_setdstoffset_command_with_dut_as_server[145.2.5.
[TC-TIMESYNC-2.5] SetDSTOffset command with DUT as Server]
**** link:#_tc_timesync_2_6_setdefaultntp_command_with_dut_as_server[145.2.6.
[TC-TIMESYNC-2.6] SetDefaultNTP command with DUT as Server]
**** link:#_tc_timesync_2_7_localtime_calculation_for_time_zone_with_dut_as_server[145.2.7.
[TC-TIMESYNC-2.7] LocalTime calculation for time zone with DUT as
Server]
**** link:#_tc_timesync_2_8_localtime_calculation_for_dst_offset_with_dut_as_server[145.2.8.
[TC-TIMESYNC-2.8] LocalTime calculation for DST offset with DUT as
Server]
**** link:#_tc_timesync_2_9_localtime_calculation_for_time_zone_with_dst_offset_with_dut_as_server[145.2.9.
[TC-TIMESYNC-2.9] LocalTime calculation for time zone with DST offset
with DUT as Server]
**** link:#_tc_timesync_2_10_dsttableempty_event_generation_with_dut_as_server[145.2.10.
[TC-TIMESYNC-2.10] DSTTableEmpty event generation with DUT as Server]
**** link:#_tc_timesync_2_11_dststatus_event_generation_with_dut_as_server[145.2.11.
[TC-TIMESYNC-2.11] DSTStatus event generation with DUT as Server]
**** link:#_tc_timesync_2_12_timezonestatus_event_generation_with_dut_as_server[145.2.12.
[TC-TIMESYNC-2.12] TimeZoneStatus event generation with DUT as Server]
**** link:#_tc_timesync_2_13_missingtrustedtimesource_event_generation_with_dut_as_server[145.2.13.
[TC-TIMESYNC-2.13] MissingTrustedTimeSource event generation with DUT as
Server]
**** link:#_tc_timesync_3_1_endpoint_composition_with_dut_as_server[145.2.14.
[TC-TIMESYNC-3.1] Endpoint composition with DUT as Server]
* link:#_carbon_monoxide_concentration_measurement_cluster_test_plan[*Carbon
Monoxide Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_42[146. PICS Definition]
*** link:#_role_44[146.1. Role]
*** link:#_server_45[146.2. Server]
**** link:#_features_28[146.2.1. Features]
**** link:#_attributes_48[146.2.2. Attributes]
** link:#_test_case_list_44[147. Test Case List]
** link:#_test_cases_44[148. Test Cases]
*** link:#_generic_test_cases_38[148.1. Generic test cases]
**** link:#_tc_cmoconc_1_1_global_attributes_with_dut_as_server[148.1.1.
[TC-CMOCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_46[148.2. Server]
**** link:#_tc_cmoconc_2_1_attributes_with_dut_as_server[148.2.1.
[TC-CMOCONC-2.1] Attributes with DUT as Server]
* link:#_carbon_dioxide_concentration_measurement_cluster_test_plan[*Carbon
Dioxide Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_43[149. PICS Definition]
*** link:#_role_45[149.1. Role]
*** link:#_server_47[149.2. Server]
**** link:#_features_29[149.2.1. Features]
**** link:#_attributes_49[149.2.2. Attributes]
** link:#_test_case_list_45[150. Test Case List]
** link:#_test_cases_45[151. Test Cases]
*** link:#_generic_test_cases_39[151.1. Generic test cases]
**** link:#_tc_cdoconc_1_1_global_attributes_with_dut_as_server[151.1.1.
[TC-CDOCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_48[151.2. Server]
**** link:#_tc_cdoconc_2_1_attributes_with_dut_as_server[151.2.1.
[TC-CDOCONC-2.1] Attributes with DUT as Server]
* link:#_nitrogen_dioxide_concentration_measurement_cluster_test_plan[*Nitrogen
Dioxide Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_44[152. PICS Definition]
*** link:#_role_46[152.1. Role]
*** link:#_server_49[152.2. Server]
**** link:#_features_30[152.2.1. Features]
**** link:#_attributes_50[152.2.2. Attributes]
** link:#_test_case_list_46[153. Test Case List]
** link:#_test_cases_46[154. Test Cases]
*** link:#_generic_test_cases_40[154.1. Generic test cases]
**** link:#_tc_ndoconc_1_1_global_attributes_with_dut_as_server[154.1.1.
[TC-NDOCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_50[154.2. Server]
**** link:#_tc_ndoconc_2_1_attributes_with_dut_as_server[154.2.1.
[TC-NDOCONC-2.1] Attributes with DUT as Server]
* link:#_ozone_concentration_measurement_cluster_test_plan[*Ozone
Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_45[155. PICS Definition]
*** link:#_role_47[155.1. Role]
*** link:#_server_51[155.2. Server]
**** link:#_features_31[155.2.1. Features]
**** link:#_attributes_51[155.2.2. Attributes]
** link:#_test_case_list_47[156. Test Case List]
** link:#_test_cases_47[157. Test Cases]
*** link:#_generic_test_cases_41[157.1. Generic test cases]
**** link:#_tc_ozconc_1_1_global_attributes_with_dut_as_server[157.1.1.
[TC-OZCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_52[157.2. Server]
**** link:#_tc_ozconc_2_1_attributes_with_dut_as_server[157.2.1.
[TC-OZCONC-2.1] Attributes with DUT as Server]
* link:#_pm2_5_concentration_measurement_cluster_test_plan[*PM2.5
Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_46[158. PICS Definition]
*** link:#_role_48[158.1. Role]
*** link:#_server_53[158.2. Server]
**** link:#_features_32[158.2.1. Features]
**** link:#_attributes_52[158.2.2. Attributes]
** link:#_test_case_list_48[159. Test Case List]
** link:#_test_cases_48[160. Test Cases]
*** link:#_generic_test_cases_42[160.1. Generic test cases]
**** link:#_tc_pmiconc_1_1_global_attributes_with_dut_as_server[160.1.1.
[TC-PMICONC-1.1] Global attributes with DUT as Server]
*** link:#_server_54[160.2. Server]
**** link:#_tc_pmiconc_2_1_attributes_with_dut_as_server[160.2.1.
[TC-PMICONC-2.1] Attributes with DUT as Server]
* link:#_formaldehyde_concentration_measurement_cluster_test_plan[*Formaldehyde
Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_47[161. PICS Definition]
*** link:#_role_49[161.1. Role]
*** link:#_server_55[161.2. Server]
**** link:#_features_33[161.2.1. Features]
**** link:#_attributes_53[161.2.2. Attributes]
** link:#_test_case_list_49[162. Test Case List]
** link:#_test_cases_49[163. Test Cases]
*** link:#_generic_test_cases_43[163.1. Generic test cases]
**** link:#_tc_fldconc_1_1_global_attributes_with_dut_as_server[163.1.1.
[TC-FLDCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_56[163.2. Server]
**** link:#_tc_fldconc_2_1_attributes_with_dut_as_server[163.2.1.
[TC-FLDCONC-2.1] Attributes with DUT as Server]
* link:#_pm1_concentration_measurement_cluster_test_plan[*PM1
Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_48[164. PICS Definition]
*** link:#_role_50[164.1. Role]
*** link:#_server_57[164.2. Server]
**** link:#_features_34[164.2.1. Features]
**** link:#_attributes_54[164.2.2. Attributes]
** link:#_test_case_list_50[165. Test Case List]
** link:#_test_cases_50[166. Test Cases]
*** link:#_generic_test_cases_44[166.1. Generic test cases]
**** link:#_tc_pmhconc_1_1_global_attributes_with_dut_as_server[166.1.1.
[TC-PMHCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_58[166.2. Server]
**** link:#_tc_pmhconc_2_1_attributes_with_dut_as_server[166.2.1.
[TC-PMHCONC-2.1] Attributes with DUT as Server]
* link:#_pm10_concentration_measurement_cluster_test_plan[*PM10
Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_49[167. PICS Definition]
*** link:#_role_51[167.1. Role]
*** link:#_server_59[167.2. Server]
**** link:#_features_35[167.2.1. Features]
**** link:#_attributes_55[167.2.2. Attributes]
** link:#_test_case_list_51[168. Test Case List]
** link:#_test_cases_51[169. Test Cases]
*** link:#_generic_test_cases_45[169.1. Generic test cases]
**** link:#_tc_pmkconc_1_1_global_attributes_with_dut_as_server[169.1.1.
[TC-PMKCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_60[169.2. Server]
**** link:#_tc_pmkconc_2_1_attributes_with_dut_as_server[169.2.1.
[TC-PMKCONC-2.1] Attributes with DUT as Server]
* link:#_total_volatile_organic_compounds_concentration_measurement_cluster_test_plan[*Total
Volatile Organic Compounds Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_50[170. PICS Definition]
*** link:#_role_52[170.1. Role]
*** link:#_server_61[170.2. Server]
**** link:#_features_36[170.2.1. Features]
**** link:#_attributes_56[170.2.2. Attributes]
** link:#_test_case_list_52[171. Test Case List]
** link:#_test_cases_52[172. Test Cases]
*** link:#_generic_test_cases_46[172.1. Generic test cases]
**** link:#_tc_tvocconc_1_1_global_attributes_with_dut_as_server[172.1.1.
[TC-TVOCCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_62[172.2. Server]
**** link:#_tc_tvocconc_2_1_attributes_with_dut_as_server[172.2.1.
[TC-TVOCCONC-2.1] Attributes with DUT as Server]
* link:#_radon_concentration_measurement_cluster_test_plan[*Radon
Concentration Measurement Cluster Test Plan*]
** link:#_pics_definition_51[173. PICS Definition]
*** link:#_role_53[173.1. Role]
*** link:#_server_63[173.2. Server]
**** link:#_features_37[173.2.1. Features]
**** link:#_attributes_57[173.2.2. Attributes]
** link:#_test_case_list_53[174. Test Case List]
** link:#_test_cases_53[175. Test Cases]
*** link:#_generic_test_cases_47[175.1. Generic test cases]
**** link:#_tc_rnconc_1_1_global_attributes_with_dut_as_server[175.1.1.
[TC-RNCONC-1.1] Global attributes with DUT as Server]
*** link:#_server_64[175.2. Server]
**** link:#_tc_rnconc_2_1_attributes_with_dut_as_server[175.2.1.
[TC-RNCONC-2.1] Attributes with DUT as Server]
* link:#_temperature_control_cluster_test_plan[*Temperature Control
Cluster Test Plan*]
** link:#_pics_definition_52[176. PICS Definition]
*** link:#_role_54[176.1. Role]
*** link:#_server_65[176.2. Server]
**** link:#_features_38[176.2.1. Features]
**** link:#_attributes_58[176.2.2. Attributes]
**** link:#_manual_controllable_18[176.2.3. Manual controllable]
**** link:#_commands_received_27[176.2.4. Commands received]
** link:#_test_case_list_54[177. Test Case List]
** link:#_test_cases_54[178. Test Cases]
*** link:#_generic_test_cases_48[178.1. Generic test cases]
**** link:#_tc_tctl_1_1_global_attributes_with_dut_as_server[178.1.1.
[TC-TCTL-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_25[178.2. Server as DUT]
**** link:#_tc_tctl_2_1_attributes_with_dut_as_server[178.2.1.
[TC-TCTL-2.1] Attributes with DUT as Server]
**** link:#_tc_tctl_2_2_optional_temperature_number_attributes_with_dut_as_server[178.2.2.
[TC-TCTL-2.2] Optional Temperature number attributes with DUT as Server]
**** link:#_tc_tctl_2_3_optional_temperature_level_attributes_with_dut_as_server[178.2.3.
[TC-TCTL-2.3] Optional temperature level attributes with DUT as Server]
**** link:#_tc_tctl_3_2_optional_temperature_number_functionality_with_dut_as_server[178.2.4.
[TC-TCTL-3.2] Optional temperature number functionality with DUT as
Server]
**** link:#_tc_tctl_3_3_optional_temperature_level_functionality_with_dut_as_server[178.2.5.
[TC-TCTL-3.3] Optional temperature level functionality with DUT as
Server]
* link:#_laundry_washer_mode_cluster_test_plan[*Laundry Washer Mode
Cluster Test Plan*]
** link:#_laundry_washer_mode_cluster_testing_overview[179. Laundry
Washer Mode Cluster Testing Overview]
** link:#_pics_definition_53[180. PICS Definition]
*** link:#_role_55[180.1. Role]
*** link:#_server_66[180.2. Server]
**** link:#_features_39[180.2.1. Features]
**** link:#_attributes_59[180.2.2. Attributes]
**** link:#_commands_received_28[180.2.3. Commands received]
**** link:#_commands_generated_29[180.2.4. Commands generated]
**** link:#_manual_controllable_19[180.2.5. Manual controllable]
** link:#_pixit_definition_12[181. PIXIT Definition]
** link:#_test_case_list_55[182. Test Case List]
** link:#_test_cases_55[183. Test Cases]
*** link:#_attribute_test_cases_2[183.1. Attribute test cases]
**** link:#_tc_lwm_1_1_global_attributes_with_dut_as_server[183.1.1.
[TC-LWM-1.1] Global attributes with DUT as Server]
**** link:#_tc_lwm_1_2_cluster_attributes_with_dut_as_server[183.1.2.
[TC-LWM-1.2] Cluster attributes with DUT as Server]
*** link:#_changetomode_test_cases_4[183.2. ChangeToMode Test Cases]
**** link:#_tc_lwm_2_1_change_to_mode_functionality_with_dut_as_server[183.2.1.
[TC-LWM-2.1] Change to Mode functionality with DUT as Server]
*** link:#_onoff_and_startup_mode_test_cases_4[183.3. On/Off and StartUp
Mode Test Cases]
**** link:#_tc_lwm_3_1_on_mode_functionality_with_dut_as_server[183.3.1.
[TC-LWM-3.1] On Mode functionality with DUT as Server]
**** link:#_tc_lwm_3_2_startup_mode_functionality_with_dut_as_server[183.3.2.
[TC-LWM-3.2] Startup Mode functionality with DUT as Server]
**** link:#_tc_lwm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[183.3.3.
[TC-LWM-3.3] On Mode and Startup Mode functionality with DUT as Server]
* link:#_washer_controls_cluster_test_plan[*Washer Controls Cluster Test
Plan*]
** link:#_pics_definition_54[184. PICS Definition]
*** link:#_role_56[184.1. Role]
*** link:#_server_67[184.2. Server]
**** link:#_features_40[184.2.1. Features]
**** link:#_attributes_60[184.2.2. Attributes]
**** link:#_manual_controllable_20[184.2.3. Manual controllable]
** link:#_test_case_list_56[185. Test Case List]
** link:#_test_cases_56[186. Test Cases]
*** link:#_generic_test_cases_49[186.1. Generic test cases]
**** link:#_tc_washerctrl_1_1_global_attributes_with_server_as_dut[186.1.1.
[TC-WASHERCTRL-1.1] Global attributes with server as DUT]
*** link:#_server_as_dut_26[186.2. Server as DUT]
**** link:#_tc_washerctrl_2_1_optional_spin_attributes_with_dut_as_server[186.2.1.
[TC-WASHERCTRL-2.1] Optional Spin attributes with DUT as Server]
**** link:#_tc_washerctrl_2_2_optional_rinse_attributes_with_dut_as_server[186.2.2.
[TC-WASHERCTRL-2.2] Optional rinse attributes with DUT as Server]
**** link:#_tc_washerctrl_3_1_rinse_functionality_with_dut_as_server[186.2.3.
[TC-WASHERCTRL-3.1] Rinse functionality with DUT as Server]
**** link:#_tc_washerctrl_3_2_optional_spin_functionality_with_dut_as_server[186.2.4.
[TC-WASHERCTRL-3.2] Optional spin functionality with DUT as Server]
* link:#_fan_control_cluster_test_plan[*Fan Control Cluster Test Plan*]
** link:#_pics_definition_55[187. PICS Definition]
*** link:#_role_57[187.1. Role]
*** link:#_server_68[187.2. Server]
**** link:#_features_41[187.2.1. Features]
**** link:#_attributes_61[187.2.2. Attributes]
**** link:#_commands_received_29[187.2.3. Commands received]
** link:#_test_case_list_57[188. Test Case List]
** link:#_test_cases_57[189. Test Cases]
*** link:#_generic_test_cases_50[189.1. Generic test cases]
**** link:#_tc_fan_1_1_global_attributes_with_dut_as_server[189.1.1.
[TC-FAN-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_27[189.2. Server as DUT]
**** link:#_tc_fan_2_1_mandatory_attributes_with_dut_as_server[189.2.1.
[TC-FAN-2.1] Mandatory Attributes with DUT as Server]
**** link:#_tc_fan_2_2_optional_speed_attributes_with_dut_as_server[189.2.2.
[TC-FAN-2.2] Optional speed attributes with DUT as Server]
**** link:#_tc_fan_2_3_optional_rock_attributes_with_dut_as_server[189.2.3.
[TC-FAN-2.3] Optional rock attributes with DUT as Server]
**** link:#_tc_fan_2_4_optional_wind_attributes_with_dut_as_server[189.2.4.
[TC-FAN-2.4] Optional wind attributes with DUT as Server]
**** link:#_tc_fan_2_5_optional_direction_attributes_with_dut_as_server[189.2.5.
[TC-FAN-2.5] Optional direction attributes with DUT as Server]
**** link:#_tc_fan_3_1_mandatory_functionality_with_dut_as_server[189.2.6.
[TC-FAN-3.1] Mandatory functionality with DUT as Server]
**** link:#_tc_fan_3_2_optional_speed_functionality_with_dut_as_server[189.2.7.
[TC-FAN-3.2] Optional speed functionality with DUT as Server]
**** link:#_tc_fan_3_3_optional_rock_functionality_with_dut_as_server[189.2.8.
[TC-FAN-3.3] Optional rock functionality with DUT as Server]
**** link:#_tc_fan_3_4_optional_wind_functionality_with_dut_as_server[189.2.9.
[TC-FAN-3.4] Optional wind functionality with DUT as Server]
**** link:#_tc_fan_3_5_optional_step_functionality_with_dut_as_server[189.2.10.
[TC-FAN-3.5] Optional step functionality with DUT as Server]
**** link:#_tc_fan_3_6_optional_direction_functionality_with_dut_as_server[189.2.11.
[TC-FAN-3.6] Optional direction functionality with DUT as Server]
* link:#_dishwasher_mode_cluster_test_plan[*Dishwasher Mode Cluster Test
Plan*]
** link:#_dishwasher_mode_cluster_testing_overview[190. Dishwasher Mode
Cluster Testing Overview]
** link:#_pics_definition_56[191. PICS Definition]
*** link:#_role_58[191.1. Role]
*** link:#_server_69[191.2. Server]
**** link:#_features_42[191.2.1. Features]
**** link:#_attributes_62[191.2.2. Attributes]
**** link:#_commands_received_30[191.2.3. Commands received]
**** link:#_commands_generated_30[191.2.4. Commands generated]
**** link:#_manual_controllable_21[191.2.5. Manual controllable]
** link:#_pixit_definition_13[192. PIXIT Definition]
** link:#_test_case_list_58[193. Test Case List]
** link:#_test_cases_58[194. Test Cases]
*** link:#_attribute_test_cases_3[194.1. Attribute test cases]
**** link:#_tc_dishm_1_1_global_attributes_with_dut_as_server[194.1.1.
[TC-DISHM-1.1] Global attributes with DUT as Server]
**** link:#_tc_dishm_1_2_cluster_attributes_with_dut_as_server[194.1.2.
[TC-DISHM-1.2] Cluster attributes with DUT as Server]
*** link:#_changetomode_test_cases_5[194.2. ChangeToMode Test Cases]
**** link:#_tc_dishm_2_1_change_to_mode_functionality_with_dut_as_server[194.2.1.
[TC-DISHM-2.1] Change to Mode functionality with DUT as Server]
*** link:#_onoff_and_startup_mode_test_cases_5[194.3. On/Off and StartUp
Mode Test Cases]
**** link:#_tc_dishm_3_1_on_mode_functionality_with_dut_as_server[194.3.1.
[TC-DISHM-3.1] On Mode functionality with DUT as Server]
**** link:#_tc_dishm_3_2_startup_mode_functionality_with_dut_as_server[194.3.2.
[TC-DISHM-3.2] Startup Mode functionality with DUT as Server]
**** link:#_tc_dishm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[194.3.3.
[TC-DISHM-3.3] On Mode and Startup Mode functionality with DUT as
Server]
* link:#_dishwasher_alarm_cluster_test_plan[*Dishwasher Alarm Cluster
Test Plan*]
** link:#_pics_definition_57[195. PICS Definition]
*** link:#_role_59[195.1. Role]
*** link:#_server_70[195.2. Server]
**** link:#_features_43[195.2.1. Features]
**** link:#_attributes_63[195.2.2. Attributes]
**** link:#_manual_controllable_22[195.2.3. Manual controllable]
**** link:#_events_12[195.2.4. Events]
**** link:#_commands_received_31[195.2.5. Commands received]
** link:#_test_case_list_59[196. Test Case List]
** link:#_test_cases_59[197. Test Cases]
*** link:#_generic_test_cases_51[197.1. Generic test cases]
**** link:#_tc_dishalm_1_1_global_attributes_with_dut_as_server[197.1.1.
[TC-DISHALM-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_28[197.2. Server as DUT]
**** link:#_tc_dishalm_2_1_attributes_with_dut_as_server[197.2.1.
[TC-DISHALM-2.1] Attributes with DUT as Server]
**** link:#_tc_dishalm_3_1_inflow_alarm_functionality_with_dut_as_server[197.2.2.
[TC-DISHALM-3.1] Inflow alarm functionality with DUT as Server]
**** link:#_tc_dishalm_3_2_drain_alarm_functionality_with_dut_as_server[197.2.3.
[TC-DISHALM-3.2] Drain alarm functionality with DUT as Server]
**** link:#_tc_dishalm_3_3_door_alarm_functionality_with_dut_as_server[197.2.4.
[TC-DISHALM-3.3] Door alarm functionality with DUT as Server]
**** link:#_tc_dishalm_3_4_temperature_low_alarm_functionality_with_dut_as_server[197.2.5.
[TC-DISHALM-3.4] Temperature Low alarm functionality with DUT as Server]
**** link:#_tc_dishalm_3_5_temperature_high_alarm_functionality_with_dut_as_server[197.2.6.
[TC-DISHALM-3.5] Temperature High alarm functionality with DUT as
Server]
**** link:#_tc_dishalm_3_6_water_level_alarm_functionality_with_dut_as_server[197.2.7.
[TC-DISHALM-3.6] Water Level alarm functionality with DUT as Server]
* link:#_operational_state_cluster_test_plan[*Operational State Cluster
Test Plan*]
** link:#_pics_definition_58[198. PICS Definition]
*** link:#_role_60[198.1. Role]
*** link:#_server_71[198.2. Server]
**** link:#_attributes_64[198.2.1. Attributes]
**** link:#_commands_received_32[198.2.2. Commands received]
**** link:#_commands_generated_31[198.2.3. Commands generated]
**** link:#_events_13[198.2.4. Events]
**** link:#_manual_controllable_23[198.2.5. Manual controllable]
** link:#_pixit_definition_14[199. PIXIT Definition]
** link:#_test_case_list_60[200. Test Case List]
** link:#_test_cases_60[201. Test Cases]
*** link:#_generic_test_cases_52[201.1. Generic test cases]
**** link:#_tc_opstate_1_1_global_attributes_with_dut_as_server[201.1.1.
[TC-OPSTATE-1.1] Global Attributes with DUT as Server]
*** link:#_server_as_dut_29[201.2. Server as DUT]
**** link:#_tc_opstate_2_1_attributes_with_dut_as_server[201.2.1.
[TC-OPSTATE-2.1] Attributes with DUT as Server]
**** link:#_tc_opstate_2_2_start_and_stop_commands_with_dut_as_server[201.2.2.
[TC-OPSTATE-2.2] Start and Stop commands with DUT as Server]
**** link:#_tc_opstate_2_3_pause_and_resume_commands_with_dut_as_server[201.2.3.
[TC-OPSTATE-2.3] Pause and Resume commands with DUT as Server]
**** link:#_tc_opstate_2_4_mandatory_events_with_dut_as_server[201.2.4.
[TC-OPSTATE-2.4] Mandatory Events with DUT as Server]
* link:#_air_quality_cluster_test_plan[*Air Quality Cluster Test Plan*]
** link:#_pics_definition_59[202. PICS Definition]
*** link:#_role_61[202.1. Role]
*** link:#_server_72[202.2. Server]
**** link:#_features_44[202.2.1. Features]
**** link:#_attributes_65[202.2.2. Attributes]
** link:#_test_case_list_61[203. Test Case List]
** link:#_test_cases_61[204. Test Cases]
*** link:#_generic_test_cases_53[204.1. Generic test cases]
**** link:#_tc_airqual_1_1_global_attributes_with_dut_as_server[204.1.1.
[TC-AIRQUAL-1.1] Global attributes with DUT as Server]
*** link:#_server_73[204.2. Server]
**** link:#_tc_airqual_2_1_attributes_with_dut_as_server[204.2.1.
[TC-AIRQUAL-2.1] Attributes with DUT as Server]
* link:#_hepa_filter_monitoring_cluster_test_plan[*HEPA Filter
Monitoring Cluster Test Plan*]
** link:#_pics_definition_60[205. PICS Definition]
*** link:#_role_62[205.1. Role]
*** link:#_server_74[205.2. Server]
**** link:#_features_45[205.2.1. Features]
**** link:#_attributes_66[205.2.2. Attributes]
**** link:#_commands_received_33[205.2.3. Commands received]
** link:#_test_case_list_62[206. Test Case List]
** link:#_test_cases_62[207. Test Cases]
*** link:#_generic_test_cases_54[207.1. Generic test cases]
**** link:#_tc_hepafremon_1_1_global_attributes_with_dut_as_server[207.1.1.
[TC-HEPAFREMON-1.1] Global attributes with DUT as Server]
*** link:#_server_75[207.2. Server]
**** link:#_tc_hepafremon_2_1_attributes_with_dut_as_server[207.2.1.
[TC-HEPAFREMON-2.1] Attributes with DUT as Server]
* link:#_activated_carbon_filter_monitoring_cluster_test_plan[*Activated
Carbon Filter Monitoring Cluster Test Plan*]
** link:#_pics_definition_61[208. PICS Definition]
*** link:#_role_63[208.1. Role]
*** link:#_server_76[208.2. Server]
**** link:#_features_46[208.2.1. Features]
**** link:#_attributes_67[208.2.2. Attributes]
**** link:#_commands_received_34[208.2.3. Commands received]
** link:#_test_case_list_63[209. Test Case List]
** link:#_test_cases_63[210. Test Cases]
*** link:#_generic_test_cases_55[210.1. Generic test cases]
**** link:#_tc_acfremon_1_1_global_attributes_with_dut_as_server[210.1.1.
[TC-ACFREMON-1.1] Global attributes with DUT as Server]
*** link:#_server_77[210.2. Server]
**** link:#_tc_acfremon_2_1_attributes_with_dut_as_server[210.2.1.
[TC-ACFREMON-2.1] Attributes with DUT as Server]
* link:#_icd_management_cluster_test_plan[*ICD Management Cluster Test
Plan*]
** link:#_pics_definition_62[211. PICS Definition]
*** link:#_role_64[211.1. Role]
*** link:#_server_78[211.2. Server]
**** link:#_features_47[211.2.1. Features]
**** link:#_attributes_68[211.2.2. Attributes]
**** link:#_commands_received_35[211.2.3. Commands received]
**** link:#_commands_generated_32[211.2.4. Commands generated]
*** link:#_client_22[211.3. Client]
**** link:#_attributes_69[211.3.1. Attributes]
**** link:#_commands_received_36[211.3.2. Commands received]
** link:#_test_case_list_64[212. Test Case List]
** link:#_test_cases_64[213. Test Cases]
*** link:#_generic_test_cases_56[213.1. Generic test cases]
**** link:#_tc_icdm_1_1_global_attributes_with_dut_as_server[213.1.1.
[TC-ICDM-1.1] Global attributes with DUT as Server]
*** link:#_server_79[213.2. Server]
**** link:#_tc_icdm_2_1_attributes_with_dut_as_server[213.2.1.
[TC-ICDM-2.1] Attributes with DUT as Server]
**** link:#_tc_icdm_2_2_primary_functionality_with_dut_as_server_removed[213.2.2.
[TC-ICDM-2.2] Primary functionality with DUT as Server - REMOVED]
**** link:#_tc_icdm_2_3_secondary_functionality_with_dut_as_server_removed[213.2.3.
[TC-ICDM-2.3] Secondary functionality with DUT as Server - REMOVED]
* link:#_refrigerator_and_temperature_controlled_cabinet_mode_cluster_test_plan[*Refrigerator
and Temperature Controlled Cabinet Mode Cluster Test Plan*]
** link:#_refrigerator_and_temperature_controlled_cabinet_mode_cluster_testing_overview[214.
Refrigerator and Temperature Controlled Cabinet Mode Cluster Testing
Overview]
** link:#_pics_definition_63[215. PICS Definition]
*** link:#_role_65[215.1. Role]
*** link:#_server_80[215.2. Server]
**** link:#_features_48[215.2.1. Features]
**** link:#_attributes_70[215.2.2. Attributes]
**** link:#_commands_received_37[215.2.3. Commands received]
**** link:#_commands_generated_33[215.2.4. Commands generated]
**** link:#_manual_controllable_24[215.2.5. Manual controllable]
** link:#_pixit_definition_15[216. PIXIT Definition]
** link:#_test_case_list_65[217. Test Case List]
** link:#_test_cases_65[218. Test Cases]
*** link:#_attribute_test_cases_4[218.1. Attribute test cases]
**** link:#_tc_tccm_1_1_global_attributes_with_dut_as_server[218.1.1.
[TC-TCCM-1.1] Global attributes with DUT as Server]
**** link:#_tc_tccm_1_2_cluster_attributes_with_dut_as_server[218.1.2.
[TC-TCCM-1.2] Cluster attributes with DUT as Server]
*** link:#_changetomode_test_cases_6[218.2. ChangeToMode Test Cases]
**** link:#_tc_tccm_2_1_change_to_mode_functionality_with_dut_as_server[218.2.1.
[TC-TCCM-2.1] Change to Mode functionality with DUT as Server]
*** link:#_onoff_and_startup_mode_test_cases_6[218.3. On/Off and StartUp
Mode Test Cases]
**** link:#_tc_tccm_3_1_on_mode_functionality_with_dut_as_server[218.3.1.
[TC-TCCM-3.1] On Mode functionality with DUT as Server]
**** link:#_tc_tccm_3_2_startup_mode_functionality_with_dut_as_server[218.3.2.
[TC-TCCM-3.2] Startup Mode functionality with DUT as Server]
**** link:#_tc_tccm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[218.3.3.
[TC-TCCM-3.3] On Mode and Startup Mode functionality with DUT as Server]
* link:#_refrigerator_alarm_cluster_test_plan[*Refrigerator Alarm
Cluster Test Plan*]
** link:#_pics_definition_64[219. PICS Definition]
*** link:#_role_66[219.1. Role]
*** link:#_server_81[219.2. Server]
**** link:#_attributes_71[219.2.1. Attributes]
**** link:#_events_14[219.2.2. Events]
**** link:#_commands_received_38[219.2.3. Commands received]
** link:#_pixit_definition_16[220. PIXIT Definition]
** link:#_test_case_list_66[221. Test Case List]
** link:#_test_cases_66[222. Test Cases]
*** link:#_generic_test_cases_57[222.1. Generic test cases]
**** link:#_tc_refalm_1_1_global_attributes_with_dut_as_server[222.1.1.
[TC-REFALM-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_30[222.2. Server as DUT]
**** link:#_tc_refalm_2_1_attributes_with_dut_as_server[222.2.1.
[TC-REFALM-2.1] Attributes with DUT as Server]
**** link:#_tc_refalm_2_2_primary_functionality_with_dut_as_server[222.2.2.
[TC-REFALM-2.2] Primary functionality with DUT as Server]
**** link:#_tc_refalm_2_3_local_suppression_of_the_door_alarm_with_dut_as_server[222.2.3.
[TC-REFALM-2.3] Local suppression of the door alarm with DUT as Server]
* link:#_rvc_operational_state_cluster_test_plan[*RVC Operational State
Cluster Test Plan*]
** link:#_pics_definition_65[223. PICS Definition]
*** link:#_role_67[223.1. Role]
*** link:#_server_82[223.2. Server]
**** link:#_attributes_72[223.2.1. Attributes]
**** link:#_commands_received_39[223.2.2. Commands received]
**** link:#_commands_generated_34[223.2.3. Commands generated]
**** link:#_events_15[223.2.4. Events]
**** link:#_manual_controllable_25[223.2.5. Manual controllable]
** link:#_test_case_list_67[224. Test Case List]
** link:#_test_cases_67[225. Test Cases]
*** link:#_generic_test_cases_58[225.1. Generic test cases]
**** link:#_tc_rvcopstate_1_1_global_attributes_dut_as_server[225.1.1.
[TC-RVCOPSTATE-1.1] Global attributes [DUT as Server]]
*** link:#_server_as_dut_31[225.2. Server as DUT]
**** link:#_tc_rvcopstate_2_1_attribute_verification_dut_as_server[225.2.1.
[TC-RVCOPSTATE-2.1] Attribute verification [DUT as Server]]
**** link:#_tc_rvcopstate_2_2_start_and_stop_commands_dut_as_server[225.2.2.
[TC-RVCOPSTATE-2.2] Start and Stop commands [DUT as Server]]
**** link:#_tc_rvcopstate_2_3_pause_and_resume_commands_dut_as_server[225.2.3.
[TC-RVCOPSTATE-2.3] Pause and Resume commands [DUT as Server]]
* link:#_smoke_co_alarm_cluster_test_plan[*Smoke CO Alarm Cluster Test
Plan*]
** link:#_pics_definition_66[226. PICS Definition]
*** link:#_role_68[226.1. Role]
*** link:#_server_83[226.2. Server]
**** link:#_features_49[226.2.1. Features]
**** link:#_attributes_73[226.2.2. Attributes]
**** link:#_events_16[226.2.3. Events]
**** link:#_manual_controllable_26[226.2.4. Manual controllable]
**** link:#_commands_received_40[226.2.5. Commands received]
** link:#_pixit_definition_17[227. PIXIT Definition]
** link:#_test_case_list_68[228. Test Case List]
** link:#_test_cases_68[229. Test Cases]
*** link:#_generic_test_cases_59[229.1. Generic test cases]
**** link:#_tc_smokeco_1_1_global_attributes_with_dut_as_server[229.1.1.
[TC-SMOKECO-1.1] Global attributes with DUT as Server]
*** link:#_server_as_dut_32[229.2. Server as DUT]
**** link:#_tc_smokeco_2_1_attributes_with_dut_as_server[229.2.1.
[TC-SMOKECO-2.1] Attributes with DUT as Server]
**** link:#_tc_smokeco_2_2_primary_functionality_smoke_alarm_with_dut_as_server[229.2.2.
[TC-SMOKECO-2.2] Primary Functionality - Smoke Alarm with DUT as Server]
**** link:#_tc_smokeco_2_3_primary_functionality_co_alarm_with_dut_as_server[229.2.3.
[TC-SMOKECO-2.3] Primary Functionality - CO Alarm with DUT as Server]
**** link:#_tc_smokeco_2_4_secondary_functionality_mandatory_with_dut_as_server[229.2.4.
[TC-SMOKECO-2.4] Secondary Functionality - Mandatory with DUT as Server]
**** link:#_tc_smokeco_2_5_secondary_functionality_optional_with_dut_as_server[229.2.5.
[TC-SMOKECO-2.5] Secondary Functionality - Optional with DUT as Server]
**** link:#_tc_smokeco_2_6_expressedstate_attribute_multiple_alarms_with_dut_as_server[229.2.6.
[TC-SMOKECO-2.6] ExpressedState Attribute - Multiple Alarms with DUT as
Server]

[[content]]
[[_notice_of_use_and_disclosure]]
== link:#_notice_of_use_and_disclosure[]Notice of Use and Disclosure

Copyright © Connectivity Standards Alliance (2021). All rights reserved.
This information within this document is the property of the
Connectivity Standards Alliance and its use and disclosure are
restricted.

Elements of Connectivity Standards Alliance specifications may be
subject to third party intellectual property rights, including without
limitation, patent, copyright or trademark rights (such a third party
may or may not be a member of the Connectivity Standards Alliance). The
Connectivity Standards Alliance is not responsible and shall not be held
responsible in any manner for identifying or failing to identify any or
all such third party intellectual property rights.

This document and the information contained herein are provided on an
"AS IS" basis and the Connectivity Standards Alliance DISCLAIMS ALL
WARRANTIES EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO (A) ANY
WARRANTY THAT THE USE OF THE INFORMATION HEREIN WILL NOT INFRINGE ANY
RIGHTS OF THIRD PARTIES (INCLUDING WITHOUT LIMITATION ANY INTELLECTUAL
PROPERTY RIGHTS INCLUDING PATENT, COPYRIGHT OR TRADEMARK RIGHTS) OR (B)
ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE, TITLE OR NON-INFRINGEMENT. IN NO EVENT WILL THE CONNECTIVITY
STANDARDS ALLIANCE BE LIABLE FOR ANY LOSS OF PROFITS, LOSS OF BUSINESS,
LOSS OF USE OF DATA, INTERRUPTION OF BUSINESS, OR FOR ANY OTHER DIRECT,
INDIRECT, SPECIAL OR EXEMPLARY, INCIDENTAL, PUNITIVE OR CONSEQUENTIAL
DAMAGES OF ANY KIND, IN CONTRACT OR IN TORT, IN CONNECTION WITH THIS
DOCUMENT OR THE INFORMATION CONTAINED HEREIN, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH LOSS OR DAMAGE.

All company, brand and product names may be trademarks that are the sole
property of their respective owners.

This legal notice must be included on all copies of this document that
are made.

Connectivity Standards Alliance +
508 Second Street, Suite 206 +
Davis, CA 95616, USA

[[_participants]]
== link:#_participants[]Participants

[width="100%",cols="25%,25%,25%,25%",]
|===
|Agner, Stefan |Alvarez, José |Ananthakrishnan, Krithika |Andreola,
Cristian

|Babu, Praveen |Balducci, Alex |Bansal, Chirag |Bartolome, Diego

|Bauer-Schwan, Stefan |Beach, Chris |Beck, Austin |Becker, Markus

|Berrios, Victor |Bhat, Vikram |Bodurka, Adam |Bultman, Rob

|C, Rajashree |Cao, Cindy |Carbonara, Amato |Carmel-Veilleux, Tennessee

|Caronello, Paolo |Chalmers, Andrew |Chen, Zedd |Chudinov, Anton

|Claes, Jan |Cullen, Sam |Dakalia, Abhinav |Decenzo, Chris

|Deshpande, Prachi |Ding, Li-An |Drake, Jeff |Dunham, Michael

|Freeman, Cecille |Fu, Kenneth |Futane, Virupaksha |Fyall, Ian

|Galgalikar, Sailee |Garg, Pankaj |Garikipati, Shyam |Gaul, Dan

|Gonyea, Liam |Guo, Jiacheng |Guo, Song |H. G., Pramod

|Harvey, Gene |Heide, Janus |Heo, Joonhaeng |Hernandez Palomares, Martin

|Honnakasturi, Priyanka |Hou, Winnie |Houtepen, Rob |Hsiao, Alvin

|Hsu, Sid |Hu, Yinyi |Hussien, Emad |Jandhyala, Chaitanya

|Johns, Jerry |Josefsen, René |Kamp, Twan |Kardous, Mathieu

|Katira, Utsav |Kaur, Navjot |Khayat, Joseph |Kim, Jeonghwan

|Kleszcz, Marcin |Kneip, Daniel |Knörzer, Clemens |Kommareddi, Naveen

|Kohr, John |Kong, Lingshan |Kontra, Andrew |Kovacic, Lazar

|Królik, Damian |KY, Suma |Langewouters, Thomas |Lauric, Petru

|Lazar, Alin |Lepage, Marc |Li, James |Li, Zeng

|Liang, Gerrard |Lim, Kean |Lissianoi, Sergei |Lv, Zhinan

|Lyall, Jim |Ma, Qiang |Maes, Timothy |Makdissi, Shadi

|Mamo, Fesseha |Matignon, Florent |McAtee, Maxwell |McClain, Sean

|Mégevand, Jonathan |Mehta, Manav |Mohan, Kvs |Møller, Mikael

|Moreno, Alvaro |N.K., Sethu |Nadathur, Anush |Nandyala, Ramakrishna

|Øbakke, Erik Eskjær |Ocasio, Eric |P, Ashwini |P, Aswathy

|Palagummi, Raju |Pan, Shaofeng |Parausanu, Dragos |Paugam, Luc

|Penven, Jean-Francois |Pérez, Agustin |Petersen, Brian |Powell, Ken

|Qixiang, Wang |R A, Manjunath |Rahman, Mostafizur |Rhees, Jon

|Rozendaal, Leo |Rupp, Michael |S, Kowsalyadevi |S, Sowmya

|Salaun, Jean-Yves |Samad, Abdul |Schulze Struchtrup, Sebastian
|Seenivasan, Suraj

|Selvam, Sankar |Sena, Joe |She, Chengqiang |Shi, Lucy

|Shin, Sungmok |Sivaram |Somasundaram |Son, Jae

|Szablowski, Michał |Szewczyk, Robert |Tache, Marius |Takebe, Yasuyuki

|Thangaraj, Karthik |Trayer, Mark |Turon, Martin |Vasiliev, Sergey

|Villasenor, Joshua |Wan, Lank |Wang, David |Wang, Haoran

|Wang, Yunhan |Westadt, Caleb |Yang, Carol |Zbarsky, Boris

|Zhang, Aimee |Zhang, Xili |Zhaoxuan, Zhai |Zhong, Zain
|===

[[_document_control]]
== link:#_document_control[]Document Control

The Matter Test Plan is made of different chapters from the
Specification.

*Main Test Plans*

[width="100%",cols="50%,50%",]
|===
|Device Discovery |link:./devicediscovery.adoc[Document #]

|Secure Channel |link:./securechannel.adoc[Document #]

|Device Attestation |link:./deviceattestation.adoc[Document #]

|Basic Information |link:./cluster/basic_information.adoc[Document #]

|Node Operational Credentials
|link:./cluster/node_operational_credentials.adoc[Document #]

|Network Commissioning
|link:./cluster/network_commissioning.adoc[Document #]

|Interaction Data Model |link:./interactiondatamodel.adoc[Document #]

|Multiple Fabrics |link:./multiplefabrics.adoc[Document #]

|Bridge |link:./bridge.adoc[Document #]

|OTA Software Update |link:./softwareupdate.adoc[Document #]

|Bulk Data Exchange Protocol |link:./bdx.adoc[Document #]

|Minimal Resource Requirements
|link:./minimal_resource_reqs.adoc[Document #]

|Access Control Enforcement
|link:./AccessControlEnforcement.adoc[Document #]
|===

*Cluster Test Plans*

[width="100%",cols="50%,50%",]
|===
|OnOff Cluster |link:./cluster/onoff.adoc[Document #]

|Relative Humidity Measurement Cluster
|link:./cluster/relativehumiditymeasurement.adoc[Document #]

|Temperature Measurement Cluster
|link:./cluster/temperaturemeasurement.adoc[Document #]

|Pump Configuration and Control Cluster
|link:./cluster/pump_configuration_and_control.adoc[Document #]

|Media Cluster Library |link:./cluster/media.adoc[Document #]

|Level Control Cluster |link:./cluster/levelcontrol.adoc[Document #]

|Color Control Cluster |link:./cluster/colorcontrol.adoc[Document #]

|Occupancy Sensing Cluster
|link:./cluster/occupancysensing.adoc[Document #]

|Window Covering Cluster |link:./cluster/window_covering.adoc[Document
#]

|On/Off Switch Configuration Cluster
|link:./cluster/onoffswitchconfiguration.adoc[Document #]

|Software Diagnostics Cluster
|link:./cluster/software_diagnostics.adoc[Document #]

|Ethernet Network Diagnostics Cluster
|link:./cluster/ethernet_diagnostics.adoc[Document #]

|Switch Cluster |link:./cluster/switch.adoc[Document #]

|Actions Cluster |link:./cluster/actions.adoc[Document #]

|Scenes Cluster |link:./cluster/scenes.adoc[Document #]

|Bridged Device Basic Information
|link:./cluster/bridged_device_basic_information.adoc[Document #]

|Temperature Control Cluster
|link:./cluster/TemperatureControl.adoc[Document #]

|Carbon Monoxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/carbon_monoxide_concentration_measurement_cluster.adoc[Document
#]

|Carbon Dioxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/carbon_dioxide_concentration_measurement_cluster.adoc[Document
#]

|Ethylene Concentration Measurement Cluster
|link:./cluster/concentration-measurement/ethylene_concentration_measurement_cluster.adoc[Document
#]

|Ethylene Oxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/ethylene_oxide_concentration_measurement_cluster.adoc[Document
#]

|Hydrogen Concentration Measurement Cluster
|link:./cluster/concentration-measurement/hydrogen_concentration_measurement_cluster.adoc[Document
#]

|Hydrogen Sulfide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/hydrogen_sulfide_concentration_measurement_cluster.adoc[Document
#]

|Nitric Oxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/nitric_oxide_concentration_measurement_cluster.adoc[Document
#]

|Nitrogen Dioxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/nitrogen_dioxide_concentration_measurement_cluster.adoc[Document
#]

|Oxygen Concentration Measurement Cluster
|link:./cluster/concentration-measurement/oxygen_concentration_measurement_cluster.adoc[Document
#]

|Ozone Concentration Measurement Cluster
|link:./cluster/concentration-measurement/ozone_concentration_measurement_cluster.adoc[Document
#]

|Sulfur Dioxide Concentration Measurement Cluster
|link:./cluster/concentration-measurement/sulfur_dioxide_concentration_measurement_cluster.adoc[Document
#]

|Dissolved Oxygen Concentration Measurement Cluster
|link:./cluster/concentration-measurement/dissolved_oxygen_concentration_measurement_cluster.adoc[Document
#]

|Bromate Concentration Measurement Cluster
|link:./cluster/concentration-measurement/bromate_concentration_measurement_cluster.adoc[Document
#]

|Chloramines Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chloramines_concentration_measurement_cluster.adoc[Document
#]

|Chlorine Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chlorine_concentration_measurement_cluster.adoc[Document
#]

|Fecal coliform & E. Coli Concentration Measurement Cluster
|link:./cluster/concentration-measurement/fecal_coliform_&_e__coli_concentration_measurement_cluster.adoc[Document
#]

|Fluoride Concentration Measurement Cluster
|link:./cluster/concentration-measurement/fluoride_concentration_measurement_cluster.adoc[Document
#]

|Haloacetic Acids Concentration Measurement Cluster
|link:./cluster/concentration-measurement/haloacetic_acids_concentration_measurement_cluster.adoc[Document
#]

|Total Trihalomethanes Concentration Measurement Cluster
|link:./cluster/concentration-measurement/total_trihalomethanes_concentration_measurement_cluster.adoc[Document
#]

|Total Coliform Bacteria Concentration Measurement Cluster
|link:./cluster/concentration-measurement/total_coliform_bacteria_concentration_measurement_cluster.adoc[Document
#]

|Turbidity Concentration Measurement Cluster
|link:./cluster/concentration-measurement/turbidity_concentration_measurement_cluster.adoc[Document
#]

|Copper Concentration Measurement Cluster
|link:./cluster/concentration-measurement/copper_concentration_measurement_cluster.adoc[Document
#]

|Lead Concentration Measurement Cluster
|link:./cluster/concentration-measurement/lead_concentration_measurement_cluster.adoc[Document
#]

|Manganese Concentration Measurement Cluster
|link:./cluster/concentration-measurement/manganese_concentration_measurement_cluster.adoc[Document
#]

|Sulfate Concentration Measurement Cluster
|link:./cluster/concentration-measurement/sulfate_concentration_measurement_cluster.adoc[Document
#]

|Bromodichloromethane Concentration Measurement Cluster
|link:./cluster/concentration-measurement/bromodichloromethane_concentration_measurement_cluster.adoc[Document
#]

|Bromoform Concentration Measurement Cluster
|link:./cluster/concentration-measurement/bromoform_concentration_measurement_cluster.adoc[Document
#]

|Chlorodibromomethane Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chlorodibromomethane_concentration_measurement_cluster.adoc[Document
#]

|Chloroform Concentration Measurement Cluster
|link:./cluster/concentration-measurement/chloroform_concentration_measurement_cluster.adoc[Document
#]

|Sodium Concentration Measurement Cluster
|link:./cluster/concentration-measurement/sodium_concentration_measurement_cluster.adoc[Document
#]

|PM2.5 Concentration Measurement Cluster
|link:./cluster/concentration-measurement/pm2_5_concentration_measurement_cluster.adoc[Document
#]

|Formaldehyde Concentration Measurement Cluster
|link:./cluster/concentration-measurement/formaldehyde_concentration_measurement_cluster.adoc[Document
#]

|PM1 Concentration Measurement Cluster
|link:./cluster/concentration-measurement/pm1_concentration_measurement_cluster.adoc[Document
#]

|PM10 Concentration Measurement Cluster
|link:./cluster/concentration-measurement/pm10_concentration_measurement_cluster.adoc[Document
#]

|Total Volatile Organic Compounds Concentration Measurement Cluster
|link:./cluster/concentration-measurement/total_volatile_organic_compounds_concentration_measurement_cluster.adoc[Document
#]

|Radon Concentration Measurement Cluster
|link:./cluster/concentration-measurement/radon_concentration_measurement_cluster.adoc[Document
#]

|Laundry Washer Mode |link:./cluster/mode_laundry_washer.adoc[Document
#]

|Laundry Washer Controls Cluster
|link:./cluster/LaundryWasherControls.adoc[Document #]

|Fan Control Cluster |link:./cluster/FanControl.adoc[Document #]

|Time Synchronization |link:./cluster/time_synchronization.adoc[Document
#]

|Dishwasher Mode Cluster |link:./cluster/mode_dishwasher.adoc[Document
#]

|Dishwasher Alarm Cluster |link:./cluster/dishwasher_alarm.adoc[Document
#]

|Operational State Cluster
|link:./cluster/operationalstate.adoc[Document #]

|Air Quality Cluster |link:./cluster/air_quality.adoc[Document #]

|HEPA Filter Monitoring Cluster
|link:./cluster/resource-monitoring/hepa_filter_monitoring.adoc[Document
#]

|Activated Carbon Filter Monitoring Cluster
|link:./cluster/resource-monitoring/activated_carbon_filter_monitoring.adoc[Document
#]

|Ceramic Filter Monitoring Cluster
|link:./cluster/resource-monitoring/ceramic_filter_monitoring.adoc[Document
#]

|Electrostatic Filter Monitoring Cluster
|link:./cluster/resource-monitoring/electrostatic_filter_monitoring.adoc[Document
#]

|UV Filter Monitoring Cluster
|link:./cluster/resource-monitoring/uv_filter_monitoring.adoc[Document
#]

|Ionizing Filter Monitoring Cluster
|link:./cluster/resource-monitoring/ionizing_filter_monitoring.adoc[Document
#]

|Zeolite Filter Monitoring Cluster
|link:./cluster/resource-monitoring/zeolite_filter_monitoring.adoc[Document
#]

|Ozone Filter Monitoring Cluster
|link:./cluster/resource-monitoring/ozone_filter_monitoring.adoc[Document
#]

|Water Tank Monitoring Cluster
|link:./cluster/resource-monitoring/water_tank_monitoring.adoc[Document
#]

|Fuel Tank Monitoring Cluster
|link:./cluster/resource-monitoring/fuel_tank_monitoring.adoc[Document
#]

|Ink Cartridge Monitoring Cluster
|link:./cluster/resource-monitoring/ink_cartridge_monitoring.adoc[Document
#]

|Toner Cartridge Monitoring Cluster
|link:./cluster/resource-monitoring/toner_cartridge_monitoring.adoc[Document
#]

|Mode Select Cluster |link:./cluster/modeselect.adoc[Document #]

|RVC Run Mode Cluster |link:./cluster/mode_rvc_run.adoc[Document #]

|RVC Clean Mode Cluster |link:./cluster/mode_rvc_clean.adoc[Document #]

|ICD Management |link:./cluster/icdmanagement.adoc[Document #]

|Refrigerator Mode Cluster |link:./cluster/mode_ref_tcc.adoc[Document #]

|Refrigerator Alarm Cluster
|link:./cluster/refrigerator_alarm.adoc[Document #]

|RVC Operational State Cluster
|link:./cluster/rvcoperationalstate.adoc[Document #]

|Smoke and CO Alarm Cluster |link:./cluster/smco.adoc[Document #]
|===

[[_document_history]]
== link:#_document_history[]Document History

[width="100%",cols="15%,15%,70%",options="header",]
|===
|Version |Date |Description
|r01 |June 7, 2021 |Initial draft
|===

[[_csa_reference_documents]]
=== link:#_csa_reference_documents[]CSA Reference Documents

[width="100%",cols="15%,30%,55%",options="header",]
|===
|Reference |Reference Location/URL |Description
|[#ref_CSAManufacturerCodes]## [CSA-05-03874]
|https://groups.csa-iot.org/wg/members-all/document/10905 |CSA
Manufacturer Code Database
|===

[[_external_reference_documents]]
=== link:#_external_reference_documents[]External Reference Documents

[width="100%",cols="15%,30%,55%",options="header",]
|===
|Reference |Reference Location/URL |Description
|[#RFC3986]##[RFC 3986] |https://www.rfc-editor.org/rfc/rfc3986 |Uniform
Resource Identifier (URI)
|===

[[_onoff_cluster_test_plan]]
== link:#_onoff_cluster_test_plan[]**On/Off Cluster Test Plan**

[[_pics_definition]]
=== link:#_pics_definition[]1. PICS Definition

This section covers the On/Off Cluster Test Plan related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role]]
==== link:#_role[]1.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.S |Does the device implement the on/off cluster as a server? |O |

|OO.C |Does the device implement the on/off cluster as a client? |O |
|===

[[_server]]
==== link:#_server[]1.2. Server

[[_features]]
===== link:#_features[]1.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.S.F00(LT) |Lighting |O |

|OO.S.F01(DF) |DeadFrontBehaviour |O |
|===

[[_attributes]]
===== link:#_attributes[]1.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.S.A0000(OnOff) |Does the device implement the OnOff attribute? |M |

|OO.S.A4000(GlobalSceneControl) |Does the device implement the
OO.S.A4000(GlobalSceneControl) attribute? |LT |

|OO.S.A4001(OnTime) |Does the device implement the OnTime attribute? |LT
|

|OO.S.A4002(OffWaitTime) |Does the device implement the OffWaitTime
attribute? |LT |

|OO.S.A4003(StartUpOnOff) |Does the device implement the StartUpOnOff
attribute? |LT |
|===

[[_manual_controllable]]
===== link:#_manual_controllable[]1.2.3. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.M.ManuallyControlled |Can the OnOff attribute changed by physical
control at the device? |O |
|===

[[_commands_received]]
===== link:#_commands_received[]1.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.S.C00.Rsp(Off) |Does the device implement receiving the Off command?
|M |

|OO.S.C01.Rsp(On) |Does the device implement receiving the On command?
|M |

|OO.S.C02.Rsp(Toggle) |Does the device implement receiving the Toggle
command? |M |

|OO.S.C40.Rsp(OffWithEffect) |Does the device implement receiving the
OffWithEffect command? |LT |

|OO.S.C41.Rsp(OnWithRecallGlobalScene) |Does the device implement
receiving the OnWithRecallGlobalScene command? |LT |

|OO.S.C42.Rsp(OnWithTimedOff) |Does the device implement receiving the
OnWithTimedOff command? |LT |
|===

[[_client]]
==== link:#_client[]1.3. Client

[[_commands_generated]]
===== link:#_commands_generated[]1.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.C.C00.Tx(Off) |Does the device implement sending the Off command? |O
|

|OO.C.C01.Tx(On) |Does the device implement sending the On command? |O |

|OO.C.C02.Tx(Toggle) |Does the device implement sending the Toggle
command? |O |

|OO.C.C40.Tx(OffWithEffect) |Does the device implement sending the
OffWithEffect command? |O |

|OO.C.C41.Tx(OnWithRecallGlobalScene) |Does the device implement sending
the OnWithRecallGlobalScene command? |O |

|OO.C.C42.Tx(OnWithTimedOff) |Does the device implement sending the
OnWithTimedOff command? |O |
|===

[[_pixit_definition]]
=== link:#_pixit_definition[]2. PIXIT Definition

This section covers the On/Off Cluster’s Test Plan related PIXIT items
that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.OO.MaxCommunicationTurnaround |This is the maximum time it takes
to communicate from the TH to the DUT and back to the TH. |OO.S |For
sleepy devices the time has to be at least the sleep interval of the
DUT.
|===

[[_test_case_list]]
=== link:#_test_case_list[]3. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-OO-1.1 |Global Attributes with DUT as Server
|TC-OO-2.1 |Attributes with server as DUT
|TC-OO-2.2 |Primary functionality with server as DUT
|TC-OO-2.3 |Secondary functionality with server as DUT
|TC-OO-2.4 |Startup functionality with server as DUT
|TC-OO-3.2 |Functionality with client as DUT
|===

[[_notestesting_considerations]]
==== link:#_notestesting_considerations[]3.1. Notes/Testing Considerations

* In test cases where a change in an attribute value is tested over
time, it is permitted for the devices involved in the test to be within
a tolerance of ±15% of the expected time or value, on top of
PIXIT.OO.MaxCommunicationTurnaround.

[[_test_cases]]
=== link:#_test_cases[]4. Test Cases

'''''

[[_generic_test_cases]]
==== link:#_generic_test_cases[]4.1. Generic test cases

'''''

[[_tc_oo_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_oo_1_1_global_attributes_with_dut_as_server[]4.1.1. [TC-OO-1.1] Global Attributes with DUT as Server

[[_category]]
====== link:#_category[]Category

Functional conformance.

[[_purpose]]
====== link:#_purpose[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics]]
====== link:#_pics[]PICS

* OO.S

[[_required_devices]]
====== link:#_required_devices[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure]]
====== link:#_test_procedure[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 5.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if OO.S.F00(LT)

- bit 1: SHALL be 1 if and only if OO.S.F01(DF)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list include entries based on feature support: +
- 0x4000 SHALL be included if and only if OO.S.F00(LT)

- 0x4001 SHALL be included if and only if OO.S.F00(LT)

- 0x4002 SHALL be included if and only if OO.S.F00(LT)

- 0x4003 SHALL be included if and only if OO.S.F00(LT)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00, 0x01 & 0x02.

The list include entries based on feature support: +
- 0x40: SHALL be included if and only if OO.S.F00(LT)

- 0x41: SHALL be included if and only if OO.S.F00(LT)

- 0x42: SHALL be included if and only if OO.S.F00(LT)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_2]]
====== link:#_notestesting_considerations_2[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut]]
==== link:#_server_as_dut[]4.2. Server as DUT

[[_tc_oo_2_1_attributes_with_server_as_dut]]
===== link:#_tc_oo_2_1_attributes_with_server_as_dut[]4.2.1. [TC-OO-2.1] Attributes with server as DUT

[[_category_2]]
====== link:#_category_2[]Category

Functional conformance

[[_purpose_2]]
====== link:#_purpose_2[]Purpose

This test case verifies that the DUT can respond to on/off cluster
attribute read commands.

[[_pics_2]]
====== link:#_pics_2[]PICS

* OO.S

[[_required_devices_2]]
====== link:#_required_devices_2[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology]]
====== link:#_device_topology[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup]]
====== link:#_test_setup[]Test Setup

Commission DUT to TH

[[_test_procedure_2]]
====== link:#_test_procedure_2[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|Verify that the DUT responds with a bool value.

|3 | |OO.S.A4000(GlobalSceneControl) |TH reads the _GlobalSceneControl
attribute_ from the DUT |Verify that the DUT responds with a bool value.

|4 | |OO.S.A4001(OnTime) |TH reads the _OnTime attribute_ from the DUT
|Verify that the DUT responds with a uint16 value.

|5 | |OO.S.A4002(OffWaitTime) |TH reads the _OffWaitTime attribute_ from
the DUT |Verify that the DUT responds with a uint16 value.

|6 | |OO.S.A4003(StartUpOnOff) |TH reads the _StartUpOnOff attribute_
from the DUT |Verify that the DUT responds with an enum8 value or NULL.
|===

[[_notestesting_considerations_3]]
====== link:#_notestesting_considerations_3[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_oo_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_oo_2_2_primary_functionality_with_server_as_dut[]4.2.2. [TC-OO-2.2] Primary functionality with server as DUT

[[_category_3]]
====== link:#_category_3[]Category

Functional

[[_purpose_3]]
====== link:#_purpose_3[]Purpose

This test case verifies the primary functionality of the on/off cluster
server.

[[_pics_3]]
====== link:#_pics_3[]PICS

* OO.S

[[_required_devices_3]]
====== link:#_required_devices_3[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_2]]
====== link:#_device_topology_2[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_2]]
====== link:#_test_setup_2[]Test Setup

Commission DUT to TH

[[_test_procedure_3]]
====== link:#_test_procedure_3[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2a | |OO.S.C00.Rsp(Off) |TH sends _Off command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|2b | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value has to be FALSE

|3a | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|3b | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value has to be TRUE

|3c | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|3d | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value remains TRUE

|4a | |OO.S.C00.Rsp(Off) |TH sends _Off command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|4b | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value has to be FALSE

|4c | |OO.S.C00.Rsp(Off) |TH sends _Off command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|4d | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value remains FALSE

|5a | |OO.S.C02.Rsp(Toggle) |TH sends _Toggle command_ to DUT |Verify
DUT responds w/ status SUCCESS(0x00)

|5b | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value has to be TRUE

|5c | |OO.S.C02.Rsp(Toggle) |TH sends _Toggle command_ to DUT |Verify
DUT responds w/ status SUCCESS(0x00)

|5d | |OO.S.A0000(OnOff) |after a few seconds, TH reads _OnOff
attribute_ from DUT |Value has to be FALSE

|6a | |OO.M.ManuallyControlled |Operate on device to set _OnOff
attribute_ manually to on |

|6b | |OO.M.ManuallyControlled, OO.S.A0000(OnOff) |after a few seconds,
TH reads _OnOff attribute_ from DUT |Value has to be TRUE

|6c | |OO.M.ManuallyControlled |Operate on device to set _OnOff
attribute_ manually to off |

|6d | |OO.M.ManuallyControlled, OO.S.A0000(OnOff) |after a few seconds,
TH reads _OnOff attribute_ from DUT |Value has to be FALSE
|===

[[_notestesting_considerations_4]]
====== link:#_notestesting_considerations_4[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_oo_2_3_secondary_functionality_with_server_as_dut]]
===== link:#_tc_oo_2_3_secondary_functionality_with_server_as_dut[]4.2.3. [TC-OO-2.3] Secondary functionality with server as DUT

[[_category_4]]
====== link:#_category_4[]Category

Functional

[[_purpose_4]]
====== link:#_purpose_4[]Purpose

This test case verifies the secondary functionality of the on/off
cluster server. This test case is only required if the Level Control for
Lighting feature is supported (OO.S.F00(LT)).

[[_pics_4]]
====== link:#_pics_4[]PICS

* OO.S
* OO.S.F00(LT)

[[_required_devices_4]]
====== link:#_required_devices_4[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_3]]
====== link:#_device_topology_3[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_3]]
====== link:#_test_setup_3[]Test Setup

Commission DUT to TH

[[_test_procedure_4]]
====== link:#_test_procedure_4[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2a | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|2b | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be TRUE. The value of
GlobalSceneControl has to be TRUE.

|3a | |OO.S.C40.Rsp(OffWithEffect) |TH sends _OffWithEffect command_ to
DUT with EffectIdentifier and EffectVariant both set to 0x00 |Verify DUT
responds w/ status SUCCESS(0x00)

|3b | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be FALSE. The value of
GlobalSceneControl has to be FALSE.

|4a | |OO.S.C41.Rsp(OnWithRecallGlobalScene) |TH sends
_OnWithRecallGlobalScene command_ to DUT |Verify DUT responds w/ status
SUCCESS(0x00)

|4b | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be TRUE. The value of
GlobalSceneControl has to be TRUE.

|5a | |OO.S.C40.Rsp(OffWithEffect) |TH sends _OffWithEffect command_ to
DUT with EffectIdentifier and EffectVariant both set to 0x00 |Verify DUT
responds w/ status SUCCESS(0x00)

|5b | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be FALSE. The value of
GlobalSceneControl has to be FALSE.

|5c | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|5d | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be TRUE. The value of
GlobalSceneControl has to be TRUE.

|6a | |OO.S.C40.Rsp(OffWithEffect) |TH sends _OffWithEffect command_ to
DUT with EffectIdentifier set to 0x01 (dying light) and EffectVariant
set to 0x00 |Verify DUT responds w/ status SUCCESS(0x00)

|6b | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be FALSE. The value of
GlobalSceneControl has to be FALSE.

|7a | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|7b | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be TRUE. The value of
GlobalSceneControl has to be TRUE.

|7c | |OO.S.C41.Rsp(OnWithRecallGlobalScene) |TH sends
_OnWithRecallGlobalScene command_ to DUT |Verify DUT responds w/ status
SUCCESS(0x00)

|7d | |OO.S.A0000(OnOff) OO.S.A4000(GlobalSceneControl) |after a few
seconds, TH reads _OnOff attribute_ and _GlobalSceneControl attribute_
from DUT |The value of OnOff has to be TRUE. The value of
GlobalSceneControl has to be TRUE.

|8 | |OO.S.A4001(OnTime) OO.S.A4002(OffWaitTime) |TH reads _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnTime has
to be 0x0000. The value of OffWaitTime has to be 0x0000.

|9a | |OO.S.C42.Rsp(OnWithTimedOff) |TH sends _OnWithTimedOff command_
to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|9b | |OO.S.A0000(OnOff) OO.S.A4001(OnTime) OO.S.A4002(OffWaitTime)
|Immediately TH reads _OnOff attribute_ , _OnTime attribute_ and
_OffWaitTime attribute_ from DUT |The value of OnOff has to be TRUE. +
The value of OnTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround. +
The value of OffWaitTime has to be 0x012c.

|10a | |OO.S.C42.Rsp(OnWithTimedOff) |TH sends _OnWithTimedOff command_
to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|10b | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|10c | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|10d | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|10e | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be TRUE. +
The value of OnTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround. +
The value of OffWaitTime has to be 0x012c.

|11a | |OO.S.C40.Rsp(OffWithEffect) |After 10s, TH sends _OffWithEffect
command_ to DUT with EffectIdentifier and EffectVariant both set to 0x00
|Verify DUT responds w/ status SUCCESS(0x00)

|11b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround.

|12a | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|12b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be approximately equal to 0x00c8. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround.

|13a | |OO.S.C01.Rsp(On) |After 10s, TH sends _On command_ to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|13b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be TRUE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be equal to 0x0000.

|14a | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|14b | |OO.S.C00.Rsp(Off) |After 10s, TH sends _Off command_ to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|14c | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround.

|15 | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |After 30s, TH reads _OnOff attribute_ , _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnOff has
to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be equal to 0x0000.

|16a | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|16b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be equal to 0x0000.

|17a | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|17b | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x01 (AcceptOnlyWhenOn 1) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|17c | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be TRUE. +
The value of OnTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround. +
The value of OffWaitTime has to be 0x012c.

|17d | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |After 40s, TH reads _OnOff attribute_ , _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnOff has
to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be equal to 0x0000.

|18a | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x00 (AcceptOnlyWhenOn 0) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|18b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be 0x01. +
The value of OnTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround. +
The value of OffWaitTime has to be 0x012c.

|19a | |OO.S.C42.Rsp(OnWithTimedOff) |TH sends _OnWithTimedOff command_
to DUT with +
OnOffControl: 0x00 (AcceptOnlyWhenOn 0) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|19b | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x00 (AcceptOnlyWhenOn 0) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|19c | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |After 10s, TH reads _OnOff attribute_ , _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnOff has
to be TRUE. +
The value of OnTime has to be approximately equal to 0x00c8. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround. +
The value of OffWaitTime has to be 0x012c.

|20a | |OO.S.C00.Rsp(Off) |TH sends _Off command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|20b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround.

|21a | |OO.S.C42.Rsp(OnWithTimedOff) |TH sends _OnWithTimedOff command_
to DUT with +
OnOffControl: 0x00 (AcceptOnlyWhenOn 0) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|21b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |After 10s, TH reads _OnOff attribute_ , _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnOff has
to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be approximately equal to 0x00c8. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround.

|22a | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|22b | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be TRUE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be 0x0000.

|23a | |OO.S.C42.Rsp(OnWithTimedOff) |After 10s, TH sends
_OnWithTimedOff command_ to DUT with +
OnOffControl: 0x00 (AcceptOnlyWhenOn 0) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|23b | |OO.S.C00.Rsp(Off) |TH sends _Off command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|23c | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |Immediately TH reads _OnOff attribute_ ,
_OnTime attribute_ and _OffWaitTime attribute_ from DUT |The value of
OnOff has to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround.

|23d | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |After 40s, TH reads _OnOff attribute_ , _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnOff has
to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be equal to 0x0000.

|24a | |OO.S.C42.Rsp(OnWithTimedOff) |TH sends _OnWithTimedOff command_
to DUT with +
OnOffControl: 0x00 (AcceptOnlyWhenOn 0) +
OnTime: 0x012c (30s) +
OffTime: 0x012c (30s) |Verify DUT responds w/ status SUCCESS(0x00)

|24b | |OO.S.A0000(OnOff) OO.S.A4001(OnTime) OO.S.A4002(OffWaitTime)
|Immediately TH reads _OnOff attribute_ , _OnTime attribute_ and
_OffWaitTime attribute_ from DUT |The value of OnOff has to be TRUE. +
The value of OnTime has to be approximately equal to 0x012c. The
tolerance is PIXIT.OO.MaxCommunicationTurnaround. +
The value of OffWaitTime has to be 0x012c.

|24c | |OO.S.A0000(OnOff) +
OO.S.A4001(OnTime) +
OO.S.A4002(OffWaitTime) |After 40s, TH reads _OnOff attribute_ , _OnTime
attribute_ and _OffWaitTime attribute_ from DUT |The value of OnOff has
to be FALSE. +
The value of OnTime has to be 0x0000. +
The value of OffWaitTime has to be equal to 0x0000.
|===

[[_notestesting_considerations_5]]
====== link:#_notestesting_considerations_5[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_oo_2_4_startup_functionality_with_server_as_dut]]
===== link:#_tc_oo_2_4_startup_functionality_with_server_as_dut[]4.2.4. [TC-OO-2.4] Startup functionality with server as DUT

[[_category_5]]
====== link:#_category_5[]Category

Functional

[[_purpose_5]]
====== link:#_purpose_5[]Purpose

This test case verifies the startup functionality of the on/off cluster
server. This test case is only required if the Level Control for
Lighting feature is supported (OO.S.F00(LT)).

[[_pics_5]]
====== link:#_pics_5[]PICS

* OO.S
* OO.S.F00(LT)

[[_required_devices_5]]
====== link:#_required_devices_5[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_4]]
====== link:#_device_topology_4[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_4]]
====== link:#_test_setup_4[]Test Setup

Commission DUT to TH

[[_test_procedure_5]]
====== link:#_test_procedure_5[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|3a | |OO.S.A4003(StartUpOnOff) |TH writes a value of 0 to _StartUpOnOff
attribute_ of DUT |Verify DUT responds w/ status SUCCESS(0x00)

|3b | | |Power off DUT |

|3c | | |Power on DUT |

|3d | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be FALSE.

|4a | |OO.S.A4003(StartUpOnOff) |TH writes a value of 1 to _StartUpOnOff
attribute_ of DUT |Verify DUT responds w/ status SUCCESS(0x00)

|4b | | |Power off DUT |

|4c | | |Power on DUT |

|4d | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be TRUE.

|5a | |OO.S.A4003(StartUpOnOff) |TH writes a value of 2 to _StartUpOnOff
attribute_ of DUT |Verify DUT responds w/ status SUCCESS(0x00)

|5b | | |Power off DUT |

|5c | | |Power on DUT |

|5d | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be FALSE.

|5e | | |Power off DUT |

|5f | | |Power on DUT |

|5g | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be TRUE.

|6a | |OO.S.A4003(StartUpOnOff) |TH writes NULL to _StartUpOnOff
attribute_ of DUT |Verify DUT responds w/ status SUCCESS(0x00)

|6b | | |Power off DUT |

|6c | | |Power on DUT |

|6d | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be TRUE.

|6e | |OO.S.C00.Rsp(Off) |TH sends _Off command_ to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|6f | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be FALSE.

|6g | | |Power off DUT |

|6h | | |Power on DUT |

|6i | |OO.S.A0000(OnOff) |TH reads the _OnOff attribute_ from the DUT
|The value of OnOff has to be FALSE.
|===

[[_notestesting_considerations_6]]
====== link:#_notestesting_considerations_6[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

'''''

[[_client_as_dut]]
==== link:#_client_as_dut[]4.3. Client as DUT

'''''

[[_tc_oo_3_2_functionality_with_client_as_dut]]
===== link:#_tc_oo_3_2_functionality_with_client_as_dut[]4.3.1. [TC-OO-3.2] Functionality with client as DUT

[[_category_6]]
====== link:#_category_6[]Category

Functional

[[_purpose_6]]
====== link:#_purpose_6[]Purpose

This test case verifies the functionality of the On/Off cluster client.

[[_pics_6]]
====== link:#_pics_6[]PICS

* OO.C

[[_required_devices_6]]
====== link:#_required_devices_6[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_5]]
====== link:#_device_topology_5[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_5]]
====== link:#_test_setup_5[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_6]]
====== link:#_test_procedure_6[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |OO.C.C00.Tx(Off) |DUT issues an Off command to the Test Harness.
|If OO.C.C00.Tx(Off), Test Harness receives the Off command from the
DUT. The command has no parameters.

|2 | |OO.C.C01.Tx(On) |DUT issues an On command to the Test Harness. |If
OO.C.C01.Tx(On), Test Harness receives the On command from the DUT. The
command has no parameters.

|3 | |OO.C.C02.Tx(Toggle) |DUT issues an Toggle command to the Test
Harness. |If OO.C.C02.Tx(Toggle), Test Harness receives the Toggle
command from the DUT. The command has no parameters.

|4 | |OO.C.C40.Tx(OffWithEffect) |DUT issues an OffWithEffect command to
the Test Harness. |If OO.C.C40.Tx(OffWithEffect), Test Harness receives
the OffWithEffect command from the DUT. Verify the command has two
parameters: +
ID 0 (EffectIdentifier): the type is a uint8, the value has to be 0 or
1. +
ID 1 (EffectVariant): the type is a uint8. If EffectIdentifier is 0 the
value of EffectVariant has to be 0, 1 or 2. If EffectIdentifier is 1 the
value of EffectVariant has to be 0.

|5 | |OO.C.C41.Tx(OnWithRecallGlobalScene) |DUT issues an
OnWithRecallGlobalScene command to the Test Harness. |If
OO.C.C41.Tx(OnWithRecallGlobalScene), Test Harness receives the
OnWithRecallGlobalScene command from the DUT. The command has no
parameters.

|6 | |OO.C.C42.Tx(OnWithTimedOff) |DUT issues an OnWithTimedOff command
to the Test Harness. |If OO.C.C42.Tx(OnWithTimedOff), Test Harness
receives the OnWithTimedOff command from the DUT. Verify the command has
three parameters: +
ID 0 (OnOffControl): the type is a map8, the value has to be 0x00 or
0x01. +
ID 1 (OnTime): the type is a uint16. +
ID 2 (OffWaitTime): the type is a uint16.
|===

[[_notestesting_considerations_7]]
====== link:#_notestesting_considerations_7[]Notes/Testing Considerations

Spec git revision c4688d430620af534f51e6e002e2ac13deed2223

'''''

[[_temperature_measurement_cluster_test_plan]]
== link:#_temperature_measurement_cluster_test_plan[]**Temperature Measurement Cluster Test Plan**

[[_pics_definition_2]]
=== link:#_pics_definition_2[]5. PICS Definition

This section covers the Temperature Measurement Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_2]]
==== link:#_role_2[]5.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TMP.S |Does the device implement the temperature measurement cluster as
a server? |O |
|===

[[_server_2]]
==== link:#_server_2[]5.2. Server

[[_attributes_2]]
===== link:#_attributes_2[]5.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TMP.S.A0000(MeasuredValue) |Does the device implement the MeasuredValue
attribute? |M |

|TMP.S.A0001(MinMeasuredValue) |Does the device implement the
MinMeasuredValue attribute? |M |

|TMP.S.A0002(MaxMeasuredValue) |Does the device implement the
MaxMeasuredValue attribute? |M |

|TMP.S.A0003(Tolerance) |Does the device implement the Tolerance
attribute? |O |
|===

[[_manual_controllable_2]]
===== link:#_manual_controllable_2[]5.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TMP.M.ManuallyControlled |Can the MeasuredValue attribute changed by
physical control at the device? |O |
|===

[[_test_case_list_2]]
=== link:#_test_case_list_2[]6. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-TMP-1.1 |Global attributes with server as DUT
|TC-TMP-2.1 |Attributes with server as DUT
|TC-TMP-2.2 |Primary functionality with server as DUT
|===

[[_test_cases_2]]
=== link:#_test_cases_2[]7. Test Cases

'''''

[[_generic_test_cases_2]]
==== link:#_generic_test_cases_2[]7.1. Generic test cases

'''''

[[_tc_tmp_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_tmp_1_1_global_attributes_with_server_as_dut[]7.1.1. [TC-TMP-1.1] Global attributes with server as DUT

[[_category_7]]
====== link:#_category_7[]Category

Functional conformance

[[_purpose_7]]
====== link:#_purpose_7[]Purpose

This test case verifies the Temperature Measurement Global attributes

[[_pics_7]]
====== link:#_pics_7[]PICS

* TMP.S

[[_required_devices_7]]
====== link:#_required_devices_7[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_7]]
====== link:#_test_procedure_7[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |2.3.1 | |TH reads the _ClusterRevision attribute_ from the DUT
|Verify that the DUT response indicates that the ClusterRevision
attribute has the value 4

|3 | | |TH reads the _FeatureMap attribute_ from the DUT |Verify that
the FeatureMap attribute has the value 0.

|4 |7.13.3 | |TH reads the _AttributeList attribute_ from the DUT
|Verify that the DUT response provides a list of supported attributes.
This list should include the mandatory attributes (values 0, 1 and 2)
and the optional Tolerance attribute (value 3) if TMP.S.A0003(Tolerance)
is true. It should also include the global attributes ClusterRevision,
FeatureMap, AttributeList, AcceptedCommandList and GeneratedCommandList
(value 65533, 65532, 65531, 65529 and 65528)

|5 |7.13.3.1 | |TH reads the _AcceptedCommandList attribute_ from the
DUT |Verify that the DUT response provides a list of supported commands.
For this cluster the list is usually empty but it can contain
manufacturer specific command IDs.

|6 |7.13.3.2 | |TH reads the _GeneratedCommandList attribute_ from the
DUT |Verify that the DUT response provides a list of supported commands.
For this cluster the list is usually empty.

|7 |7.13.4 | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. For this cluster the list
is usually empty but it can contain manufacturer specific event IDs.
|===

[[_notestesting_considerations_8]]
====== link:#_notestesting_considerations_8[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec GIT revision
c4688d430620af534f51e6e002e2ac13deed2223

[[_server_as_dut_2]]
==== link:#_server_as_dut_2[]7.2. Server as DUT

[[_tc_tmp_2_1_attributes_with_server_as_dut]]
===== link:#_tc_tmp_2_1_attributes_with_server_as_dut[]7.2.1. [TC-TMP-2.1] Attributes with server as DUT

[[_category_8]]
====== link:#_category_8[]Category

Functional

[[_purpose_8]]
====== link:#_purpose_8[]Purpose

This test case verifies the behavior of the non-global attributes of the
Temperature Measurement cluster server.

[[_pics_8]]
====== link:#_pics_8[]PICS

* TMP.S

[[_required_devices_8]]
====== link:#_required_devices_8[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_6]]
====== link:#_device_topology_6[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_6]]
====== link:#_test_setup_6[]Test Setup

Commission DUT to TH

[[_test_procedure_8]]
====== link:#_test_procedure_8[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |2.3.4.2 |TMP.S.A0001(MinMeasuredValue) |TH reads the
_MinMeasuredValue_ attribute from the DUT a|
Verify that the DUT response contains either +
null +
or +
an int16 where +
-27315 ≤ _MinMeasuredValue_ ≤ 32766. +

Note the value for usage in later steps as TMP~min~. +
If _MinMeasuredValue_ is null note -27315.

|3 |2.3.4.3 |TMP.S.A0002(MaxMeasuredValue) |TH reads the
_MaxMeasuredValue_ attribute from the DUT a|
Verify that the DUT response contains either +
null +
or +
an int16 where +
TMP~min~ < _MaxMeasuredValue_ ≤ 32767. +

Note the value for usage in later steps as TMP~max~. +
If _MaxMeasuredValue_ is null note 32767.

|4 |2.3.4.1 |TMP.S.A0000(MeasuredValue) |TH reads the _MeasuredValue_
attribute from the DUT |Verify that the DUT response contains either +
null +
or +
a int16 where +
TMP~min~ ≤ _MeasuredValue_ ≤ TMP~max~.

|5 |2.3.4.4 |TMP.S.A0003(Tolerance) |TH reads the _Tolerance attribute_
from the DUT |Verify that the DUT responds with an uint16 value. Its
value should be in the range of 0 and 2048
|===

[[_notestesting_considerations_9]]
====== link:#_notestesting_considerations_9[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_tmp_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_tmp_2_2_primary_functionality_with_server_as_dut[]7.2.2. [TC-TMP-2.2] Primary functionality with server as DUT

[[_category_9]]
====== link:#_category_9[]Category

Functional

[[_purpose_9]]
====== link:#_purpose_9[]Purpose

This test case verifies the primary functionality of the Temperature
Measurement cluster server.

[[_pics_9]]
====== link:#_pics_9[]PICS

* TMP.S

[[_required_devices_9]]
====== link:#_required_devices_9[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_7]]
====== link:#_device_topology_7[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_7]]
====== link:#_test_setup_7[]Test Setup

Commission DUT to TH

[[_test_procedure_9]]
====== link:#_test_procedure_9[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |2.3.4.2 |TMP.S.A0001(MinMeasuredValue) |TH reads _MinMeasuredValue_
attribute from DUT |

|3 |2.3.4.3 |TMP.S.A0002(MaxMeasuredValue) |TH reads _MaxMeasuredValue_
attribute from DUT |

|4 |2.3.4.1, 2.3.4.2, 2.3.4.3 |TMP.S.A0000(MeasuredValue) |TH reads
_MeasuredValue_ attribute from DUT |Verify that _MeasuredValue_
attribute is in range of _MinMeasuredValue_ attribute and
_MaxMeasuredValue_ attribute.

|5 | |TMP.M.ManuallyControlled |Operate on device to change the
temperature significantly |

|6 | |TMP.S.A0000(MeasuredValue) |after a few seconds, TH reads
_MeasuredValue_ attribute from DUT |Value has to be different
|===

[[_notestesting_considerations_10]]
====== link:#_notestesting_considerations_10[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_relative_humidity_measurement_cluster_test_plan]]
== link:#_relative_humidity_measurement_cluster_test_plan[]**Relative Humidity Measurement Cluster Test Plan**

[[_pics_definition_3]]
=== link:#_pics_definition_3[]8. PICS Definition

This section covers the Relative Humidity Measurement Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_3]]
==== link:#_role_3[]8.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RH.S |Does the device implement the relative humidity measurement
cluster as a server? |O |

|RH.C |Does the device implement the relative humidity measurement
cluster as a client? |O |
|===

[[_server_3]]
==== link:#_server_3[]8.2. Server

[[_attributes_3]]
===== link:#_attributes_3[]8.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RH.S.A0000(MeasuredValue) |Does the device implement the _MeasuredValue
attribute_? |M |

|RH.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue attribute_? |M |

|RH.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue attribute_? |M |

|RH.S.A0003(Tolerance) |Does the device implement the _Tolerance
attribute_? |O |
|===

[[_manual_controllable_3]]
===== link:#_manual_controllable_3[]8.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RH.M.ManuallyControlled |Can the _MeasuredValue attribute_ changed by
physical control at the device? |O |
|===

[[_test_case_list_3]]
=== link:#_test_case_list_3[]9. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-RH-1.1 |Global Attributes with Server as DUT
|TC-RH-2.1 |Attributes with Server as DUT
|TC-RH-2.2 |Primary Functionality with Server as DUT
|===

[[_test_cases_3]]
=== link:#_test_cases_3[]10. Test Cases

'''''

[[_generic_test_cases_3]]
==== link:#_generic_test_cases_3[]10.1. Generic test cases

'''''

[[_tc_rh_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_rh_1_1_global_attributes_with_server_as_dut[]10.1.1. [TC-RH-1.1] Global Attributes with Server as DUT

[[_category_10]]
====== link:#_category_10[]Category

Functional conformance

[[_purpose_10]]
====== link:#_purpose_10[]Purpose

This test case verifies the Relative Humidity Global attributes.

[[_pics_10]]
====== link:#_pics_10[]PICS

* RH.S

[[_required_devices_10]]
====== link:#_required_devices_10[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_10]]
====== link:#_test_procedure_10[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |2.6.1 | |TH reads the _ClusterRevision attribute_ from the DUT.
|Verify that the DUT response indicates that the ClusterRevision
attribute has the value 3.

|3 | | |TH reads the _FeatureMap attribute_ from the DUT. |Verify that
the FeatureMap attribute has the value 0.

|4 |7.13.3 | |TH reads the _AttributeList attribute_ from the DUT.
|Verify that the DUT response provides a list of supported attributes.
This list should include the mandatory attributes (values 0, 1 and 2)
and the optional _Tolerance attribute_ (value 3) if
RH.S.A0003(Tolerance) is true. It should also include the global
attributes ClusterRevision, FeatureMap, AttributeList,
AcceptedCommandList and GeneratedCommandList (value 65533, 65532, 65531,
65529 and 65528).

|5 |7.13.3.1 | |TH reads the _AcceptedCommandList attribute_ from the
DUT. |Verify that the DUT response provides a list of supported
commands. For this cluster the list is usually empty but it can contain
manufacturer specific command IDs.

|6 |7.13.3.2 | |TH reads the _GeneratedCommandList attribute_ from the
DUT. |Verify that the DUT response provides a list of supported
commands. For this cluster the list is usually empty.

|7 |7.13.4 | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. For this cluster the list
is usually empty but it can contain manufacturer specific event IDs.
|===

[[_notestesting_considerations_11]]
====== link:#_notestesting_considerations_11[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec GIT revision
6e56f582bc3f82335c1a0af39b77ddc44b13b849

[[_server_as_dut_3]]
==== link:#_server_as_dut_3[]10.2. Server as DUT

[[_tc_rh_2_1_attributes_with_server_as_dut]]
===== link:#_tc_rh_2_1_attributes_with_server_as_dut[]10.2.1. [TC-RH-2.1] Attributes with Server as DUT

[[_category_11]]
====== link:#_category_11[]Category

Functional

[[_purpose_11]]
====== link:#_purpose_11[]Purpose

This test case verifies the behavior of the non-global attributes of the
Relative Humidity Measurement cluster server.

[[_pics_11]]
====== link:#_pics_11[]PICS

* RH.S

[[_required_devices_11]]
====== link:#_required_devices_11[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_8]]
====== link:#_device_topology_8[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_8]]
====== link:#_test_setup_8[]Test Setup

Commission DUT to TH

[[_test_procedure_11]]
====== link:#_test_procedure_11[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |2.6.4.2 |RH.S.A0001(MinMeasuredValue) |TH reads the
_MinMeasuredValue attribute_ from the DUT. a|
Verify that the DUT response contains either +
null +
or +
a uint16 where +
0 ≤ _MinMeasuredValue_ ≤ 9999. +

Note the value for usage in later steps as RH~min~. +
If _MinMeasuredValue_ is null note 0.

|3 |2.6.4.3 |RH.S.A0002(MaxMeasuredValue) |TH reads the
_MaxMeasuredValue attribute_ from the DUT. a|
Verify that the DUT response contains either +
null +
or +
a uint16 where +
RH~min~ < _MaxMeasuredValue_ ≤ 10000. +

Note the value for usage in later steps as RH~max~. +
If _MaxMeasuredValue_ is null note 10000.

|4 |2.6.4.1 |RH.S.A0000(MeasuredValue) |TH reads the _MeasuredValue
attribute_ from the DUT. |Verify that the DUT response contains either +
null +
or +
a uint16 where +
RH~min~ ≤ _MeasuredValue_ ≤ RH~max~.

|5 |2.6.4.4 |RH.S.A0003(Tolerance) |TH reads the _Tolerance attribute_
from the DUT. |Verify that the DUT responds with a uint16 value. Its
value should be in the range of 0 and 2048.
|===

[[_notestesting_considerations_12]]
====== link:#_notestesting_considerations_12[]Notes/Testing Considerations

Spec GIT revision 6e56f582bc3f82335c1a0af39b77ddc44b13b849

[[_tc_rh_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_rh_2_2_primary_functionality_with_server_as_dut[]10.2.2. [TC-RH-2.2] Primary Functionality with Server as DUT

[[_category_12]]
====== link:#_category_12[]Category

Functional

[[_purpose_12]]
====== link:#_purpose_12[]Purpose

This test case verifies the primary functionality of the Relative
Humidity Measurement cluster server.

[[_pics_12]]
====== link:#_pics_12[]PICS

* RH.S

[[_required_devices_12]]
====== link:#_required_devices_12[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_9]]
====== link:#_device_topology_9[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_9]]
====== link:#_test_setup_9[]Test Setup

Commission DUT to TH

[[_test_procedure_12]]
====== link:#_test_procedure_12[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |2.6.4.2 |RH.S.A0001(MinMeasuredValue) |TH reads _MinMeasuredValue
attribute_ from DUT. |

|3 |2.6.4.3 |RH.S.A0002(MaxMeasuredValue) |TH reads _MaxMeasuredValue
attribute_ from DUT. |

|4 |2.6.4.1, 2.6.4.2, 2.6.4.3 |RH.S.A0000(MeasuredValue) |TH reads
_MeasuredValue attribute_ from DUT. |Verify that _MeasuredValue
attribute_ is in range of _MinMeasuredValue attribute_ and
_MaxMeasuredValue attribute_.

|5 | |RH.M.ManuallyControlled |Operate on device to change the humidity
significantly. |

|6 | |RH.S.A0000(MeasuredValue) |after a few seconds, TH reads
_MeasuredValue attribute_ from DUT. |Value has to be different.
|===

[[_notestesting_considerations_13]]
====== link:#_notestesting_considerations_13[]Notes/Testing Considerations

Spec GIT revision 6e56f582bc3f82335c1a0af39b77ddc44b13b849

[[_thermostat_user_configuration_cluster_test_plan]]
== link:#_thermostat_user_configuration_cluster_test_plan[]**Thermostat User Configuration Cluster Test Plan**

[[_pics_definition_4]]
=== link:#_pics_definition_4[]11. PICS Definition

This section covers the Thermostat User Configuration Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_4]]
==== link:#_role_4[]11.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSUIC.S |Does the device implement the Thermostat User Configuration
cluster as a server? |O |

|TSUIC.C |Does the device implement the Thermostat User Configuration
cluster as a client? |O |
|===

[[_server_4]]
==== link:#_server_4[]11.2. Server

[[_attributes_4]]
===== link:#_attributes_4[]11.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSUIC.S.A0000(TemperatureDisplayMode) |Does the device implement the
TemperatureDisplayMode attribute? |M |

|TSUIC.S.A0001(KeypadLockout) |Does the device implement the
KeypadLockout attribute? |M |

|TSUIC.S.A0002(ScheduleProgrammingVisibility) |Does the device implement
the ScheduleProgrammingVisibility attribute? |O |
|===

[[_test_case_list_4]]
=== link:#_test_case_list_4[]12. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-TSUIC-1.1 |Global attributes with DUT as Server
|TC-TSUIC-2.1 |Attributes with server as DUT
|TC-TSUIC-2.2 |Primary functionality with server as DUT
|===

[[_test_cases_4]]
=== link:#_test_cases_4[]13. Test Cases

'''''

[[_generic_test_cases_4]]
==== link:#_generic_test_cases_4[]13.1. Generic test cases

'''''

[[_tc_tsuic_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_tsuic_1_1_global_attributes_with_dut_as_server[]13.1.1. [TC-TSUIC-1.1] Global attributes with DUT as Server

[[_category_13]]
====== link:#_category_13[]Category

Functional conformance.

[[_purpose_13]]
====== link:#_purpose_13[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_13]]
====== link:#_pics_13[]PICS

* TSUIC.S

[[_required_devices_13]]
====== link:#_required_devices_13[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_13]]
====== link:#_test_procedure_13[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if
TSUIC.S.A0002(ScheduleProgrammingVisibility)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_14]]
====== link:#_notestesting_considerations_14[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_4]]
==== link:#_server_as_dut_4[]13.2. Server as DUT

'''''

[[_tc_tsuic_2_1_attributes_with_server_as_dut]]
===== link:#_tc_tsuic_2_1_attributes_with_server_as_dut[]13.2.1. [TC-TSUIC-2.1] Attributes with server as DUT

[[_category_14]]
====== link:#_category_14[]Category

Functional

[[_purpose_14]]
====== link:#_purpose_14[]Purpose

This test case verifies the behavior of the non-global attributes of the
Thermostat User Configuration cluster server.

[[_pics_14]]
====== link:#_pics_14[]PICS

* TSUIC.S

[[_required_devices_14]]
====== link:#_required_devices_14[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_10]]
====== link:#_device_topology_10[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_10]]
====== link:#_test_setup_10[]Test Setup

Commission DUT to TH

[[_test_procedure_14]]
====== link:#_test_procedure_14[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |4.5.5.1 |TSUIC.S.A0000(TemperatureDisplayMode) |TH reads the
_TemperatureDisplayMode_ attribute from the DUT |Verify that the DUT
responds with an enum8 value. Its value should be in the range of 0 and
1

|3 |4.5.5.2 |TSUIC.S.A0001(KeypadLockout) |TH reads the _KeypadLockout_
attribute from the DUT |Verify that the DUT responds with an enum8
value. Its value should be in the range of 0 and 5

|4 |4.5.5.3 |TSUIC.S.A0002(ScheduleProgrammingVisibility) |TH reads the
_ScheduleProgrammingVisibility_ attribute from the DUT |Verify that the
DUT responds with an enum8 value. Its value should be in the range of 0
and 1
|===

[[_notestesting_considerations_15]]
====== link:#_notestesting_considerations_15[]Notes/Testing Considerations

Spec git revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_tsuic_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_tsuic_2_2_primary_functionality_with_server_as_dut[]13.2.2. [TC-TSUIC-2.2] Primary functionality with server as DUT

[[_category_15]]
====== link:#_category_15[]Category

Functional

[[_purpose_15]]
====== link:#_purpose_15[]Purpose

This test case verifies the primary functionality of the Thermostat User
Configuration cluster server.

[[_pics_15]]
====== link:#_pics_15[]PICS

* TSUIC.S

[[_required_devices_15]]
====== link:#_required_devices_15[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_11]]
====== link:#_device_topology_11[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_11]]
====== link:#_test_setup_11[]Test Setup

Commission DUT to TH

[[_test_procedure_15]]
====== link:#_test_procedure_15[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH

2a

4.5.5.1

TSUIC.S.A0000(TemperatureDisplayMode)

TH writes a value of 0 to _TemperatureDisplayMode attribute_ of DUT

Temperature displayed in °C.

2b

TH reads the _TemperatureDisplayMode attribute_ of DUT

Verify that the TemperatureDisplayMode attribute has the value 0.

2c

TH writes a value of 1 to _TemperatureDisplayMode attribute_ of DUT

Temperature displayed in °F.

2d

TH reads the _TemperatureDisplayMode attribute_ of DUT

Verify that the TemperatureDisplayMode attribute has the value 1.

2e

TH writes a value of greater than 1 to _TemperatureDisplayMode
attribute_ of DUT

DUT should return an error CONSTRAINT_ERROR (0x87).

2f

TH reads the _TemperatureDisplayMode attribute_ of DUT

Verify that the TemperatureDisplayMode attribute still has the value 1.

3a

4.5.5.2

TSUIC.S.A0001(KeypadLockout)

TH writes a value of 0 to _KeypadLockout attribute_ of DUT

All functionality available to the user.

3b

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute has the value 0.

3c

TH writes a value of 1 to _KeypadLockout attribute_ of DUT

Level 1 reduced functionality.

3d

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute has the value 1.

3e

TH writes a value of 2 to _KeypadLockout attribute_ of DUT

Level 2 reduced functionality.

3f

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute has the value 2.

3g

TH writes a value of 3 to _KeypadLockout attribute_ of DUT

Level 3 reduced functionality.

3h

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute has the value 3.

3i

TH writes a value of 4 to _KeypadLockout attribute_ of DUT

Level 4 reduced functionality.

3j

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute has the value 4.

3k

TH writes a value of 5 to _KeypadLockout attribute_ of DUT

Least functionality available to the user.

3l

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute has the value 5.

3m

TH writes a value of greater than 5 to _KeypadLockout attribute_ of DUT

DUT should return an error CONSTRAINT_ERROR (0x87).

3n

TH reads the _KeypadLockout attribute_ of DUT

Verify that the KeypadLockout attribute still has the value 5.

4a

4.5.5.3

TSUIC.S.A0002(ScheduleProgrammingVisibility)

TH writes a value of 0 to _ScheduleProgrammingVisibility attribute_ of
DUT

Local schedule programming functionality is enabled at the thermostat.

4b

TH reads the _ScheduleProgrammingVisibility attribute_ of DUT

Verify that the ScheduleProgrammingVisibility attribute has the value 0

4c

TH writes a value of 1 to _ScheduleProgrammingVisibility attribute_ of
DUT

Local schedule programming functionality is disabled at the thermostat.

4d

TH reads the _ScheduleProgrammingVisibility attribute_ of DUT

Verify that the ScheduleProgrammingVisibility attribute has the value 1.

4e

TH writes a value of greater than 1 to _ScheduleProgrammingVisibility
attribute_ of DUT

DUT should return an error CONSTRAINT_ERROR (0x87).

4f

TH reads the _ScheduleProgrammingVisibility attribute_ of DUT

Verify that the ScheduleProgrammingVisibility attribute still has the
value 1.

[[_notestesting_considerations_16]]
== link:#_notestesting_considerations_16[]Notes/Testing Considerations

Spec git revision c4688d430620af534f51e6e002e2ac13deed2223

[[_pump_configuration_and_control_cluster_test_plan]]
== link:#_pump_configuration_and_control_cluster_test_plan[]**Pump Configuration and Control Cluster Test Plan**

[[_pics_definition_5]]
=== link:#_pics_definition_5[]14. PICS Definition

This section covers the Pump Configuration and Control Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_5]]
==== link:#_role_5[]14.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PCC.S |Does the device implement the Pump Configuration and Control
cluster as a server? |O |
|===

[[_server_5]]
==== link:#_server_5[]14.2. Server

[[_features_2]]
===== link:#_features_2[]14.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PCC.S.F00(PRSCONST) |Supports operating in constant pressure mode |O.a+
|

|PCC.S.F01(PRSCOMP) |Supports operating in compensated pressure mode
|O.a+ |

|PCC.S.F02(FLW) |Supports operating in constant flow mode |O.a+ |

|PCC.S.F03(SPD) |Supports operating in constant speed mode |O.a+ |

|PCC.S.F04(TEMP) |Supports operating in constant temperature mode |O.a+
|

|PCC.S.F05(AUTO) |Supports operating in automatic mode |O |

|PCC.S.F06(LOCAL) |Supports operating using local settings |O |
|===

[[_attributes_5]]
===== link:#_attributes_5[]14.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PCC.S.A0000(MaxPressure) |Does the device implement the _MaxPressure_
attribute? |M |

|PCC.S.A0001(MaxSpeed) |Does the device implement the _MaxSpeed_
attribute? |M |

|PCC.S.A0002(MaxFlow) |Does the device implement the _MaxFlow_
attribute? |M |

|PCC.S.A0003(MinConstPressure) |Does the device implement the
_MinConstPressure_ attribute? |PRSCONST, [AUTO] |

|PCC.S.A0004(MaxConstPressure) |Does the device implement the
_MaxConstPressure_ attribute? |PRSCONST, [AUTO] |

|PCC.S.A0005(MinCompPressure) |Does the device implement the
_MinCompPressure_ attribute? |PRSCOMP, [AUTO] |

|PCC.S.A0006(MaxCompPressure) |Does the device implement the
_MaxCompPressure_ attribute? |PRSCOMP, [AUTO] |

|PCC.S.A0007(MinConstSpeed) |Does the device implement the
_MinConstSpeed_ attribute? |SPD, [AUTO] |

|PCC.S.A0008(MaxConstSpeed) |Does the device implement the
_MaxConstSpeed_ attribute? |SPD, [AUTO] |

|PCC.S.A0009(MinConstFlow) |Does the device implement the _MinConstFlow_
attribute? |FLW, [AUTO] |

|PCC.S.A000a(MaxConstFlow) |Does the device implement the _MaxConstFlow_
attribute? |FLW, [AUTO] |

|PCC.S.A000b(MinConstTemp) |Does the device implement the _MinConstTemp_
attribute? |TEMP, [AUTO] |

|PCC.S.A000c(MaxConstTemp) |Does the device implement the _MaxConstTemp_
attribute? |TEMP, [AUTO] |

|PCC.S.A0010(PumpStatus) |Does the device implement the _PumpStatus_
attribute? |O |

|PCC.S.A0011(EffectiveOperationMode) |Does the device implement the
_EffectiveOperationMode_ attribute? |M |

|PCC.S.A0012(EffectiveControlMode) |Does the device implement the
_EffectiveControlMode_ attribute? |M |

|PCC.S.A0013(Capacity) |Does the device implement the _Capacity_
attribute? |M |

|PCC.S.A0014(Speed) |Does the device implement the _Speed_ attribute? |O
|

|PCC.S.A0015(LifetimeRunningHours) |Does the device implement the
_LifetimeRunningHours_ attribute? |O |

|PCC.S.A0016(Power) |Does the device implement the _Power_ attribute? |O
|

|PCC.S.A0017(LifetimeEnergyConsumed) |Does the device implement the
_LifetimeEnergyConsumed_ attribute? |O |

|PCC.S.A0020(OperationMode) |Does the device implement the
_OperationMode_ attribute? |M |

|PCC.S.A0021(ControlMode) |Does the device implement the _ControlMode_
attribute? |O |
|===

[[_events]]
===== link:#_events[]14.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PCC.S.E00(SupplyVoltageLow) |Does the device implement the
_SupplyVoltageLow_ event? |O |

|PCC.S.E01(SupplyVoltageHigh) |Does the device implement the
_SupplyVoltageHigh_ event? |O |

|PCC.S.E02(PowerMissingPhase) |Does the device implement the
_PowerMissingPhase_ event? |O |

|PCC.S.E03(SystemPressureLow) |Does the device implement the
_SystemPressureLow_ event? |O |

|PCC.S.E04(SystemPressureHigh) |Does the device implement the
_SystemPressureHigh_ event? |O |

|PCC.S.E05(DryRunning) |Does the device implement the _DryRunning_
event? |O |

|PCC.S.E06(MotorTemperatureHigh) |Does the device implement the
_MotorTemperatureHigh_ event? |O |

|PCC.S.E07(PumpMotorFatalFailure) |Does the device implement the
_PumpMotorFatalFailure_ event? |O |

|PCC.S.E08(ElectronicTemperatureHigh) |Does the device implement the
_ElectronicTemperatureHigh_ event? |O |

|PCC.S.E09(PumpBlocked) |Does the device implement the _PumpBlocked_
event? |O |

|PCC.S.E0a(SensorFailure) |Does the device implement the _SensorFailure_
event? |O |

|PCC.S.E0b(ElectronicNonFatalFailure) |Does the device implement the
_ElectronicNonFatalFailure_ event? |O |

|PCC.S.E0c(ElectronicFatalFailure) |Does the device implement the
_ElectronicFatalFailure_ event? |O |

|PCC.S.E0d(GeneralFault) |Does the device implement the _GeneralFault_
event? |O |

|PCC.S.E0e(Leakage) |Does the device implement the _Leakage_ event? |O |

|PCC.S.E0f(AirDetection) |Does the device implement the _AirDetection_
event? |O |

|PCC.S.E10(TurbineOperation) |Does the device implement the
_TurbineOperation_ event? |O |
|===

[[_test_case_list_5]]
=== link:#_test_case_list_5[]15. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-PCC-1.1 |Global Attributes with DUT as Server
|TC-PCC-2.1 |Attributes with Server as DUT
|TC-PCC-2.2 |Operation Mode with Server as DUT
|TC-PCC-2.3 |Control Mode with Server as DUT
|TC-PCC-2.4 |Life Time Counters with Server as DUT
|===

[[_test_cases_5]]
=== link:#_test_cases_5[]16. Test Cases

'''''

[[_generic_test_cases_5]]
==== link:#_generic_test_cases_5[]16.1. Generic Test Cases

'''''

[[_tc_pcc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_pcc_1_1_global_attributes_with_dut_as_server[]16.1.1. [TC-PCC-1.1] Global Attributes with DUT as Server

[[_category_16]]
====== link:#_category_16[]Category

Functional conformance.

[[_purpose_16]]
====== link:#_purpose_16[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_16]]
====== link:#_pics_16[]PICS

* PCC.S

[[_required_devices_16]]
====== link:#_required_devices_16[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_16]]
====== link:#_test_procedure_16[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 4.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if PCC.S.F00(PRSCONST)

- bit 1: SHALL be 1 if and only if PCC.S.F01(PRSCOMP)

- bit 2: SHALL be 1 if and only if PCC.S.F02(FLW)

- bit 3: SHALL be 1 if and only if PCC.S.F03(SPD)

- bit 4: SHALL be 1 if and only if PCC.S.F04(TEMP)

- bit 5: SHALL be 1 if and only if PCC.S.F05(AUTO)

- bit 6: SHALL be 1 if and only if PCC.S.F06(LOCAL)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0011, 0x0012, 0x0013, 0x0020, 0xfff8, 0xfff9,
0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0010: SHALL be included if and only if PCC.S.A0010(PumpStatus)

- 0x0014: SHALL be included if and only if PCC.S.A0014(Speed)

- 0x0015: SHALL be included if and only if
PCC.S.A0015(LifetimeRunningHours)

- 0x0016: SHALL be included if and only if PCC.S.A0016(Power)

- 0x0017: SHALL be included if and only if
PCC.S.A0017(LifetimeEnergyConsumed)

- 0x0021: SHALL be included if and only if PCC.S.A0021(ControlMode)

The list include entries based on feature support: +
- 0x0003: SHALL be included if PCC.S.F00(PRSCONST) or (PCC.S.F05(AUTO) &
PCC.S.A0003(MinConstPressure)) and SHALL NOT be included otherwise.

- 0x0004: SHALL be included if PCC.S.F00(PRSCONST) or (PCC.S.F05(AUTO) &
PCC.S.A0004(MaxConstPressure)) and SHALL NOT be included otherwise.

- 0x0005: SHALL be included if PCC.S.F01(PRSCOMP) or (PCC.S.F05(AUTO) &
PCC.S.A0005(MinCompPressure)) and SHALL NOT be included otherwise.

- 0x0006: SHALL be included if PCC.S.F01(PRSCOMP) or (PCC.S.F05(AUTO) &
PCC.S.A0006(MaxCompPressure)) and SHALL NOT be included otherwise.

- 0x0007: SHALL be included if PCC.S.F03(SPD) or (PCC.S.F05(AUTO) &
PCC.S.A0007(MinConstSpeed)) and SHALL NOT be included otherwise.

- 0x0008: SHALL be included if PCC.S.F03(SPD) or (PCC.S.F05(AUTO) &
PCC.S.A0008(MaxConstSpeed)) and SHALL NOT be included otherwise.

- 0x0009: SHALL be included if PCC.S.F02(FLW) or (PCC.S.F05(AUTO) &
PCC.S.A0009(MinConstFlow)) and SHALL NOT be included otherwise.

- 0x000a: SHALL be included if PCC.S.F02(FLW) or (PCC.S.F05(AUTO) &
PCC.S.A000a(MaxConstFlow)) and SHALL NOT be included otherwise.

- 0x000b: SHALL be included if PCC.S.F04(TEMP) or (PCC.S.F05(AUTO) &
PCC.S.A000b(MinConstTemp)) and SHALL NOT be included otherwise.

- 0x000c: SHALL be included if PCC.S.F04(TEMP) or (PCC.S.F05(AUTO) &
PCC.S.A000c(MaxConstTemp)) and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list MAY include these optional entries: +
- 0x00: SHALL be included if and only if PCC.S.E00(SupplyVoltageLow)

- 0x01: SHALL be included if and only if PCC.S.E01(SupplyVoltageHigh)

- 0x02: SHALL be included if and only if PCC.S.E02(PowerMissingPhase)

- 0x03: SHALL be included if and only if PCC.S.E03(SystemPressureLow)

- 0x04: SHALL be included if and only if PCC.S.E04(SystemPressureHigh)

- 0x05: SHALL be included if and only if PCC.S.E05(DryRunning)

- 0x06: SHALL be included if and only if PCC.S.E06(MotorTemperatureHigh)

- 0x07: SHALL be included if and only if
PCC.S.E07(PumpMotorFatalFailure)

- 0x08: SHALL be included if and only if
PCC.S.E08(ElectronicTemperatureHigh)

- 0x09: SHALL be included if and only if PCC.S.E09(PumpBlocked)

- 0x0a: SHALL be included if and only if PCC.S.E0a(SensorFailure)

- 0x0b: SHALL be included if and only if
PCC.S.E0b(ElectronicNonFatalFailure)

- 0x0c: SHALL be included if and only if
PCC.S.E0c(ElectronicFatalFailure)

- 0x0d: SHALL be included if and only if PCC.S.E0d(GeneralFault)

- 0x0e: SHALL be included if and only if PCC.S.E0e(Leakage)

- 0x0f: SHALL be included if and only if PCC.S.E0f(AirDetection)

- 0x10: SHALL be included if and only if PCC.S.E10(TurbineOperation)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_17]]
====== link:#_notestesting_considerations_17[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_dut_as_server]]
==== link:#_dut_as_server[]16.2. DUT as Server

'''''

[[_tc_pcc_2_1_attributes_with_server_as_dut]]
===== link:#_tc_pcc_2_1_attributes_with_server_as_dut[]16.2.1. [TC-PCC-2.1] Attributes with Server as DUT

[[_category_17]]
====== link:#_category_17[]Category

Functional.

[[_purpose_17]]
====== link:#_purpose_17[]Purpose

This test case verifies the non-global attributes of the Pump
Configuration and Control cluster server.

[[_pics_17]]
====== link:#_pics_17[]PICS

* PCC.S

[[_required_devices_17]]
====== link:#_required_devices_17[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_12]]
====== link:#_device_topology_12[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_12]]
====== link:#_test_setup_12[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_17]]
====== link:#_test_procedure_17[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.4.7.1 |PCC.S.A0000(MaxPressure) |TH reads from the DUT the
_MaxPressure_ attribute. |Verify that the DUT response contains an int16
value. Value has to be between a range of -32768 and 32767.

|3 |AC.4.7.2 |PCC.S.A0001(MaxSpeed) |TH reads from the DUT the
_MaxSpeed_ attribute. |Verify that the DUT response contains a uint16
value. Value has to be between a range of 0 and 65535.

|4 |AC.4.7.3 |PCC.S.A0002(MaxFlow) |TH reads from the DUT the _MaxFlow_
attribute. |Verify that the DUT response contains a uint16 value. Value
has to be between a range of 0 and 65535.

|5 |AC.4.7.4 |PCC.S.A0003(MinConstPressure) |TH reads from the DUT the
_MinConstPressure_ attribute. |Verify that the DUT response contains an
int16 value. Value has to be between a range of -32768 and 32767.

|6 |AC.4.7.5 |PCC.S.A0004(MaxConstPressure) |TH reads from the DUT the
_MaxConstPressure_ attribute. |Verify that the DUT response contains an
int16 value. Value has to be between a range of -32768 and 32767.

|7 |AC.4.7.6 |PCC.S.A0005(MinCompPressure) |TH reads from the DUT the
_MinCompPressure_ attribute. |Verify that the DUT response contains an
int16 value. Value has to be between a range of -32768 and 32767.

|8 |AC.4.7.7 |PCC.S.A0006(MaxCompPressure) |TH reads from the DUT the
_MaxCompPressure_ attribute. |Verify that the DUT response contains an
int16 value. Value has to be between a range of -32768 and 32767.

|9 |AC.4.7.8 |PCC.S.A0007(MinConstSpeed) |TH reads from the DUT the
_MinConstSpeed_ attribute. |Verify that the DUT response contains a
uint16 value. Value has to be between a range of 0 and 65535.

|10 |AC.4.7.9 |PCC.S.A0008(MaxConstSpeed) |TH reads from the DUT the
_MaxConstSpeed_ attribute. |Verify that the DUT response contains a
uint16 value. Value has to be between a range of 0 and 65535.

|11 |AC.4.7.10 |PCC.S.A0009(MinConstFlow) |TH reads from the DUT the
_MinConstFlow_ attribute. |Verify that the DUT response contains a
uint16 value. Value has to be between a range of 0 and 65535.

|12 |AC.4.7.11 |PCC.S.A000a(MaxConstFlow) |TH reads from the DUT the
_MaxConstFlow_ attribute. |Verify that the DUT response contains a
uint16 value. Value has to be between a range of 0 and 65535.

|13 |AC.4.7.12 |PCC.S.A000b(MinConstTemp) |TH reads from the DUT the
_MinConstTemp_ attribute. |Verify that the DUT response contains an
int16 value. Value has to be between a range of -32768 and 32767.

|14 |AC.4.7.13 |PCC.S.A000c(MaxConstTemp) |TH reads from the DUT the
_MaxConstTemp_ attribute. |Verify that the DUT response contains an
int16 value. Value has to be between a range of -32768 and 32767.

|15 |AC.4.7.14 |PCC.S.A0010(PumpStatus) |TH reads from the DUT the
_PumpStatus_ attribute. |Verify that the DUT response contains a map16
value. Value has to be between a range of 0 and 8.

|16 |AC.4.7.15 |PCC.S.A0011(EffectiveOperationMode) |TH reads from the
DUT the _EffectiveOperationMode_ attribute. |Verify that the DUT
response contains an enum8 value. Value has to be between a range of 0
and 3.

|17 |AC.4.7.16 |PCC.S.A0012(EffectiveControlMode) |TH reads from the DUT
the _EffectiveControlMode_ attribute. |Verify that the DUT response
contains an enum8 value. Value has to be between a range of 0 and 7.

|18 |AC.4.7.17 |PCC.S.A0013(Capacity) |TH reads from the DUT the
_Capacity_ attribute. |Verify that the DUT response contains an int16
value. Value has to be between a range of -32768 and 32767.

|19 |AC.4.7.18 |PCC.S.A0014(Speed) |TH reads from the DUT the _Speed_
attribute. |Verify that the DUT response contains a uint16 value. Value
has to be between a range of 0 and 65535.

|20 |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH reads from the DUT
the _LifetimeRunningHours_ attribute. |Verify that the DUT response
contains a uint24 value. Value has to be between a range of 0 and
16777215.

|21 |AC.4.7.20 |PCC.S.A0016(Power) |TH reads from the DUT the _Power_
attribute. |Verify that the DUT response contains a uint24 value. Value
has to be between a range of 0 and 16777215.

|22 |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH reads from the
DUT the _LifetimeEnergyConsumed_ attribute. |Verify that the DUT
response contains a uint32 value. Value has to be between a range of 0
and 4294967295.

|23 |AC.4.7.22 |PCC.S.A0020(OperationMode) |TH reads from the DUT the
_OperationMode_ attribute. |Verify that the DUT response contains an
enum8 value. Value has to be between a range of 0 and 3.

|24 |AC.4.7.23 |PCC.S.A0021(ControlMode) |TH reads from the DUT the
_ControlMode_ attribute. |Verify that the DUT response contains an enum8
value. Value has to be between a range of 0 and 7.
|===

[[_notestesting_considerations_18]]
====== link:#_notestesting_considerations_18[]Notes/Testing Considerations

[[_tc_pcc_2_2_operation_mode_with_server_as_dut]]
===== link:#_tc_pcc_2_2_operation_mode_with_server_as_dut[]16.2.2. [TC-PCC-2.2] Operation Mode with Server as DUT

[[_category_18]]
====== link:#_category_18[]Category

Functional.

[[_purpose_18]]
====== link:#_purpose_18[]Purpose

This test case verifies the _EffectiveOperationMode_ Attribute of the
Pump Configuration and Control cluster server.

[[_pics_18]]
====== link:#_pics_18[]PICS

* PCC.S

[[_required_devices_18]]
====== link:#_required_devices_18[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_13]]
====== link:#_device_topology_13[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_13]]
====== link:#_test_setup_13[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_18]]
====== link:#_test_procedure_18[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2a |AC.4.7.22 |PCC.S.A0020(OperationMode) |TH write 0 (Normal) to the
_OperationMode_ attribute to DUT. |DUT response indicating that the
write command was a SUCCESS.

|2b |AC.4.7.15 |PCC.S.A0011(EffectiveOperationMode) |TH reads from the
DUT the _EffectiveOperationMode_ attribute. |The returned attribute is 0
(Normal).

|3a |AC.4.7.22 |PCC.S.F03(SPD) & PCC.S.A0020(OperationMode) |TH write 1
(Minimum) to the _OperationMode_ attribute to DUT. |DUT response
indicating that the write command was a SUCCESS.

|3b |AC.4.7.15 |PCC.S.F03(SPD) & PCC.S.A0011(EffectiveOperationMode) |TH
reads from the DUT the _EffectiveOperationMode_ attribute. |The returned
attribute is 1 (Minimum).

|4a |AC.4.7.22 |PCC.S.F03(SPD) & PCC.S.A0020(OperationMode) |TH write 2
(Maximum) to the _OperationMode_ attribute to DUT one at a time. |DUT
response indicating that the write command was a SUCCESS.

|4b |AC.4.7.15 |PCC.S.F03(SPD) & PCC.S.A0011(EffectiveOperationMode) |TH
reads from the DUT the _EffectiveOperationMode_ attribute. |The returned
attribute is 2 (Maximum).

|5a |AC.4.7.22 |PCC.S.F06(LOCAL) & PCC.S.A0020(OperationMode) |TH write
3 (Local) to the _OperationMode_ attribute to DUT. |DUT response
indicating that the write command was a SUCCESS.

|5b |AC.4.7.15 |PCC.S.F06(LOCAL) & PCC.S.A0011(EffectiveOperationMode)
|TH reads from the DUT the _EffectiveOperationMode_ attribute. |The
returned attribute is 3 (Local).
|===

[[_notestesting_considerations_19]]
====== link:#_notestesting_considerations_19[]Notes/Testing Considerations

[[_tc_pcc_2_3_control_mode_with_server_as_dut]]
===== link:#_tc_pcc_2_3_control_mode_with_server_as_dut[]16.2.3. [TC-PCC-2.3] Control Mode with Server as DUT

[[_category_19]]
====== link:#_category_19[]Category

Functional.

[[_purpose_19]]
====== link:#_purpose_19[]Purpose

This test case verifies the _EffectiveControlMode_ Attribute of the Pump
Configuration and Control cluster server.

[[_pics_19]]
====== link:#_pics_19[]PICS

* PCC.S

[[_required_devices_19]]
====== link:#_required_devices_19[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_14]]
====== link:#_device_topology_14[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_14]]
====== link:#_test_setup_14[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_19]]
====== link:#_test_procedure_19[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2a |AC.4.7.22 |PCC.S.A0020(OperationMode) |TH write 0 (Normal) to the
_OperationMode_ attribute to DUT. |DUT response indicating that the
write command was a SUCCESS.

|2b |AC.4.7.15 |PCC.S.A0011(EffectiveOperationMode) |TH reads from the
DUT the _EffectiveOperationMode_ attribute. |The returned attribute is 0
(Normal).

|3a |AC.4.7.23 |PCC.S.F03(SPD) & PCC.S.A0021(ControlMode) |TH write 0
(ConstantSpeed) to the _ControlMode_ attribute to DUT one at a time.
|DUT response indicating that the write command was a SUCCESS.

|3b |AC.4.7.16 |PCC.S.F03(SPD) & PCC.S.A0012(EffectiveControlMode) |TH
reads from the DUT the _EffectiveControlMode_ attribute. |The returned
attribute is 0 (ConstantSpeed).

|4a |AC.4.7.23 |PCC.S.F00(PRSCONST) & PCC.S.A0021(ControlMode) |TH write
1 (ConstantPressure) to the _ControlMode_ attribute to DUT one at a
time. |DUT response indicating that the write command was a SUCCESS.

|4b |AC.4.7.16 |PCC.S.F00(PRSCONST) & PCC.S.A0012(EffectiveControlMode)
|TH reads from the DUT the _EffectiveControlMode_ attribute. |The
returned attribute is 1 (ConstantPressure).

|5a |AC.4.7.23 |PCC.S.F01(PRSCOMP) & PCC.S.A0021(ControlMode) |TH write
2 (ProportionalPressure) to the _ControlMode_ attribute to DUT one at a
time. |DUT response indicating that the write command was a SUCCESS.

|5b |AC.4.7.16 |PCC.S.F01(PRSCOMP) & PCC.S.A0012(EffectiveControlMode)
|TH reads from the DUT the _EffectiveControlMode_ attribute. |The
returned attribute is 2 (ProportionalPressure).

|6a |AC.4.7.23 |PCC.S.F02(FLW) & PCC.S.A0021(ControlMode) |TH write 3
(ConstantFlow) to the _ControlMode_ attribute to DUT one at a time. |DUT
response indicating that the write command was a SUCCESS.

|6b |AC.4.7.16 |PCC.S.F02(FLW) & PCC.S.A0012(EffectiveControlMode) |TH
reads from the DUT the _EffectiveControlMode attribute. |The returned
attribute is 3 (ConstantFlow).

|7a |AC.4.7.23 |PCC.S.F04(TEMP) & PCC.S.A0021(ControlMode) |TH write 5
(ConstantTemperature) to the _ControlMode_ attribute to DUT one at a
time. |DUT response indicating that the write command was a SUCCESS.

|7b |AC.4.7.16 |PCC.S.F04(TEMP) & PCC.S.A0012(EffectiveControlMode) |TH
reads from the DUT the _EffectiveControlMode_ attribute. |The returned
attribute is 5 (ConstantTemperature).

|8a |AC.4.7.23 |PCC.S.F05(AUTO) & PCC.S.A0021(ControlMode) |TH write 7
(Automatic) to the _ControlMode_ attribute to DUT one at a time. |DUT
response indicating that the write command was a SUCCESS.

|8b |AC.4.7.16 |PCC.S.F05(AUTO) & PCC.S.A0012(EffectiveControlMode) |TH
reads from the DUT the _EffectiveControlMode_ attribute. |The returned
attribute is 7 (Automatic).
|===

[[_notestesting_considerations_20]]
====== link:#_notestesting_considerations_20[]Notes/Testing Considerations

[[_tc_pcc_2_4_life_time_counters_with_server_as_dut]]
===== link:#_tc_pcc_2_4_life_time_counters_with_server_as_dut[]16.2.4. [TC-PCC-2.4] Life Time Counters with Server as DUT

[[_category_20]]
====== link:#_category_20[]Category

Functional.

[[_purpose_20]]
====== link:#_purpose_20[]Purpose

This test case verifies the _LifetimeRunningHours_ and
_LifetimeEnergyConsumed_ attributes of the Pump Configuration and
Control cluster server.

[[_pics_20]]
====== link:#_pics_20[]PICS

* PCC.S

[[_required_devices_20]]
====== link:#_required_devices_20[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_15]]
====== link:#_device_topology_15[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_15]]
====== link:#_test_setup_15[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_20]]
====== link:#_test_procedure_20[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2a |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH write 1 to the
_LifetimeRunningHours_ attribute of DUT. |DUT response indicating that
the write command was a SUCCESS.

|2b |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH reads from the DUT
the _LifetimeRunningHours_ attribute. |The returned value is 1.

|3a |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH write 2 to the
_LifetimeRunningHours_ attribute of DUT. |DUT response indicating that
the write command was a SUCCESS.

|3b |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH reads from the DUT
the _LifetimeRunningHours_ attribute. |The returned value is 2.

|4a |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH write 3 to the
_LifetimeRunningHours_ attribute of DUT. |DUT response indicating that
the write command was a SUCCESS.

|4b |AC.4.7.19 |PCC.S.A0015(LifetimeRunningHours) |TH reads from the DUT
the _LifetimeRunningHours_ attribute. |The returned value is 3.

|5a |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH write 1 to the
_LifetimeEnergyConsumed_ attribute of DUT. |DUT response indicating that
the write command was a SUCCESS.

|5b |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH reads from the
DUT the _LifetimeEnergyConsumed_ attribute. |The returned value is 1.

|6a |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH write 2 to the
_LifetimeEnergyConsumed_ attribute of DUT. |DUT response indicating that
the write command was a SUCCESS.

|6b |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH reads from the
DUT the _LifetimeEnergyConsumed_ attribute. |The returned value is 2.

|7a |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH write 3 to the
_LifetimeEnergyConsumed_ attribute of DUT. |DUT response indicating that
the write command was a SUCCESS.

|7b |AC.4.7.21 |PCC.S.A0017(LifetimeEnergyConsumed) |TH reads from the
DUT the _LifetimeEnergyConsumed_ attribute. |The returned value is 3.
|===

[[_notestesting_considerations_21]]
====== link:#_notestesting_considerations_21[]Notes/Testing Considerations

[[_media_cluster_test_plan]]
== link:#_media_cluster_test_plan[]**Media Cluster Test Plan**

[[_pics_definition_6]]
=== link:#_pics_definition_6[]17. PICS Definition

This section covers the Media Cluster related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_6]]
==== link:#_role_6[]17.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MC.S |Does the device implement the casting video player as a server?
|O |

|MC.C |Does the device implement the casting video player as a client?
|O |

|LOWPOWER.S |Does the device implement the Low Power cluster as a
server? |O |

|LOWPOWER.C |Does the device implement the Low Power cluster as a
client? |O |

|WAKEONLAN.S |Does the device implement the Wake On LAN cluster as a
server? |O |

|WAKEONLAN.C |Does the device implement the Wake On LAN cluster as a
client? |O |

|KEYPADINPUT.S |Does the device implement the Keypad Input cluster as a
server? |O |

|KEYPADINPUT.C |Does the device implement the Keypad Input cluster as a
client? |O |

|APPLAUNCHER.S |Does the device implement the Application Launcher
cluster as a server? |O |

|APPLAUNCHER.C |Does the device implement the Application Launcher
cluster as a client? |O |

|MEDIAINPUT.S |Does the device implement the Media Input cluster as a
server? |O |

|MEDIAINPUT.C |Does the device implement the Media Input cluster as a
client? |O |

|CHANNEL.S |Does the device implement the Channel cluster as a server?
|O |

|CHANNEL.C |Does the device implement the Channel cluster as a client?
|O |

|MEDIAPLAYBACK.S |Does the device implement the Media Playback cluster
as a server? |O |

|MEDIAPLAYBACK.C |Does the device implement the Media Playback cluster
as a client? |O |

|AUDIOOUTPUT.S |Does the device implement the Audio Output cluster as a
server? |O |

|AUDIOOUTPUT.C |Does the device implement the Audio Output cluster as a
client? |O |

|TGTNAV.S |Does the device implement the Target Navigator cluster as a
server? |O |

|TGTNAV.C |Does the device implement the Target Navigator cluster as a
client? |O |

|APBSC.S |Does the device implement the Application Basic cluster as a
server? |O |

|APBSC.C |Does the device implement the Application Basic cluster as a
client? |O |

|CONTENTLAUNCHER.S |Does the device implement the Content Launcher
cluster as a server? |O |

|CONTENTLAUNCHER.C |Does the device implement the Content Launcher
cluster as a client? |O |

|ALOGIN.S |Does the device implement the Account Login cluster as a
server? |O |

|ALOGIN.C |Does the device implement the Account Login cluster as a
client? |O |
|===

[[_server_6]]
==== link:#_server_6[]17.2. Server

[[_features_3]]
===== link:#_features_3[]17.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|KEYPADINPUT.S.F00(NV) |Does the DUT support the Keypad Input server
cluster, Navigation Keys? |O |

|KEYPADINPUT.S.F01(LK) |Does the DUT support the Keypad Input server
cluster, Location Keys? |O |

|KEYPADINPUT.S.F02(NK) |Does the DUT support the Keypad Input server
cluster, Number Keys? |O |

|APPLAUNCHER.S.F00(AP) |Does the DUT support the Application Launcher
server cluster, Application Platform feature? |O |

|MEDIAINPUT.S.F00(NU) |Does the DUT support the Media Input server
cluster, Name Updates feature? |O |

|CHANNEL.S.F00(CL) |Does the DUT support the Channel server cluster,
Channel List feature? |O |

|CHANNEL.S.F01(LI) |Does the DUT support the Channel server cluster,
Lineup Info feature? |O |

|MEDIAPLAYBACK.S.F00(AS) |Does the DUT support the Media Playback server
cluster, Advanced Seek feature? |O |

|MEDIAPLAYBACK.S.F01(VS) |Does the DUT support the Media Playback server
cluster, Variable Speed feature? |O |

|AUDIOOUTPUT.S.F00(NU) |Does the DUT support the Audio Output server
cluster, Name Updates feature? |O |

|CONTENTLAUNCHER.S.F00(CS) |Does the DUT support the Content Launcher
server cluster, Content Search feature? |O |

|CONTENTLAUNCHER.S.F01(UP) |Does the DUT support the Content Launcher
server cluster, URL Playback feature? |O |
|===

[[_manual_controllable_4]]
===== link:#_manual_controllable_4[]17.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ALOGIN.S.M.COMMISSIONABLE |Does the DUT support the Content Launcher
server cluster and is Commissionable? |O |

|MC.S.M.UDC |Does the DUT support the commissioning procedure initiated
by a commissionee using User Directed Commissioning? |O |

|MC.S.M.UDCLOGIN |Does the DUT support the commissioning procedure
initiated by a commissionee using User Directed Commissioning without
PIN code entry? |O |
|===

[[_attributes_6]]
===== link:#_attributes_6[]17.2.3. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WAKEONLAN.S.A0000(MACAddress) |Does the DUT support the Wake On LAN
server cluster, _MACAddress_ attribute? |O |

|APPLAUNCHER.S.A0000(CatalogList) |Does the DUT support the Application
Launcher server cluster, _CatalogList_ attribute? |APPLAUNCHER.S.F00(AP)
|

|APPLAUNCHER.S.A0001(CurrentApp) |Does the DUT support the Application
Launcher server cluster, _CurrentApp_ attribute? |O |

|MEDIAINPUT.S.A0000(InputList) |Does the DUT support the Media Input
server cluster, _InputList_ attribute? |M |

|MEDIAINPUT.S.A0001(CurrentInput) |Does the DUT support the Media Input
server cluster, _CurrentInput_ attribute? |M |

|CHANNEL.S.A0000(ChannelList) |Does the DUT support the Channel server
cluster, _ChannelList_ attribute? |CHANNEL.S.F00(CL) |

|CHANNEL.S.A0001(Lineup) |Does the DUT support the Channel server
cluster, _Lineup_ attribute? |CHANNEL.S.F01(LI) |

|CHANNEL.S.A0002(CurrentChannel) |Does the DUT support the Channel
server cluster, _CurrentChannel_ attribute? |O |

|MEDIAPLAYBACK.S.A0000(CurrentState) |Does the DUT support the Media
Playback server cluster, _ CurrentState_ attribute? |M |

|MEDIAPLAYBACK.S.A0001(StartTime) |Does the DUT support the Media
Playback server cluster, _StartTime_ attribute? |MEDIAPLAYBACK.S.F00(AS)
|

|MEDIAPLAYBACK.S.A0002(Duration) |Does the DUT support the Media
Playback server cluster, _Duration_ attribute? |MEDIAPLAYBACK.S.F00(AS)
|

|MEDIAPLAYBACK.S.A0003(SampledPosition) |Does the DUT support the Media
Playback server cluster, _SampledPosition_ attribute?
|MEDIAPLAYBACK.S.F00(AS) |

|MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |Does the DUT support the Media
Playback server cluster, _PlaybackSpeed_ attribute?
|MEDIAPLAYBACK.S.F00(AS) |

|MEDIAPLAYBACK.S.A0005(SeekRangeEnd) |Does the DUT support the Media
Playback server cluster, _SeekRangeEnd_ attribute?
|MEDIAPLAYBACK.S.F00(AS) |

|MEDIAPLAYBACK.S.A0006(SeekRangeStart) |Does the DUT support the Media
Playback server cluster, _SeekRangeStart_ attribute?
|MEDIAPLAYBACK.S.F00(AS) |

|AUDIOOUTPUT.S.A0000(OutputList) |Does the DUT support the Audio Output
server cluster, _OutputList_ attribute? |M |

|AUDIOOUTPUT.S.A0001(CurrentOutput) |Does the DUT support the Audio
Output server cluster, _CurrentOutput_ attribute? |M |

|TGTNAV.S.A0000(TargetList) |Does the DUT support the Target Navigator
server cluster, _TargetList_ attribute? |M |

|TGTNAV.S.A0001(CurrentTarget) |Does the DUT support the Target
Navigator server cluster, _CurrentTarget_ attribute? |O |

|APBSC.S.A0000(VendorName) |Does the DUT support the Application Basic
server cluster, _VendorName_ attribute? |O |

|APBSC.S.A0001(VendorID) |Does the DUT support the Application Basic
server cluster, _VendorID_ attribute? |O |

|APBSC.S.A0002(ApplicationName) |Does the DUT support the Application
Basic server cluster, _ApplicationName_ attribute? |M |

|APBSC.S.A0003(ProductID) |Does the DUT support the Application Basic
server cluster, _ProductID_ attribute? |O |

|APBSC.S.A0004(Application) |Does the DUT support the Application Basic
server cluster, _Application_ attribute? |M |

|APBSC.S.A0005(Status) |Does the DUT support the Application Basic
server cluster, _Status_ attribute? |M |

|APBSC.S.A0006(ApplicationVersion) |Does the DUT support the Application
Basic server cluster, _ApplicationVersion_ attribute? |M |

|APBSC.S.A0007(AllowedVendorList) |Does the DUT support the Application
Basic server cluster, _AllowedVendorList_ attribute? |M |

|CONTENTLAUNCHER.S.A0000(AcceptHeader) |Does the DUT support the Content
Launcher server cluster, _AcceptHeader_ attribute?
|CONTENTLAUNCHER.S.F01(UP) |

|CONTENTLAUNCHER.S.A0001(SupportedStreamingProtocols) |Does the DUT
support the Content Launcher server cluster,
_SupportedStreamingProtocols_ attribute? |CONTENTLAUNCHER.S.F01(UP) |
|===

[[_commands_received_2]]
===== link:#_commands_received_2[]17.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LOWPOWER.S.C00.Rsp(Sleep) |Does the DUT support the Low Power server
cluster, _Sleep_ command? |M |

|KEYPADINPUT.S.C00.Rsp(SendKey) |Does the DUT support the Keypad Input
server cluster, _SendKey_ command? |M |

|APPLAUNCHER.S.C00.Rsp(LaunchApp) |Does the DUT support the Application
Launcher server cluster, _LaunchApp_ command? |M |

|APPLAUNCHER.S.C01.Rsp(StopApp) |Does the DUT support the Application
Launcher server cluster, _StopApp_ command? |M |

|APPLAUNCHER.S.C02.Rsp(HideApp) |Does the DUT support the Application
Launcher server cluster, _HideApp_ command? |M |

|MEDIAINPUT.S.C00.Rsp(SelectInput) |Does the DUT support the Media Input
server cluster, _SelectInput_ command? |M |

|MEDIAINPUT.S.C01.Rsp(ShowStatus) |Does the DUT support the Media Input
server cluster, _ShowStatus_ command? |M |

|MEDIAINPUT.S.C02.Rsp(HideStatus) |Does the DUT support the Media Input
server cluster, _HideStatus_ command? |M |

|MEDIAINPUT.S.C03.Rsp(Rename) |Does the DUT support the Media Input
server cluster, _Rename_ command? |MEDIAINPUT.S.F00(NU) |

|CHANNEL.S.C00.Rsp(ChangeChannel) |Does the DUT support the Channel
server cluster, _ChangeChannel_ command? |CHANNEL.S.F00(CL) |
CHANNEL.S.F01(LI) |

|CHANNEL.S.C02.Rsp(ChangeChannelByNumber) |Does the DUT support the
Channel server cluster, _ChangeChannelByNumber_ command? |M |

|CHANNEL.S.C03.Rsp(SkipChannel) |Does the DUT support the Channel server
cluster, _SkipChannel_ command? |M |

|MEDIAPLAYBACK.S.C00.Rsp(Play) |Does the DUT support the Media Playback
server cluster, _Play_ command? |M |

|MEDIAPLAYBACK.S.C01.Rsp(Pause) |Does the DUT support the Media Playback
server cluster, _Pause_ command? |M |

|MEDIAPLAYBACK.S.C02.Rsp(Stop) |Does the DUT support the Media Playback
server cluster, _Stop_ command? |M |

|MEDIAPLAYBACK.S.C03.Rsp(StartOver) |Does the DUT support the Media
Playback server cluster, _StartOver_ command? |O |

|MEDIAPLAYBACK.S.C04.Rsp(Previous) |Does the DUT support the Media
Playback server cluster, _Previous_ command? |O |

|MEDIAPLAYBACK.S.C05.Rsp(Next) |Does the DUT support the Media Playback
server cluster, _Next_ command? |O |

|MEDIAPLAYBACK.S.C06.Rsp(Rewind) |Does the DUT support the Media
Playback server cluster, _Rewind_ command? |MEDIAPLAYBACK.S.F01(VS) |

|MEDIAPLAYBACK.S.C07.Rsp(FastForward) |Does the DUT support the Media
Playback server cluster, _FastForward_ command? |MEDIAPLAYBACK.S.F01(VS)
|

|MEDIAPLAYBACK.S.C08.Rsp(SkipForward) |Does the DUT support the Media
Playback server cluster, _SkipForward_ command? |O |

|MEDIAPLAYBACK.S.C09.Rsp(SkipBackward) |Does the DUT support the Media
Playback server cluster, _SkipBackward_ command? |O |

|MEDIAPLAYBACK.S.C0b.Rsp(Seek) |Does the DUT support the Media Playback
server cluster, _Seek_ command? |MEDIAPLAYBACK.S.F00(AS) |

|AUDIOOUTPUT.S.C00.Rsp(SelectOutput) |Does the DUT support the Audio
Output server cluster, _SelectOutput_ command? |M |

|AUDIOOUTPUT.S.C01.Rsp(RenameOutput) |Does the DUT support the Audio
Output server cluster, _RenameOutput_ command? |AUDIOOUTPUT.S.F00(NU) |

|TGTNAV.S.C00.Rsp(NavigateTarget) |Does the DUT support the Target
Navigator server cluster, _NavigateTarget_ command? |M |

|CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |Does the DUT support the
Content Launcher server cluster, _LaunchContent_ command?
|CONTENTLAUNCHER.S.F00(CS) |

|CONTENTLAUNCHER.S.C01.Rsp(LaunchURL) |Does the DUT support the Content
Launcher server cluster, _LaunchURL_ command? |CONTENTLAUNCHER.S.F01(UP)
|

|ALOGIN.S.C00.Rsp(GetSetupPIN) |Does the DUT support the Account Login
server cluster, _GetSetupPIN_ command? |M |

|ALOGIN.S.C02.Rsp(Login) |Does the DUT support the Account Login server
cluster, _Login_ command? |M |

|ALOGIN.S.C03.Rsp(Logout) |Does the DUT support the Account Login server
cluster, _Logout_ command? |M |
|===

[[_client_2]]
==== link:#_client_2[]17.3. Client

[[_commands_generated_2]]
===== link:#_commands_generated_2[]17.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LOWPOWER.C.C00.Tx(Sleep) |Does the DUT support the Low Power client
cluster, _Sleep_ command? |O |

|KEYPADINPUT.C.C00.Tx(SendKey) |Does the DUT support the Keypad Input
client cluster, _SendKey_ command? |O |

|APPLAUNCHER.C.C00.Tx(LaunchApp) |Does the DUT support the Application
Launcher client cluster, _LaunchApp_ command? |O |

|APPLAUNCHER.C.C01.Tx(StopApp) |Does the DUT support the Application
Launcher client cluster, _StopApp_ command? |O |

|APPLAUNCHER.C.C02.Tx(HideApp) |Does the DUT support the Application
Launcher client cluster, _HideApp_ command? |O |

|MEDIAINPUT.C.C00.Tx(SelectInput) |Does the DUT support the Media Input
client cluster, _SelectInput_ command? |O |

|MEDIAINPUT.C.C01.Tx(ShowStatus) |Does the DUT support the Media Input
client cluster, _ShowStatus_ command? |O |

|MEDIAINPUT.C.C02.Tx(HideStatus) |Does the DUT support the Media Input
client cluster, _HideStatus_ command? |O |

|MEDIAINPUT.C.C03.Tx(Rename) |Does the DUT support the Media Input
server cluster, _Rename_ command? |O |

|CHANNEL.C.C00.Tx(ChangeChannel) |Does the DUT support the Channel
client cluster, _ChangeChannel_ command? |O |

|CHANNEL.C.C02.Tx(ChangeChannelByNumber) |Does the DUT support the
Channel client cluster, _ChangeChannelByNumber_ command? |O |

|CHANNEL.C.C03.Tx(SkipChannel) |Does the DUT support the Channel client
cluster, _SkipChannel_ command? |O |

|MEDIAPLAYBACK.C.C00.Tx(Play) |Does the DUT support the Media Playback
client cluster, _Play_ command? |O |

|MEDIAPLAYBACK.C.C01.Tx(Pause) |Does the DUT support the Media Playback
client cluster, _Pause_ command? |O |

|MEDIAPLAYBACK.C.C02.Tx(Stop) |Does the DUT support the Media Playback
client cluster, _Stop_ command? |O |

|MEDIAPLAYBACK.C.C03.Tx(StartOver) |Does the DUT support the Media
Playback client cluster, _StartOver_ command? |O |

|MEDIAPLAYBACK.C.C04.Tx(Previous) |Does the DUT support the Media
Playback client cluster, _Previous_ command? |O |

|MEDIAPLAYBACK.C.C05.Tx(Next) |Does the DUT support the Media Playback
client cluster, _Next_ command? |O |

|MEDIAPLAYBACK.C.C06.Tx(Rewind) |Does the DUT support the Media Playback
client cluster, _Rewind_ command? |O |

|MEDIAPLAYBACK.C.C07.Tx(FastForward) |Does the DUT support the Media
Playback client cluster, _FastForward_ command? |O |

|MEDIAPLAYBACK.C.C08.Tx(SkipForward) |Does the DUT support the Media
Playback client cluster, _SkipForward_ command? |O |

|MEDIAPLAYBACK.C.C09.Tx(SkipBackward) |Does the DUT support the Media
Playback client cluster, _SkipBackward_ command? |O |

|MEDIAPLAYBACK.C.C0b.Tx(Seek) |Does the DUT support the Media Playback
client cluster, _Seek_ command? |O |

|AUDIOOUTPUT.C.C00.Tx(SelectOutput) |Does the DUT support the Audio
Output client cluster, _SelectOutput_ command? |O |

|AUDIOOUTPUT.C.C01.Tx(RenameOutput) |Does the DUT support the Audio
Output client cluster, _RenameOutput_ command? |O |

|TGTNAV.C.C00.Tx(NavigateTarget) |Does the DUT support the Target
Navigator client cluster, _NavigateTarget_ command? |O |

|CONTENTLAUNCHER.C.C00.Tx(LaunchContent) |Does the DUT support the
Content Launcher client cluster, _LaunchContent_ command? |O |

|CONTENTLAUNCHER.C.C01.Tx(LaunchURL) |Does the DUT support the Content
Launcher client cluster, _LaunchURL_ command? |O |

|ALOGIN.C.C00.Tx(GetSetupPIN) |Does the DUT support the Account Login
client cluster, _GetSetupPIN_ command? |O |

|ALOGIN.C.C00.Tx(Login) |Does the DUT support the Account Login client
cluster, _Login_ command? |O |

|ALOGIN.C.C00.Tx(Logout) |Does the DUT support the Account Login client
cluster, _Logout_ command? |O |
|===

[[_test_case_list_6]]
=== link:#_test_case_list_6[]18. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-LOWPOWER-1.1 |Global attributes - Low Power Cluster (DUT as Server)

|TC-KEYPADINPUT-1.2 |Global attributes - Navigation Keypad Input Cluster
(DUT as Server)

|TC-APPLAUNCHER-1.3 |Global attributes - Application Launcher Cluster
(DUT as Server)

|TC-MEDIAINPUT-1.4 |Global attributes - Media Input Cluster (DUT as
Server)

|TC-WAKEONLAN-1.5 |Global attributes - Wake on LAN Cluster (DUT as
Server)

|TC-CHANNEL-1.6 |Global attributes - Channel Cluster (DUT as Server)

|TC-MEDIAPLAYBACK-1.7 |Global attributes - Media Playback Cluster (DUT
as Server)

|TC-AUDIOOUTPUT-1.8 |Global attributes - Audio Output Cluster (DUT as
Server)

|TC-TGTNAV-1.9 |Global attributes - Target Navigator Cluster (DUT as
Server)

|TC-APBSC-1.10 |Global attributes - Application Basic Cluster (DUT as
Server)

|TC-CONTENTLAUNCHER-1.11 |Global attributes - Content Launcher Cluster
(DUT as Server)

|TC-ALOGIN-1.12 |Global attributes - Account Login Cluster (DUT as
Server)

|TC-LOWPOWER-2.1 |Low Power Mode Verification (DUT as Server)

|TC-LOWPOWER-2.2 |Low Power Mode Verification (DUT as Client)

|TC-KEYPADINPUT-3.1 |Send Key Command Verification (DUT as Client)

|TC-KEYPADINPUT-3.2 |Location Keys Verification

|TC-KEYPADINPUT-3.3 |Number Keys Verification

|TC-APPLAUNCHER-3.5 |Catalog List Verification

|TC-APPLAUNCHER-3.6 |Current App Verification

|TC-APPLAUNCHER-3.7 |Launch Application Verification

|TC-APPLAUNCHER-3.7.1 |Launch Application Verification (DUT as Client)

|TC-APPLAUNCHER-3.8 |Stop Application Verification

|TC-APPLAUNCHER-3.8.1 |Stop Application Verification (DUT as Client)

|TC-APPLAUNCHER-3.9 |Hide Application Verification

|TC-APPLAUNCHER-3.9.1 |Hide Application Verification (DUT as Client)

|TC-MEDIAINPUT-3.10 |Input List Verification

|TC-MEDIAINPUT-3.11 |Select Input Verification

|TC-MEDIAINPUT-3.12 |Show & Hide Input Status Verification

|TC-MEDIAINPUT-3.13 |Rename Input Verification

|TC-MEDIAINPUT-3.14 |Select Input Verification (DUT as Client)

|TC-MEDIAINPUT-3.15 |Show Input Status Verification (DUT as Client)

|TC-MEDIAINPUT-3.16 |Hide Input Status Verification (DUT as Client)

|TC-MEDIAINPUT-3.17 |Rename Input Verification (DUT as Client)

|TC-WAKEONLAN-4.1 |Wake-On LAN Verification

|TC-CHANNEL-5.1 |List TV Channels Verification

|TC-CHANNEL-5.2 |Change Channel by Number Verification

|TC-CHANNEL-5.3 |Skip Channel Verification

|TC-CHANNEL-5.4 |Change Channel Verification (DUT as Client)

|TC-CHANNEL-5.5 |Change Channel by Number Verification (DUT as Client)

|TC-CHANNEL-5.6 |Skip Channel Verification (DUT as Client)

|TC-MEDIAPLAYBACK-6.1 |Mandatory Media Playback Verification

|TC-MEDIAPLAYBACK-6.2 |Optional Media Playback Verification

|TC-MEDIAPLAYBACK-6.3 |Advanced Seek Media Playback Verification

|TC-MEDIAPLAYBACK-6.4 |Variable Speed Media Playback Verification

|TC-MEDIAPLAYBACK-6.5 |Mandatory Media Playback Verification (DUT as
Client)

|TC-MEDIAPLAYBACK-6.6 |Optional Media Playback Verification (DUT as
Client)

|TC-AUDIOOUTPUT-7.1 |Select Audio Output Verification

|TC-AUDIOOUTPUT-7.2 |Rename Audio Output Verification

|TC-AUDIOOUTPUT-7.3 |Select Audio Output Verification (DUT as Client)

|TC-AUDIOOUTPUT-7.4 |Rename Audio Output Verification (DUT as Client)

|TC-TGTNAV-8.1 |Navigate Target Verification

|TC-TGTNAV-8.2 |Navigate Target Verification (DUT as Client)

|TC-APBSC-9.1 |Application Basic Attribute Verification

|TC-CONTENTLAUNCHER-10.1 |Read Content Launcher Attributes

|TC-CONTENTLAUNCHER-10.3 |Launch Content Verification

|TC-CONTENTLAUNCHER-10.4 |Launch Content Verification (DUT as Client)

|TC-CONTENTLAUNCHER-10.5 |Launch URL Verification

|TC-CONTENTLAUNCHER-10.6 |Launch URL Verification (DUT as Client)

|TC-CONTENTLAUNCHER-10.7 |Content Search Verification

|TC-MC-11.1 |Casting Video Player via User-Directed Commissioning
Verification

|TC-MC-11.2 |Casting Video Player via UX Screen with PIN Verification

|TC-ALOGIN-12.1 |Account Login Verification

|TC-ALOGIN-12.2 |Account Login Verification (DUT as Client)
|===

[[_test_cases_6]]
=== link:#_test_cases_6[]19. Test Cases

'''''

[[_global_attribute_test_cases]]
==== link:#_global_attribute_test_cases[]19.1. Global Attribute test cases

'''''

[[_tc_lowpower_1_1_global_attributes_low_power_cluster_dut_as_server]]
===== link:#_tc_lowpower_1_1_global_attributes_low_power_cluster_dut_as_server[]19.1.1. [TC-LOWPOWER-1.1] Global attributes - Low Power Cluster (DUT as Server)

[[_category_21]]
====== link:#_category_21[]Category

Functional conformance

[[_purpose_21]]
====== link:#_purpose_21[]Purpose

This test case verifies the Low Power cluster global attributes

[[_pics_21]]
====== link:#_pics_21[]PICS

* LOWPOWER.S

[[_required_devices_21]]
====== link:#_required_devices_21[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_16]]
====== link:#_test_setup_16[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_21]]
====== link:#_test_procedure_21[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Low Power 1.1.1 | |TH reads the _ClusterRevision attribute_ from the
DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Low Power 1.2 | |TH reads the _FeatureMap attribute_ from the DUT
|Verify that the DUT response indicates that the FeatureMap attribute
has the value 0 or returns a general error that the attribute is not
supported.

|3 |Low Power 1.2 | |TH reads the _AttributeList attribute_ from the DUT
a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Low Power 1.3 | |TH reads the _AcceptedCommandList attribute_ from
the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the value
0.

|5 |Low Power 1.3 | |TH reads the _GeneratedCommandList attribute_ from
the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be an empty list.

|6 | | |TH reads the _EventList attribute_ from the DUT |Verify that the
DUT response provides a list of supported events, which for this cluster
should be an empty list.
|===

[[_notestesting_considerations_22]]
====== link:#_notestesting_considerations_22[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit a639682 on
Jan 12

[[_tc_keypadinput_1_2_global_attributes_keypad_input_cluster_dut_as_server]]
===== link:#_tc_keypadinput_1_2_global_attributes_keypad_input_cluster_dut_as_server[]19.1.2. [TC-KEYPADINPUT-1.2] Global attributes - Keypad Input Cluster (DUT as Server)

[[_category_22]]
====== link:#_category_22[]Category

Functional conformance

[[_purpose_22]]
====== link:#_purpose_22[]Purpose

This test case verifies the Keypad Input cluster global attributes

[[_pics_22]]
====== link:#_pics_22[]PICS

* KEYPADINPUT.S

[[_required_devices_22]]
====== link:#_required_devices_22[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_17]]
====== link:#_test_setup_17[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_22]]
====== link:#_test_procedure_22[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Keypad Input 1.1.1 | |TH reads the _ClusterRevision attribute_ from
the DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Keypad Input 1.2 | |TH reads the _FeatureMap attribute_ from the DUT
a|
Verify that the DUT response indicates that the FeatureMap attribute has
the following values based on feature/PICS support:

Bit 0 - Set to 1 if the DUT supports Navigation Keys
(KEYPADINPUT.S.F00(NV) is true)

Bit 1 - Set to 1 if the DUT supports Location Keys
(KEYPADINPUT.S.F01(LK) is true)

Bit 2 - Set to 1 if the DUT supports Number Keys (KEYPADINPUT.S.F02(NK)
is true)

|3 |Keypad Input 1.2 | |TH reads the _AttributeList attribute_ from the
DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Keypad Input 1.3 | |TH reads the _AcceptedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the value
0.

|5 |Keypad Input 1.3 | |TH reads the _GeneratedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the value
1.

|6 |Keypad Input | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_23]]
====== link:#_notestesting_considerations_23[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit b0c035d on
Feb 11

[[_tc_applauncher_1_3_global_attributes_application_launcher_cluster_dut_as_server]]
===== link:#_tc_applauncher_1_3_global_attributes_application_launcher_cluster_dut_as_server[]19.1.3. [TC-APPLAUNCHER-1.3] Global attributes - Application Launcher Cluster (DUT as Server)

[[_category_23]]
====== link:#_category_23[]Category

Functional conformance

[[_purpose_23]]
====== link:#_purpose_23[]Purpose

This test case verifies the Application Launcher cluster global
attributes

[[_pics_23]]
====== link:#_pics_23[]PICS

* APPLAUNCHER.S

[[_required_devices_23]]
====== link:#_required_devices_23[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_18]]
====== link:#_test_setup_18[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_23]]
====== link:#_test_procedure_23[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Application Launcher 1.1.1 | |TH reads the _ClusterRevision
attribute_ from the DUT |Verify that the DUT response indicates that the
ClusterRevision attribute has the value 1

|2 |Application Launcher 1.2 | |TH reads the _FeatureMap attribute_ from
the DUT |Verify that the DUT response indicates that the FeatureMap
attribute has bit 0 set to 1 if the DUT supports the Application
Platform feature (APPLAUNCHER.S.F00(AP) is true).

|3 |Application Launcher 1.2 | |TH reads the _AttributeList attribute_
from the DUT a|
Verify that the DUT response provides a list of supported attributes,
which should have the following entries based on feature/PICS support:

0 - CatalogList attribute ( APPLAUNCHER.S.A0000(CatalogList))

1 - CurrentApp attribute (APPLAUNCHER.S.A0001(CurrentApp))

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Application Launcher 1.3 | |TH reads the _AcceptedCommandList
attribute_ from the DUT |Verify that the DUT response provides a list of
supported commands, which for this cluster should be a list containing
the values 0, 1, and 2.

|5 |Application Launcher 1.3 | |TH reads the _GeneratedCommandList
attribute_ from the DUT |Verify that the DUT response provides a list of
supported commands, which for this cluster should be a list containing
the value 3.

|6 |Application Launcher | |TH reads the _EventList attribute_ from the
DUT |Verify that the DUT response provides a list of supported events,
which for this cluster should be an empty list.
|===

[[_notestesting_considerations_24]]
====== link:#_notestesting_considerations_24[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit 446f4fe on
Jan 17

[[_tc_mediainput_1_4_global_attributes_media_input_cluster_dut_as_server]]
===== link:#_tc_mediainput_1_4_global_attributes_media_input_cluster_dut_as_server[]19.1.4. [TC-MEDIAINPUT-1.4] Global attributes - Media Input Cluster (DUT as Server)

[[_category_24]]
====== link:#_category_24[]Category

Functional conformance

[[_purpose_24]]
====== link:#_purpose_24[]Purpose

This test case verifies the Media Input cluster global attributes

[[_pics_24]]
====== link:#_pics_24[]PICS

* MEDIAINPUT.S

[[_required_devices_24]]
====== link:#_required_devices_24[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_19]]
====== link:#_test_setup_19[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_24]]
====== link:#_test_procedure_24[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Media Input 1.1.1 | |TH reads the _ClusterRevision attribute_ from
the DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Media Input 1.2 | |TH reads the _FeatureMap attribute_ from the DUT
|Verify that the DUT response indicates that the FeatureMap attribute
has bit 0 set to 1 if the DUT supports the Name Updates feature
(MEDIAINPUT.S.F00(NU) is true).

|3 |Media Input 1.2 | |TH reads the _AttributeList attribute_ from the
DUT a|
Verify that the DUT response provides a list of supported attributes,
which should have the following entries based on feature/PICS support:

0 - CatalogList attribute (MEDIAINPUT.S.A0000(InputList))

1 - CurrentApp attribute (MEDIAINPUT.S.A0001(CurrentInput))

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Media Input 1.4 | |TH reads the _AcceptedCommandList attribute_ from
the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the values
0, 1, 2, and 3.

|5 |Media Input 1.4 | |TH reads the _GeneratedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be an empty list.

|6 |Media Input | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_25]]
====== link:#_notestesting_considerations_25[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit b0c035d on
Feb 7

[[_tc_wakeonlan_1_5_global_attributes_wake_on_lan_cluster_dut_as_server]]
===== link:#_tc_wakeonlan_1_5_global_attributes_wake_on_lan_cluster_dut_as_server[]19.1.5. [TC-WAKEONLAN-1.5] Global attributes - Wake on LAN Cluster (DUT as Server)

[[_category_25]]
====== link:#_category_25[]Category

Functional conformance

[[_purpose_25]]
====== link:#_purpose_25[]Purpose

This test case verifies the Wake On LAN cluster global attributes

[[_pics_25]]
====== link:#_pics_25[]PICS

* WAKEONLAN.S

[[_required_devices_25]]
====== link:#_required_devices_25[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_20]]
====== link:#_test_setup_20[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_25]]
====== link:#_test_procedure_25[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Wake on LAN 1.1.1 | |TH reads the _ClusterRevision attribute_ from
the DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Wake on LAN 1.2 | |TH reads the _FeatureMap attribute_ from the DUT
|Verify that the DUT response has the value 0 or returns a general error
that the attribute is not supported.

|3 |Wake on LAN 1.2 | |TH reads the _AttributeList attribute_ from the
DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

0 - MACAddress

1 - LinkLocalAddress

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Wake on LAN 1.4 | |TH reads the _AcceptedCommandList attribute_ from
the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be an empty list.

|5 |Wake on LAN 1.4 | |TH reads the _GeneratedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be an empty list.

|6 |Wake on LAN | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_26]]
====== link:#_notestesting_considerations_26[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit d4a89ef on
Dec 10, 2021

[[_tc_channel_1_6_global_attributes_channel_cluster_dut_as_server]]
===== link:#_tc_channel_1_6_global_attributes_channel_cluster_dut_as_server[]19.1.6. [TC-CHANNEL-1.6] Global attributes - Channel Cluster (DUT as Server)

[[_category_26]]
====== link:#_category_26[]Category

Functional conformance

[[_purpose_26]]
====== link:#_purpose_26[]Purpose

This test case verifies the Channel cluster global attributes

[[_pics_26]]
====== link:#_pics_26[]PICS

* CHANNEL.S

[[_required_devices_26]]
====== link:#_required_devices_26[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_21]]
====== link:#_test_setup_21[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_26]]
====== link:#_test_procedure_26[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Channel 1.1.1 | |TH reads the _ClusterRevision attribute_ from the
DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Channel 1.2 | |TH reads the _FeatureMap attribute_ from the DUT a|
Verify that the DUT response indicates that the FeatureMap attribute has
the following values based on feature/PICS support:

Bit 0 - Set to 1 if the DUT supports Channel Lists (CHANNEL.S.F00(CL) is
true)

Bit 1 - Set to 1 if the DUT supports Lineup Info (CHANNEL.S.F01(LI) is
true)

|3 |Channel 1.2 | |TH reads the _AttributeList attribute_ from the DUT
a|
Verify that the DUT response provides a list of supported attributes,
which should have the following entries based on feature/PICS support:

0 - ChannelList attribute (CHANNEL.S.A0000(ChannelList))

1 - Lineup attribute (CHANNEL.S.A0001(Lineup))

2 - CurrentChannel attribute (CHANNEL.S.A0002(CurrentChannel))

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Channel 1.4 | |TH reads the _AcceptedCommandList attribute_ from the
DUT a|
Verify that the DUT response provides a list of supported commands,
which for this cluster should contain list ID entries as follows based
on command/PICS support:

0 - ChangeChannel command (CHANNEL.S.C00.Rsp(ChangeChannel))

2 - ChangeChannelByNumber command
(CHANNEL.S.C02.Rsp(ChangeChannelByNumber))

3 - SkipChannel command (CHANNEL.S.C03.Rsp(SkipChannel))

|5 |Channel 1.4 | |TH reads the _GeneratedCommandList attribute_ from
the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should contain a list entry with ID 1
if the DUT supports ChangeChannelResponse (CHANNEL.S.F00(CL) or
CHANNEL.S.F01(LI) is true).

|6 |Channel | |TH reads the _EventList attribute_ from the DUT |Verify
that the DUT response provides a list of supported events, which for
this cluster should be an empty list.
|===

[[_notestesting_considerations_27]]
====== link:#_notestesting_considerations_27[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit 2ce84d6 on
Jan 24

[[_tc_mediaplayback_1_7_global_attributes_media_playback_cluster_dut_as_server]]
===== link:#_tc_mediaplayback_1_7_global_attributes_media_playback_cluster_dut_as_server[]19.1.7. [TC-MEDIAPLAYBACK-1.7] Global attributes - Media Playback Cluster (DUT as Server)

[[_category_27]]
====== link:#_category_27[]Category

Functional conformance

[[_purpose_27]]
====== link:#_purpose_27[]Purpose

This test case verifies the Media Playback cluster global attributes

[[_pics_27]]
====== link:#_pics_27[]PICS

* MEDIAPLAYBACK.S

[[_required_devices_27]]
====== link:#_required_devices_27[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_22]]
====== link:#_test_setup_22[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_27]]
====== link:#_test_procedure_27[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Media Playback 1.1.1 | |TH reads the _ClusterRevision attribute_
from the DUT |Verify that the DUT response indicates that the
ClusterRevision attribute has the value 1

|2 |Media Playback 1.2 | |TH reads the _FeatureMap attribute_ from the
DUT a|
Verify that the DUT response indicates that the FeatureMap attribute has
the following values based on feature/PICS support:

Bit 0 - Set to 1 if the DUT supports Advanced Seek
(MEDIAPLAYBACK.S.F00(AS) is true)

Bit 1 - Set to 1 if the DUT supports Variable Speed
(MEDIAPLAYBACK.S.F01(VS) is true)

|3 |Media Playback 1.2 | |TH reads the _AttributeList attribute_ from
the DUT a|
Verify that the DUT response provides a list of supported attributes,
which should have the following entries based on feature/PICS support:

0 - CurrentState (mandatory cluster attribute)

1 - StartTime (MEDIAPLAYBACK.S.A0001(StartTime))

2 - Duration (MEDIAPLAYBACK.S.A0002(Duration))

3 - SampledPosition (MEDIAPLAYBACK.S.A0003(SampledPosition))

4 - PlaybackSpeed (MEDIAPLAYBACK.S.A0004(PlaybackSpeed))

5 - SeekRangeEnd (MEDIAPLAYBACK.S.A0005(SeekRangeEnd))

6 - SeekRangeStart (MEDIAPLAYBACK.S.A0006(SeekRangeStart))

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Media Playback 1.4 | |TH reads the _AcceptedCommandList attribute_
from the DUT a|
Verify that the DUT response provides a list of supported commands,
which for this cluster should contain list ID entries as follows based
on command/PICS support:

0 - Play (mandatory)

1 - Pause (mandatory)

2 - Stop (mandatory)

3 - StartOver (MEDIAPLAYBACK.S.C03.Rsp(StartOver))

4 - Previous (MEDIAPLAYBACK.S.C04.Rsp(Previous))

5 - Next (MEDIAPLAYBACK.S.C05.Rsp(Next))

6 - Rewind (MEDIAPLAYBACK.S.C06.Rsp(Rewind))

7 - FastForward (MEDIAPLAYBACK.S.C07.Rsp(FastForward))

8 - SkipForward (MEDIAPLAYBACK.S.C08.Rsp(SkipForward))

9 - SkipBackward (MEDIAPLAYBACK.S.C09.Rsp(SkipBackward))

11 - Seek (MEDIAPLAYBACK.S.C0b.Rsp(Seek))

|5 |Media Playback 1.4 | |TH reads the _GeneratedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should contain a list entry with ID 10
(PlaybackResponse, which is mandatory).

|6 |Media Playback | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_28]]
====== link:#_notestesting_considerations_28[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit 886d7f9 on
Feb 10

[[_tc_audiooutput_1_8_global_attributes_audio_output_cluster_dut_as_server]]
===== link:#_tc_audiooutput_1_8_global_attributes_audio_output_cluster_dut_as_server[]19.1.8. [TC-AUDIOOUTPUT-1.8] Global attributes - Audio Output Cluster (DUT as Server)

[[_category_28]]
====== link:#_category_28[]Category

Functional conformance

[[_purpose_28]]
====== link:#_purpose_28[]Purpose

This test case verifies the Audio Output cluster global attributes

[[_pics_28]]
====== link:#_pics_28[]PICS

* AUDIOOUTPUT.S

[[_required_devices_28]]
====== link:#_required_devices_28[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_23]]
====== link:#_test_setup_23[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_28]]
====== link:#_test_procedure_28[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Audio Output 1.1.1 | |TH reads the _ClusterRevision attribute_ from
the DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Audio Output 1.2 | |TH reads the _FeatureMap attribute_ from the DUT
|Verify that the DUT response indicates that the FeatureMap attribute
has bit 1 set to 1 if the device supports Name Updates
(AUDIOOUTPUT.S.F00(NU) is true).

|3 |Audio Output 1.2 | |TH reads the _AttributeList attribute_ from the
DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

0 - OutputList (mandatory)

1 - CurrentOutput (mandatory)

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Audio Output 1.3 | |TH reads the _AcceptedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the value
0.

|5 |Audio Output 1.3 | |TH reads the _GeneratedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be an empty list.

|6 |Audio Output | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_29]]
====== link:#_notestesting_considerations_29[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit b0c035d on
Feb 8

[[_tc_tgtnav_1_9_global_attributes_target_navigator_cluster_dut_as_server]]
===== link:#_tc_tgtnav_1_9_global_attributes_target_navigator_cluster_dut_as_server[]19.1.9. [TC-TGTNAV-1.9] Global attributes - Target Navigator Cluster (DUT as Server)

[[_category_29]]
====== link:#_category_29[]Category

Functional conformance

[[_purpose_29]]
====== link:#_purpose_29[]Purpose

This test case verifies the Target Navigator cluster global attributes

[[_pics_29]]
====== link:#_pics_29[]PICS

* TGTNAV.S

[[_required_devices_29]]
====== link:#_required_devices_29[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_24]]
====== link:#_test_setup_24[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_29]]
====== link:#_test_procedure_29[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Target Navigator 1.1.1 | |TH reads the _ClusterRevision attribute_
from the DUT |Verify that the DUT response indicates that the
ClusterRevision attribute has the value 1

|2 |Target Navigator 1.2 | |TH reads the _FeatureMap attribute_ from the
DUT |Verify that the DUT response has the value 0 or returns a general
error that the attribute is not supported.

|3 |Target Navigator 1.2 | |TH reads the _AttributeList attribute_ from
the DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

0 - TargetList (mandatory)

1 - CurrentTarget (TGTNAV.S.A0001(CurrentTarget))

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Target Navigator 1.3 | |TH reads the _AcceptedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the value
0.

|5 |Target Navigator 1.3 | |TH reads the _GeneratedCommandList
attribute_ from the DUT |Verify that the DUT response provides a list of
supported commands, which for this cluster should be a list containing
the value 1.

|6 |Target Navigator | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_30]]
====== link:#_notestesting_considerations_30[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit 68e04f6 on
Feb 10

[[_tc_apbsc_1_10_global_attributes_application_basic_cluster_dut_as_server]]
===== link:#_tc_apbsc_1_10_global_attributes_application_basic_cluster_dut_as_server[]19.1.10. [TC-APBSC-1.10] Global attributes - Application Basic Cluster (DUT as Server)

[[_category_30]]
====== link:#_category_30[]Category

Functional conformance

[[_purpose_30]]
====== link:#_purpose_30[]Purpose

This test case verifies the Application Basic cluster global attributes

[[_pics_30]]
====== link:#_pics_30[]PICS

* APBSC.S

[[_required_devices_30]]
====== link:#_required_devices_30[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_25]]
====== link:#_test_setup_25[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_30]]
====== link:#_test_procedure_30[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Application Basic 1.1.1 | |TH reads the _ClusterRevision attribute_
from the DUT |Verify that the DUT response indicates that the
ClusterRevision attribute has the value 1

|2 |Application Basic 1.2 | |TH reads the _FeatureMap attribute_ from
the DUT |Verify that the DUT response has the value 0 or returns a
general error that the attribute is not supported.

|3 |Application Basic 1.2 | |TH reads the _AttributeList attribute_ from
the DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

0 - VendorName (APBSC.S.A0000(VendorName))

1 - VendorID (APBSC.S.A0001(VendorID))

2 - ApplicationName (mandatory)

3 - ProductID (APBSC.S.A0003(ProductID))

4 - Application (mandatory)

5 - Status (mandatory)

6 - ApplicationVersion (mandatory)

7 - AllowedVendorList (mandatory)

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Application Basic 1.3 | |TH reads the _AcceptedCommandList
attribute_ from the DUT |Verify that the DUT response provides a list of
supported commands, which for this cluster should be an empty list.

|5 |Application Basic 1.3 | |TH reads the _GeneratedCommandList
attribute_ from the DUT |Verify that the DUT response provides an empty
list of supported commands, which for this cluster should be an empty
list.

|6 |Application Basic | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_31]]
====== link:#_notestesting_considerations_31[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit 8110d7e on
Jan 19

[[_tc_contentlauncher_1_11_global_attributes_content_launcher_cluster_dut_as_server]]
===== link:#_tc_contentlauncher_1_11_global_attributes_content_launcher_cluster_dut_as_server[]19.1.11. [TC-CONTENTLAUNCHER-1.11] Global attributes - Content Launcher Cluster (DUT as Server)

[[_category_31]]
====== link:#_category_31[]Category

Functional conformance

[[_purpose_31]]
====== link:#_purpose_31[]Purpose

This test case verifies the Content Launcher cluster global attributes

[[_pics_31]]
====== link:#_pics_31[]PICS

* CONTENTLAUNCHER.S

[[_required_devices_31]]
====== link:#_required_devices_31[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_26]]
====== link:#_test_setup_26[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_31]]
====== link:#_test_procedure_31[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Content Launcher 1.1.1 | |TH reads the _ClusterRevision attribute_
from the DUT |Verify that the DUT response indicates that the
ClusterRevision attribute has the value 1

|2 |Content Launcher 1.2 | |TH reads the _FeatureMap attribute_ from the
DUT a|
Verify that the DUT response indicates that the FeatureMap attribute has
the following values based on feature/PICS support:

Bit 0 - Set to 1 if the DUT supports Content Search
(CONTENTLAUNCHER.S.F00(CS) is true)

Bit 1 - Set to 1 if the DUT supports URL Playback
(CONTENTLAUNCHER.S.F01(UP) is true)

|3 |Content Launcher 1.2 | |TH reads the _AttributeList attribute_ from
the DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

0 - AcceptHeader (CONTENTLAUNCHER.S.A0000(AcceptHeader))

1 - SupportedStreamingProtocols
(CONTENTLAUNCHER.S.A0001(SupportedStreamingProtocols))

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Content Launcher 1.3 | |TH reads the _AcceptedCommandList attribute_
from the DUT a|
Verify that the DUT response provides a list of supported commands,
which for this cluster should contain list ID entries as follows based
on command/PICS support:

0 - LaunchContent command (CONTENTLAUNCHER.C.C00.Tx(LaunchContent))

1 - LaunchURL command (CONTENTLAUNCHER.C.C01.Tx(LaunchURL))

|5 |Content Launcher 1.3 | |TH reads the _GeneratedCommandList
attribute_ from the DUT |Verify that the DUT response provides a list of
supported commands, which for this cluster should be a list containing
the value 2.

|6 |Content Launcher | |TH reads the _EventList attribute_ from the DUT
|Verify that the DUT response provides a list of supported events, which
for this cluster should be an empty list.
|===

[[_notestesting_considerations_32]]
====== link:#_notestesting_considerations_32[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit 68e04f6 on
Feb 10

[[_tc_alogin_1_12_global_attributes_account_login_cluster_dut_as_server]]
===== link:#_tc_alogin_1_12_global_attributes_account_login_cluster_dut_as_server[]19.1.12. [TC-ALOGIN-1.12] Global attributes - Account Login Cluster (DUT as Server)

[[_category_32]]
====== link:#_category_32[]Category

Functional conformance

[[_purpose_32]]
====== link:#_purpose_32[]Purpose

This test case verifies the Account Login cluster global attributes

[[_pics_32]]
====== link:#_pics_32[]PICS

* ALOGIN.S

[[_required_devices_32]]
====== link:#_required_devices_32[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_setup_27]]
====== link:#_test_setup_27[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_32]]
====== link:#_test_procedure_32[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |Account Login 1.1.1 | |TH reads the _ClusterRevision attribute_ from
the DUT |Verify that the DUT response indicates that the ClusterRevision
attribute has the value 1

|2 |Account Login 1.2 | |TH reads the _FeatureMap attribute_ from the
DUT |Verify that the DUT response indicates that the FeatureMap
attribute has the value 0 or returns a general error that the attribute
is not supported.

|3 |Account Login 1.2 | |TH reads the _AttributeList attribute_ from the
DUT a|
Verify that the DUT response provides a list of supported attributes,
which for this cluster should contain:

65528 (0xFFF8) - GeneratedCommandList

65529 (0xFFF9) - AcceptedCommandList

65531 (0xFFFB) - AttributeList

65532 (0xFFFC) - FeatureMap

65533 (0xFFFD) - ClusterRevision

|4 |Account Login 1.3 | |TH reads the _AcceptedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the values
0, 2, and 3.

|5 |Account Login 1.3 | |TH reads the _GeneratedCommandList attribute_
from the DUT |Verify that the DUT response provides a list of supported
commands, which for this cluster should be a list containing the value
1.

|6 | | |TH reads the _EventList attribute_ from the DUT |Verify that the
DUT response provides a list of supported events, which for this cluster
should be an empty list.
|===

[[_notestesting_considerations_33]]
====== link:#_notestesting_considerations_33[]Notes/Testing Considerations

Test Step #6 cannot be executed with V1.0 SDK. Latest commit b0c035d on
Feb 8

[[_low_power_cluster_test_cases]]
==== link:#_low_power_cluster_test_cases[]19.2. Low Power Cluster Test Cases

'''''

[[_tc_lowpower_2_1_low_power_mode_verification_dut_as_server]]
===== link:#_tc_lowpower_2_1_low_power_mode_verification_dut_as_server[]19.2.1. [TC-LOWPOWER-2.1] Low Power Mode Verification (DUT as Server)

[[_category_33]]
====== link:#_category_33[]Category

Functional conformance

[[_purpose_33]]
====== link:#_purpose_33[]Purpose

This test case verifies the low power cluster server functionality

[[_pics_33]]
====== link:#_pics_33[]PICS

* LOWPOWER.S

[[_preconditions]]
====== link:#_preconditions[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_33]]
====== link:#_required_devices_33[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_16]]
====== link:#_device_topology_16[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_28]]
====== link:#_test_setup_28[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_33]]
====== link:#_test_procedure_33[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |LOWPOWER.S.C00.Rsp(Sleep) |TH sends _Sleep command_ to DUT |Verify
response is a successful (value 0x00) status response and that the
device enters its low power state.
|===

[[_notestesting_considerations_34]]
====== link:#_notestesting_considerations_34[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

'''''

[[_tc_lowpower_2_2_low_power_mode_verification_dut_as_client]]
===== link:#_tc_lowpower_2_2_low_power_mode_verification_dut_as_client[]19.2.2. [TC-LOWPOWER-2.2] Low Power Mode Verification (DUT as Client)

[[_category_34]]
====== link:#_category_34[]Category

Functional conformance

[[_purpose_34]]
====== link:#_purpose_34[]Purpose

This test case verifies that the DUT can send a low power command

[[_pics_34]]
====== link:#_pics_34[]PICS

* LOWPOWER.C

[[_required_devices_34]]
====== link:#_required_devices_34[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_17]]
====== link:#_device_topology_17[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_29]]
====== link:#_test_setup_29[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_34]]
====== link:#_test_procedure_34[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |LOWPOWER.C.C00.Tx(Sleep) |DUT sends _Sleep command_ to TH |Verify
command is successfully received by TH
|===

[[_notestesting_considerations_35]]
====== link:#_notestesting_considerations_35[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

'''''

[[_keypad_input_cluster_test_cases]]
==== link:#_keypad_input_cluster_test_cases[]19.3. KeyPad Input Cluster Test Cases

'''''

[[_tc_keypadinput_3_1_send_key_command_verification_dut_as_client]]
===== link:#_tc_keypadinput_3_1_send_key_command_verification_dut_as_client[]19.3.1. [TC-KEYPADINPUT-3.1] Send Key Command Verification (DUT as Client)

[[_category_35]]
====== link:#_category_35[]Category

Functional conformance

[[_purpose_35]]
====== link:#_purpose_35[]Purpose

This test case verifies that the DUT can send a SendKey command

[[_pics_35]]
====== link:#_pics_35[]PICS

* KEYPADINPUT.C

[[_required_devices_35]]
====== link:#_required_devices_35[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_18]]
====== link:#_device_topology_18[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_30]]
====== link:#_test_setup_30[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_35]]
====== link:#_test_procedure_35[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |KEYPADINPUT.C.C00.Tx(SendKey) |DUT sends _SendKey command_ to TH
|Verify command is successfully received by TH
|===

[[_notestesting_considerations_36]]
====== link:#_notestesting_considerations_36[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_keypadinput_3_2_location_keys_verification]]
===== link:#_tc_keypadinput_3_2_location_keys_verification[]19.3.2. [TC-KEYPADINPUT-3.2] Location Keys Verification

[[_category_36]]
====== link:#_category_36[]Category

Functional conformance

[[_purpose_36]]
====== link:#_purpose_36[]Purpose

This test case verifies the KeypadInput cluster interface in accordance
with Location Keys

[[_pics_36]]
====== link:#_pics_36[]PICS

* KEYPADINPUT.S.F01(LK)

[[_preconditions_2]]
====== link:#_preconditions_2[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_36]]
====== link:#_required_devices_36[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_19]]
====== link:#_device_topology_19[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_31]]
====== link:#_test_setup_31[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_36]]
====== link:#_test_procedure_36[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.7.2. Features |KEYPADINPUT.S.C00.Rsp(SendKey)
KEYPADINPUT.S.F01(LK) |TH sends CEC Settings Keys(0x0A) to DUT |Verify
response is a successful (value 0) status response

|2 | |KEYPADINPUT.S.C00.Rsp(SendKey) KEYPADINPUT.S.F01(LK) |TH sends CEC
Home Keys(0x09) to DUT |Verify response is a successful (value 0) status
response
|===

[[_notestesting_considerations_37]]
====== link:#_notestesting_considerations_37[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_keypadinput_3_3_number_keys_verification]]
===== link:#_tc_keypadinput_3_3_number_keys_verification[]19.3.3. [TC-KEYPADINPUT-3.3] Number Keys Verification

[[_category_37]]
====== link:#_category_37[]Category

Functional conformance

[[_purpose_37]]
====== link:#_purpose_37[]Purpose

This test case verifies the KeypadInput cluster interface in accordance
with Number Keys

[[_pics_37]]
====== link:#_pics_37[]PICS

* KEYPADINPUT.S.F02(NK)

[[_preconditions_3]]
====== link:#_preconditions_3[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_37]]
====== link:#_required_devices_37[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_20]]
====== link:#_device_topology_20[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_32]]
====== link:#_test_setup_32[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_37]]
====== link:#_test_procedure_37[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.7.2. Features |KEYPADINPUT.S.C00.Rsp(SendKey)
KEYPADINPUT.S.F02(NK) |TH sends Number 1 to 9 Code to DUT (eg. 0x20-0x29
in HDMI CDC) |Verify response is a successful (value 0) status response
|===

[[_notestesting_considerations_38]]
====== link:#_notestesting_considerations_38[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_application_launcher_cluster_test_cases]]
==== link:#_application_launcher_cluster_test_cases[]19.4. Application Launcher Cluster Test Cases

'''''

[[_tc_applauncher_3_5_catalog_list_verification]]
===== link:#_tc_applauncher_3_5_catalog_list_verification[]19.4.1. [TC-APPLAUNCHER-3.5] Catalog List Verification

[[_category_38]]
====== link:#_category_38[]Category

Functional conformance

[[_purpose_38]]
====== link:#_purpose_38[]Purpose

This test case verifies the catalog lists for an Application Launcher
cluster

[[_pics_38]]
====== link:#_pics_38[]PICS

* APPLAUNCHER.S

[[_preconditions_4]]
====== link:#_preconditions_4[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_38]]
====== link:#_required_devices_38[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_21]]
====== link:#_device_topology_21[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_33]]
====== link:#_test_setup_33[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_38]]
====== link:#_test_procedure_38[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.4.3.1 Features |APPLAUNCHER.S.A0000(CatalogList) |TH reads
_CatalogList attribute_ from the DUT for the list of supported
application catalogs |Verify the list of supported catalogs, where each
entry in the list is a CSA-issued Vendor Id of type unsigned 16 bit
integer(ranging between 0-65536) for the catalog.
|===

[[_notestesting_considerations_39]]
====== link:#_notestesting_considerations_39[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

Latest commit 446f4fe on Jan 17

[[_tc_applauncher_3_6_current_app_verification]]
===== link:#_tc_applauncher_3_6_current_app_verification[]19.4.2. [TC-APPLAUNCHER-3.6] Current App Verification

[[_category_39]]
====== link:#_category_39[]Category

Functional conformance

[[_purpose_39]]
====== link:#_purpose_39[]Purpose

This test case verifies the description of in-focus Application

[[_pics_39]]
====== link:#_pics_39[]PICS

* APPLAUNCHER.S

[[_preconditions_5]]
====== link:#_preconditions_5[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_39]]
====== link:#_required_devices_39[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_22]]
====== link:#_device_topology_22[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_34]]
====== link:#_test_setup_34[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_39]]
====== link:#_test_procedure_39[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |Application Launcher 1.3 |APPLAUNCHER.S.A0001(CurrentApp) |TH reads
the _CurrentApp attribute_ from the DUT to describe the current in-focus
application |Verify the in-focus application attributes, which should
include the display Application ID(type:uint16) , Catalog Vendor
ID(type:string) or _Null_ if there is no current in-focus application
|===

[[_notestesting_considerations_40]]
====== link:#_notestesting_considerations_40[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

Latest commit 446f4fe on Jan 17

[[_tc_applauncher_3_7_launch_application_verification]]
===== link:#_tc_applauncher_3_7_launch_application_verification[]19.4.3. [TC-APPLAUNCHER-3.7] Launch Application Verification

[[_category_40]]
====== link:#_category_40[]Category

Functional conformance

[[_purpose_40]]
====== link:#_purpose_40[]Purpose

This test case verifies launching of a specified application with
optional data

[[_pics_40]]
====== link:#_pics_40[]PICS

* APPLAUNCHER.S

[[_preconditions_6]]
====== link:#_preconditions_6[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT supports one or more apps |
|===

[[_required_devices_40]]
====== link:#_required_devices_40[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_23]]
====== link:#_device_topology_23[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_35]]
====== link:#_test_setup_35[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_40]]
====== link:#_test_procedure_40[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.4.4.1 Features |APPLAUNCHER.S.C00.Rsp(LaunchApp) |TH sends a
_LaunchApp command_ to DUT to launch and bring an application to the
foreground |Verify the requested application is launched and a
successful (value 0) response is received and Status Attribute is
updated to ACTIVE_VISIBLE_FOCUS on the application Basic cluster of the
Endpoint corresponding to launched application.

|2 |6.4.5.1 Features |APPLAUNCHER.S.C00.Rsp(LaunchApp) |TH sends a
_LaunchApp command_ to DUT to launch an app which is not available
|Verify that no application is launched and a "APP_NOT_AVAILABLE" (value
1) response is received
|===

[[_notestesting_considerations_41]]
====== link:#_notestesting_considerations_41[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.
. For the tv-app example app, you can use the following command:

chip-tool applicationlauncher launch-app '\{"catalogVendorId": 123,
"applicationId": "exampleid"}' 1234 1

'''''

[[_tc_applauncher_3_7_1_launch_application_verification_dut_as_client]]
===== link:#_tc_applauncher_3_7_1_launch_application_verification_dut_as_client[]19.4.4. [TC-APPLAUNCHER-3.7.1] Launch Application Verification (DUT as Client)

[[_category_41]]
====== link:#_category_41[]Category

Functional conformance

[[_purpose_41]]
====== link:#_purpose_41[]Purpose

This test case verifies that the DUT can send a LaunchApp command

[[_pics_41]]
====== link:#_pics_41[]PICS

* APPLAUNCHER.C

[[_required_devices_41]]
====== link:#_required_devices_41[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_24]]
====== link:#_device_topology_24[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_36]]
====== link:#_test_setup_36[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_41]]
====== link:#_test_procedure_41[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |APPLAUNCHER.C.C00.Tx(LaunchApp) |DUT sends _LaunchApp command_ to
TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_42]]
====== link:#_notestesting_considerations_42[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_applauncher_3_8_stop_application_verification]]
===== link:#_tc_applauncher_3_8_stop_application_verification[]19.4.5. [TC-APPLAUNCHER-3.8] Stop Application Verification

[[_category_42]]
====== link:#_category_42[]Category

Functional conformance

[[_purpose_42]]
====== link:#_purpose_42[]Purpose

This test case verifies stopping of a specified application

[[_pics_42]]
====== link:#_pics_42[]PICS

* APPLAUNCHER.S

[[_preconditions_7]]
====== link:#_preconditions_7[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT supports one or more apps |
|===

[[_required_devices_42]]
====== link:#_required_devices_42[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_25]]
====== link:#_device_topology_25[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_37]]
====== link:#_test_setup_37[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_42]]
====== link:#_test_procedure_42[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.4.4.1 Features |APPLAUNCHER.S.C01.Rsp(StopApp) |TH sends a
_StopApp command_ to DUT to stop a running application |Verify the
requested application is no longer running/visible and Status Attribute
is updated to STOPPED on the application Basic cluster of the Endpoint
corresponding to stopped application.
|===

[[_notestesting_considerations_43]]
====== link:#_notestesting_considerations_43[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

'''''

[[_tc_applauncher_3_8_1_stop_application_verification_dut_as_client]]
===== link:#_tc_applauncher_3_8_1_stop_application_verification_dut_as_client[]19.4.6. [TC-APPLAUNCHER-3.8.1] Stop Application Verification (DUT as Client)

[[_category_43]]
====== link:#_category_43[]Category

Functional conformance

[[_purpose_43]]
====== link:#_purpose_43[]Purpose

This test case verifies that the DUT can send a StopApp command

[[_pics_43]]
====== link:#_pics_43[]PICS

* APPLAUNCHER.C

[[_required_devices_43]]
====== link:#_required_devices_43[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_26]]
====== link:#_device_topology_26[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_38]]
====== link:#_test_setup_38[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_43]]
====== link:#_test_procedure_43[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |APPLAUNCHER.C.C01.Tx(StopApp) |DUT sends _StopApp command_ to TH
|Verify command is successfully received by TH
|===

[[_notestesting_considerations_44]]
====== link:#_notestesting_considerations_44[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_applauncher_3_9_hide_application_verification]]
===== link:#_tc_applauncher_3_9_hide_application_verification[]19.4.7. [TC-APPLAUNCHER-3.9] Hide Application Verification

[[_category_44]]
====== link:#_category_44[]Category

Functional conformance

[[_purpose_44]]
====== link:#_purpose_44[]Purpose

This test case verifies Hiding of a specified application

[[_pics_44]]
====== link:#_pics_44[]PICS

* APPLAUNCHER.S

[[_preconditions_8]]
====== link:#_preconditions_8[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT supports one or more apps |
|===

[[_required_devices_44]]
====== link:#_required_devices_44[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_27]]
====== link:#_device_topology_27[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_39]]
====== link:#_test_setup_39[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_44]]
====== link:#_test_procedure_44[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.4.4.1 Features |APPLAUNCHER.S.C02.Rsp(HideApp) |TH sends a
_HideApp command_ to DUT to Hide a running and Active application
|Verify the requested application is hidden and Status Attribute is
updated to ACTIVE_HIDDEN or STOPPED on the application Basic cluster of
the Endpoint corresponding to Hidden application.
|===

[[_notestesting_considerations_45]]
====== link:#_notestesting_considerations_45[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

'''''

[[_tc_applauncher_3_9_1_hide_application_verification_dut_as_client]]
===== link:#_tc_applauncher_3_9_1_hide_application_verification_dut_as_client[]19.4.8. [TC-APPLAUNCHER-3.9.1] Hide Application Verification (DUT as Client)

[[_category_45]]
====== link:#_category_45[]Category

Functional conformance

[[_purpose_45]]
====== link:#_purpose_45[]Purpose

This test case verifies that the DUT can send a HideApp command

[[_pics_45]]
====== link:#_pics_45[]PICS

* APPLAUNCHER.C

[[_required_devices_45]]
====== link:#_required_devices_45[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_28]]
====== link:#_device_topology_28[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_40]]
====== link:#_test_setup_40[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_45]]
====== link:#_test_procedure_45[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |APPLAUNCHER.C.C02.Tx(HideApp) |DUT sends _HideApp command_ to TH
|Verify command is successfully received by TH
|===

[[_notestesting_considerations_46]]
====== link:#_notestesting_considerations_46[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_media_input_cluster_test_cases]]
==== link:#_media_input_cluster_test_cases[]19.5. Media Input Cluster Test Cases

'''''

[[_tc_mediainput_3_10_input_list_verification]]
===== link:#_tc_mediainput_3_10_input_list_verification[]19.5.1. [TC-MEDIAINPUT-3.10] Input List Verification

[[_category_46]]
====== link:#_category_46[]Category

Functional conformance

[[_purpose_46]]
====== link:#_purpose_46[]Purpose

This test case verifies the list of inputs supported by the media device

[[_pics_46]]
====== link:#_pics_46[]PICS

* MEDIAINPUT.S

[[_preconditions_9]]
====== link:#_preconditions_9[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_46]]
====== link:#_required_devices_46[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_29]]
====== link:#_device_topology_29[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_41]]
====== link:#_test_setup_41[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_46]]
====== link:#_test_procedure_46[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.8.3 Features |MEDIAINPUT.S.A0000(InputList) |TH reads the
_InputList attribute_ from the DUT to show list of Inputs available
|Verify list of available inputs supported by the device is provided,
where each entry in the list contains an index(type:uint 8), InputType
(InputType Enums), Name (type: Strings), and Description(Type:String)
|===

[[_notestesting_considerations_47]]
====== link:#_notestesting_considerations_47[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediainput_3_11_select_input_verification]]
===== link:#_tc_mediainput_3_11_select_input_verification[]19.5.2. [TC-MEDIAINPUT-3.11] Select Input Verification

[[_category_47]]
====== link:#_category_47[]Category

Functional conformance

[[_purpose_47]]
====== link:#_purpose_47[]Purpose

This test case verifies the change of media input to the selected input.

[[_pics_47]]
====== link:#_pics_47[]PICS

* MEDIAINPUT.S

[[_preconditions_10]]
====== link:#_preconditions_10[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_47]]
====== link:#_required_devices_47[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_30]]
====== link:#_device_topology_30[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_42]]
====== link:#_test_setup_42[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_47]]
====== link:#_test_procedure_47[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.8.4.1 Features |MEDIAINPUT.S.A0000(InputList) |TH reads _InputList
attribute from the DUT to show the list of inputs available . |Verify
list of available inputs supported by the device is provided, where each
entry in the list contains an index(type:uint 8), InputType (InputType
Enums), Name (type: Strings), and Description(Type:String)

|1 |6.8.4.1 Features |MEDIAINPUT.S.C00.Rsp(SelectInput) |TH sends
_SelectInput command_ to DUT to select an input by passing the index of
the preferred input. |Verify upon receipt that the input is changed to
the specific index in the input list and a successful response (value 0)
is received.

|1 |6.8.4.1 Features |MEDIAINPUT.S.A0001(CurrentInput) |TH reads
_CurrentInput attribute from the DUT to show the current input selected.
|Verify that the index returned is the same as that provided in step 2.
|===

[[_notestesting_considerations_48]]
====== link:#_notestesting_considerations_48[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediainput_3_12_show_and_hide_input_status_verification]]
===== link:#_tc_mediainput_3_12_show_and_hide_input_status_verification[]19.5.3. [TC-MEDIAINPUT-3.12] Show and Hide Input Status Verification

[[_category_48]]
====== link:#_category_48[]Category

Functional conformance

[[_purpose_48]]
====== link:#_purpose_48[]Purpose

This test case verifies the active status of the input list

[[_pics_48]]
====== link:#_pics_48[]PICS

* MEDIAINPUT.S

[[_preconditions_11]]
====== link:#_preconditions_11[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_48]]
====== link:#_required_devices_48[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_31]]
====== link:#_device_topology_31[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_43]]
====== link:#_test_setup_43[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_48]]
====== link:#_test_procedure_48[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.8.4.2 Features |MEDIAINPUT.S.A0000(InputList) |TH reads the
_InputList attribute_ from the DUT to show list of Inputs available
|Verify that the list of inputs is received.

|2 |6.8.4.2 Features |MEDIAINPUT.S.C01.Rsp(ShowStatus) |TH sends
_ShowInputStatus command_ to DUT to show active status of the input list
|Verify upon receipt that the active status of the input is displayed on
the device and a successful response (Value 0) is received.

|3 |6.8.4.3 |MEDIAINPUT.S.C02.Rsp(HideStatus) |TH sends _HideInputStatus
command_ to DUT to hide active status of the input list |Verify upon
receipt that the active status of the input is hidden on the device and
a successful response (Value 0) is received.
|===

[[_notestesting_considerations_49]]
====== link:#_notestesting_considerations_49[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.
. Refer to manufacturer provided instructions for the expected physical
DUT behavior for the show and hide input status commands.

[[_tc_mediainput_3_13_rename_input_verification]]
===== link:#_tc_mediainput_3_13_rename_input_verification[]19.5.4. [TC-MEDIAINPUT-3.13] Rename Input Verification

[[_category_49]]
====== link:#_category_49[]Category

Functional conformance

[[_purpose_49]]
====== link:#_purpose_49[]Purpose

This test case verifies renaming of an input

[[_pics_49]]
====== link:#_pics_49[]PICS

* MEDIAINPUT.S

[[_preconditions_12]]
====== link:#_preconditions_12[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT passed TC 3.8 and has one or more inputs available |
|===

[[_required_devices_49]]
====== link:#_required_devices_49[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_32]]
====== link:#_device_topology_32[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_44]]
====== link:#_test_setup_44[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

DUT may provide special argument values to each command.

[[_test_procedure_49]]
====== link:#_test_procedure_49[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.8.4.4 Features |MEDIAINPUT.S.A0000(InputList) |TH reads the
_InputList attribute_ from the DUT to show list of Inputs available
|Verify that the list of inputs is received.

|2 |6.8.4.4 Features |MEDIAINPUT.S.C03.Rsp(Rename) |TH sends a
_RenameInput command_ to DUT to rename an input from the list returned
in step 1 |Verify response is a successful (value 0) status response

|3 |6.8.4.4 Features |MEDIAINPUT.S.A0000(InputList) |TH reads the
_InputList attribute_ from the DUT to show list of Inputs available
|Verify that the list of inputs is received and that the input in the
list from step 2 is renamed
|===

[[_notestesting_considerations_50]]
====== link:#_notestesting_considerations_50[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediainput_3_14_select_input_verification_dut_as_client]]
===== link:#_tc_mediainput_3_14_select_input_verification_dut_as_client[]19.5.5. [TC-MEDIAINPUT-3.14] Select Input Verification (DUT as Client)

[[_category_50]]
====== link:#_category_50[]Category

Functional conformance

[[_purpose_50]]
====== link:#_purpose_50[]Purpose

This test case verifies that the DUT can send a SelectInput command

[[_pics_50]]
====== link:#_pics_50[]PICS

* MEDIAINPUT.C

[[_required_devices_50]]
====== link:#_required_devices_50[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_33]]
====== link:#_device_topology_33[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_45]]
====== link:#_test_setup_45[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_50]]
====== link:#_test_procedure_50[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAINPUT.C.C00.Tx(SelectInput) |DUT sends _SelectInput command_
to TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_51]]
====== link:#_notestesting_considerations_51[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediainput_3_15_show_input_status_verification_dut_as_client]]
===== link:#_tc_mediainput_3_15_show_input_status_verification_dut_as_client[]19.5.6. [TC-MEDIAINPUT-3.15] Show Input Status Verification (DUT as Client)

[[_category_51]]
====== link:#_category_51[]Category

Functional conformance

[[_purpose_51]]
====== link:#_purpose_51[]Purpose

This test case verifies that the DUT can send a ShowInputStatus command

[[_pics_51]]
====== link:#_pics_51[]PICS

* MEDIAINPUT.C

[[_required_devices_51]]
====== link:#_required_devices_51[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_34]]
====== link:#_device_topology_34[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_46]]
====== link:#_test_setup_46[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_51]]
====== link:#_test_procedure_51[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAINPUT.C.C01.Tx(ShowStatus) |DUT sends _ShowInputStatus
command_ to TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_52]]
====== link:#_notestesting_considerations_52[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediainput_3_16_hide_input_status_verification_dut_as_client]]
===== link:#_tc_mediainput_3_16_hide_input_status_verification_dut_as_client[]19.5.7. [TC-MEDIAINPUT-3.16] Hide Input Status Verification (DUT as Client)

[[_category_52]]
====== link:#_category_52[]Category

Functional conformance

[[_purpose_52]]
====== link:#_purpose_52[]Purpose

This test case verifies that the DUT can send a HideInputStatus command

[[_pics_52]]
====== link:#_pics_52[]PICS

* MEDIAINPUT.C

[[_required_devices_52]]
====== link:#_required_devices_52[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_35]]
====== link:#_device_topology_35[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_47]]
====== link:#_test_setup_47[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_52]]
====== link:#_test_procedure_52[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAINPUT.C.C02.Tx(HideStatus) |DUT sends _HideInputStatus
command_ to TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_53]]
====== link:#_notestesting_considerations_53[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediainput_3_17_rename_input_verification_dut_as_client]]
===== link:#_tc_mediainput_3_17_rename_input_verification_dut_as_client[]19.5.8. [TC-MEDIAINPUT-3.17] Rename Input Verification (DUT as Client)

[[_category_53]]
====== link:#_category_53[]Category

Functional conformance

[[_purpose_53]]
====== link:#_purpose_53[]Purpose

This test case verifies that the DUT can send a RenameInput command

[[_pics_53]]
====== link:#_pics_53[]PICS

* MEDIAINPUT.C

[[_required_devices_53]]
====== link:#_required_devices_53[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_36]]
====== link:#_device_topology_36[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_48]]
====== link:#_test_setup_48[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_53]]
====== link:#_test_procedure_53[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |6.8.4.4 Features |MEDIAINPUT.C.C03.Tx(Rename) |DUT sends
_RenameInput command_ to TH |Verify command is successfully received by
TH
|===

[[_notestesting_considerations_54]]
====== link:#_notestesting_considerations_54[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_wake_on_lan_test_cases]]
==== link:#_wake_on_lan_test_cases[]19.6. Wake-On LAN Test Cases

'''''

[[_tc_wakeonlan_4_1_wake_on_lan_verification]]
===== link:#_tc_wakeonlan_4_1_wake_on_lan_verification[]19.6.1. [TC-WAKEONLAN-4.1] Wake-On LAN Verification

[[_category_54]]
====== link:#_category_54[]Category

Functional conformance

[[_purpose_54]]
====== link:#_purpose_54[]Purpose

This test case verifies that the device can wake up from a low-power
state using the Wake-On LAN standard

[[_pics_54]]
====== link:#_pics_54[]PICS

* WAKEONLAN.S

[[_preconditions_13]]
====== link:#_preconditions_13[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_54]]
====== link:#_required_devices_54[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_37]]
====== link:#_device_topology_37[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_49]]
====== link:#_test_setup_49[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_54]]
====== link:#_test_procedure_54[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |WAKEONLAN.S.A0000(MACAddress) |TH reads the _MACAddress attribute_
from the DUT |Verify that the response contains a 48-bit MAC Address.
Record the MAC address.

|2 | |LOWPOWER.S.C00.Rsp(Sleep) |TH sends a _Sleep command_ to DUT
|Verify response is a successful (value 0x00) status response.

|3 |WoL Standard | |TH sends a Wake-On LAN magic packet containing the
MAC address from step 1 |Verify that the DUT is no longer in a low-power
state.
|===

[[_notestesting_considerations_55]]
====== link:#_notestesting_considerations_55[]Notes/Testing Considerations

. If the device does not support the MAC Address attribute, then the MAC
address can be acquired by other means (network scans, device
documentation, etc) for step 3.
. If the device does not support the Low Power cluster (LOWPOWER.S),
then the DUT can be put to sleep using other means for step 2. Latest
commit d4a89ef on Dec 10, 2021
. To verify a device has woken up, any Matter cluster command can be
send to the device (for example, read descriptor cluster at endpoint 1).
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tv_channel_test_cases]]
==== link:#_tv_channel_test_cases[]19.7. TV Channel Test Cases

'''''

[[_tc_channel_5_1_list_tv_channels_verification]]
===== link:#_tc_channel_5_1_list_tv_channels_verification[]19.7.1. [TC-CHANNEL-5.1] List TV Channels Verification

[[_category_55]]
====== link:#_category_55[]Category

Functional conformance

[[_purpose_55]]
====== link:#_purpose_55[]Purpose

This test case verifies that the device can provide a list of its known
TV channels

[[_pics_55]]
====== link:#_pics_55[]PICS

* CHANNEL.S

[[_preconditions_14]]
====== link:#_preconditions_14[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_55]]
====== link:#_required_devices_55[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_38]]
====== link:#_device_topology_38[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_50]]
====== link:#_test_setup_50[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_55]]
====== link:#_test_procedure_55[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CHANNEL.S.A0000(ChannelList) |TH reads the _ChannelList attribute_
from the DUT a|
Verify that the response contains a list of the known TV channels. Each
list element should consist of the following:

{empty}1. Major number (unsigned 16-bit integer, mandatory)

{empty}2. Minor number (unsigned 16-bit integer, mandatory)

{empty}3. Name (String, optional)

{empty}4. Call sign (String, optional)

{empty}5. Affiliate call sign (String, optional)

|===

[[_notestesting_considerations_56]]
====== link:#_notestesting_considerations_56[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_channel_5_2_change_channel_by_number_verification]]
===== link:#_tc_channel_5_2_change_channel_by_number_verification[]19.7.2. [TC-CHANNEL-5.2] Change Channel by Number Verification

[[_category_56]]
====== link:#_category_56[]Category

Functional conformance

[[_purpose_56]]
====== link:#_purpose_56[]Purpose

This test case verifies that the device can change channels when
provided with a channel number

[[_pics_56]]
====== link:#_pics_56[]PICS

* CHANNEL.S

[[_preconditions_15]]
====== link:#_preconditions_15[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_56]]
====== link:#_required_devices_56[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_39]]
====== link:#_device_topology_39[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_51]]
====== link:#_test_setup_51[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_56]]
====== link:#_test_procedure_56[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CHANNEL.S.A0000(ChannelList) |TH reads the _ChannelList attribute_
from the DUT |Verify that the response contains a list of the known TV
channels.

|2 | |CHANNEL.S.C02.Rsp(ChangeChannelByNumber) |TH sends a
_ChangeChannelByNumber command_ to the DUT with channel information
(major and minor numbers) from the list in step 1 |Verify that a
successful (status 0) response is received and verify that a channel
change has occurred on the device.

|3 | |CHANNEL.S.A0002(CurrentChannel) |TH reads the _CurrentChannel
attribute_ from the DUT |Verify that the major and minor numbers in the
response are the same numbers provided in step 2.
|===

[[_notestesting_considerations_57]]
====== link:#_notestesting_considerations_57[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_channel_5_3_skip_channel_verification]]
===== link:#_tc_channel_5_3_skip_channel_verification[]19.7.3. [TC-CHANNEL-5.3] Skip Channel Verification

[[_category_57]]
====== link:#_category_57[]Category

Functional conformance

[[_purpose_57]]
====== link:#_purpose_57[]Purpose

This test case verifies that the device can change channels up or down

[[_pics_57]]
====== link:#_pics_57[]PICS

* CHANNEL.S

[[_preconditions_16]]
====== link:#_preconditions_16[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_57]]
====== link:#_required_devices_57[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_40]]
====== link:#_device_topology_40[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_52]]
====== link:#_test_setup_52[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_57]]
====== link:#_test_procedure_57[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CHANNEL.S.A0001(Lineup) |TH reads the _Lineup attribute_ from the
DUT |Verify that the response contains a lineup info object.

|2 | |CHANNEL.S.A0000(ChannelList) |TH reads the _ChannelList attribute_
from the DUT |Verify that the response contains a list of the known TV
channels. Note the major and minor values of each channel in the list
and their respective index.

|3 | |CHANNEL.S.A0002(CurrentChannel) |TH reads the _CurrentChannel
attribute_ from the DUT |Verify that the response contains a the major
and minor number of the current channel. Note the index of that channel
in the list from step 1.

|4 | |CHANNEL.S.C03.Rsp(SkipChannel) |TH sends a _SkipChannel command_
to the DUT with a value of 1 |Verify that a successful (status 0)
response is received and verify that the channel has changed on the
device.

|5 | |CHANNEL.S.A0002(CurrentChannel) |TH reads the _CurrentChannel
attribute_ from the DUT |Verify that the major and minor numbers in the
response are the same as that of the next channel in the index (value of
index from step 2 plus 1).
|===

[[_notestesting_considerations_58]]
====== link:#_notestesting_considerations_58[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_channel_5_4_change_channel_verification_dut_as_client]]
===== link:#_tc_channel_5_4_change_channel_verification_dut_as_client[]19.7.4. [TC-CHANNEL-5.4] Change Channel Verification (DUT as Client)

[[_category_58]]
====== link:#_category_58[]Category

Functional conformance

[[_purpose_58]]
====== link:#_purpose_58[]Purpose

This test case verifies that the DUT can send a ChangeChannel command

[[_pics_58]]
====== link:#_pics_58[]PICS

* CHANNEL.C

[[_required_devices_58]]
====== link:#_required_devices_58[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_41]]
====== link:#_device_topology_41[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_53]]
====== link:#_test_setup_53[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_58]]
====== link:#_test_procedure_58[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CHANNEL.C.C00.Tx(ChangeChannel) |DUT sends _ChangeChannel command_
to TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_59]]
====== link:#_notestesting_considerations_59[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_channel_5_5_change_channel_by_number_verification_dut_as_client]]
===== link:#_tc_channel_5_5_change_channel_by_number_verification_dut_as_client[]19.7.5. [TC-CHANNEL-5.5] Change Channel By Number Verification (DUT as Client)

[[_category_59]]
====== link:#_category_59[]Category

Functional conformance

[[_purpose_59]]
====== link:#_purpose_59[]Purpose

This test case verifies that the DUT can send a ChangeChannelByNumber
command

[[_pics_59]]
====== link:#_pics_59[]PICS

* CHANNEL.C

[[_required_devices_59]]
====== link:#_required_devices_59[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_42]]
====== link:#_device_topology_42[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_54]]
====== link:#_test_setup_54[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_59]]
====== link:#_test_procedure_59[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CHANNEL.C.C02.Tx(ChangeChannelByNumber) |DUT sends
_ChangeChannelByNumber command_ to TH |Verify command is successfully
received by TH
|===

[[_notestesting_considerations_60]]
====== link:#_notestesting_considerations_60[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_channel_5_6_skip_channel_verification_dut_as_client]]
===== link:#_tc_channel_5_6_skip_channel_verification_dut_as_client[]19.7.6. [TC-CHANNEL-5.6] Skip Channel Verification (DUT as Client)

[[_category_60]]
====== link:#_category_60[]Category

Functional conformance

[[_purpose_60]]
====== link:#_purpose_60[]Purpose

This test case verifies that the DUT can send a SkipChannel command

[[_pics_60]]
====== link:#_pics_60[]PICS

* CHANNEL.C

[[_required_devices_60]]
====== link:#_required_devices_60[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_43]]
====== link:#_device_topology_43[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_55]]
====== link:#_test_setup_55[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_60]]
====== link:#_test_procedure_60[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |CHANNEL.C.C03.Tx(SkipChannel) |DUT sends _SkipChannel command_ to
TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_61]]
====== link:#_notestesting_considerations_61[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_media_playback_test_cases]]
==== link:#_media_playback_test_cases[]19.8. Media Playback Test Cases

'''''

[[_tc_mediaplayback_6_1_mandatory_media_playback_verification]]
===== link:#_tc_mediaplayback_6_1_mandatory_media_playback_verification[]19.8.1. [TC-MEDIAPLAYBACK-6.1] Mandatory Media Playback Verification

[[_category_61]]
====== link:#_category_61[]Category

Functional conformance

[[_purpose_61]]
====== link:#_purpose_61[]Purpose

This test case verifies the mandatory commands for the Media Playback
cluster (Play, Pause, Stop)

[[_pics_61]]
====== link:#_pics_61[]PICS

* MEDIAPLAYBACK.S

[[_preconditions_17]]
====== link:#_preconditions_17[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is powered on and not in a low power state |

|2 | |DUT has media content available for playback |

|3 | |Media content is loaded/selected and in a paused state at the
beginning of the content (PlayBackPosition 0) |
|===

[[_required_devices_61]]
====== link:#_required_devices_61[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_44]]
====== link:#_device_topology_44[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_56]]
====== link:#_test_setup_56[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_61]]
====== link:#_test_procedure_61[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PAUSED"

|2 |Media Playback 1.4.1 |MEDIAPLAYBACK.S.C00.Rsp(Play) |TH sends a
_Play command_ to the DUT |Verify that a successful (status 0) response
is received and verify that the media state is playing.

|3 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PLAYING"

|4 |Media Playback 1.4.2 |MEDIAPLAYBACK.S.C01.Rsp(Pause) |TH sends a
_Pause command_ to the DUT |Verify that a successful (status 0) response
is received and verify that the media state is paused.

|5 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PAUSED"

|6 |Media Playback 1.4.3 |MEDIAPLAYBACK.S.C02.Rsp(Stop) |TH sends a
_Stop command_ to the DUT |Verify that a successful (status 0) response
is received and verify that the media state is stopped. Refer to
manufacturer provided instructions for the expected physical DUT
behavior for the stop command.

|7 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "NOT_PLAYING"
|===

[[_notestesting_considerations_62]]
====== link:#_notestesting_considerations_62[]Notes/Testing Considerations

. Manufacturer should provide information on the desired behavior for
the stop command in step 6 (ex: should the user be navigated back to a
home screen).
. Manufacturer may provide instructions for how to verify media playback
state.
. Manufacturer may provide instructions for how to put media state into
precondition state. With the example tv-app, state can be set to paused
using the pause command:

chip-tool mediaplayback pause 1234 3

[[_tc_mediaplayback_6_2_optional_media_playback_verification]]
===== link:#_tc_mediaplayback_6_2_optional_media_playback_verification[]19.8.2. [TC-MEDIAPLAYBACK-6.2] Optional Media Playback Verification

[[_category_62]]
====== link:#_category_62[]Category

Functional conformance

[[_purpose_62]]
====== link:#_purpose_62[]Purpose

This test case verifies the optional commands for the Media Playback
cluster (StartOver, Previous, Next, SkipForward, and SkipBackward)

[[_pics_62]]
====== link:#_pics_62[]PICS

* MEDIAPLAYBACK.S

[[_preconditions_18]]
====== link:#_preconditions_18[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is powered on and not in a low power state |

|2 | |DUT has media content available for playback |

|3 | |Media content is loaded/selected and in a paused state at the
beginning of the content (PlayBackPosition 0) |

|4 | |At least 2 media items are queued |
|===

[[_required_devices_62]]
====== link:#_required_devices_62[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_45]]
====== link:#_device_topology_45[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_57]]
====== link:#_test_setup_57[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_62]]
====== link:#_test_procedure_62[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PAUSED"

|2 | |MEDIAPLAYBACK.S.C00.Rsp(Play) |TH sends a _Play command_ to the
DUT |Verify that a successful (status 0) response is received and verify
that the media state is playing.

|3 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PLAYING"

|4 |Media Playback 1.4.4 |MEDIAPLAYBACK.S.C03.Rsp(StartOver) |TH sends a
_StartOver command_ to the DUT |Verify that a successful (status 0)
response is received and verify that the media state has started over.

|5 |Media Playback 1.4.5 |MEDIAPLAYBACK.S.C05.Rsp(Next) |TH sends a
_Next command_ to the DUT |Verify that a successful (status 0) response
is received and verify that the next media item in the queue has been
loaded (see manufacturer defined behavior)

|6 |Media Playback 1.4.6 |MEDIAPLAYBACK.S.C04.Rsp(Previous) |TH sends a
_Previous command_ to the DUT |Verify that a successful (status 0)
response is received and verify that the previous media item in the
queue has been loaded (see manufacturer defined behavior)

|7 |Media Playback 1.4.9 |MEDIAPLAYBACK.S.C08.Rsp(SkipForward) |TH sends
a _SkipForward command_ to the DUT with a _DeltaPositionMilliseconds_
value of 10000 |Verify that a successful (status 0) response is received
and verify that the media has skipped forward 10 seconds

|8 |Media Playback 1.4.9 |MEDIAPLAYBACK.S.A0003(SampledPosition) |TH
reads the _SampledPosition attribute_ from the DUT |Verify that the
response has a position of 10000

|9 |Media Playback 1.4.10 |MEDIAPLAYBACK.S.C09.Rsp(SkipBackward) |TH
sends a _SkipBackward command_ to the DUT with a
_DeltaPositionMilliseconds_ value of 10000 |Verify that a successful
(status 0) response is received and verify that the media has skipped
backward 10 seconds

|10 |Media Playback 1.4.10 |MEDIAPLAYBACK.S.A0003(SampledPosition) |TH
reads the _SampledPosition attribute_ from the DUT |Verify that the
response has a position of 0
|===

[[_notestesting_considerations_63]]
====== link:#_notestesting_considerations_63[]Notes/Testing Considerations

. Manufacturer should provide information on the desired behavior for
the next and previous commands in steps 5 and 6 respectively (ex: should
the experience progress to the previous/next item in a media queue?)
. If a skip (steps 7 and 9) falls in the middle of a frame, the device
must set the position to the beginning of that frame. Physical
measurements and _SampledPosition_ reads may not exactly reflect the
number of skipped milliseconds.
. Manufacturer may provide instructions for how to verify media playback
state.

[[_tc_mediaplayback_6_3_advanced_seek_media_playback_verification]]
===== link:#_tc_mediaplayback_6_3_advanced_seek_media_playback_verification[]19.8.3. [TC-MEDIAPLAYBACK-6.3] Advanced Seek Media Playback Verification

[[_category_63]]
====== link:#_category_63[]Category

Functional conformance

[[_purpose_63]]
====== link:#_purpose_63[]Purpose

This test case verifies the seek command for the Media Playback cluster

[[_pics_63]]
====== link:#_pics_63[]PICS

* MEDIAPLAYBACK.S

[[_preconditions_19]]
====== link:#_preconditions_19[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is powered on and not in a low power state |

|2 | |DUT has media content available for playback |

|3 | |Media content is loaded/selected and in a paused state at the
beginning of the content (PlayBackPosition 0) |
|===

[[_required_devices_63]]
====== link:#_required_devices_63[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_46]]
====== link:#_device_topology_46[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_58]]
====== link:#_test_setup_58[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_63]]
====== link:#_test_procedure_63[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.C0b.Rsp(Seek) |TH sends a
_Seek command_ to the DUT with a _Position_ value of 10000 |Verify that
a successful (status 0) response is received and verify that the media
has moved to 10 seconds from the starting point.

|2 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.A0003(SampledPosition) |TH
reads the _SampledPosition attribute_ from the DUT |Verify that the
response has a position of 10000

|3 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.A0001(StartTime) |TH reads
the _StartTime attribute_ from the DUT |Verify that the response is a
valid start time or null.

|4 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.A0005(SeekRangeEnd) |TH reads
the _SeekRangeEnd attribute_ from the DUT |Verify that the response is a
valid position or Nas.

|5 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.A0006(SeekRangeStart) |TH
reads the _SeekRangeStart attribute_ from the DUT |Verify that the
response is a valid position or Nas.

|6 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.A0002(Duration) |TH reads the
_Duration attribute_ from the DUT |Verify that the response is null or
not 0.

|7 |Media Playback 1.4.11 |MEDIAPLAYBACK.S.C0b.Rsp(Seek) |TH sends a
_Seek command_ to the DUT with a _Position_ value beyond the furthest
valid position (ex: beyond the duration of the media) |Verify that a
_SEEK_OUT_OF_RANGE_ (status 5) response is received and verify that the
media has not moved.
|===

[[_notestesting_considerations_64]]
====== link:#_notestesting_considerations_64[]Notes/Testing Considerations

. If a seek (steps 1) falls in the middle of a frame, the device must
set the position to the beginning of that frame. Physical measurements
and _SampledPosition_ reads may not exactly reflect the seeked
milliseconds.
. Manufacturer may provide instructions for how to verify media playback
state.

[[_tc_mediaplayback_6_4_variable_speed_media_playback_verification]]
===== link:#_tc_mediaplayback_6_4_variable_speed_media_playback_verification[]19.8.4. [TC-MEDIAPLAYBACK-6.4] Variable Speed Media Playback Verification

[[_category_64]]
====== link:#_category_64[]Category

Functional conformance

[[_purpose_64]]
====== link:#_purpose_64[]Purpose

This test case verifies the variable speed commands for the Media
Playback cluster (Rewind, FastForward)

[[_pics_64]]
====== link:#_pics_64[]PICS

* MEDIAPLAYBACK.S

[[_preconditions_20]]
====== link:#_preconditions_20[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT is powered on and not in a low power state |

|2 | |DUT has media content available for playback |

|3 | |Media content is loaded/selected and in a paused state at the
beginning of the content (PlayBackPosition 0) |
|===

[[_required_devices_64]]
====== link:#_required_devices_64[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_47]]
====== link:#_device_topology_47[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_59]]
====== link:#_test_setup_59[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_64]]
====== link:#_test_procedure_64[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PAUSED"

|2 | |MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |TH reads the _PlaybackSpeed
attribute_ from the DUT |Verify that the response has a PlaybackSpeed of
0

|3 |Media Playback 1.4.8 |MEDIAPLAYBACK.S.C07.Rsp(FastForward) |TH sends
a _FastForward command_ to the DUT |Verify that a successful (status 0)
response is received and verify that the media state is playing.

|4 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PLAYING"

|5 | |MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |TH reads the _PlaybackSpeed
attribute_ from the DUT |Verify that the response has a PlaybackSpeed of
1

|6 |Media Playback 1.4.8 |MEDIAPLAYBACK.S.C07.Rsp(FastForward) |TH sends
a _FastForward command_ to the DUT |Verify that a successful (status 0)
response is received and verify that the media play speed has increased.

|7 | |MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |TH reads the _PlaybackSpeed
attribute_ from the DUT |Verify that the response has a PlaybackSpeed of
2

|8 |Media Playback 1.4.7 |MEDIAPLAYBACK.S.C06.Rsp(Rewind) |TH sends a
_Rewind command_ to the DUT |Verify that a successful (status 0)
response is received and verify that the media play has reversed
direction.

|9 | |MEDIAPLAYBACK.S.A0000(CurrentState) |TH reads the _CurrentState
attribute_ from the DUT |Verify that the response has a playback status
of "PLAYING"

|10 | |MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |TH reads the _PlaybackSpeed
attribute_ from the DUT |Verify that the response has a PlaybackSpeed of
-1

|11 |Media Playback 1.4.7 |MEDIAPLAYBACK.S.C06.Rsp(Rewind) |TH sends a
_Rewind command_ to the DUT |Verify that a successful (status 0)
response is received and verify that the media play speed has increased
in the reverse direction.

|12 | |MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |TH reads the _PlaybackSpeed
attribute_ from the DUT |Verify that the response has a PlaybackSpeed of
-2

|13 | |MEDIAPLAYBACK.S.C00.Rsp(Play) |TH sends a _Play command_ to the
DUT |Verify that a successful (status 0) response is received and verify
that the media is has resumed playing forward at the default speed.

|14 |Media Playback 1.4.1 |MEDIAPLAYBACK.S.A0004(PlaybackSpeed) |TH
reads the _PlaybackSpeed attribute_ from the DUT |Verify that the
response has a PlaybackSpeed of 1

|15 |Media Playback 1.4.8 |MEDIAPLAYBACK.S.C07.Rsp(FastForward) |TH
sends consecutive _FastForward commands_ up to the manufacturer defined
max speed |Verify that a _SPEED_OUT_OF_RANGE_ (status 4) response is
received.

|16 |Media Playback 1.4.7 |MEDIAPLAYBACK.S.C06.Rsp(Rewind) |TH sends
consecutive _Rewind commands_ up to the manufacturer defined max speed
|Verify that a _SPEED_OUT_OF_RANGE_ (status 4) response is received.
|===

[[_notestesting_considerations_65]]
====== link:#_notestesting_considerations_65[]Notes/Testing Considerations

. Manufacturer should provide values for the maximum fast-forward and
rewind speeds for steps 15 and 16
. Manufacturer may provide instructions for how to verify media playback
state.

[[_tc_mediaplayback_6_5_mandatory_media_playback_verification_dut_as_client]]
===== link:#_tc_mediaplayback_6_5_mandatory_media_playback_verification_dut_as_client[]19.8.5. [TC-MEDIAPLAYBACK-6.5] Mandatory Media Playback Verification (DUT as Client)

[[_category_65]]
====== link:#_category_65[]Category

Functional conformance

[[_purpose_65]]
====== link:#_purpose_65[]Purpose

This test case verifies that the DUT can send mandatory Playback
commands

[[_pics_65]]
====== link:#_pics_65[]PICS

* MEDIAPLAYBACK.C

[[_required_devices_65]]
====== link:#_required_devices_65[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_48]]
====== link:#_device_topology_48[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_60]]
====== link:#_test_setup_60[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_65]]
====== link:#_test_procedure_65[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAPLAYBACK.C.C00.Tx(Play) |DUT sends _Play command_ to TH
|Verify command is successfully received by TH

|2 | |MEDIAPLAYBACK.C.C01.Tx(Pause) |DUT sends _Pause command_ to TH
|Verify command is successfully received by TH

|3 | |MEDIAPLAYBACK.C.C02.Tx(Stop) |DUT sends _Stop command_ to TH
|Verify command is successfully received by TH
|===

[[_notestesting_considerations_66]]
====== link:#_notestesting_considerations_66[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mediaplayback_6_7_optional_media_playback_verification_dut_as_client]]
===== link:#_tc_mediaplayback_6_7_optional_media_playback_verification_dut_as_client[]19.8.6. [TC-MEDIAPLAYBACK-6.7] Optional Media Playback Verification (DUT as Client)

[[_category_66]]
====== link:#_category_66[]Category

Functional conformance

[[_purpose_66]]
====== link:#_purpose_66[]Purpose

This test case verifies that the DUT can send optional Playback commands

[[_pics_66]]
====== link:#_pics_66[]PICS

* MEDIAPLAYBACK.C

[[_required_devices_66]]
====== link:#_required_devices_66[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_49]]
====== link:#_device_topology_49[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_61]]
====== link:#_test_setup_61[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_66]]
====== link:#_test_procedure_66[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |MEDIAPLAYBACK.C.C00.Tx(Play) |DUT sends _Play command_ to TH
|Verify command is successfully received by TH

|2 |Media Playback 1.4.4 |MEDIAPLAYBACK.C.C03.Tx(StartOver) |DUT sends
_StartOver command_ to TH |Verify command is successfully received by TH

|3 |Media Playback 1.4.5 |MEDIAPLAYBACK.C.C05.Tx(Next) |DUT sends _Next
command_ to TH |Verify command is successfully received by TH

|4 |Media Playback 1.4.6 |MEDIAPLAYBACK.C.C04.Tx(Previous) |DUT sends
_Previous command_ to TH |Verify command is successfully received by TH

|5 |Media Playback 1.4.9 |MEDIAPLAYBACK.C.C08.Tx(SkipForward) |DUT sends
_SkipForward command_ to TH |Verify command is successfully received by
TH

|6 |Media Playback 1.4.10 |MEDIAPLAYBACK.C.C09.Tx(SkipBackward) |DUT
sends _SkipBackward command_ to TH |Verify command is successfully
received by TH
|===

[[_notestesting_considerations_67]]
====== link:#_notestesting_considerations_67[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_audio_output_test_cases]]
==== link:#_audio_output_test_cases[]19.9. Audio Output Test Cases

'''''

[[_tc_audiooutput_7_1_select_output_verification]]
===== link:#_tc_audiooutput_7_1_select_output_verification[]19.9.1. [TC-AUDIOOUTPUT-7.1] Select Output Verification

[[_category_67]]
====== link:#_category_67[]Category

Functional conformance

[[_purpose_67]]
====== link:#_purpose_67[]Purpose

This test case verifies the select audio output command for the Audio
Output cluster

[[_pics_67]]
====== link:#_pics_67[]PICS

* AUDIOOUTPUT.S

[[_preconditions_21]]
====== link:#_preconditions_21[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_67]]
====== link:#_required_devices_67[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_50]]
====== link:#_device_topology_50[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_62]]
====== link:#_test_setup_62[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_67]]
====== link:#_test_procedure_67[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |AudioOutput 1.3.1 |AUDIOOUTPUT.S.A0000(OutputList) |TH reads the
_OutputList attribute_ from the DUT |Verify that a list of outputs (type
OutPutInfo) is returned.

|2 |AudioOutput 1.4.1 |AUDIOOUTPUT.S.C00.Rsp(SelectOutput) |TH sends a
_SelectAudioOutput command_ to the DUT with an index from the list in
step 1 |Verify that a successful (status 0) response is received.

|3 |AudioOutput 1.3.2 |AUDIOOUTPUT.S.A0001(CurrentOutput) |TH reads the
_CurrentOutput attribute_ from the DUT |Verify that the index returned
is the same as that provided in step 2.
|===

[[_notestesting_considerations_68]]
====== link:#_notestesting_considerations_68[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_audiooutput_7_2_rename_output_verification]]
===== link:#_tc_audiooutput_7_2_rename_output_verification[]19.9.2. [TC-AUDIOOUTPUT-7.2] Rename Output Verification

[[_category_68]]
====== link:#_category_68[]Category

Functional conformance

[[_purpose_68]]
====== link:#_purpose_68[]Purpose

This test case verifies the rename output command for the Audio Output
cluster

[[_pics_68]]
====== link:#_pics_68[]PICS

* AUDIOOUTPUT.S

[[_preconditions_22]]
====== link:#_preconditions_22[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_68]]
====== link:#_required_devices_68[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_51]]
====== link:#_device_topology_51[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_63]]
====== link:#_test_setup_63[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_68]]
====== link:#_test_procedure_68[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |AudioOutput 1.3.1 |AUDIOOUTPUT.S.A0000(OutputList) |TH reads the
_OutputList attribute_ from the DUT |Verify that a list of outputs (type
OutPutInfo) is returned. Select an index from the list to be renamed in
the next step.

|2 |AudioOutput 1.4.2 |AUDIOOUTPUT.S.C01.Rsp(RenameOutput) |TH sends a
_RenameOutput command_ to the DUT with an index from the list in step 1
and the name "CertTest" |Verify that a successful (status 0) response is
received.

|1 |AudioOutput 1.3.1 |AUDIOOUTPUT.S.A0001(CurrentOutput) |TH reads the
_OutputList attribute_ from the DUT |Verify that the output at the index
provided in step 2 has the name "CertTest".
|===

[[_notestesting_considerations_69]]
====== link:#_notestesting_considerations_69[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_audiooutput_7_3_select_output_verification_dut_as_client]]
===== link:#_tc_audiooutput_7_3_select_output_verification_dut_as_client[]19.9.3. [TC-AUDIOOUTPUT-7.3] Select Output Verification (DUT as Client)

[[_category_69]]
====== link:#_category_69[]Category

Functional conformance

[[_purpose_69]]
====== link:#_purpose_69[]Purpose

This test case verifies that the DUT can send the SelectOutput command

[[_pics_69]]
====== link:#_pics_69[]PICS

* AUDIOOUTPUT.C

[[_required_devices_69]]
====== link:#_required_devices_69[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_52]]
====== link:#_device_topology_52[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_64]]
====== link:#_test_setup_64[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_69]]
====== link:#_test_procedure_69[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |AUDIOOUTPUT.C.C00.Tx(SelectOutput) |DUT sends _SelectOutput
command_ to TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_70]]
====== link:#_notestesting_considerations_70[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_audiooutput_7_4_rename_output_verification_dut_as_client]]
===== link:#_tc_audiooutput_7_4_rename_output_verification_dut_as_client[]19.9.4. [TC-AUDIOOUTPUT-7.4] Rename Output Verification (DUT as Client)

[[_category_70]]
====== link:#_category_70[]Category

Functional conformance

[[_purpose_70]]
====== link:#_purpose_70[]Purpose

This test case verifies that the DUT can send the RenameOutput command

[[_pics_70]]
====== link:#_pics_70[]PICS

* AUDIOOUTPUT.C

[[_required_devices_70]]
====== link:#_required_devices_70[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_53]]
====== link:#_device_topology_53[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_65]]
====== link:#_test_setup_65[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_70]]
====== link:#_test_procedure_70[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |AudioOutput 1.4.2 |AUDIOOUTPUT.C.C01.Tx(RenameOutput) |DUT sends
_RenameOutput command_ to TH |Verify command is successfully received by
TH
|===

[[_notestesting_considerations_71]]
====== link:#_notestesting_considerations_71[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_target_navigator_cluster_test_cases]]
==== link:#_target_navigator_cluster_test_cases[]19.10. Target Navigator Cluster Test Cases

'''''

[[_tc_tgtnav_8_1_navigate_target_verification]]
===== link:#_tc_tgtnav_8_1_navigate_target_verification[]19.10.1. [TC-TGTNAV-8.1] Navigate Target Verification

[[_category_71]]
====== link:#_category_71[]Category

Functional conformance

[[_purpose_71]]
====== link:#_purpose_71[]Purpose

This test case verifies that the DUT can respond to navigation related
commands and provide values of associated attributes.

[[_pics_71]]
====== link:#_pics_71[]PICS

* TGTNAV.S

[[_preconditions_23]]
====== link:#_preconditions_23[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT has one or more navigation targets available |
|===

[[_required_devices_71]]
====== link:#_required_devices_71[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_54]]
====== link:#_device_topology_54[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_66]]
====== link:#_test_setup_66[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_71]]
====== link:#_test_procedure_71[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |TargetNavigator 1.3.2 |TGTNAV.S.A0001(CurrentTarget) |TH reads the
_CurrentTarget attribute_ from the DUT |Verify that a target ID (type
uint8, Null/NaU also acceptable) is returned. Record the value for usage
in the next step (1b).

|1b |TargetNavigator 1.3.1 |TGTNAV.S.A0000(TargetList) |TH reads the
_TargetList attribute_ from the DUT |Verify that a list of targets (type
TargetInfo with a uint8 id and string name) is returned. Select a
identifier from the list that is different from the value recorded in
the previous step (1a).

|2a |TargetNavigator 1.4.1 |TGTNAV.S.C00.Rsp(NavigateTarget) |TH sends a
_NavigateTarget command_ to the DUT with the identifier from step 1b
|Verify the target is navigated to/moved to the foreground on the DUT’s
user experience.

|2b |TargetNavigator 1.3.2 |TGTNAV.S.A0001(CurrentTarget) |TH reads the
_CurrentTarget attribute_ from the DUT |Verify that the target ID
returned is the same as the identifier provided in 2a. Record the value
for usage in the next step (3a).
|===

[[_notestesting_considerations_72]]
====== link:#_notestesting_considerations_72[]Notes/Testing Considerations

. Confirm which navigation targets support optional application specific
data, the data string to-be provided, and the expected behavior for that
data with the manufacturer for usage in steps 3.
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_tgtnav_8_2_navigate_target_verification_dut_as_client]]
===== link:#_tc_tgtnav_8_2_navigate_target_verification_dut_as_client[]19.10.2. [TC-TGTNAV-8.2] Navigate Target Verification (DUT as Client)

[[_category_72]]
====== link:#_category_72[]Category

Functional conformance

[[_purpose_72]]
====== link:#_purpose_72[]Purpose

This test case verifies that the DUT can send the NavigateTarget command

[[_pics_72]]
====== link:#_pics_72[]PICS

* TGTNAV.C

[[_required_devices_72]]
====== link:#_required_devices_72[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_55]]
====== link:#_device_topology_55[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_67]]
====== link:#_test_setup_67[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_72]]
====== link:#_test_procedure_72[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |TGTNAV.C.C00.Tx(NavigateTarget) |DUT sends _NavigateTarget
command_ to TH |Verify command is successfully received by TH
|===

[[_notestesting_considerations_73]]
====== link:#_notestesting_considerations_73[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_application_basic_cluster_test_cases]]
==== link:#_application_basic_cluster_test_cases[]19.11. Application Basic Cluster Test Cases

'''''

[[_tc_apbsc_9_1_application_basic_attribute_verification]]
===== link:#_tc_apbsc_9_1_application_basic_attribute_verification[]19.11.1. [TC-APBSC-9.1] Application Basic Attribute Verification

[[_category_73]]
====== link:#_category_73[]Category

Functional conformance

[[_purpose_73]]
====== link:#_purpose_73[]Purpose

This test case verifies the DUT can properly respond to commands to read
basic media application attributes

[[_pics_73]]
====== link:#_pics_73[]PICS

* APBSC.S

[[_preconditions_24]]
====== link:#_preconditions_24[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT has one or more Content Apps available |
|===

[[_required_devices_73]]
====== link:#_required_devices_73[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_56]]
====== link:#_device_topology_56[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_68]]
====== link:#_test_setup_68[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_73]]
====== link:#_test_procedure_73[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ApplicationBasic 1.3.1 |APBSC.S.A0000(VendorName) |TH reads the
_VendorName attribute_ from the DUT |Verify that the value is a human
readable string of the name of the vendor and is less than or equal to
32 UTF-8 characters.

|2 |ApplicationBasic 1.3.2 |APBSC.S.A0001(VendorID) |TH reads the
_VendorID attribute_ from the DUT |Verify that the value is the
Connectivity Standards Alliance assigned vendor ID for that Content App.

|3 |ApplicationBasic 1.3.3 |APBSC.S.A0002(ApplicationName) |TH reads the
_ApplicationName attribute_ from the DUT |Verify that the value is a
human readable string of the vendor-assigned Content App name and is
less than or equal to 256 UTF-8 characters.

|4 |ApplicationBasic 1.3.4 |APBSC.S.A0003(ProductID) |TH reads the
_ProductID attribute_ from the DUT |Verify that the value is an unsigned
16-bit integer of the vendor-assigned identifier for the Content App or,
if the Content App is certified by a standards body such as the CSA, the
certifying vendor-assigned identifier.

|5 |ApplicationBasic 1.3.5, 1.4.1, DIAL Registry
|APBSC.S.A0004(Application) |TH reads the _Application attribute_ from
the DUT a|
Verify that a CatalogVendorID and ApplicationID are returned.

The CatalogVendorID should be an unsigned 16-bit integer of the vendor
ID of the catalog, which should be either a CSA issued ID or 0x0000 if
it is the DIAL catalog.

The ApplicationID should be a string of the application identifier or
the DIAL prefix if the CatalogVendorID is the DIAL catalog.

|6 |ApplicationBasic 1.3.6, 1.4.2 |APBSC.S.A0005(Status) |TH reads the
_Status attribute_ from the DUT |Verify that the value is from 0 to 3
and represents the current running state of the application (0 =
stopped, 1 = running, visible to user, and active target for input, 2 =
running, but not visible to the user, 3 = running and visible, but not
the active target for input).

|7 |ApplicationBasic 1.3.7 |APBSC.S.A0006(ApplicationVersion) |TH reads
the _ApplicationVersion attribute_ from the DUT |Verify that the value
is a human readable string of the version of the Content App assigned by
the vendor. The string should be less than or equal to 32 UTF-8
characters.

|8 |ApplicationBasic 1.3.8 |APBSC.S.A0007(AllowedVendorList) |TH reads
the _AllowedVendorList attribute_ from the DUT |Verify that a list of
vendor ids is returned. Each entry should be a CSA assigned Content App
vendor ID.
|===

[[_notestesting_considerations_74]]
====== link:#_notestesting_considerations_74[]Notes/Testing Considerations

. Step 2: Refer to CSA provided documentation for a list of Content App
vendor IDs.
. Step 4: Validate certification status of the Content App with the
device or app developer.
. Step 5: Validate the catalog vendor ID issuer with the device or app
developer.
. Step 5: The current DIAL registry is available here:
http://www.dial-multiscreen.org/dial-registry/namespace-database
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_content_launcher_cluster_test_cases]]
==== link:#_content_launcher_cluster_test_cases[]19.12. Content Launcher Cluster Test Cases

'''''

[[_tc_contentlauncher_10_1_read_content_launcher_attributes]]
===== link:#_tc_contentlauncher_10_1_read_content_launcher_attributes[]19.12.1. [TC-CONTENTLAUNCHER-10.1] Read Content Launcher Attributes

[[_category_74]]
====== link:#_category_74[]Category

Functional conformance

[[_purpose_74]]
====== link:#_purpose_74[]Purpose

This test case verifies that the DUT can properly respond to attribute
read requests

[[_pics_74]]
====== link:#_pics_74[]PICS

* CONTENTLAUNCHER.S

[[_required_devices_74]]
====== link:#_required_devices_74[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |TH as client
|===

[[_device_topology_57]]
====== link:#_device_topology_57[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_69]]
====== link:#_test_setup_69[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_74]]
====== link:#_test_procedure_74[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ContentLauncher 1.3.1 |CONTENTLAUNCHER.S.A0000(AcceptHeader) |TH
reads the _AcceptHeader attribute_ from the DUT |Verify that response
contains a list of strings. The strings should be HTTP Accept Headers
that represent the content types supported by the DUT/App.

|2 |ContentLauncher 1.3.2
|CONTENTLAUNCHER.S.A0001(SupportedStreamingProtocols) |TH reads the
_SupportedStreamingProtocols attribute_ from the DUT |Verify that the
response contains a bitmap with a maximum size of 32 bits.
|===

[[_notestesting_considerations_75]]
====== link:#_notestesting_considerations_75[]Notes/Testing Considerations

. Step 2 - Currently supported protocols are DASH (represented by bit 0
set to 1 in the SupportedStreamingProtocols bitmap) and HLS (bit 1 set
to 1)
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_contentlauncher_10_3_launch_content_verification]]
===== link:#_tc_contentlauncher_10_3_launch_content_verification[]19.12.2. [TC-CONTENTLAUNCHER-10.3] Launch Content Verification

[[_category_75]]
====== link:#_category_75[]Category

Functional conformance

[[_purpose_75]]
====== link:#_purpose_75[]Purpose

This test case verifies that the DUT can properly respond to launch
content commands

[[_pics_75]]
====== link:#_pics_75[]PICS

* CONTENTLAUNCHER.S

[[_required_devices_75]]
====== link:#_required_devices_75[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |TH as client
|===

[[_device_topology_58]]
====== link:#_device_topology_58[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_70]]
====== link:#_test_setup_70[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_75]]
====== link:#_test_procedure_75[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ContentLauncher 1.4.1 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with a search parameter and
string, and AutoPlay flag set to false |The DUT should respond with a
success response (value 0) and optional application specific data in
string from. The DUT should also present via its user interface a list
of matches based on the provided search criteria.

|2 |ContentLauncher 1.4.1 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with a search parameter and
string, and AutoPlay flag set to true |The DUT should respond with a
success response (value 0) and optional application specific data in
string from. THE DUT should also begin playing content that best matched
the given search criteria.
|===

[[_notestesting_considerations_76]]
====== link:#_notestesting_considerations_76[]Notes/Testing Considerations

. Refer to device or application documentation for supported content
search strings.
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_contentlauncher_10_4_launch_content_verification_dut_as_client]]
===== link:#_tc_contentlauncher_10_4_launch_content_verification_dut_as_client[]19.12.3. [TC-CONTENTLAUNCHER-10.4] Launch Content Verification (DUT as Client)

[[_category_76]]
====== link:#_category_76[]Category

Functional conformance

[[_purpose_76]]
====== link:#_purpose_76[]Purpose

This test case verifies that the DUT can send the LaunchContent command

[[_pics_76]]
====== link:#_pics_76[]PICS

* CONTENTLAUNCHER.C

[[_required_devices_76]]
====== link:#_required_devices_76[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_59]]
====== link:#_device_topology_59[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_71]]
====== link:#_test_setup_71[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_76]]
====== link:#_test_procedure_76[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ContentLauncher 1.4.1 |CONTENTLAUNCHER.C.C00.Tx(LaunchContent) |DUT
sends _LaunchContent command_ to TH |Verify command is successfully
received by TH
|===

[[_notestesting_considerations_77]]
====== link:#_notestesting_considerations_77[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_contentlauncher_10_5_launch_url_verification]]
===== link:#_tc_contentlauncher_10_5_launch_url_verification[]19.12.4. [TC-CONTENTLAUNCHER-10.5] Launch URL Verification

[[_category_77]]
====== link:#_category_77[]Category

Functional conformance

[[_purpose_77]]
====== link:#_purpose_77[]Purpose

This test case verifies that the DUT can properly respond to launch URL
commands

[[_pics_77]]
====== link:#_pics_77[]PICS

* CONTENTLAUNCHER.S

[[_required_devices_77]]
====== link:#_required_devices_77[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |TH as client
|===

[[_device_topology_60]]
====== link:#_device_topology_60[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_72]]
====== link:#_test_setup_72[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_77]]
====== link:#_test_procedure_77[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C01.Rsp(LaunchURL) |TH
sends a _LaunchURL command_ to the DUT with a known good content URL
string |The DUT should respond with a success respond (value 0) and
indicate it has launched the content at the given URL.

|2 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C01.Rsp(LaunchURL) |TH
sends a _LaunchURL command_ to the DUT with a known good content URL
string and a display string |The DUT should respond with a success
response (value 0) and indicate it has launched the content at the given
URL with the given display string in the application-specific
description area.

|3 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C01.Rsp(LaunchURL) |TH
sends a _LaunchURL command_ to the DUT with a known good content URL
string and a brand information object. |The DUT should respond with a
success response (value 0) and indicate it has launched the content at
the given URL with the player interface updated as per the provided
branding information.

|4 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C01.Rsp(LaunchURL) |TH
sends a _LaunchURL command_ to the DUT with a known unreachable content
URL string. |The DUT should respond with a URL_NOT_AVAILABLE response
(value 1).

|5 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C01.Rsp(LaunchURL) |TH
sends a _LaunchURL command_ to the DUT with a known un-authorized
content URL string. |The DUT should respond with a AUTH_FAILED response
(value 2).
|===

[[_notestesting_considerations_78]]
====== link:#_notestesting_considerations_78[]Notes/Testing Considerations

. Refer to testing documentation for supported content URLs and test
branding information.
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_contentlauncher_10_6_launch_url_verification_dut_as_client]]
===== link:#_tc_contentlauncher_10_6_launch_url_verification_dut_as_client[]19.12.5. [TC-CONTENTLAUNCHER-10.6] Launch URL Verification (DUT as Client)

[[_category_78]]
====== link:#_category_78[]Category

Functional conformance

[[_purpose_78]]
====== link:#_purpose_78[]Purpose

This test case verifies that the DUT can send the LaunchURL command

[[_pics_78]]
====== link:#_pics_78[]PICS

* CONTENTLAUNCHER.C

[[_required_devices_78]]
====== link:#_required_devices_78[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_61]]
====== link:#_device_topology_61[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_73]]
====== link:#_test_setup_73[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_78]]
====== link:#_test_procedure_78[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.C.C01.Tx(LaunchURL) |DUT
sends _LaunchURL command_ to TH |Verify command is successfully received
by TH
|===

[[_notestesting_considerations_79]]
====== link:#_notestesting_considerations_79[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_contentlauncher_10_7_content_search_verification]]
===== link:#_tc_contentlauncher_10_7_content_search_verification[]19.12.6. [TC-CONTENTLAUNCHER-10.7] Content Search Verification

[[_category_79]]
====== link:#_category_79[]Category

Functional conformance

[[_purpose_79]]
====== link:#_purpose_79[]Purpose

This test case verifies that the DUT can support searching content by
identifiers

[[_pics_79]]
====== link:#_pics_79[]PICS

* CONTENTLAUNCHER.S

[[_required_devices_79]]
====== link:#_required_devices_79[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |TH as client
|===

[[_device_topology_62]]
====== link:#_device_topology_62[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_74]]
====== link:#_test_setup_74[]Test Setup

Commission DUT to TH, if not done so already. In some cases, such as
with a Casting Video Player, the DUT commissions the TH.

[[_test_procedure_79]]
====== link:#_test_procedure_79[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Actor" and Value as An Actor’s name, for example,
“Gaby sHoffman” |The DUT should respond with a success response (value
0) and should play or display the search result.

|2 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Channel" and Value as Channel Name name, for
example, "PBS" |The DUT should respond with a success response (value 0)
and should play or display the search result.

|3 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Character" and Value as Character’s name,for
example, “Snow White” |The DUT should respond with a success response
(value 0) and should play or display the search result.

|4 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Director" and Value as Director’s name, for
example, “Spike Lee” |The DUT should respond with a success response
(value 0) and should play or display the search result.

|5 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Event" and Value as An Event’s name , for example
"Football games" |The DUT should respond with a success response (value
0) and should play or display the search result.

|6 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Franchise" and Value as Franchise’s name,for
example "Star Wars" |The DUT should respond with a success response
(value 0) and should play or display the search result.

|7 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Genre" and Value as Genre’s name, for example
"Horror" |The DUT should respond with a success response (value 0) and
should play or display the search result.

|8 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "League" and Value as League’s name, for example
"NCAA" |The DUT should respond with a success response (value 0) and
should play or display the search result.

|9 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Popularity" and Value as Popularity’s name |The
DUT should respond with a success response (value 0) and should play or
display the search result.

|10 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Provider" and Value as Provider’s name, for
example "Netflix" |The DUT should respond with a success response (value
0) and should play or display the search result.

|11 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Sport" and Value as Sport’s name, for example,
football |The DUT should respond with a success response (value 0) and
should play or display the search result.

|12 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "SportsTeam" and Value as SportTeam’s name , for
example "Arsenel" |The DUT should respond with a success response (value
0) and should play or display the search result.

|13 |ContentLauncher 1.4.2 |CONTENTLAUNCHER.S.C00.Rsp(LaunchContent) |TH
sends a _LaunchContent command_ to the DUT with search parameter
consisting of Type As "Type" and Value as Type’s name, for example
"TVSeries", |The DUT should respond with a success response (value 0)
and should play or display the search result.
|===

[[_notestesting_considerations_80]]
====== link:#_notestesting_considerations_80[]Notes/Testing Considerations

. Refer to device or application documentation for supported content
search strings.
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_casting_video_player_test_cases]]
==== link:#_casting_video_player_test_cases[]19.13. Casting Video Player Test Cases

'''''

[[_tc_mc_11_1_casting_video_player_via_user_directed_commissioning_verification_dut_as_server]]
===== link:#_tc_mc_11_1_casting_video_player_via_user_directed_commissioning_verification_dut_as_server[]19.13.1. [TC-MC-11.1] Casting Video Player via User-Directed Commissioning Verification (DUT as Server)

[[_category_80]]
====== link:#_category_80[]Category

Functional conformance

[[_purpose_80]]
====== link:#_purpose_80[]Purpose

This test case verifies that a Commissioner is able to handle the
commissioning procedure initiated by a commissionee using User Directed
Commissioning.

[[_pics_80]]
====== link:#_pics_80[]PICS

* MC.S.M.UDCLOGIN

[[_preconditions_25]]
====== link:#_preconditions_25[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |DUT and Harness support Commissioner Discovery feature
|2 | | |DUT is already in the network
|3 | | |DUT supports AccountLogin cluster for certain Content Apps
|===

[[_required_devices_80]]
====== link:#_required_devices_80[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*

|1 |DUT |Matter Commissioner that supports Commissioner Discovery and is
already in network

|2 |TH |Commissionee that is in an uncommissioned state and support
Commissioner Discovery
|===

[[_test_procedure_80]]
====== link:#_test_procedure_80[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH start scanning for available commissioners using Commissioner
Discovery |TH must find the DUT Commissioner .

|2 | | |TH is instructed to select the commissioner found in step 1 |TH
should send a request to select the commissioner(DUT).

|3 | | |DUT prompt user for onboarding by giving an option to accept or
reject the commissioning of TH . |DUT must prompt user for accept or
reject onboarding.

|4 | | |DUT start the commissioning procedure with TH, when user accepts
the commissioning |Commissioning procedure ends with success.

|5 | | |TH reads the endpoints from the DUT |Verify an endpoint of type
"casting video player".

|6 | | |TH reads the endpoints from the DUT |Verify an endpoint of type
"speaker"(optional).

|7 | | |TH reads the endpoints from the DUT |Verify an endpoint of type
"content-app"(optional).
|===

[[_notestesting_considerations_81]]
====== link:#_notestesting_considerations_81[]Notes/Testing Considerations

. Refer to device or application documentation for supported DUT
configuration.
. For step 3 (prompt user), manufacturer may utilize a custom method for
obtaining user consent other than an on-screen prompt.
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_mc_11_2_casting_video_player_via_ux_screen_with_pin_verification_dut_as_server]]
===== link:#_tc_mc_11_2_casting_video_player_via_ux_screen_with_pin_verification_dut_as_server[]19.13.2. [TC-MC-11.2] Casting Video Player via UX Screen with PIN Verification (DUT as Server)

[[_category_81]]
====== link:#_category_81[]Category

Functional conformance

[[_purpose_81]]
====== link:#_purpose_81[]Purpose

This test case verifies that the manual pairing code can be provided to
the Commissioner and parsed to onboard the device onto the Matter
network.

[[_pics_81]]
====== link:#_pics_81[]PICS

* MC.S.M.UDC

[[_preconditions_26]]
====== link:#_preconditions_26[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |DUT and Harness support Commissioner Discovery feature
|2 | | |DUT is already in the network
|===

[[_required_devices_81]]
====== link:#_required_devices_81[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*

|1 |DUT |Matter Commissioner that supports Commissioner Discovery and is
already in network

|2 |TH |Commissionee that is in an uncommissioned state and support
Commissioner Discovery
|===

[[_test_procedure_81]]
====== link:#_test_procedure_81[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |TH start scanning for available commissioners using Commissioner
Discovery |TH must find the DUT Commissioner .

|2 | | |TH is instructed to select the commissioner found in step 1 |TH
should send a request to select the commissioner(DUT).

|3 | | |TH provides 11/21 digit manual pairing code or setup passcode.
|TH must provide 11/21 digit manual pairing code or setup passcode to
enter into DUT.

|4 | | |DUT Prompts user to enter the pairing code (provided by TH in
previous step). |When right code is entered, commissioning procedure
ends with success.

|5 | | |TH reads the endpoints from the DUT |Verify an endpoint of type
"casting video player".

|6 | | |TH reads the endpoints from the DUT |Verify an endpoint of type
"speaker"(optional).

|7 | | |TH reads the endpoints from the DUT |Verify an endpoint of type
"content-app"(optional).
|===

[[_notestesting_considerations_82]]
====== link:#_notestesting_considerations_82[]Notes/Testing Considerations

. Refer to device or application documentation for supported DUT
configuration.
. For step 4 (prompt user), manufacturer may utilize a custom method for
obtaining code other than an on-screen prompt.
. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_account_login_cluster_player_test_cases]]
==== link:#_account_login_cluster_player_test_cases[]19.14. Account Login Cluster Player Test Cases

'''''

[[_tc_alogin_12_1_account_login_verification]]
===== link:#_tc_alogin_12_1_account_login_verification[]19.14.1. [TC-ALOGIN-12.1] Account Login Verification

[[_category_82]]
====== link:#_category_82[]Category

Functional conformance

[[_purpose_82]]
====== link:#_purpose_82[]Purpose

This test case verifies that the DUT can respond to account login
commands.

[[_pics_82]]
====== link:#_pics_82[]PICS

* ALOGIN.S

[[_preconditions_27]]
====== link:#_preconditions_27[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|2 | |DUT is commissionable |
|===

[[_required_devices_82]]
====== link:#_required_devices_82[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_63]]
====== link:#_device_topology_63[]Device Topology

TH and DUT are on the same fabric. TH has Administrator privileges on
DUT.

[[_test_setup_75]]
====== link:#_test_setup_75[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_82]]
====== link:#_test_procedure_82[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |ALOGIN.S.C00.Rsp(GetSetupPIN) |TH sends a _GetSetupPIN command_ to
the DUT with test values provided by the product maker. |Verify that the
DUT responds with a valid _GetSetupPINResponse_.

|2 | |ALOGIN.S.C02.Rsp(Login) |TH sends a _Login command_ to the DUT
with test values provided by the product maker. |Verify that the DUT
responds with a standard command response.

|3 | |ALOGIN.S.C03.Rsp(Logout) |TH sends a _Logout command_ to the DUT
with test values provided by the product maker. |Verify that the DUT
responds with a standard command response.
|===

[[_notestesting_considerations_83]]
====== link:#_notestesting_considerations_83[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_tc_alogin_12_2_account_login_verification_dut_as_client]]
===== link:#_tc_alogin_12_2_account_login_verification_dut_as_client[]19.14.2. [TC-ALOGIN-12.2] Account Login Verification (DUT as Client)

[[_category_83]]
====== link:#_category_83[]Category

Functional conformance

[[_purpose_83]]
====== link:#_purpose_83[]Purpose

This test case verifies that the DUT can send the Account Login commands

[[_pics_83]]
====== link:#_pics_83[]PICS

* ALOGIN.C

[[_required_devices_83]]
====== link:#_required_devices_83[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_64]]
====== link:#_device_topology_64[]Device Topology

TH and DUT are on the same fabric. DUT has Administrator privileges on
TH.

[[_test_setup_76]]
====== link:#_test_setup_76[]Test Setup

Commission TH to DUT, if not done so already. In some cases, such as
with a Casting Video Player, the TH commissions the DUT.

[[_test_procedure_83]]
====== link:#_test_procedure_83[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |ALOGIN.C.C00.Tx(GetSetupPIN) |DUT sends _GetSetupPIN command_ to
TH |Verify command is successfully received by TH

|2 | |ALOGIN.C.C00.Tx(Login) |DUT sends _Login command_ to TH |Verify
command is successfully received by TH

|3 | |ALOGIN.C.C00.Tx(Logout) |DUT sends _Logout command_ to TH |Verify
command is successfully received by TH
|===

[[_notestesting_considerations_84]]
====== link:#_notestesting_considerations_84[]Notes/Testing Considerations

. Refer to manufacturer provided instructions for special argument
values to each command, and/or additional steps required to put DUT into
correct state to exhibit test behavior.

[[_level_control_cluster_test_plan]]
== link:#_level_control_cluster_test_plan[]**Level Control Cluster Test Plan**

[[_pics_definition_7]]
=== link:#_pics_definition_7[]20. PICS Definition

This section covers the PICS items that are referenced in the following
test cases. Support for an item is considered as "true" for conditional
statements within the test case steps.

[[_role_7]]
==== link:#_role_7[]20.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LVL.S |Does the device implement the Level Control cluster as a server?
|O |
|===

[[_server_7]]
==== link:#_server_7[]20.2. Server

[[_features_4]]
===== link:#_features_4[]20.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LVL.S.F00(OO) |Does the DUT(server) support the "Dependency with the
On/Off cluster" feature? |O |

|LVL.S.F01(LT) |Does the DUT(server) support the "Behavior that supports
lighting applications" feature? |O |

|LVL.S.F02(FQ) |Does the DUT(server) support the "Frequency attributes
and behavior" feature? |O |
|===

[[_attributes_7]]
===== link:#_attributes_7[]20.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LVL.S.A0000(CurrentLevel) |Does the DUT(server) support the
CurrentLevel attribute? |M |

|LVL.S.A0001(RemainingTime) |Does the DUT(server) support the
RemainingTime attribute? |LVL.S.F01(LT) |

|LVL.S.A0002(MinLevel) |Does the DUT(server) support the MinLevel
attribute? |O |

|LVL.S.A0003(MaxLevel) |Does the DUT(server) support the MaxLevel
attribute? |O |

|LVL.S.A0004(CurrentFrequency) |Does the DUT(server) support the
CurrentFrequency attribute? |LVL.S.F02(FQ) |

|LVL.S.A0005(MinFrequency) |Does the DUT(server) support the
MinFrequency attribute? |LVL.S.F02(FQ) |

|LVL.S.A0006(MaxFrequency) |Does the DUT(server) support the
MaxFrequency attribute? |LVL.S.F02(FQ) |

|LVL.S.A000f(Options) |Does the DUT(server) support the Options
attribute? |M |

|LVL.S.A0010(OnOffTransitionTime) |Does the DUT(server) support the
OnOffTransitionTime attribute? |O |

|LVL.S.A0011(OnLevel) |Does the DUT(server) support the OnLevel
attribute? |M |

|LVL.S.A0012(OnTransitionTime) |Does the DUT(server) support the
OnTransitionTime attribute? |O |

|LVL.S.A0013(OffTransitionTime) |Does the DUT(server) support the
OffTransitionTime attribute? |O |

|LVL.S.A0014(DefaultMoveRate) |Does the DUT(server) support the
DefaultMoveRate attribute? |O |

|LVL.S.A4000(StartUpCurrentLevel) |Does the DUT(server) support the
StartUpCurrentLevel attribute? |LVL.S.F01(LT) |
|===

[[_commands_received_3]]
===== link:#_commands_received_3[]20.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LVL.S.C00.Rsp(MoveToLevel) |Does the DUT(server) support the
MoveToLevel command? |M |

|LVL.S.C01.Rsp(Move) |Does the DUT(server) support the Move command? |M
|

|LVL.S.C02.Rsp(Step) |Does the DUT(server) support the Step command? |M
|

|LVL.S.C03.Rsp(Stop) |Does the DUT(server) support the Stop command? |M
|

|LVL.S.C04.Rsp(MoveToLevelWithOnOff) |Does the DUT(server) support the
MoveToLevel with On/Off command? |M |

|LVL.S.C05.Rsp(MoveWithOnOff) |Does the DUT(server) support the Move
with On/Off command? |M |

|LVL.S.C06.Rsp(StepWithOnOff) |Does the DUT(server) support the Step
with On/Off command? |M |

|LVL.S.C07.Rsp(StopWithOnOff) |Does the DUT(server) support the Stop
with On/Off command? |M |

|LVL.S.C08.Rsp(MoveToClosestFrequency) |Does the DUT(server) support the
MoveToClosestFrequency command? |LVL.S.F02(FQ) |
|===

[[_manual_controllable_5]]
===== link:#_manual_controllable_5[]20.2.4. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LVL.S.M.VarRate |Is the DUT(server) able to move at a variable rate
feature? |O |
|===

[[_test_case_list_7]]
=== link:#_test_case_list_7[]21. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-LVL-1.1 |Global attributes with (DUT as Server)

|TC-LVL-2.1 |Read cluster attributes (DUT as Server)

|TC-LVL-2.2 |Write cluster attributes (DUT as Server)

|TC-LVL-3.1 |MoveToLevel Verification (DUT as Server)

|TC-LVL-4.1 |Move Verification (DUT as Server)

|TC-LVL-5.1 |Step Verification (DUT as Server)

|TC-LVL-6.1 |Stop Verification (DUT as Server)

|TC-LVL-7.1 |Verification of MoveToClosestFrequency command (DUT as
Server)
|===

[[_test_cases_7]]
=== link:#_test_cases_7[]22. Test Cases

'''''

[[_generic_test_cases_6]]
==== link:#_generic_test_cases_6[]22.1. Generic test cases

'''''

[[_tc_lvl_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_lvl_1_1_global_attributes_with_server_as_dut[]22.1.1. [TC-LVL-1.1] Global attributes with server as DUT

[[_category_84]]
====== link:#_category_84[]Category

Functional conformance

[[_purpose_84]]
====== link:#_purpose_84[]Purpose

This test case verifies that the DUT can provide the Level Control
Cluster Global attributes.

[[_pics_84]]
====== link:#_pics_84[]PICS

* LVL.S

[[_required_devices_84]]
====== link:#_required_devices_84[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_84]]
====== link:#_test_procedure_84[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH reads the _ClusterRevision attribute_ from the DUT |Verify
that the DUT response indicates that the ClusterRevision attribute has
the value 5

|2 | | |TH reads the _FeatureMap attribute_ from the DUT |Verify that
the DUT response indicates that the FeatureMap attribute has bit 0 set
to 1 if the DUT has a dependency on the On/Off cluster (i.e.
LVL.S.F00(OO) is true), bit 1 set if the DUT supports lighting
applications (i.e. LVL.S.F01(LT) is true), and bit 2 is set if the DUT
supports frequency behavior (i.e. LVL.S.F02(FQ) is true).

|3 | | |TH reads the _AttributeList attribute_ from the DUT a|
Verify that the DUT response provides a list of supported attributes.
This list should include the mandatory attributes (values 0, 17, 15) and
the following values based on support for optional attributes:

If the DUT supports lighting applications (LVL.S.F01(LT) is true): 1,
16384

If the DUT supports frequency behavior (LVL.S.F02(FQ) is true): 4, 5, 6

MinLevel attribute (LVL.S.A0002(MinLevel) is true): 2

MaxLevel attribute (LVL.S.A0003(MaxLevel) is true): 3

OnOffTransitionTime attribute (LVL.S.A0010(OnOffTransitionTime) is
true): 16

OnTransitionTime attribute (LVL.S.A0012(OnTransitionTime) is true): 18

OffTransitionTime attribute (LVL.S.A0013(OffTransitionTime) is true): 19

DefaultMoveRate attribute (LVL.S.A0014(DefaultMoveRate) is true): 20

|4a | | |TH reads AcceptedCommandList attribute from DUT |Verify that
the DUT response provides a list of supported commands, which for this
cluster should be a list containing the values 0 through 7 and the value
8 if the DUT supports frequency behavior (LVL.S.F02(FQ) is true).

|4b | | |TH reads GeneratedCommandList attribute from DUT |list SHALL be
empty

|5 | | |TH reads the _EventList attribute_ from the DUT |Verify that the
DUT response provides a list of supported events, which for this cluster
should be an empty list.
|===

[[_notestesting_considerations_85]]
====== link:#_notestesting_considerations_85[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

[[_cluster_attribute_test_cases]]
==== link:#_cluster_attribute_test_cases[]22.2. Cluster Attribute test cases

'''''

[[_tc_lvl_2_1_read_cluster_attributes_dut_as_server]]
===== link:#_tc_lvl_2_1_read_cluster_attributes_dut_as_server[]22.2.1. [TC-LVL-2.1] Read cluster attributes (DUT as Server)

[[_category_85]]
====== link:#_category_85[]Category

Functional conformance

[[_purpose_85]]
====== link:#_purpose_85[]Purpose

This test case verifies that the DUT can respond to Level Control
cluster attribute read commands.

[[_pics_85]]
====== link:#_pics_85[]PICS

* LVL.S

[[_required_devices_85]]
====== link:#_required_devices_85[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_85]]
====== link:#_test_procedure_85[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.5.1 |LVL.S.A0000(CurrentLevel) |TH reads the _CurrentLevel
attribute_ from the DUT |Verify that the DUT response contains an
integer with a maximum size of 8 bits.

|2 |1.5.2 |LVL.S.A0001(RemainingTime) |TH reads the _RemainingTime
attribute_ from the DUT |Verify that the DUT response contains an
integer with a maximum size of 16 bits.

|3 |1.5.3 |LVL.S.A0002(MinLevel) |TH reads the _MinLevel attribute_ from
the DUT a|
* Verify that the DUT response contains an integer with a maximum size
of 8 bits.
* If LVL.S.F01(LT), verify that the value is exactly 1.

|4 |1.5.4 |LVL.S.A0003(MaxLevel) & LVL.S.A0002(MinLevel) |TH reads the
_MaxLevel attribute_ from the DUT a|
* Verify that the DUT response contains an integer with a maximum size
of 8 bits.
* Verify that the value is larger than or equal to the _MinLevel_ value
read in step 3.
* Verify that the value is less than or equal to 254.
* If LVL.S.F01(LT), verify that the value is exactly 254.

|4b | |LVL.S.A0002(MinLevel) & LVL.S.A0000(CurrentLevel) | |verify that
the value of the _CurrentLevel attribute_ read in step 1 is larger than
or equal to the value of the _MinLevel attribute_ read in step 3

|4c | |LVL.S.A0003(MaxLevel) & LVL.S.A0000(CurrentLevel) | |verify that
the value of the _CurrentLevel attribute_ read in step 1 is less than or
equal to the value of the _MaxLevel attribute_ read in step 4

|5 |1.5.5 |LVL.S.A0004(CurrentFrequency) |TH reads the _CurrentFrequency
attribute_ from the DUT |Verify that the DUT response contains an
integer with a maximum size of 16 bits.

|6 |1.5.6 |LVL.S.A0005(MinFrequency) |TH reads the _MinFrequency
attribute_ from the DUT |Verify that the DUT response contains an
integer with a maximum size of 16 bits.

|7 |1.5.7 |LVL.S.A0006(MaxFrequency) |TH reads the _MaxFrequency
attribute_ from the DUT |Verify that the DUT response contains an
integer with a maximum size of 16 bits.

|7b | |LVL.S.A0004(CurrentFrequency) & LVL.S.A0005(MinFrequency) |
|Verify that the value of the _CurrentFrequency attribute_ read in step
5 is larger than or equal to the value of the _MinFrequency attribute_
read in step 6

|7c | |LVL.S.A0004(CurrentFrequency) & LVL.S.A0006(MaxFrequency) |
|Verify that the value of the _CurrentFrequency attribute_ read in step
5 is less than or equal to the value of the _MaxFrequency attribute_
read in step 7

|8 |1.5.9 |LVL.S.A0010(OnOffTransitionTime) |TH reads the
_OnOffTransitionTime attribute_ from the DUT |Verify that the DUT
response contains an integer with a maximum size of 16 bits.

|9 |1.5.10 |LVL.S.A0011(OnLevel) |TH reads the _OnLevel attribute_ from
the DUT a|
If the value is not null

* Verify that the DUT response contains an integer with a maximum size
of 8 bits.
* Verify that the value is larger than or equal to the _MinLevel_ value
read in step 3.
* Verify that the value is less than or equal to the _MaxLevel_ value
read in step 4.

|10 |1.5.11 |LVL.S.A0012(OnTransitionTime) |TH reads the
_OnTransitionTime attribute_ from the DUT |Verify that the DUT response
contains an integer with a maximum size of 16 bits.

|11 |1.5.12 |LVL.S.A0013(OffTransitionTime) |TH reads the
_OffTransitionTime attribute_ from the DUT |Verify that the DUT response
contains an integer with a maximum size of 16 bits.

|12 |1.5.13 |LVL.S.A0014(DefaultMoveRate) |TH reads the _DefaultMoveRate
attribute_ from the DUT |Verify that the DUT response contains an
integer with a maximum size of 8 bits.

|13 |1.5.8 |LVL.S.A000f(Options) |TH reads the _Options attribute_ from
the DUT a|
* Verify that the DUT response contains a bitmap.
* Verify that bits other than bits 0 and 1 are set to 0.

|14 |1.5.14 |LVL.S.A4000(StartUpCurrentLevel) |TH reads the
_StartUpCurrentLevel attribute_ from the DUT |Verify that the DUT
response contains an integer with a maximum size of 8 bits.
|===

[[_notestesting_considerations_86]]
====== link:#_notestesting_considerations_86[]Notes/Testing Considerations

[[_tc_lvl_2_2_write_cluster_attributes_dut_as_server]]
===== link:#_tc_lvl_2_2_write_cluster_attributes_dut_as_server[]22.2.2. [TC-LVL-2.2] Write cluster attributes (DUT as Server)

[[_category_86]]
====== link:#_category_86[]Category

Functional conformance

[[_purpose_86]]
====== link:#_purpose_86[]Purpose

This test case verifies that the DUT can respond to Level Control
cluster attribute write commands.

[[_pics_86]]
====== link:#_pics_86[]PICS

* LVL.S

[[_preconditions_28]]
====== link:#_preconditions_28[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH has write access to DUT (Operate and manage privilege) |
|===

[[_required_devices_86]]
====== link:#_required_devices_86[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_86]]
====== link:#_test_procedure_86[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a |1.5.9 |LVL.S.A0010(OnOffTransitionTime) |TH reads the
_OnOffTransitionTime attribute_ from the DUT |Verify that the DUT
response contains an integer. Record the value for usage in step 1b.

|1b |1.5.9 |LVL.S.A0010(OnOffTransitionTime) |TH writes the
_OnOffTransitionTime attribute_ on the DUT with a different value than
that read in 1a |Verify that write request was successful.

|1c |1.5.9 |LVL.S.A0010(OnOffTransitionTime) |TH reads the
_OnOffTransitionTime attribute_ from the DUT |Verify that the DUT
response contains the value given in step 1b.

|2a |1.5.10 |LVL.S.A0011(OnLevel) |TH reads the _OnLevel attribute_ from
the DUT |Verify that the DUT response contains an integer. Record the
value for usage in step 2b.

|2b |1.5.10 |LVL.S.A0011(OnLevel) |TH writes the _OnLevel attribute_ on
the DUT with a different value than that read in 2a |Verify that write
request was successful.

|2c |1.5.10 |LVL.S.A0011(OnLevel) |TH reads the _OnLevel attribute_ from
the DUT |Verify that the DUT response contains the value given in step
2b.

|3a |1.5.11 |LVL.S.A0012(OnTransitionTime) |TH reads the
_OnTransitionTime attribute_ from the DUT |Verify that the DUT response
contains an integer. Record the value for usage in step 3b.

|3b |1.5.11 |LVL.S.A0012(OnTransitionTime) |TH writes the
_OnTransitionTime attribute_ on the DUT with a different value than that
read in 3a |Verify that write request was successful.

|3c |1.5.11 |LVL.S.A0012(OnTransitionTime) |TH reads the
_OnTransitionTime attribute_ from the DUT |Verify that the DUT response
contains the value given in step 3b.

|4a |1.5.12 |LVL.S.A0013(OffTransitionTime) |TH reads the
_OffTransitionTime attribute_ from the DUT |Verify that the DUT response
contains an integer. Record the value for usage in step 4b.

|4b |1.5.12 |LVL.S.A0013(OffTransitionTime) |TH writes the
_OffTransitionTime attribute_ on the DUT with a different value than
that read in 4a |Verify that write request was successful.

|4c |1.5.12 |LVL.S.A0013(OffTransitionTime) |TH reads the
_OffTransitionTime attribute_ from the DUT |Verify that the DUT response
contains the value given in step 4b.

|5a |1.5.13 |LVL.S.A0014(DefaultMoveRate) |TH reads the _DefaultMoveRate
attribute_ from the DUT |Verify that the DUT response contains an
integer. Record the value for usage in step 5b.

|5b |1.5.13 |LVL.S.A0014(DefaultMoveRate) |TH writes the
_DefaultMoveRate attribute_ on the DUT with a different value than that
read in 5a |Verify that write request was successful.

|5c |1.5.13 |LVL.S.A0014(DefaultMoveRate) |TH reads the _DefaultMoveRate
attribute_ from the DUT |Verify that the DUT response contains the value
given in step 5b.

|6a |1.5.14 |LVL.S.A4000(StartUpCurrentLevel) |TH reads the
_StartUpCurrentLevel attribute_ from the DUT |Verify that the DUT
response contains an integer. Record the value for usage in step 6b.

|6b |1.5.14 |LVL.S.A4000(StartUpCurrentLevel) |TH writes the
_StartUpCurrentLevel attribute_ on the DUT with a different value than
that read in 6a |Verify that write request was successful.

|6c |1.5.14 |LVL.S.A4000(StartUpCurrentLevel) |TH reads the
_StartUpCurrentLevel attribute_ from the DUT |Verify that the DUT
response contains the value given in step 6b.
|===

[[_notestesting_considerations_87]]
====== link:#_notestesting_considerations_87[]Notes/Testing Considerations

[[_movetolevel_test_cases]]
==== link:#_movetolevel_test_cases[]22.3. MoveToLevel Test Cases

'''''

[[_tc_lvl_3_1_movetolevel_verification_dut_as_server]]
===== link:#_tc_lvl_3_1_movetolevel_verification_dut_as_server[]22.3.1. [TC-LVL-3.1] MoveToLevel Verification (DUT as Server)

[[_category_87]]
====== link:#_category_87[]Category

Functional conformance

[[_purpose_87]]
====== link:#_purpose_87[]Purpose

This test case verifies the MoveToLevel and MoveToLevelWithOnOff command
functionality

[[_pics_87]]
====== link:#_pics_87[]PICS

* LVL.S

[[_preconditions_29]]
====== link:#_preconditions_29[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_87]]
====== link:#_required_devices_87[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_65]]
====== link:#_device_topology_65[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_77]]
====== link:#_test_setup_77[]Test Setup

* Commission DUT to TH, if not done so already.
* For commands used in steps 1-4 of this test, use fields
OptionsMask=0x00 and OptionsOverride=0x00.
* For the steps 5 and beyond, use fields OptionsMask and OptionsOverride
as specified in the test steps.
* The levels used in this test assume that MinLevel=1 and MaxLevel=254.
For DUTs that have different values, adapt the values used accordingly.

[[_test_procedure_87]]
====== link:#_test_procedure_87[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

LVL.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1a

LVL.S.A0011(OnLevel)

TH writes NULL to the _OnLevel attribute_ +
(NOTE - fix/workaround for #2176)

Verify that write request was successful.

tests for MoveToLevelWithOnOff (starting with DUT in OFF state)

2a

LVL.S.C04.Rsp(MoveToLevelWithOnOff) & OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

2b

LVL.S.C04.Rsp(MoveToLevelWithOnOff)

TH sends a _MoveToLevelWithOnOff_ command to DUT, with _Level_ =50 and
_TransitionTime_ =0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

2c

LVL.S.C04.Rsp(MoveToLevelWithOnOff) & OO.S.A0000(OnOff)

TH reads _OnOff attribute_ (On/Off cluster) from DUT

The value of OnOff has to be TRUE.

2d

LVL.S.C04.Rsp(MoveToLevelWithOnOff) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 2b.

steps to make sure DUT is on and at level 50 (for steps 4a etc) in case
!LVL.S.C04.Rsp(MoveToLevelWithOnOff)

3a

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

3b

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to DUT, with _Level_ =50 and
_TransitionTime_ =0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

3c

LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 3b.

tests for MoveToLevel (with transition time)

4a

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with _Level_ = 200 and
_TransitionTime_ = 300 (30 s). This means the level should increase by
150 units in 30s, so 5 units/s.

Verify DUT responds with a successful (value 0x00) status response

4b

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 100 (50+10*5).

4c

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After another 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 150 (50+20*5).

4d

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After another 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 200 (50+30*5).

4e

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After another 5 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
is now stable at the value 200.

4f

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel) &
!LVL.S.M.VarRate

TH reads _CurrentLevel attribute_ from DUT (after DUT has finished the
transition)

Verify that the DUT response indicates that the CurrentLevel attribute
is at the value 200.

tests for Options-bits (ExecuteIfOff=false)

5a

LVL.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

no error response

5b

LVL.S.A000f(Options)

TH reads the _Options attribute_ from the DUT

* Verify that the DUT response contains a bitmap, with value 0x00.

5c

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

5d

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 100
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device moves to the given level.

5e

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 5d.

5f

OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

5g

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 120
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

5h

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
(still) has the value given in 5d.

5i

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 140
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

5j

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
(still) has the value given in 5d.

5k

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 160
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x01

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

5l

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 5k.

tests for Options-bits (ExecuteIfOff=true)

6a

LVL.S.A000f(Options)

TH writes 0x01 to the _Options attribute_

6b

LVL.S.A000f(Options)

TH reads the _Options attribute_ from the DUT

* Verify that the DUT response contains a bitmap, with value 0x01.

6c

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

6d

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 100
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device moves to the given level.

6e

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 6d.

6f

OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

6g

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 120
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

6h

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 6g.

6i

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 140
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

6j

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
(still) has the value given in 6g.

6k

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to the DUT with

* Level = 160
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x01

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

6l

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 6k.

[[_notestesting_considerations_88]]
=== link:#_notestesting_considerations_88[]Notes/Testing Considerations

. In test cases where a change in an attribute value is tested over time
(e.g. steps 4b-4c-4d), it is permitted for the devices involved in the
test to be within a tolerance of ±15% of the expected value. As such,
these test cases indicate that the attribute value must be approximately
equal to an expected value, to which the ±15% tolerance should then be
applied. All other attribute values presented are expected to be exact.

[[_move_test_cases]]
=== link:#_move_test_cases[]22.4. Move Test Cases

'''''

[[_tc_lvl_4_1_move_verification_dut_as_server]]
==== link:#_tc_lvl_4_1_move_verification_dut_as_server[]22.4.1. [TC-LVL-4.1] Move Verification (DUT as Server)

[[_category_88]]
===== link:#_category_88[]Category

Functional conformance

[[_purpose_88]]
===== link:#_purpose_88[]Purpose

This test case verifies the Move and MoveWithOnOff command functionality

[[_pics_88]]
===== link:#_pics_88[]PICS

* LVL.S

[[_preconditions_30]]
===== link:#_preconditions_30[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_88]]
===== link:#_required_devices_88[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_66]]
===== link:#_device_topology_66[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_78]]
===== link:#_test_setup_78[]Test Setup

* Commission DUT to TH, if not done so already.
* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The levels used in this test assume that MinLevel=1 and MaxLevel=254.
For DUTs that have different values, adapt the values used accordingly.

[[_test_procedure_88]]
===== link:#_test_procedure_88[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

LVL.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

LVL.S.A0003(MaxLevel)

TH reads the _MaxLevel attribute_ from the DUT

Note the value for usage in later steps.

tests for MoveWithOnOff (starting with DUT in OFF state)

2a

LVL.S.C05.Rsp(MoveWithOnOff) & OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

2b

LVL.S.C05.Rsp(MoveWithOnOff)

TH sends a _MoveWithOnOff_ command to DUT, with _MoveMode_ =0x00 (up)
and _Rate_ =10 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2c

LVL.S.C05.Rsp(MoveWithOnOff) & OO.S.A0000(OnOff)

TH reads _OnOff attribute_ (On/Off cluster) from DUT

The value of OnOff has to be TRUE.

2d

LVL.S.C05.Rsp(MoveWithOnOff) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

2e

LVL.S.C05.Rsp(MoveWithOnOff) & LVL.S.A0000(CurrentLevel)

After 5 seconds TH reads _CurrentLevel attribute_ from DUT

If not at MaxLevel, value is 50 (5*10) units higher than what was read
at 2d.

steps to make sure DUT is on and at level 50 (for steps 4a etc) in case
!LVL.S.C05.Rsp(MoveWithOnOff)

3a

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

3b

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to DUT, with _Level_ =50 and
_TransitionTime_ =0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

3c

LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 3b.

tests for Move

4a

LVL.S.C01.Rsp(Move)

TH sends a _Move_ command to the DUT with _MoveMode_ =0x00 (up) and
_Rate_ =5 (units/s)

Verify DUT responds with a successful (value 0x00) status response

4b

LVL.S.C01.Rsp(Move) & LVL.S.A0000(CurrentLevel)

After 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 100 (50+10*5).

4c

LVL.S.C01.Rsp(Move) & LVL.S.A0000(CurrentLevel)

After another 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 150 (50+20*5).

4d

LVL.S.C01.Rsp(Move) & LVL.S.A0000(CurrentLevel)

After another 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 200 (50+30*5).

4e

LVL.S.C01.Rsp(Move) & LVL.S.A0000(CurrentLevel)

After another 19 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has stabilized at the max value 254 (50+49*5=295 > max).

[[_notestesting_considerations_89]]
=== link:#_notestesting_considerations_89[]Notes/Testing Considerations

. If the DUT is not able to move at a variable rate (LVL.S.M.VarRate is
false), the move rate field should be disregarded in these test steps.
The DUT should instead move at a fixed rate.
. In test cases where a change in an attribute value is tested over time
(e.g. steps 4b-4d), it is permitted for the devices involved in the test
to be within a tolerance of ±15% of the expected value. As such, these
test cases indicate that the attribute value must be approximately equal
to an expected value, to which the ±15% tolerance should then be
applied. All other attribute values presented are expected to be exact.

[[_step_test_cases]]
=== link:#_step_test_cases[]22.5. Step Test Cases

'''''

[[_tc_lvl_5_1_step_verification_dut_as_server]]
==== link:#_tc_lvl_5_1_step_verification_dut_as_server[]22.5.1. [TC-LVL-5.1] Step Verification (DUT as Server)

[[_category_89]]
===== link:#_category_89[]Category

Functional conformance

[[_purpose_89]]
===== link:#_purpose_89[]Purpose

This test case verifies the Step and StepWithOnOff command functionality

[[_pics_89]]
===== link:#_pics_89[]PICS

* LVL.S

[[_preconditions_31]]
===== link:#_preconditions_31[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_89]]
===== link:#_required_devices_89[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_67]]
===== link:#_device_topology_67[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_79]]
===== link:#_test_setup_79[]Test Setup

* Commission DUT to TH, if not done so already.
* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The levels used in this test assume that MinLevel=1 and MaxLevel=254.
For DUTs that have different values, adapt the values used accordingly.

[[_test_procedure_89]]
===== link:#_test_procedure_89[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

LVL.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

tests for StepWithOnOff (starting with DUT in OFF state)

2a

LVL.S.C06.Rsp(StepWithOnOff) & OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

2b

LVL.S.C06.Rsp(StepWithOnOff)

TH sends a _StepWithOnOff_ command to DUT, with _StepMode_ =0x00 (up),
_StepSize_ =50 and _TransitionTime_ =0 (immediate).

Verify DUT responds with a successful (value 0x00) status response.

2c

LVL.S.C06.Rsp(StepWithOnOff) & OO.S.A0000(OnOff)

TH reads _OnOff attribute_ (On/Off cluster) from DUT

The value of OnOff has to be TRUE.

steps to make sure DUT is on and at level 50 (for steps 4a etc) in case
!LVL.S.C06.Rsp(StepWithOnOff)

3a

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

3b

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to DUT, with _Level_ =50 and
_TransitionTime_ =0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

3c

LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 3b.

tests for Step (with transition time)

4a

LVL.S.C02.Rsp(Step)

TH sends a _Step_ command to the DUT with StepMode_ =0x00 (up),
_StepSize_ =150 and _TransitionTime_ =300 (30 s). This means the level
should increase by 150 units in 30s, so 5 units/s.

Verify DUT responds with a successful (value 0x00) status response

4b

LVL.S.C02.Rsp(Step) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 100 (50+10*5).

4c

LVL.S.C02.Rsp(Step) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After another 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 150 (50+20*5).

4d

LVL.S.C02.Rsp(Step) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After another 10 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value 200 (50+30*5).

4e

LVL.S.C02.Rsp(Step) & LVL.S.A0000(CurrentLevel) & LVL.S.M.VarRate

After another 5 seconds, TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
is now stable at the value 200.

4f

LVL.S.C02.Rsp(Step) & LVL.S.A0000(CurrentLevel) & !LVL.S.M.VarRate

TH reads _CurrentLevel attribute_ from DUT (after DUT has finished the
transition)

Verify that the DUT response indicates that the CurrentLevel attribute
is at the value 200.

[[_notestesting_considerations_90]]
=== link:#_notestesting_considerations_90[]Notes/Testing Considerations

. If the DUT is not able to move at a variable rate (LVL.S.M.VarRate is
false), the move rate field should be disregarded in these test steps.
The DUT should instead move at a fixed rate.
. In test cases where a change in an attribute value is tested over time
(e.g. steps 4b-4d), it is permitted for the devices involved in the test
to be within a tolerance of ±15% of the expected value. As such, these
test cases indicate that the attribute value must be approximately equal
to an expected value, to which the ±15% tolerance should then be
applied. All other attribute values presented are expected to be exact.

[[_stop_test_cases]]
=== link:#_stop_test_cases[]22.6. Stop Test Cases

'''''

[[_tc_lvl_6_1_stop_verification_dut_as_server]]
==== link:#_tc_lvl_6_1_stop_verification_dut_as_server[]22.6.1. [TC-LVL-6.1] Stop Verification (DUT as Server)

[[_category_90]]
===== link:#_category_90[]Category

Functional conformance

[[_purpose_90]]
===== link:#_purpose_90[]Purpose

This test case verifies the Stop and StopWithOnOff command functionality

[[_pics_90]]
===== link:#_pics_90[]PICS

* LVL.S
* LVL.S.M.VarRate

[[_preconditions_32]]
===== link:#_preconditions_32[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_90]]
===== link:#_required_devices_90[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_68]]
===== link:#_device_topology_68[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_80]]
===== link:#_test_setup_80[]Test Setup

* Commission DUT to TH, if not done so already.
* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The levels used in this test assume that MinLevel=1 and MaxLevel=254.
For DUTs that have different values, adapt the values used accordingly.

[[_test_procedure_90]]
===== link:#_test_procedure_90[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

steps to make sure DUT is on and at level 50 (for steps 2 etc)

1a

LVL.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

1c

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to DUT, with _Level_ =50 and
_TransitionTime_ =0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

1d

LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 1c.

2

1.6.4

LVL.S.C01.Rsp(Move)

TH sends a _Move_ command to the DUT, with the _MoveMode_ field set to
0x00 (move up) and the _Rate_ field set to 0x05 (5 units/s)

Verify DUT responds with a successful (value 0x00) status response.

3

1.6.4

LVL.S.C03.Rsp(Stop)

After 5 seconds, TH sends a _Stop_ command to the DUT

Verify DUT responds with a successful (value 0x00) status response.

Physically verify that the device has stopped transitioning.

4

1.6.4

LVL.S.C01.Rsp(Move) & LVL.S.C03.Rsp(Stop) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has increased by 25 units compared to the level read in step 1d.

5

1.6.4

LVL.S.C01.Rsp(Move)

TH sends a _Move_ command to the DUT, with the _MoveMode_ field set to
0x00 (move up) and the _Rate_ field set to 0x05 (5 units/s)

Verify DUT responds with a successful (value 0x00) status response.

6

1.6.4

LVL.S.C07.Rsp(StopWithOnOff)

After 5 seconds, TH sends a _StopWithOnOff_ command to the DUT

Verify DUT responds with a successful (value 0x00) status response.

Physically verify that the device has stopped transitioning.

7

1.6.4

LVL.S.C01.Rsp(Move) & LVL.S.C07.Rsp(StopWithOnOff) &
LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has increased by 25 units compared to the level read in step 4.

[[_notestesting_considerations_91]]
=== link:#_notestesting_considerations_91[]Notes/Testing Considerations

. In test cases where a change in an attribute value is tested over time
(e.g. steps 4 and 7), it is permitted for the devices involved in the
test to be within a tolerance of ±15% of the expected value. As such,
these test cases indicate that the attribute value must be approximately
equal to an expected value, to which the ±15% tolerance should then be
applied. All other attribute values presented are expected to be exact.

'''''

[[_tc_lvl_7_1_verification_of_movetoclosestfrequency_command_dut_as_server]]
=== link:#_tc_lvl_7_1_verification_of_movetoclosestfrequency_command_dut_as_server[]22.6.2. [TC-LVL-7.1] Verification of MoveToClosestFrequency command (DUT as Server)

[[_category_91]]
==== link:#_category_91[]Category

Functional conformance

[[_purpose_91]]
==== link:#_purpose_91[]Purpose

This test case verifies the command functionality for
MoveToClosestFrequency.

[[_pics_91]]
==== link:#_pics_91[]PICS

* LVL.S
* LVL.S.F02(FQ)

[[_preconditions_33]]
==== link:#_preconditions_33[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is powered on and not in a low power state |
|===

[[_required_devices_91]]
==== link:#_required_devices_91[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_69]]
==== link:#_device_topology_69[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_81]]
==== link:#_test_setup_81[]Test Setup

* Commission DUT to TH, if not done so already.
* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[[_test_procedure_91]]
==== link:#_test_procedure_91[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

LVL.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

1a

LVL.S.A0002(MinLevel)

TH reads the _MinLevel attribute_ from the DUT

Note the value for usage in later steps.

1b

LVL.S.A0003(MaxLevel)

TH reads the _MaxLevel attribute_ from the DUT

Note the value for usage in later steps.

1c

LVL.S.C00.Rsp(MoveToLevel)

TH sends a _MoveToLevel_ command to DUT, with the _Level_ field set to a
value between the MinLevel and MaxLevel values (if present, otherwise
between 0x01 and 0xFE) and the _TransitionTime_ field set to 0x0000
(move immediately).

Verify DUT responds with a successful (value 0x00) status response and
that the device completes moving to the given level.

1d

1.6.1

LVL.S.C00.Rsp(MoveToLevel) & LVL.S.A0000(CurrentLevel)

TH reads _CurrentLevel attribute_ from DUT

Verify that the DUT response indicates that the CurrentLevel attribute
has the value given in 1c.

2a

LVL.S.A0004(CurrentFrequency)

TH reads the _CurrentFrequency_ attribute.

Set f~c~ to the value of the _CurrentFrequency_ attribute.

2b

LVL.S.A0005(MinFrequency)

TH reads the _MinFrequency_ attribute.

Set f~min~ to the value of the _MinFrequency_ attribute.

2c

LVL.S.A0006(MaxFrequency)

TH reads the _MaxFrequency_ attribute.

Set f~max~ to the value of the _MaxFrequency_ attribute.

2d

LVL.S.A0006(MaxFrequency)

sanity check on values read in steps 2a..2c

* if f~max~ < f~min~, FAIL the test
* if f~c~ < f~min~, FAIL the test
* if f~c~ > f~max~, FAIL the test

3a

LVL.S.C08.Rsp(MoveToClosestFrequency)

TH sends a _MoveToClosestFrequency_ command to DUT, with the _frequency_
field set to a random value _f~rand~_, chosen such that: f~min~ <
f~rand~ < f~max~

Verify DUT responds with a successful (value 0x00) status response

3b

LVL.S.C08.Rsp(MoveToClosestFrequency) & LVL.S.A0004(CurrentFrequency)

TH reads the _CurrentFrequency_ attribute.

The value of the _CurrentFrequency_ attribute is approximately equal to
_f~rand~_.

steps 4a,4b SHALL be skipped if f~max~ > 0xfffd

4a

LVL.S.C08.Rsp(MoveToClosestFrequency)

TH sends a _MoveToClosestFrequency_ command to DUT, with the _frequency_
field set to _f~max~_ + 1

Verify DUT responds with a CONSTRAINT_ERROR (value 0x87) status response

4b

LVL.S.C08.Rsp(MoveToClosestFrequency) & LVL.S.A0004(CurrentFrequency)

TH reads the _CurrentFrequency_ attribute.

The value of the _CurrentFrequency_ attribute is equal to the value read
in step 3b.

steps 5a,5b SHALL be skipped if f~min~ < 0x0002

5a

LVL.S.C08.Rsp(MoveToClosestFrequency)

TH sends a _MoveToClosestFrequency_ command to DUT, with the _frequency_
field set to _f~min~_ - 1

Verify DUT responds with a CONSTRAINT_ERROR (value 0x87) status response

5b

LVL.S.C08.Rsp(MoveToClosestFrequency) & LVL.S.A0004(CurrentFrequency)

TH reads the _CurrentFrequency_ attribute.

The value of the _CurrentFrequency_ attribute is equal to the value read
in step 4b (if that step was executed) resp. the value read in step 3b
(if step 4b was not executed).

[[_notestesting_considerations_92]]
=== link:#_notestesting_considerations_92[]Notes/Testing Considerations

Test Steps #3, #4, #5 cannot be executed with V1.0 SDK

'''''

[[_color_control_cluster_test_plan]]
== link:#_color_control_cluster_test_plan[]**Color Control Cluster Test Plan**

*Tolerance allowance*

In test cases where a change in an attribute value is tested over time,
it is permitted for the devices involved in the test to be within a
tolerance of ±15% of the expected time.

Also, when reading attributes representing a color value, they may
deviate from the value provided in a related command due to rounding
effects in DUT, inaccuracies during a transition (±15% value tolerance
allowed), or due to clipping if the value provided in the command is
outside the support range of the DUT.

[[_pics_definition_8]]
=== link:#_pics_definition_8[]23. PICS Definition

This section covers the Color Control Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case Steps.

[[_role_8]]
==== link:#_role_8[]23.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.S |Does the device implement the Color Control cluster as a server?
|Optional |

|CC.C |Does the device implement the Color Control cluster as a client?
|Optional |
|===

[[_server_8]]
==== link:#_server_8[]23.2. Server

[[_features_5]]
===== link:#_features_5[]23.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.S.F00(HS) |Does the DUT(server) support the "Hue/Saturation"
feature? |O |

|CC.S.F01(EHUE) |Does the DUT(server) support the "Enhanced Hue"
feature? |O |

|CC.S.F02(CL) |Does the DUT(server) support the "Color Loop" feature? |O
|

|CC.S.F03(XY) |Does the DUT(server) support the "Color XY" feature? |O |

|CC.S.F04(CT) |Does the DUT(server) support the "Color Temperature"
feature? |O |
|===

[[_attributes_8]]
===== link:#_attributes_8[]23.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.S.A0000(CurrentHue) |Does the device implement the CurrentHue
attribute? |CC.S.F00(HS) |

|CC.S.A0001(CurrentSaturation) |Does the device implement the
CurrentSaturation attribute? |CC.S.F00(HS) |

|CC.S.A0002(RemainingTime) |Does the device implement the REMAININGTime
attribute? |CC.S: Optional |

|CC.S.A0003(CurrentX) |Does the device implement the CurrentX attribute?
|CC.S.F03(XY) |

|CC.S.A0004(CurrentY) |Does the device implement the CurrentY attribute?
|CC.S.F03(XY) |

|CC.S.A0005(DriftCompensation) |Does the device implement the
DriftCompensation attribute? |CC.S: Optional |

|CC.S.A0006(CompensationText) |Does the device implement the
CompensationText attribute? |CC.S: Optional |

|CC.S.A0007(ColorTemperatureMireds) |Does the device implement the
ColorTemperatureMireds attribute? |CC.S.F04(CT) |

|CC.S.A0008(ColorMode) |Does the device implement the ColorMode
attribute? |CC.S: Mandatory |

|CC.S.A000f(Options) |Does the device implement the Options attribute?
|CC.S: Mandatory |

|CC.S.A0010(NumberOfPrimaries) |Does the device implement the
NumberOfPrimaries attribute? |CC.S: Mandatory |

|CC.S.A0011(Primary1X) |Does the device implement the Primary1X
attribute? |PIXIT_NUMBEROFPRIMARIES>0: Mandatory |

|CC.S.A0012(Primary1Y) |Does the device implement the Primary1Y
attribute? |PIXIT_NUMBEROFPRIMARIES>0: Mandatory |

|CC.S.A0013(Primary1Intensity) |Does the device implement the
Primary1Intensity attribute? |PIXIT_NUMBEROFPRIMARIES>0: Mandatory |

|CC.S.A0015(Primary2X) |Does the device implement the Primary2X
attribute? |PIXIT_NUMBEROFPRIMARIES>1: Mandatory |

|CC.S.A0016(Primary2Y) |Does the device implement the Primary2Y
attribute? |PIXIT_NUMBEROFPRIMARIES>1: Mandatory |

|CC.S.A0017(Primary2Intensity) |Does the device implement the
Primary2Intensity attribute? |PIXIT_NUMBEROFPRIMARIES>1: Mandatory |

|CC.S.A0019(Primary3X) |Does the device implement the Primary3X
attribute? |PIXIT_NUMBEROFPRIMARIES>2: Mandatory |

|CC.S.A001a(Primary3Y) |Does the device implement the Primary3Y
attribute? |PIXIT_NUMBEROFPRIMARIES>2: Mandatory |

|CC.S.A001b(Primary3Intensity) |Does the device implement the
Primary3Intensity attribute? |PIXIT_NUMBEROFPRIMARIES>2: Mandatory |

|CC.S.A0020(Primary4X) |Does the device implement the Primary4X
attribute? |PIXIT_NUMBEROFPRIMARIES>3: Mandatory |

|CC.S.A0021(Primary4Y) |Does the device implement the Primary4Y
attribute? |PIXIT_NUMBEROFPRIMARIES>3: Mandatory |

|CC.S.A0022(Primary4Intensity) |Does the device implement the
Primary4Intensity attribute? |PIXIT_NUMBEROFPRIMARIES>3: Mandatory |

|CC.S.A0024(Primary5X) |Does the device implement the Primary5X
attribute? |PIXIT_NUMBEROFPRIMARIES>4: Mandatory |

|CC.S.A0025(Primary5Y) |Does the device implement the Primary5Y
attribute? |PIXIT_NUMBEROFPRIMARIES>4: Mandatory |

|CC.S.A0026(Primary5Intensity) |Does the device implement the
Primary5Intensity attribute? |PIXIT_NUMBEROFPRIMARIES>4: Mandatory |

|CC.S.A0028(Primary6X) |Does the device implement the Primary6X
attribute? |PIXIT_NUMBEROFPRIMARIES>5: Mandatory |

|CC.S.A0029(Primary6Y) |Does the device implement the Primary6Y
attribute? |PIXIT_NUMBEROFPRIMARIES>5: Mandatory |

|CC.S.A002a(Primary6Intensity) |Does the device implement the
Primary6Intensity attribute? |PIXIT_NUMBEROFPRIMARIES>5: Mandatory |

|CC.S.A0030(WhitePointX) |Does the device implement the WhitePointX
attribute? |CC.S: Optional |

|CC.S.A0031(WhitePointY) |Does the device implement the WhitePointY
attribute? |CC.S: Optional |

|CC.S.A0032(ColorPointRX) |Does the device implement the ColorPointRX
attribute? |CC.S: Optional |

|CC.S.A0033(ColorPointRY) |Does the device implement the ColorPointRY
attribute? |CC.S: Optional |

|CC.S.A0034(ColorPointRIntensity) |Does the device implement the
ColorPointRIntensity attribute? |CC.S: Optional |

|CC.S.A0036(ColorPointGX) |Does the device implement the ColorPointGX
attribute? |CC.S: Optional |

|CC.S.A0037(ColorPointGY) |Does the device implement the ColorPointGY
attribute? |CC.S: Optional |

|CC.S.A0038(ColorPointGIntensity) |Does the device implement the
ColorPointGIntensity attribute? |CC.S: Optional |

|CC.S.A003a(ColorPointBX) |Does the device implement the ColorPointBX
attribute? |CC.S: Optional |

|CC.S.A003b(ColorPointBY) |Does the device implement the ColorPointBY
attribute? |CC.S: Optional |

|CC.S.A003c(ColorPointBIntensity) |Does the device implement the
ColorPointBIntensity attribute? |CC.S: Optional |

|CC.S.A4000(EnhancedCurrentHue) |Does the device implement the
EnhancedCurrentHue attribute? |CC.S.F01(EHUE) |

|CC.S.A4001(EnhancedColorMode) |Does the device implement the
EnhancedColorMode attribute? |CC.S: Mandatory |

|CC.S.A4002(ColorLoopActive) |Does the device implement the
ColorLoopActive attribute? |CC.S.F02(CL) |

|CC.S.A4003(ColorLoopDirection) |Does the device implement the
ColorLoopDirection attribute? |CC.S.F02(CL) |

|CC.S.A4004(ColorLoopTime) |Does the device implement the ColorLoopTime
attribute? |CC.S.F02(CL) |

|CC.S.A4005(ColorLoopStartEnhancedHue) |Does the device implement the
ColorLoopStartEnhancedHue attribute? |CC.S.F02(CL) |

|CC.S.A4006(ColorLoopStoredEnhancedHue) |Does the device implement the
ColorLoopStoredEnhancedHue attribute? |CC.S.F02(CL) |

|CC.S.A400a(ColorCapabilities) |Does the device implement the
ColorCapabilities attribute? |CC.S: Mandatory |

|CC.S.A400b(ColorTempPhysicalMinMireds) |Does the device implement the
ColorTempPhysicalMinMireds attribute? |CC.S.F04(CT) |

|CC.S.A400c(ColorTempPhysicalMaxMireds) |Does the device implement the
ColorTempPhysicalMaxMireds attribute? |CC.S.F04(CT) |

|CC.S.A400d(CoupleColorTempToLevelMinMireds) |Does the device implement
the CoupleColorTempToLevelMinMireds attribute? |CC.S.F04(CT) |
CC.S.A0007(ColorTemperatureMireds) |

|CC.S.A4010(StartUpColorTemperatureMireds) |Does the device implement
the StartUpColorTemperatureMireds attribute? |CC.S.F04(CT) |
CC.S.A0007(ColorTemperatureMireds) |
|===

[[_commands_received_4]]
===== link:#_commands_received_4[]23.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.S.C00.Rsp(MoveToHue) |Does the device implement receiving the
MoveToHue command? |CC.S.F00(HS) |

|CC.S.C01.Rsp(MoveHue) |Does the device implement receiving the MoveHue
command? |CC.S.F00(HS) |

|CC.S.C02.Rsp(StepHue) |Does the device implement receiving the StepHue
command? |CC.S.F00(HS) |

|CC.S.C03.Rsp(MoveToSaturation) |Does the device implement receiving the
MoveToSaturation command? |CC.S.F00(HS) |

|CC.S.C04.Rsp(MoveSaturation) |Does the device implement receiving the
MoveSaturation command? |CC.S.F00(HS) |

|CC.S.C05.Rsp(StepSaturation) |Does the device implement receiving the
StepSaturation command? |CC.S.F00(HS) |

|CC.S.C06.Rsp(MoveToHueAndSaturation) |Does the device implement
receiving the MoveToHueAndSaturation command? |CC.S.F00(HS) |

|CC.S.C07.Rsp(MoveToColor) |Does the device implement receiving the
MoveToColor command? |CC.S.F03(XY) |

|CC.S.C08.Rsp(MoveColor) |Does the device implement receiving the
MoveColor command? |CC.S.F03(XY) |

|CC.S.C09.Rsp(StepColor) |Does the device implement receiving the
StepColor command? |CC.S.F03(XY) |

|CC.S.C0a.Rsp(MoveToColorTemperature) |Does the device implement
receiving the MoveToColorTemperature command? |CC.S.F04(CT) |

|CC.S.C40.Rsp(EnhancedMoveToHue) |Does the device implement receiving
the EnhancedMoveToHue command? |CC.S.F01(EHUE) |

|CC.S.C41.Rsp(EnhancedMoveHue) |Does the device implement receiving the
EnhancedMoveHue command? |CC.S.F01(EHUE) |

|CC.S.C42.Rsp(EnhancedStepHue) |Does the device implement receiving the
EnhancedStepHue command? |CC.S.F01(EHUE) |

|CC.S.C43.Rsp(EnhancedMoveToHueAndSaturation) |Does the device implement
receiving the EnhancedMoveToHueAndSaturation command? |CC.S.F01(EHUE) |

|CC.S.C44.Rsp(ColorLoopSet) |Does the device implement receiving the
ColorLoopSet command? |CC.S.F02(CL) |

|CC.S.C47.Rsp(StopMoveStep) |Does the device implement receiving the
StopMoveStep command? |CC.S.F00(HS) | CC.S.F03(XY) | CC.S.F04(CT) |

|CC.S.C4b.Rsp(MoveColorTemperature) |Does the device implement receiving
the MoveColorTemperature command? |CC.S.F04(CT) |

|CC.S.C4c.Rsp(StepColorTemperature) |Does the device implement receiving
the StepColorTemperature command? |CC.S.F04(CT) |
|===

[[_client_3]]
==== link:#_client_3[]23.3. Client

[[_features_6]]
===== link:#_features_6[]23.3.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.C.F00(HS) |Does the DUT(client) support the "Hue/Saturation"
feature? |O |

|CC.C.F01(EHUE) |Does the DUT(client) support the "Enhanced Hue"
feature? |O |

|CC.C.F02(CL) |Does the DUT(client) support the "Color Loop" feature? |O
|

|CC.C.F03(XY) |Does the DUT(client) support the "Color XY" feature? |O |

|CC.C.F04(CT) |Does the DUT(client) support the "Color Temperature"
feature? |O |
|===

[[_attributes_9]]
===== link:#_attributes_9[]23.3.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.C.A0000(CurrentHue) |Does the DUT(client) have access privileges for
the CurrentHue attribute implemented on server? |O |

|CC.C.A0001(CurrentSaturation) |Does the DUT(client) have access
privileges for the CurrentSaturation attribute implemented on server? |O
|

|CC.C.A0002(RemainingTime) |Does the DUT(client) have access privileges
for the RemainingTime attribute implemented on server? |O |

|CC.C.A0003(CurrentX) |Does the DUT(client) have access privileges for
the CurrentX attribute implemented on server? |O |

|CC.C.A0004(CurrentY) |Does the DUT(client) have access privileges for
the CurrentY attribute implemented on server? |O |

|CC.C.A0005(DriftCompensation) |Does the DUT(client) have access
privileges for the DriftCompensation attribute implemented on server? |O
|

|CC.C.A0006(CompensationText) |Does the DUT(client) have access
privileges for the CompensationText attribute implemented on server? |O
|

|CC.C.A0007(ColorTemperatureMireds) |Does the DUT(client) have access
privileges for the ColorTemperatureMireds attribute implemented on
server? |O |

|CC.C.A0008(ColorMode) |Does the DUT(client) have access privileges for
the ColorMode attribute implemented on server? |O |

|CC.C.A000f(Options) |Does the DUT(client) have access privileges for
the Options attribute implemented on server? |O |

|CC.C.A0010(NumberOfPrimaries) |Does the DUT(client) have access
privileges for the NumberOfPrimaries attribute implemented on server? |O
|

|CC.C.A0011(Primary1X) |Does the DUT(client) have access privileges for
the Primary1X attribute implemented on server? |O |

|CC.C.A0012(Primary1Y) |Does the DUT(client) have access privileges for
the Primary1Y attribute implemented on server? |O |

|CC.C.A0013(Primary1Intensity) |Does the DUT(client) have access
privileges for the Primary1Intensity attribute implemented on server? |O
|

|CC.C.A0015(Primary2X) |Does the DUT(client) have access privileges for
the Primary2X attribute implemented on server? |O |

|CC.C.A0016(Primary2Y) |Does the DUT(client) have access privileges for
the Primary2Y attribute implemented on server? |O |

|CC.C.A0017(Primary2Intensity) |Does the DUT(client) have access
privileges for the Primary2Intensity attribute implemented on server? |O
|

|CC.C.A0019(Primary3X) |Does the DUT(client) have access privileges for
the Primary3X attribute implemented on server? |O |

|CC.C.A001a(Primary3Y) |Does the DUT(client) have access privileges for
the Primary3Y attribute implemented on server? |O |

|CC.C.A001b(Primary3Intensity) |Does the DUT(client) have access
privileges for the Primary3Intensity attribute implemented on server? |O
|

|CC.C.A0020(Primary4X) |Does the DUT(client) have access privileges for
the Primary4X attribute implemented on server? |O |

|CC.C.A0021(Primary4Y) |Does the DUT(client) have access privileges for
the Primary4Y attribute implemented on server? |O |

|CC.C.A0022(Primary4Intensity) |Does the DUT(client) have access
privileges for the Primary4Intensity attribute implemented on server? |O
|

|CC.C.A0024(Primary5X) |Does the DUT(client) have access privileges for
the Primary5X attribute implemented on server? |O |

|CC.C.A0025(Primary5Y) |Does the DUT(client) have access privileges for
the Primary5Y attribute implemented on server? |O |

|CC.C.A0026(Primary5Intensity) |Does the DUT(client) have access
privileges for the Primary5Intensity attribute implemented on server? |O
|

|CC.C.A0028(Primary6X) |Does the DUT(client) have access privileges for
the Primary6X attribute implemented on server? |O |

|CC.C.A0029(Primary6Y) |Does the DUT(client) have access privileges for
the Primary6Y attribute implemented on server? |O |

|CC.C.A002a(Primary6Intensity) |Does the DUT(client) have access
privileges for the Primary6Intensity attribute implemented on server? |O
|

|CC.C.A0030(WhitePointX) |Does the DUT(client) have access privileges
for the WhitePointX attribute implemented on server? |O |

|CC.C.A0031(WhitePointY) |Does the DUT(client) have access privileges
for the WhitePointY attribute implemented on server? |O |

|CC.C.A0032(ColorPointRX) |Does the DUT(client) have access privileges
for the ColorPointRX attribute implemented on server? |O |

|CC.C.A0033(ColorPointRY) |Does the DUT(client) have access privileges
for the ColorPointRY attribute implemented on server? |O |

|CC.C.A0034(ColorPointRIntensity) |Does the DUT(client) have access
privileges for the ColorPointRIntensity attribute implemented on server?
|O |

|CC.C.A0036(ColorPointGX) |Does the DUT(client) have access privileges
for the ColorPointGX attribute implemented on server? |O |

|CC.C.A0037(ColorPointGY) |Does the DUT(client) have access privileges
for the ColorPointGY attribute implemented on server? |O |

|CC.C.A0038(ColorPointGIntensity) |Does the DUT(client) have access
privileges for the ColorPointGIntensity attribute implemented on server?
|O |

|CC.C.A003a(ColorPointBX) |Does the DUT(client) have access privileges
for the ColorPointBX attribute implemented on server? |O |

|CC.C.A003b(ColorPointBY) |Does the DUT(client) have access privileges
for the ColorPointBY attribute implemented on server? |O |

|CC.C.A003c(ColorPointBIntensity) |Does the DUT(client) have access
privileges for the ColorPointBIntensity attribute implemented on server?
|O |

|CC.C.A4000(EnhancedCurrentHue) |Does the DUT(client) have access
privileges for the EnhancedCurrentHue attribute implemented on server?
|O |

|CC.C.A4001(EnhancedColorMode) |Does the DUT(client) have access
privileges for the EnhancedColorMode attribute implemented on server? |O
|

|CC.C.A4002(ColorLoopActive) |Does the DUT(client) have access
privileges for the ColorLoopActive attribute implemented on server? |O |

|CC.C.A4003(ColorLoopDirection) |Does the DUT(client) have access
privileges for the ColorLoopDirection attribute implemented on server?
|O |

|CC.C.A4004(ColorLoopTime) |Does the DUT(client) have access privileges
for the ColorLoopTime attribute implemented on server? |O |

|CC.C.A4005(ColorLoopStartEnhancedHue) |Does the DUT(client) have access
privileges for the ColorLoopStartEnhancedHue attribute implemented on
server? |O |

|CC.C.A4006(ColorLoopStoredEnhancedHue) |Does the DUT(client) have
access privileges for the ColorLoopStoredEnhancedHue attribute
implemented on server? |O |

|CC.C.A400a(ColorCapabilities) |Does the DUT(client) have access
privileges for the ColorCapabilities attribute implemented on server? |O
|

|CC.C.A400b(ColorTempPhysicalMinMireds) |Does the DUT(client) have
access privileges for the ColorTempPhysicalMinMireds attribute
implemented on server? |O |

|CC.C.A400c(ColorTempPhysicalMaxMireds) |Does the DUT(client) have
access privileges for the ColorTempPhysicalMaxMireds attribute
implemented on server? |O |

|CC.C.A400d(CoupleColorTempToLevelMinMireds) |Does the DUT(client) have
access privileges for the CoupleColorTempToLevelMinMireds attribute
implemented on server? |O |

|CC.C.A4010(StartUpColorTemperatureMireds) |Does the DUT(client) have
access privileges for the StartUpColorTemperatureMireds attribute
implemented on server? |O |
|===

[[_commands_generated_3]]
===== link:#_commands_generated_3[]23.3.3. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CC.C.C00.Tx(MoveToHue) |Does the device implement sending the MoveToHue
command? |O |

|CC.C.C01.Tx(MoveHue) |Does the device implement sending the MoveHue
command? |O |

|CC.C.C02.Tx(StepHue) |Does the device implement sending the StepHue
command? |O |

|CC.C.C03.Tx(MoveToSaturation) |Does the device implement sending the
MoveToSaturation command? |O |

|CC.C.C04.Tx(MoveSaturation) |Does the device implement sending the
MoveSaturation command? |O |

|CC.C.C05.Tx(StepSaturation) |Does the device implement sending the
StepSaturation command? |O |

|CC.C.C06.Tx(MoveToHueAndSaturation) |Does the device implement sending
the MoveToHueAndSaturation command? |O |

|CC.C.C07.Tx(MoveToColor) |Does the device implement sending the
MoveToColor command? |O |

|CC.C.C08.Tx(MoveColor) |Does the device implement sending the MoveColor
command? |O |

|CC.C.C09.Tx(StepColor) |Does the device implement sending the StepColor
command? |O |

|CC.C.C0a.Tx(MoveToColorTemperature) |Does the device implement sending
the MoveToColorTemperature command? |O |

|CC.C.C40.Tx(EnhancedMoveToHue) |Does the device implement sending the
EnhancedMoveToHue command? |O |

|CC.C.C41.Tx(EnhancedMoveHue) |Does the device implement sending the
EnhancedMoveHue command? |O |

|CC.C.C42.Tx(EnhancedStepHue) |Does the device implement sending the
EnhancedStepHue command? |O |

|CC.C.C43.Tx(EnhancedMoveToHueAndSaturation) |Does the device implement
sending the EnhancedMoveToHueAndSaturation command? |O |

|CC.C.C44.Tx(ColorLoopSet) |Does the device implement sending the
ColorLoopSet command? |O |

|CC.C.C47.Tx(StopMoveStep) |Does the device implement sending the
StopMoveStep command? |O |

|CC.C.C4b.Tx(MoveColorTemperature) |Does the device implement sending
the MoveColorTemperature command? |O |

|CC.C.C4c.Tx(StepColorTemperature) |Does the device implement sending
the StepColorTemperature command? |O |
|===

[[_pixit_definition_2]]
=== link:#_pixit_definition_2[]24. PIXIT Definition

This section covers the Color Control’s Test Plan related PIXIT items
that might be required in the following test cases.
:PIXIT_NUMBEROFPRIMARIES : PIXIT.CC.NumberOfPrimaries

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT_NUMBEROFPRIMARIES |The NumberOfPrimaries attribute contains the
number of color primaries implemented on this device |M |
|===

[[_test_case_list_8]]
=== link:#_test_case_list_8[]25. Test Case List

[width="100%",cols="15%,85%",]
|===
|*TC UUID* |*Test Case Name*

|TC-CC-1.1 |Global attributes with server as DUT

|TC-CC-2.1 |Attributes with server as DUT

|TC-CC-3.1 |Hue MoveTo functionality with server as DUT

|TC-CC-3.2 |Hue Move functionality with server as DUT

|TC-CC-3.3 |Hue Step functionality with server as DUT

|TC-CC-3.4 |Hue functionality with client as DUT

|TC-CC-4.1 |Saturation MoveTo functionality with server as DUT

|TC-CC-4.2 |Saturation Move functionality with server as DUT

|TC-CC-4.3 |Saturation Step functionality with server as DUT

|TC-CC-4.4 |MoveToHueAndSaturation functionality with server as DUT

|TC-CC-4.5 |Saturation functionality with client as DUT

|TC-CC-5.1 |Color MoveTo functionality with server as DUT

|TC-CC-5.2 |Color Move functionality with server as DUT

|TC-CC-5.3 |Color Step functionality with server as DUT

|TC-CC-5.4 |Color functionality with client as DUT

|TC-CC-6.1 |Color Temperature MoveTo functionality with server as DUT

|TC-CC-6.2 |Color Temperature Move functionality with server as DUT

|TC-CC-6.3 |Color Temperature Step functionality with server as DUT

|TC-CC-6.4 |Color Temperature functionality with client as DUT

|TC-CC-6.5 |Color Temperature StartUpColorTemperatureMireds
functionality with server as DUT

|TC-CC-7.1 |Enhanced MoveTo functionality with server as DUT

|TC-CC-7.2 |Enhanced Move functionality with server as DUT

|TC-CC-7.3 |Enhanced Step functionality with server as DUT

|TC-CC-7.4 |MoveToEnhancedHueAndSaturation functionality with server as
DUT

|TC-CC-7.5 |Enhanced functionality with client as DUT

|TC-CC-8.1 |Stop Move Step functionality with server as DUT

|TC-CC-9.1 |ColorLoopSet Validation with server as DUT

|TC-CC-9.2 |ColorLoopSet Validation with server as DUT - change
Direction without Stop

|TC-CC-9.3 |ColorLoopSet Validation with server as DUT - change Time
without Stop

|TC-CC-9.4 |ColorLoopSet Validation with client as DUT
|===

[[_test_cases_8]]
=== link:#_test_cases_8[]26. Test Cases

'''''

[[_global_attributes]]
==== link:#_global_attributes[]26.1. Global Attributes

'''''

[[_tc_cc_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_cc_1_1_global_attributes_with_server_as_dut[]26.1.1. [TC-CC-1.1] Global attributes with server as DUT

[[_category_92]]
====== link:#_category_92[]Category

Functional conformance

[[_purpose_92]]
====== link:#_purpose_92[]Purpose

This test case verifies the ColorControl Global attributes

[[_pics_92]]
====== link:#_pics_92[]PICS

* CC.S

[[_required_devices_92]]
====== link:#_required_devices_92[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as client
|2 |DUT |DUT as server
|===

[[_test_procedure_92]]
====== link:#_test_procedure_92[]Test Procedure

[width="100%",cols="5%,5%,5%,25%,60%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | | |TH reads from the DUT the (0xFFFD) _ClusterRevision attribute_
|Verify that the DUT response contains a Minimal revision of 6

|3 | | |TH reads from the DUT the (0xFFFC) _FeatureMap attribute_ a|
Verify that the DUT response contains the following bitmap32

- bit 0 is set to 1 if CC.S.F00(HS) is true, and 0 otherwise

- bit 1 is set to 1 if CC.S.F01(EHue) is true, and 0 otherwise

- bit 2 is set to 1 if CC.S.F02(CL) is true, and 0 otherwise

- bit 3 is set to 1 if CC.S.F03(XY) is true, and 0 otherwise

- bit 4 is set to 1 if CC.S.F04(CT) is true, and 0 otherwise

|4 | | |TH reads from the DUT the (0xFFFB) _AttributeList attribute_ a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support: bit for an attribute must be set to 1 if the
corresponding PICS is true, and set to 0 otherwise

* CC.S.A0000(CurrentHue)
* CC.S.A0001(CurrentSaturation)
* CC.S.A0002(RemainingTime)
* CC.S.A0003(CurrentX)
* CC.S.A0004(CurrentY)
* CC.S.A0005(DriftCompensation)
* CC.S.A0006(CompensationText)
* CC.S.A0007(ColorTemperatureMireds)
* CC.S.A0008(ColorMode)
* CC.S.A000f(Options)
* CC.S.A0010(NumberOfPrimaries)
* CC.S.A0011(Primary1X)
* CC.S.A0012(Primary1Y)
* CC.S.A0013(Primary1Intensity)
* CC.S.A0015(Primary2X)
* CC.S.A0016(Primary2Y)
* CC.S.A0017(Primary2Intensity)
* CC.S.A0019(Primary3X)
* CC.S.A001a(Primary3Y)
* CC.S.A001b(Primary3Intensity)
* CC.S.A0020(Primary4X)
* CC.S.A0021(Primary4Y)
* CC.S.A0022(Primary4Intensity)
* CC.S.A0024(Primary5X)
* CC.S.A0025(Primary5Y)
* CC.S.A0026(Primary5Intensity)
* CC.S.A0028(Primary6X)
* CC.S.A0029(Primary6Y)
* CC.S.A002a(Primary6Intensity)
* CC.S.A0030(WhitePointX)
* CC.S.A0031(WhitePointY)
* CC.S.A0032(ColorPointRX)
* CC.S.A0033(ColorPointRY)
* CC.S.A0034(ColorPointRIntensity)
* CC.S.A0036(ColorPointGX)
* CC.S.A0037(ColorPointGY)
* CC.S.A0038(ColorPointGIntensity)
* CC.S.A003a(ColorPointBX)
* CC.S.A003b(ColorPointBY)
* CC.S.A003c(ColorPointBIntensity)
* CC.S.A4000(EnhancedCurrentHue)
* CC.S.A4001(EnhancedColorMode)
* CC.S.A4002(ColorLoopActive)
* CC.S.A4003(ColorLoopDirection)
* CC.S.A4004(ColorLoopTime)
* CC.S.A4005(ColorLoopStartEnhancedHue)
* CC.S.A4006(ColorLoopStoredEnhancedHue)
* CC.S.A400a(ColorCapabilities)
* CC.S.A400b(ColorTempPhysicalMinMireds)
* CC.S.A400c(ColorTempPhysicalMaxMireds)
* CC.S.A400d(CoupleColorTempToLevelMinMireds)
* CC.S.A4010(StartUpColorTemperatureMireds)
* It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 | | |TH reads from the DUT the (0xFFFA) _EventList attribute_ |Verify
that the DUT response contains a list of supported events empty for this
cluster.

|6 | | |TH reads from the DUT the (0xFFF9) _AcceptedCommandList
attribute_ a|
Verify that the DUT response contains a list of Accepted commands based
on its PICS support: bit for a command must be set to 1 if the
corresponding PICS is true, and set to 0 otherwise

* CC.S.C00(MoveToHue)
* CC.S.C01(MoveHue)
* CC.S.C02(StepHue)
* CC.S.C03(MoveToSaturation)
* CC.S.C04(MoveSaturation)
* CC.S.C05(StepSaturation)
* CC.S.C06(MoveToHueAndSaturation)
* CC.S.C07(MoveToColor)
* CC.S.C08(MoveColor)
* CC.S.C09(StepColor)
* CC.S.C0a(MoveToColorTemperature)
* CC.S.C40(EnhancedMoveToHue)
* CC.S.C41(EnhancedMoveHue)
* CC.S.C42(EnhancedStepHue)
* CC.S.C43(EnhancedMoveToHueAndSaturation)
* CC.S.C44(ColorLoopSet)
* CC.S.C47(StopMoveStep)
* CC.S.C4b(MoveColorTemperature)
* CC.S.C4c(StepColorTemperature)

|7 | | |TH reads from the DUT the (0xFFF8) _GeneratedCommandList
attribute_ |Verify that the DUT response contains a list of Generated
commands empty for this cluster.
|===

[[_notestesting_considerations_93]]
====== link:#_notestesting_considerations_93[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_cluster_attributes]]
==== link:#_cluster_attributes[]26.2. Cluster Attributes

'''''

[[_tc_cc_2_1_attributes_with_server_as_dut]]
===== link:#_tc_cc_2_1_attributes_with_server_as_dut[]26.2.1. [TC-CC-2.1] Attributes with server as DUT

[[_category_93]]
====== link:#_category_93[]Category

Functional conformance

[[_purpose_93]]
====== link:#_purpose_93[]Purpose

This test case verifies the ColorControl Cluster attributes with server
as DUT

[[_pics_93]]
====== link:#_pics_93[]PICS

* CC.S

[[_required_devices_93]]
====== link:#_required_devices_93[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as client
|2 |DUT |DUT as server
|===

[[_test_procedure_93]]
====== link:#_test_procedure_93[]Test Procedure

[width="100%",cols="6%,8%,8%,39%,39%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |CC.S.A0000(CurrentHue) |TH reads from the DUT the (0x0000)
_CurrentHue attribute_ |Verify that the DUT response contains an uint8

|3 | |CC.S.A0001(CurrentSaturation) |TH reads from the DUT the (0x0001)
_CurrentSaturation attribute_ |Verify that the DUT response contains an
uint8

|4 | |CC.S.A0002(RemainingTime) |TH reads from the DUT the (0x0002)
_RemainingTime attribute_ |Verify that the DUT response contains an
uint16

|5 | |CC.S.A0003(CurrentX) |TH reads from the DUT the (0x0003) _CurrentX
attribute_ |Verify that the DUT response contains an uint16 [Min:0
Max:0xfeff]

|6 | |CC.S.A0004(CurrentY) |TH reads from the DUT the (0x0004) _CurrentY
attribute_ |Verify that the DUT response contains an uint16 [Min:0
Max:0xfeff]

|7 | |CC.S.A0005(DriftCompensation) |TH reads from the DUT the (0x0005)
_DriftCompensation attribute_ |Verify that the DUT response contains a
enum8 [Min:0 Max:4]

|8 | |CC.S.A0006(CompensationText) |TH reads from the DUT the (0x0006)
_CompensationText attribute_ |Verify that the DUT response contains a
string [Max:254]

|9 | |CC.S.A0007(ColorTemperatureMireds) |TH reads from the DUT the
(0x0007) _ColorTemperatureMireds attribute_ |Verify that the DUT
response contains an uint16 [Min:0 Max:0xfeff]

|10 | |CC.S.A0008(ColorMode) |TH reads from the DUT the (0x0008)
_ColorMode attribute_ a|
Verify that the DUT response contains an enum8 [Min:0 Max:2]

- 0 CurrentHue and CurrentSaturation

- 1 CurrentX and CurrentY

- 2 ColorTemperatureMireds

|11 | |CC.S.A000f(Options) |TH reads from the DUT the (0x000f) _Options
attribute_ a|
Verify that the DUT response contains a bitmap8

- 0 None

- 1 Other / Unknown

- 2 Temperature monitoring

- 3 Optical luminance monitoring and feedback

- 4 Optical Color monitoring and feedback

|12 | |CC.S.A4000(EnhancedCurrentHue) |TH reads from the DUT the
(0x4000) _EnhancedCurrentHue attribute_ |Verify that the DUT response
contains an uint16

|13 | |CC.S.A4001(EnhancedColorMode) |TH reads from the DUT the (0x4001)
_EnhancedColorMode attribute_ a|
Verify that the DUT response contains a enum8

- 0 CurrentHue and CurrentSaturation

- 1 CurrentX and CurrentY

- 2 ColorTemperatureMireds

- 3 EnhancedCurrentHue and CurrentSaturation

|14 | |CC.S.A4002(ColorLoopActive) |TH reads from the DUT the (0x4002)
_ColorLoopActive attribute_ |Verify that the DUT response contains an
uint8

|15 | |CC.S.A4003(ColorLoopDirection) |TH reads from the DUT the
(0x4003) _ColorLoopDirection attribute_ |Verify that the DUT response
contains an uint8

|16 | |CC.S.A4004(ColorLoopTime) |TH reads from the DUT the (0x4004)
_ColorLoopTime attribute_ |Verify that the DUT response contains an
uint16

|17 | |CC.S.A4005(ColorLoopStartEnhancedHue) |TH reads from the DUT the
(0x4005) _ColorLoopStartEnhancedHue attribute_ |Verify that the DUT
response contains an uint16

|18 | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH reads from the DUT the
(0x4006) _ColorLoopStoredEnhancedHue attribute_ |Verify that the DUT
response contains an uint16

|19 | |CC.S.A400a(ColorCapabilities) |TH reads from the DUT the (0x400a)
_ColorCapabilities attribute_ |Verify that the DUT response contains a
map16 [Min:0 Max:0x001f] Bits 0-4 of the _ColorCapabilities_ attribute
SHALL have the same values as the corresponding bits of the _FeatureMap_
attribute.

|20 | |CC.S.A400b(ColorTempPhysicalMinMireds) |TH reads from the DUT the
(0x400b) _ColorTempPhysicalMinMireds attribute_ |Verify that the DUT
response contains an uint16 [Min:0 Max:0xfeff]

|21 | |CC.S.A400c(ColorTempPhysicalMaxMireds) |TH reads from the DUT the
(0x400c) _ColorTempPhysicalMaxMireds attribute_ |Verify that the DUT
response contains an uint16 [Min:0 Max:0xfeff]

|22 | |CC.S.A400d(CoupleColorTempToLevelMinMireds) |TH reads from the
DUT the (0x400d) _CoupleColorTempToLevelMinMireds attribute_ |Verify
that the DUT response contains an uint16 [Min:
_ColorTempPhysicalMinMireds_ Max: _ColorTempPhysicalMaxMireds_ ]

|23 | |CC.S.A4010(StartUpColorTemperatureMireds) |TH reads from the DUT
the (0x4010) _StartUpColorTemperatureMireds attribute_ |Verify that the
DUT response contains an uint16 [Min:0 Max:0xfeff or null]

|24 | |CC.S.A0010(NumberOfPrimaries) |TH reads from the DUT the (0x0010)
_NumberOfPrimaries attribute_ |Verify that the DUT response contains an
uint8 and _NumberOfPrimaries_ equals to PIXIT_NUMBEROFPRIMARIES.

|25 | |CC.S.A0011(Primary1X) |TH reads from the DUT the (0x0011)
_Primary1X attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 1 or more

|26 | |CC.S.A0012(Primary1Y) |TH reads from the DUT the (0x0012)
_Primary1Y attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 1 or more

|27 | |CC.S.A0013(Primary1Intensity) |TH reads from the DUT the (0x0013)
_Primary1Intensity attribute_ |Verify that the DUT response contains an
uint8 if _NumberOfPrimaries_ is 1 or more

|28 | |CC.S.A0015(Primary2X) |TH reads from the DUT the (0x0015)
_Primary2X attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 2 or more

|29 | |CC.S.A0016(Primary2Y) |TH reads from the DUT the (0x0016)
_Primary2Y attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 2 or more

|30 | |CC.S.A0017(Primary2Intensity) |TH reads from the DUT the (0x0017)
_Primary2Intensity attribute_ |Verify that the DUT response contains an
uint8 if _NumberOfPrimaries_ is 2 or more

|31 | |CC.S.A0019(Primary3X) |TH reads from the DUT the (0x0019)
_Primary3X attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 3 or more

|32 | |CC.S.A001a(Primary3Y) |TH reads from the DUT the (0x001a)
_Primary3Y attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 3 or more

|33 | |CC.S.A001b(Primary3Intensity) |TH reads from the DUT the (0x001b)
_Primary3Intensity attribute_ |Verify that the DUT response contains an
uint8 if _NumberOfPrimaries_ is 3 or more

|34 | |CC.S.A0020(Primary4X) |TH reads from the DUT the (0x0020)
_Primary4X attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 4 or more

|35 | |CC.S.A0021(Primary4Y) |TH reads from the DUT the (0x0021)
_Primary4Y attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 4 or more

|36 | |CC.S.A0022(Primary4Intensity) |TH reads from the DUT the (0x0022)
_Primary4Intensity attribute_ |Verify that the DUT response contains an
uint8 if _NumberOfPrimaries_ is 4 or more

|37 | |CC.S.A0024(Primary5X) |TH reads from the DUT the (0x0024)
_Primary5X attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 5 or more

|38 | |CC.S.A0025(Primary5Y) |TH reads from the DUT the (0x0025)
_Primary5Y attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 5 or more

|39 | |CC.S.A0026(Primary5Intensity) |TH reads from the DUT the (0x0026)
_Primary5Intensity attribute_ |Verify that the DUT response contains an
uint8 if _NumberOfPrimaries_ is 5 or more

|40 | |CC.S.A0028(Primary6X) |TH reads from the DUT the (0x0028)
_Primary6X attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 6

|41 | |CC.S.A0029(Primary6Y) |TH reads from the DUT the (0x0029)
_Primary6Y attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff] if _NumberOfPrimaries_ is 6

|42 | |CC.S.A002a(Primary6Intensity) |TH reads from the DUT the (0x002a)
_Primary6Intensity attribute_ |Verify that the DUT response contains an
uint8 if _NumberOfPrimaries_ is 6

|43 | |CC.S.A0030(WhitePointX) |TH reads from the DUT the (0x0030)
_WhitePointX attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff]

|44 | |CC.S.A0031(WhitePointY) |TH reads from the DUT the (0x0031)
_WhitePointY attribute_ |Verify that the DUT response contains an uint16
[Min:0 Max:0xfeff]

|45 | |CC.S.A0032(ColorPointRX) |TH reads from the DUT the (0x0032)
_ColorPointRX attribute_ |Verify that the DUT response contains an
uint16 [Min:0 Max:0xfeff]

|46 | |CC.S.A0033(ColorPointRY) |TH reads from the DUT the (0x0033)
_ColorPointRY attribute_ |Verify that the DUT response contains an
uint16 [Min:0 Max:0xfeff]

|47 | |CC.S.A0034(ColorPointRIntensity) |TH reads from the DUT the
(0x0034) _ColorPointRIntensity attribute_ |Verify that the DUT response
contains an uint8

|48 | |CC.S.A0036(ColorPointGX) |TH reads from the DUT the (0x0036)
_ColorPointGX attribute_ |Verify that the DUT response contains an
uint16 [Min:0 Max:0xfeff]

|49 | |CC.S.A0037(ColorPointGY) |TH reads from the DUT the (0x0037)
_ColorPointGY attribute_ |Verify that the DUT response contains an
uint16 [Min:0 Max:0xfeff]

|50 | |CC.S.A0038(ColorPointGIntensity) |TH reads from the DUT the
(0x0038) _ColorPointGIntensity attribute_ |Verify that the DUT response
contains an uint8

|51 | |CC.S.A003a(ColorPointBX) |TH reads from the DUT the (0x003a)
_ColorPointBX attribute_ |Verify that the DUT response contains an
uint16 [Min:0 Max:0xfeff]

|52 | |CC.S.A003b(ColorPointBY) |TH reads from the DUT the (0x003b)
_ColorPointBY attribute_ |Verify that the DUT response contains an
uint16 [Min:0 Max:0xfeff]

|53 | |CC.S.A003c(ColorPointBIntensity) |TH reads from the DUT the
(0x003c) _ColorPointBIntensity attribute_ |Verify that the DUT response
contains an uint8
|===

[[_notestesting_considerations_94]]
====== link:#_notestesting_considerations_94[]Notes/Testing Considerations

'''''

[[_functional_test_cases]]
==== link:#_functional_test_cases[]26.3. Functional test cases

'''''

[[_tc_cc_3_1_hue_moveto_functionality_with_server_as_dut]]
===== link:#_tc_cc_3_1_hue_moveto_functionality_with_server_as_dut[]26.3.1. [TC-CC-3.1] Hue MoveTo functionality with server as DUT

[[_category_94]]
====== link:#_category_94[]Category

Functional

[[_purpose_94]]
====== link:#_purpose_94[]Purpose

This test case verifies Hue MoveTo functionality of the Color Control
cluster server.

[[_pics_94]]
====== link:#_pics_94[]PICS

* CC.S

[[_preconditions_34]]
====== link:#_preconditions_34[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_94]]
====== link:#_required_devices_94[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_70]]
====== link:#_device_topology_70[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_82]]
====== link:#_test_setup_82[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_94]]
====== link:#_test_procedure_94[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

MoveToHue, shortest distance; from 60 to 120 (distance 60) over 30s, so
increasing by 20 units every 10s

2a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=60, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=120, __Direction__=0x00
(shortest distance) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
80 (60+(120-60)*(10/30)).

2d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
100 (60+(120-60)*(20/30)).

2e

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
120 (60+(120-60)*(30/30)).

2f

CC.S.A0000(CurrentHue)

After another 5 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute is now stable at the
value 120.

MoveToHue, longest distance; from 60 to 135 (-120 mod 255), distance =
180, so decreasing by 60 units every 10s

3a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=60, __Direction__=0x00
(Shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=135, __Direction__=0x01
(longest distance) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
0 (60-60).

3d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
195 (60-120 mod 255).

3e

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
135 (60-180 mod 255).

3f

CC.S.A0000(CurrentHue)

After another 5 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute is now stable at the
value 135.

MoveToHue, up, from 60 to 120 (distance 60) in 30s so increasing by 20
units every 10s

4a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=60, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

4b

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=120, __Direction__=0x02
(up) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

4c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
80 (60+(120-60)*(10/30)).

4d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
100 (60+(120-60)*(20/30)).

4e

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
120 (60+(120-60)*(30/30)).

4f

CC.S.A0000(CurrentHue)

After another 5 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute is now stable at the
value 120.

MoveToHue, down, from 120 to 60 (distance 60) in 30s so decreasing by 20
units every 10s

5a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=120, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

5b

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=60, __Direction__=0x03
(down) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

5c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
100 (120-(120-60)*(10/30)).

5d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
80 (120-(120-60)*(20/30)).

5e

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
60 (120-(120-60)*(30/30)).

5f

CC.S.A0000(CurrentHue)

After another 5 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute is now stable at the
value 60.

check ColorMode

6a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

6b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_95]]
=== link:#_notestesting_considerations_95[]Notes/Testing Considerations

[[_tc_cc_3_2_hue_move_functionality_with_server_as_dut]]
=== link:#_tc_cc_3_2_hue_move_functionality_with_server_as_dut[]26.3.2. [TC-CC-3.2] Hue Move functionality with server as DUT

[[_category_95]]
==== link:#_category_95[]Category

Functional

[[_purpose_95]]
==== link:#_purpose_95[]Purpose

This test case verifies Hue Move functionality of the Color Control
cluster server.

[[_pics_95]]
==== link:#_pics_95[]PICS

* CC.S

[[_preconditions_35]]
==== link:#_preconditions_35[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_95]]
==== link:#_required_devices_95[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_71]]
==== link:#_device_topology_71[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_83]]
==== link:#_test_setup_83[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_95]]
==== link:#_test_procedure_95[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

MoveHue (up) ; start at 200 with 5 units/s and measuring every 10s (so
increases by 50 units per 10s)

2a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=200, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C01.Rsp(MoveHue)

TH sends _MoveHue command_ to DUT with __MoveMode__=0x01 (up) and
__Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
250 (200 + 10*5).

2d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
45 (200 + 20*5 = 300 mod 255).

2e

CC.S.C01.Rsp(MoveHue)

After another 10 seconds, TH sends _MoveHue command_ to DUT with
__MoveMode__=0x00 (stop) and __Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2f

CC.S.A0000(CurrentHue)

TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
95 (200 + 30*5 = 350 mod 255).

2g

CC.S.A0000(CurrentHue)

After another 2 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has stabilized at the
expected value 95.

MoveHue (down) ; start at 60 with 5 units/s and measuring every 10s (so
decreases by 50 units per 10s)

3a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=60, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C01.Rsp(MoveHue)

TH sends _MoveHue command_ to DUT with __MoveMode__=0x03 (down) and
__Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
10 (60 - 10*5).

3d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
215 (60 - 20*5 = -40 mod 255).

3e

CC.S.C01.Rsp(MoveHue)

After another 10 seconds, TH sends _MoveHue command_ to DUT with
__MoveMode__=0x00 (stop) and __Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

3f

CC.S.A0000(CurrentHue)

TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
165 (60 - 30*5 = -90 mod 255).

3g

CC.S.A0000(CurrentHue)

After another 2 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has stabilized at the
expected value 165.

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_96]]
=== link:#_notestesting_considerations_96[]Notes/Testing Considerations

[[_tc_cc_3_3_hue_step_functionality_with_server_as_dut]]
=== link:#_tc_cc_3_3_hue_step_functionality_with_server_as_dut[]26.3.3. [TC-CC-3.3] Hue Step functionality with server as DUT

[[_category_96]]
==== link:#_category_96[]Category

Functional

[[_purpose_96]]
==== link:#_purpose_96[]Purpose

This test case verifies Hue Step functionality of the Color Control
cluster server.

[[_pics_96]]
==== link:#_pics_96[]PICS

* CC.S

[[_preconditions_36]]
==== link:#_preconditions_36[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_96]]
==== link:#_required_devices_96[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_72]]
==== link:#_device_topology_72[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_84]]
==== link:#_test_setup_84[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_96]]
==== link:#_test_procedure_96[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

StepHue (up) ; start at 200 with a step of 60 units in 20s; measuring
every 10s (so changes of 30 units per 10s)

2a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=200, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C02.Rsp(StepHue)

TH sends _StepHue command_ to DUT with __StepMode__=0x01 (up),
__StepSize__=60 and __TransitionTime__=200 (20 s)

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
230 (200 + 60*(10/20)).

2d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
5 (200 + 60*(20/20) = 260 mod 255).

2e

CC.S.A0000(CurrentHue)

After another 5 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has stabilized at the
expected value 5.

StepHue (down) ; start at 50 with a step of 60 units in 20s; measuring
every 10s (so changes of 30 units per 10s)

3a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=50, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C02.Rsp(StepHue)

TH sends _StepHue command_ to DUT with __StepMode__=0x03 (down),
__StepSize__=60 and __TransitionTime__=200 (20 s)

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A0000(CurrentHue)

After 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
20 (50 - 60*(10/20)).

3d

CC.S.A0000(CurrentHue)

After another 10 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
245 (50 - 60*(30/30) = -10 mod 255).

3e

CC.S.A0000(CurrentHue)

After another 5 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has stabilized at the
expected value 245.

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_97]]
=== link:#_notestesting_considerations_97[]Notes/Testing Considerations

[[_tc_cc_3_4_hue_functionality_with_client_as_dut]]
=== link:#_tc_cc_3_4_hue_functionality_with_client_as_dut[]26.3.4. [TC-CC-3.4] Hue functionality with client as DUT

[[_category_97]]
==== link:#_category_97[]Category

Functional

[[_purpose_97]]
==== link:#_purpose_97[]Purpose

This test case verifies MoveToHue/MoveHue/StepHue/StopMoveStep
functionality of the Color Control cluster client.

[[_pics_97]]
==== link:#_pics_97[]PICS

* CC.C

[[_preconditions_37]]
==== link:#_preconditions_37[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.C.F00(HS) |
|===

[[_required_devices_97]]
==== link:#_required_devices_97[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_73]]
==== link:#_device_topology_73[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_85]]
==== link:#_test_setup_85[]Test Setup

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission TH to DUT
|2 |Set TH OnOff to On
|===

[[_test_procedure_97]]
==== link:#_test_procedure_97[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | |CC.C.C00.Tx(MoveToHue) |DUT sends _MoveToHue command_ to TH |TH
receives InvokeRequestMessage with CommandID 0x00 CommandFields matches
_MoveToHue command_ parameters; Verify that the TH response contains
with a successful (value 0x00) status response.

|1b | |CC.C.C00.Tx(MoveToHue) & CC.C.A0000(CurrentHue) |DUT reads
_CurrentHue attribute_ from TH (potentially multiple times) |TH receives
read request from Cluster 0x300 Attribute 0x0000_0000; Verify that the
TH response contains with a successful (value 0x00) status response.

|2a | |CC.C.C01.Tx(MoveHue) |DUT sends _MoveHue command_ to TH |TH
receives InvokeRequestMessage with CommandID 0x01 CommandFields matches
_MoveHue command_ parameters; Verify that the TH response contains with
a successful (value 0x00) status response.

|2b | |CC.C.C01.Tx(MoveHue) & CC.C.A0000(CurrentHue) |DUT reads
_CurrentHue attribute_ (potentially multiple times) |TH receives read
request from Cluster 0x300 Attribute 0x0000_0000; Verify that the TH
response contains with a successful (value 0x00) status response.

|3a | |CC.C.C02.Tx(StepHue) |DUT sends _StepHue command_ to TH |TH
receives InvokeRequestMessage with CommandID 0x02 CommandFields matches
_StepHue command_ parameters; Verify that the TH response contains with
a successful (value 0x00) status response.

|3b | |CC.C.C02.Tx(StepHue) & CC.C.A0000(CurrentHue) |DUT reads
_CurrentHue attribute_ from TH (potentially multiple times) |TH receives
read request from Cluster 0x300 Attribute 0x0000_0000; Verify that the
TH response contains with a successful (value 0x00) status response.

|4a | |CC.C.C47.Tx(StopMoveStep) |DUT sends _StopMoveStep command_ to
TH. |TH receives InvokeRequestMessage with CommandID 0x47 CommandFields
matches _StopMoveStep command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

|4b | |CC.C.C47.Tx(StopMoveStep) & CC.C.A0000(CurrentHue) |Over
_TransitionTime_, DUT reads _CurrentHue attribute_ from TH. |TH receives
read request from Cluster 0x300 Attribute 0x0000_0000; Verify that the
TH response contains with a successful (value 0x00) status response.
|===

[[_notestesting_considerations_98]]
==== link:#_notestesting_considerations_98[]Notes/Testing Considerations

[[_tc_cc_4_1_saturation_moveto_functionality_with_server_as_dut]]
=== link:#_tc_cc_4_1_saturation_moveto_functionality_with_server_as_dut[]26.3.5. [TC-CC-4.1] Saturation MoveTo functionality with server as DUT

[[_category_98]]
==== link:#_category_98[]Category

Functional

[[_purpose_98]]
==== link:#_purpose_98[]Purpose

This test case verifies Saturation MoveTo functionality of the Color
Control cluster server.

[[_pics_98]]
==== link:#_pics_98[]PICS

* CC.S

[[_preconditions_38]]
==== link:#_preconditions_38[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_98]]
==== link:#_required_devices_98[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_74]]
==== link:#_device_topology_74[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_86]]
==== link:#_test_setup_86[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_98]]
==== link:#_test_procedure_98[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

MoveToSaturation; from 60 to 120 (distance 60) over 30s, so increasing
by 20 units every 10s.

2a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=60 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=120 and
__TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 80 (60+(120-60)*(10/30)).

2d

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 100 (60+(120-60)*(20/30)).

2e

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 120 (60+(120-60)*(30/30)).

2f

CC.S.A0001(CurrentSaturation)

After another 5 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute is now stable at
the value 120.

check ColorMode

3a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

3b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_99]]
=== link:#_notestesting_considerations_99[]Notes/Testing Considerations

[[_tc_cc_4_2_saturation_move_functionality_with_server_as_dut]]
=== link:#_tc_cc_4_2_saturation_move_functionality_with_server_as_dut[]26.3.6. [TC-CC-4.2] Saturation Move functionality with server as DUT

[[_category_99]]
==== link:#_category_99[]Category

Functional

[[_purpose_99]]
==== link:#_purpose_99[]Purpose

This test case verifies Saturation Move functionality of the Color
Control cluster server.

[[_pics_99]]
==== link:#_pics_99[]PICS

* CC.S

[[_preconditions_39]]
==== link:#_preconditions_39[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_99]]
==== link:#_required_devices_99[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_75]]
==== link:#_device_topology_75[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_87]]
==== link:#_test_setup_87[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_99]]
==== link:#_test_procedure_99[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

MoveSaturation (up) ; start at 150 with 5 units/s and measuring every
10s (so increases by 50 units per 10s)

2a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=150 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C04.Rsp(MoveSaturation)

TH sends _MoveSaturation command_ to DUT with __MoveMode__=0x01 (up) and
__Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 200 (150 + 10*5).

2d

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 250 (150 + 20*5).

2e

CC.S.A0001(CurrentSaturation)

After another 5 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 254 (150 + 30*5 = 300 so DUT has reached max Saturation value).

MoveSaturation (down) ; start at 120 with 5 units/s and measuring every
10s (so decreases by 50 units per 10s)

3a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=120 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C04.Rsp(MoveSaturation)

TH sends _MoveSaturation command_ to DUT with __MoveMode__=0x03 (down)
and __Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 70 (120 - 10*5).

3d

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 20 (120 - 20*5).

3e

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 0 (120 - 30*5 = -30 <0 so DUT has reached min Saturation value).

MoveSaturation (up, with stop) ; start at 150 with 5 units/s and
measuring every 10s (so increases by 50 units per 10s)

4a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=150 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

4b

CC.S.C04.Rsp(MoveSaturation)

TH sends _MoveSaturation command_ to DUT with __MoveMode__=0x01 (up) and
__Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

4c

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 200 (150 + 10*5).

4d

CC.S.C04.Rsp(MoveSaturation)

TH sends _MoveSaturation command_ to DUT with __MoveMode__=0x00 (stop)
and __Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

4e

CC.S.A0001(CurrentSaturation)

TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 200.

4f

CC.S.A0001(CurrentSaturation)

After another 2 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 200.

check ColorMode

5a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

5b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_100]]
=== link:#_notestesting_considerations_100[]Notes/Testing Considerations

[[_tc_cc_4_3_saturation_step_functionality_with_server_as_dut]]
=== link:#_tc_cc_4_3_saturation_step_functionality_with_server_as_dut[]26.3.7. [TC-CC-4.3] Saturation Step functionality with server as DUT

[[_category_100]]
==== link:#_category_100[]Category

Functional

[[_purpose_100]]
==== link:#_purpose_100[]Purpose

This test case verifies Saturation Step functionality of the Color
Control cluster server.

[[_pics_100]]
==== link:#_pics_100[]PICS

* CC.S

[[_preconditions_40]]
==== link:#_preconditions_40[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_100]]
==== link:#_required_devices_100[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_76]]
==== link:#_device_topology_76[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_88]]
==== link:#_test_setup_88[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_100]]
==== link:#_test_procedure_100[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

StepSaturation (up) ; start at 200 with a step of 40 units in 20s;
measuring every 10s (so changes of 20 units per 10s)

2a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=200 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C05.Rsp(StepSaturation)

TH sends _StepSaturation command_ to DUT with __StepMode__=0x01 (up),
__StepSize__=40 and __TransitionTime__=200 (20 s)

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 220 (200 + 40*(10/20)).

2d

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 240 (200 + 40*(20/20)).

2e

CC.S.A0001(CurrentSaturation)

After another 5 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has stabilized
at the expected value 240.

StepSaturation (up) ; start at 240 with a step of 20 units in 10s - will
hit max

2f

CC.S.C05.Rsp(StepSaturation)

TH sends _StepSaturation command_ to DUT with __StepMode__=0x01 (up),
__StepSize__=20 and __TransitionTime__=100 (10 s)

Verify DUT responds with a successful (value 0x00) status response.

2g

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 254 (240 + 20*(10/10) = 260 > 254, reached max Saturation value).

StepSaturation (down) ; start at 50 with a step of 40 units in 20s;
measuring every 10s (so changes of 20 units per 10s)

3a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=50 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C05.Rsp(StepSaturation)

TH sends _StepSaturation command_ to DUT with __StepMode__=0x03 (down),
__StepSize__=40 and __TransitionTime__=200 (20 s)

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 30 (50 - 40*(10/20)).

3d

CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 10 (50 - 40*(20/20)).

3e

CC.S.A0001(CurrentSaturation)

After another 5 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has stabilized
at the expected value 10.

StepSaturation (down) ; start at 10 with a step of 20 units in 10s -
will hit min

3f

CC.S.C05.Rsp(StepSaturation)

TH sends _StepSaturation command_ to DUT with __StepMode__=0x03 (down),
__StepSize__=20 and __TransitionTime__=100 (10 s)

Verify DUT responds with a successful (value 0x00) status response.

3g

CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 0 (10 - 20*(10/10) = -10 < 0, reached min Saturation value).

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_101]]
=== link:#_notestesting_considerations_101[]Notes/Testing Considerations

[[_tc_cc_4_4_movetohueandsaturation_functionality_with_server_as_dut]]
=== link:#_tc_cc_4_4_movetohueandsaturation_functionality_with_server_as_dut[]26.3.8. [TC-CC-4.4] MoveToHueAndSaturation functionality with server as DUT

[[_category_101]]
==== link:#_category_101[]Category

Functional

[[_purpose_101]]
==== link:#_purpose_101[]Purpose

This test case verifies MoveToHueAndSaturation functionality of the
Color Control cluster server.

[[_pics_101]]
==== link:#_pics_101[]PICS

* CC.S

[[_preconditions_41]]
==== link:#_preconditions_41[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F00(HS) |
|===

[[_required_devices_101]]
==== link:#_required_devices_101[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_77]]
==== link:#_device_topology_77[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_89]]
==== link:#_test_setup_89[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_101]]
==== link:#_test_procedure_101[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

set starting point

2a

CC.S.C06.Rsp(MoveToHueAndSaturation)

TH sends _MoveToHueAndSaturation command_ to DUT with __Hue__=200,
__Saturation__=50 and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.A0000(CurrentHue) & CC.S.A0001(CurrentSaturation)

TH reads _CurrentHue and CurrentSaturation attributes_ from DUT.

Value has to be between a range of 0x00 to 0xfe. Values match what was
written in step 2a.

move with transition time

3a

CC.S.C06.Rsp(MoveToHueAndSaturation)

TH sends _MoveToHueAndSaturation command_ to DUT with __Hue__=160,
__Saturation__=80 and __TransitionTime__=200 (20s).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A0000(CurrentHue) & CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _CurrentHue and CurrentSaturation attributes_
from DUT.

Value has to be between a range of 0x00 to 0xfe. Values are in
transition between values written in 2a and 3a (i.e. DUT is in
transition).

3c

CC.S.A0000(CurrentHue) & CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _CurrentHue and CurrentSaturation
attributes_ from DUT.

Value has to be between a range of 0x00 to 0xfe. Values are expected to
be as written in 3a.

3d

CC.S.A0000(CurrentHue) & CC.S.A0001(CurrentSaturation)

After another 5 seconds, TH reads _CurrentHue and CurrentSaturation
attributes_ from DUT.

Value has to be between a range of 0x00 to 0xfe. Values are expected to
have stabilized as written in 3a.

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 0 (CurrentHue and CurrentSaturation).

[[_notestesting_considerations_102]]
=== link:#_notestesting_considerations_102[]Notes/Testing Considerations

[[_tc_cc_4_5_saturation_functionality_with_client_as_dut]]
=== link:#_tc_cc_4_5_saturation_functionality_with_client_as_dut[]26.3.9. [TC-CC-4.5] Saturation functionality with client as DUT

[[_category_102]]
==== link:#_category_102[]Category

Functional

[[_purpose_102]]
==== link:#_purpose_102[]Purpose

This test case verifies Saturation functionality of the Color Control
cluster client.

[[_pics_102]]
==== link:#_pics_102[]PICS

* CC.C

[[_preconditions_42]]
==== link:#_preconditions_42[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.C.F00(HS) |
|===

[[_required_devices_102]]
==== link:#_required_devices_102[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_78]]
==== link:#_device_topology_78[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_90]]
==== link:#_test_setup_90[]Test Setup

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission TH to DUT
|2 |Set TH OnOff to On
|===

[[_test_procedure_102]]
==== link:#_test_procedure_102[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | |CC.C.C03.Tx(MoveToSaturation) |DUT sends _MoveToSaturation
command_ to TH |TH receives InvokeRequestMessage with CommandID 0x03
CommandFields matches _MoveToSaturation command_ parameters; Verify that
the TH response contains with a successful (value 0x00) status response.

|1b | |CC.C.C03.Tx(MoveToSaturation) & CC.C.A0001(CurrentSaturation)
|DUT reads _CurrentSaturation attribute_ from TH (potentially multiple
times) |TH receives read request from Cluster 0x300 Attribute
0x0000_0001; Verify that the TH response contains with a successful
(value 0x00) status response.

|2a | |CC.C.C04.Tx(MoveSaturation) |DUT sends _MoveSaturation command_
to TH |TH receives InvokeRequestMessage with CommandID 0x04
CommandFields matches _MoveSaturation command_ parameters; Verify that
the TH response contains with a successful (value 0x00) status response.

|2b | |CC.C.C04.Tx(MoveSaturation) & CC.C.A0001(CurrentSaturation) |DUT
reads _CurrentSaturation attribute_ (potentially multiple times) |TH
receives read request from Cluster 0x300 Attribute 0x0000_0001; Verify
that the TH response contains with a successful (value 0x00) status
response.

|3a | |CC.C.C05.Tx(StepSaturation) |DUT sends _StepSaturation command_
to TH |TH receives InvokeRequestMessage with CommandID 0x05
CommandFields matches _StepSaturation command_ parameters; Verify that
the TH response contains with a successful (value 0x00) status response.

|3b | |CC.C.C05.Tx(StepSaturation) & CC.C.A0001(CurrentSaturation) |DUT
reads _CurrentSaturation attribute_ from TH (potentially multiple times)
|TH receives read request from Cluster 0x300 Attribute 0x0000_0001;
Verify that the TH response contains with a successful (value 0x00)
status response.

|4a | |CC.C.C06.Tx(MoveToHueAndSaturation) |DUT sends
_MoveToHueAndSaturation command_ to TH |TH receives InvokeRequestMessage
with CommandID 0x06 CommandFields matches _MoveToHueAndSaturation
command_ parameters; Verify that the TH response contains with a
successful (value 0x00) status response.

|4b | |CC.C.C06.Tx(MoveToHueAndSaturation) & CC.C.A0000(CurrentHue) &
CC.C.A0001(CurrentSaturation) |DUT reads _CurrentHue and
CurrentSaturation attributes_ from TH (potentially multiple times) |TH
receives read request from Cluster 0x300 Attribute 0x0000_0000 and
0x0000_0001; Verify that the TH response contains with a successful
(value 0x00) status response.

|5a | |CC.C.C47.Tx(StopMoveStep) |DUT sends _StopMoveStep command_ to
TH. |TH receives InvokeRequestMessage with CommandID 0x47 CommandFields
matches _StopMoveStep command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

|5b | |CC.C.C47.Tx(StopMoveStep) & CC.C.A0001(CurrentSaturation) |Over
_TransitionTime_, DUT reads _CurrentSaturation attribute_ from TH. |TH
receives read request from Cluster 0x300 Attribute 0x0000_0000 and
0x0000_0001; Verify that the TH response contains with a successful
(value 0x00) status response.
|===

[[_notestesting_considerations_103]]
==== link:#_notestesting_considerations_103[]Notes/Testing Considerations

[[_tc_cc_5_1_color_moveto_functionality_with_server_as_dut]]
=== link:#_tc_cc_5_1_color_moveto_functionality_with_server_as_dut[]26.3.10. [TC-CC-5.1] Color MoveTo functionality with server as DUT

[[_category_103]]
==== link:#_category_103[]Category

Functional

[[_purpose_103]]
==== link:#_purpose_103[]Purpose

This test case verifies Color MoveTo functionality of the Color Control
cluster server.

[[_pics_103]]
==== link:#_pics_103[]PICS

* CC.S

[[_preconditions_43]]
==== link:#_preconditions_43[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F03(XY) |
|===

[[_required_devices_103]]
==== link:#_required_devices_103[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_79]]
==== link:#_device_topology_79[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_91]]
==== link:#_test_setup_91[]Test Setup

* For commands used in steps 1-3 this test, use fields OptionsMask=0x00
and OptionsOverride=0x00.
* For the steps 4 and beyond, use fields OptionsMask and OptionsOverride
as specified in the test steps.
* The x/y values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_103]]
==== link:#_test_procedure_103[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

2a

CC.S.C07.Rsp(MoveToColor)

TH sends _MoveToColor command_ to DUT, with

* ColorX = 32768/0x8000 (x=0.5) (purple)
* ColorY = 19660/0x4CCC (y=0.3)
* TransitionTime = 0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Values as provided
in 2a.

3a

CC.S.C07.Rsp(MoveToColor)

TH sends _MoveToColor command_ to DUT, with

* ColorX = 13107/0x3333 (x=0.2) (blue)
* ColorY = 13107/0x3333 (y=0.2)
* TransitionTime = 200 (20s)

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After 10 seconds, TH reads _CurrentX and CurrentY attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Values are in
transition between values written in 2a and 3a (i.e. DUT is in
transition).

3c

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After another 10 seconds, TH reads _CurrentX and CurrentY attributes_
from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Values are expected
to be as written in 3a.

3d

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After another 5 seconds, TH reads _CurrentX and CurrentY attributes_
from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Values are expected
to have stabilized as written in 3a.

tests for Options-bits (ExecuteIfOff=false)

4a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

no error response

4b

CC.S.A000f(Options)

TH reads the _Options attribute_ from the DUT

* Verify that the DUT response contains a bitmap, with value 0x00.

4c

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

4d

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 32768/0x8000 (x=0.5) (purple)
* ColorY = 19660/0x4CCC (y=0.3)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device moves to the given color.

4e

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
attributes have the value given in step 4d.

4f

OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

4g

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 13107/0x3333 (x=0.2)
* ColorY = 13107/0x3333 (y=0.2)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

4h

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
(still) attributes have the value given in 4d.

4i

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 13107/0x3333 (x=0.2)
* ColorY = 32768/0x8000 (y=0.5)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

4j

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
(still) attributes have the value given in 4d.

4k

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 26214/0x6666 (x=0.4)
* ColorY = 32768/0x8000 (y=0.5)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x01

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

4l

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
attributes have the value given in 4k.

tests for Options-bits (ExecuteIfOff=true)

5a

CC.S.A000f(Options)

TH writes 0x01 to the _Options attribute_

5b

CC.S.A000f(Options)

TH reads the _Options attribute_ from the DUT

* Verify that the DUT response contains a bitmap, with value 0x01.

5c

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

5d

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 32768/0x8000 (x=0.5)
* ColorY = 19660/0x4CCC (y=0.3)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device moves to the given color.

5e

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
attributes have the value given in 5c.

5f

OO.S.C00.Rsp(Off)

TH sends _Off command_ to DUT

5g

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 13107/0x3333 (x=0.2)
* ColorY = 13107/0x3333 (y=0.2)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x00
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

5h

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
attributes have the value given in 5g.

5i

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 13107/0x3333 (x=0.2)
* ColorY = 32768/0x8000 (y=0.5)
* TransitionTime = 0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x00

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

5j

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
(still) attributes have the value given in 5g.

5k

CC.S.C07.Rsp(MoveToColor)

TH sends a _MoveToColor_ command to the DUT with

* ColorX = 26214/0x6666 (x=0.4)
* ColorY = 32768/0x8000 (y=0.5)
* TransitionTime = s0 (immediate)
* OptionsMask = 0x01
* OptionsOverride = 0x01

Verify DUT responds with a successful (value 0x00) status response and
that the device remains in the off state.

5l

CC.S.C07.Rsp(MoveToColor) & CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT

Verify that the DUT response indicates that the CurrentX and CurrentY
attributes have the value given in 5k.

check ColorMode

6a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 1
(CurrentX and CurrentY).

6b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 1 (CurrentX and CurrentY).

[[_notestesting_considerations_104]]
=== link:#_notestesting_considerations_104[]Notes/Testing Considerations

[[_tc_cc_5_2_color_move_functionality_with_server_as_dut]]
=== link:#_tc_cc_5_2_color_move_functionality_with_server_as_dut[]26.3.11. [TC-CC-5.2] Color Move functionality with server as DUT

[[_category_104]]
==== link:#_category_104[]Category

Functional

[[_purpose_104]]
==== link:#_purpose_104[]Purpose

This test case verifies Color Move functionality of the Color Control
cluster server.

[[_pics_104]]
==== link:#_pics_104[]PICS

* CC.S

[[_preconditions_44]]
==== link:#_preconditions_44[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F03(XY) |
|===

[[_required_devices_104]]
==== link:#_required_devices_104[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_80]]
==== link:#_device_topology_80[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_92]]
==== link:#_test_setup_92[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The x/y values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_104]]
==== link:#_test_procedure_104[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

1a

CC.S.C07.Rsp(MoveToColor)

TH sends _MoveToColor command_ to DUT, with

* ColorX = 33000 (x=0.503) (orange)
* ColorY = 26000 (y=0.397)
* TransitionTime = 0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

MoveColor with RateX=-100,RateY=+100 over 30s to get a total transition
of -3000/+3000

2a

CC.S.C08.Rsp(MoveColor)

TH sends _MoveColor command_ to DUT with __RateX__=-100 and_RateY_=+100

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After 10 seconds, TH reads _CurrentX and CurrentY attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Verify that the DUT
response indicates that the CurrentX attribute has the expected value
32000 (33000 -100*10). Verify that the DUT response indicates that the
CurrentY attribute has the expected value 27000 (26000 +100*10).

2c

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After another 10 seconds, TH reads _CurrentX and CurrentY attributes_
from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Verify that the DUT
response indicates that the CurrentX attribute has the expected value
31000 (33000 -100*20). Verify that the DUT response indicates that the
CurrentY attribute has the expected value 28000 (26000 +100*20).

2d

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After another 10 seconds, TH reads _CurrentX and CurrentY attributes_
from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Verify that the DUT
response indicates that the CurrentX attribute has the expected value
30000 (33000 -100*30). Verify that the DUT response indicates that the
CurrentY attribute has the expected value 29000 (26000 +100*30).

stop the transition

3a

CC.S.C47.Rsp(StopMoveStep)

TH sends _StopMoveStep command_ to DUT.

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

TH reads _CurrentX and CurrentY attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Verify that the DUT
response indicates that the CurrentX and CurrentY attributes have
stabilized at the expected values mentioned in 2d (allowing for some
further transition in the time elapsed between 2d and 3a).

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 1
(CurrentX and CurrentY).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 1 (CurrentX and CurrentY).

[[_notestesting_considerations_105]]
=== link:#_notestesting_considerations_105[]Notes/Testing Considerations

[[_tc_cc_5_3_color_step_functionality_with_server_as_dut]]
=== link:#_tc_cc_5_3_color_step_functionality_with_server_as_dut[]26.3.12. [TC-CC-5.3] Color Step functionality with server as DUT

[[_category_105]]
==== link:#_category_105[]Category

Functional

[[_purpose_105]]
==== link:#_purpose_105[]Purpose

This test case verifies Color Step functionality of the Color Control
cluster server.

[[_pics_105]]
==== link:#_pics_105[]PICS

* CC.S

[[_preconditions_45]]
==== link:#_preconditions_45[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F03(XY) |
|===

[[_required_devices_105]]
==== link:#_required_devices_105[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_81]]
==== link:#_device_topology_81[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_93]]
==== link:#_test_setup_93[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The x/y values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_105]]
==== link:#_test_procedure_105[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

2a

CC.S.C07.Rsp(MoveToColor)

TH sends _MoveToColor command_ to DUT, with ColorX = 33000, ColorY =
20000 and TransitionTime = 0 (immediate)

Verify DUT responds with a successful (value 0x00) status response.

StepColor over 20s

3a

CC.S.C09.Rsp(StepColor)

TH sends _StepColor command_ to DUT, with StepX = -20000, StepY = -6000,
TransitionTime = 200 (20s)

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After 10 seconds, TH reads _CurrentX and CurrentY attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Values are in
transition between values written in 2a and expected values in 3c (i.e.
DUT is in transition).

3c

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After another 10 seconds, TH reads _CurrentX and CurrentY attributes_
from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Verify that the DUT
response indicates that the CurrentX attribute has the expected value
13000 (33000 -20000). Verify that the DUT response indicates that the
CurrentY attribute has the expected value 14000 (20000 -6000).

3d

CC.S.A0003(CurrentX) & CC.S.A0004(CurrentY)

After another 5 seconds, TH reads _CurrentX and CurrentY attributes_
from DUT.

Value has to be between a range of 0x0000 to 0xfeff; Values are expected
to have stabilized as expected in 3c.

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 1
(CurrentX and CurrentY).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 1 (CurrentX and CurrentY).

[[_notestesting_considerations_106]]
=== link:#_notestesting_considerations_106[]Notes/Testing Considerations

[[_tc_cc_5_4_color_functionality_with_client_as_dut]]
=== link:#_tc_cc_5_4_color_functionality_with_client_as_dut[]26.3.13. [TC-CC-5.4] Color functionality with client as DUT

[[_category_106]]
==== link:#_category_106[]Category

Functional

[[_purpose_106]]
==== link:#_purpose_106[]Purpose

This test case verifies Color functionality of the Color Control cluster
client.

[[_pics_106]]
==== link:#_pics_106[]PICS

* CC.C

[[_preconditions_46]]
==== link:#_preconditions_46[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.C.F03(XY) |
|===

[[_required_devices_106]]
==== link:#_required_devices_106[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_82]]
==== link:#_device_topology_82[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_94]]
==== link:#_test_setup_94[]Test Setup

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission TH to DUT
|2 |Set TH OnOff to On
|===

[[_test_procedure_106]]
==== link:#_test_procedure_106[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | |CC.C.C07.Tx(MoveToColor) |DUT sends _MoveToColor command_ to TH
|TH receives InvokeRequestMessage with CommandID 0x07 CommandFields
matches _MoveToColor command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

|1b | |CC.C.C07.Tx(MoveToColor) & CC.C.A0003(CurrentX) &
CC.C.A0004(CurrentY) |DUT reads _CurrentX and CurrentY attributes_ from
TH (potentially multiple times) |TH receives read requests from Cluster
0x300 Attribute 0x0000_0003(CurrentX) and 0x0000_0004(CurrentY); Verify
that the TH response contains with successful (value 0x00) status
responses.

|2a | |CC.C.C08.Tx(MoveColor) |DUT sends _MoveColor command_ to TH |TH
receives InvokeRequestMessage with CommandID 0x08 CommandFields matches
_MoveColor command_ parameters; Verify that the TH response contains
with a successful (value 0x00) status response.

|2b | |CC.C.C08.Tx(MoveColor) & CC.C.A0003(CurrentX) &
CC.C.A0004(CurrentY) |DUT reads _CurrentX and CurrentY attributes_ from
TH (potentially multiple times) |TH receives read requests from Cluster
0x300 Attribute 0x0000_0003(CurrentX) and 0x0000_0004(CurrentY); Verify
that the TH response contains with successful (value 0x00) status
responses.

|3a | |CC.C.C09.Tx(StepColor) |DUT sends _StepColor command_ to TH |TH
receives InvokeRequestMessage with CommandID 0x09 CommandFields matches
_StepColor command_ parameters; Verify that the TH response contains
with a successful (value 0x00) status response.

|3b | |CC.C.C09.Tx(StepColor) & CC.C.A0003(CurrentX) &
CC.C.A0004(CurrentY) |DUT reads _CurrentX and CurrentY attributes_ from
TH (potentially multiple times) |TH receives read requests from Cluster
0x300 Attribute 0x0000_0003(CurrentX) and 0x0000_0004(CurrentY); Verify
that the TH response contains with successful (value 0x00) status
responses.

|4a | |CC.C.C47.Tx(StopMoveStep) |DUT sends _StopMoveStep command_ to
TH. |TH receives InvokeRequestMessage with CommandID 0x47 CommandFields
matches _StopMoveStep command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

|4b | |CC.C.C47.Tx(StopMoveStep) & CC.C.A0003(CurrentX) &
CC.C.A0004(CurrentY) |DUT reads _CurrentX and CurrentY attributes_ from
TH (potentially multiple times) |TH receives read requests from Cluster
0x300 Attribute 0x0000_0003(CurrentX) and 0x0000_0004(CurrentY); Verify
that the TH response contains with successful (value 0x00) status
responses.
|===

[[_notestesting_considerations_107]]
==== link:#_notestesting_considerations_107[]Notes/Testing Considerations

[[_tc_cc_6_1_color_temperature_moveto_functionality_with_server_as_dut]]
=== link:#_tc_cc_6_1_color_temperature_moveto_functionality_with_server_as_dut[]26.3.14. [TC-CC-6.1] Color Temperature MoveTo functionality with server as DUT

[[_category_107]]
==== link:#_category_107[]Category

Functional

[[_purpose_107]]
==== link:#_purpose_107[]Purpose

This test case verifies Color Temperature MoveTo functionality of the
Color Control cluster server.

[[_pics_107]]
==== link:#_pics_107[]PICS

* CC.S

[[_preconditions_47]]
==== link:#_preconditions_47[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F04(CT) |
|===

[[_required_devices_107]]
==== link:#_required_devices_107[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_83]]
==== link:#_device_topology_83[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_95]]
==== link:#_test_setup_95[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The CT values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_107]]
==== link:#_test_procedure_107[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

1a

CC.S.A400b(ColorTempPhysicalMinMireds)

TH reads _ColorTempPhysicalMinMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

1b

CC.S.A400c(ColorTempPhysicalMaxMireds)

TH reads _ColorTempPhysicalMaxMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

1c

CC.S.A0007(ColorTemperatureMireds)

TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_.

MoveToColorTemperature; from 310(3225 K) to 250(4000 K) = 60 mired steps
over 30s.

2a

CC.S.C0a.Rsp(MoveToColorTemperature)

TH sends _MoveToColorTemperature command_ to DUT with
__ColorTemperatureMireds__=310 and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C0a.Rsp(MoveToColorTemperature)

TH sends _MoveToColorTemperature command_ to DUT with
__ColorTemperatureMireds__=250 and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0007(ColorTemperatureMireds)

After 10 seconds, TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of ColorTempPhysicalMinMireds(1a) to
ColorTempPhysicalMaxMireds(1b); Verify that the DUT response indicates
that the ColorTemperatureMireds attribute has the expected value 290
(310+(250-310)*(10/30)).

2d

CC.S.A0007(ColorTemperatureMireds)

After another 10 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of ColorTempPhysicalMinMireds(1a) to
ColorTempPhysicalMaxMireds(1b); Verify that the DUT response indicates
that the ColorTemperatureMireds attribute has the expected value 270
(310+(250-310)*(20/30)).

2e

CC.S.A0007(ColorTemperatureMireds)

After another 10 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of ColorTempPhysicalMinMireds(1a) to
ColorTempPhysicalMaxMireds(1b); Verify that the DUT response indicates
that the ColorTemperatureMireds attribute has the expected value 250
(310+(250-310)*(30/30)).

2f

CC.S.A0007(ColorTemperatureMireds)

After another 5 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of ColorTempPhysicalMinMireds(1a) to
ColorTempPhysicalMaxMireds(1b); Verify that the DUT response indicates
that the ColorTemperatureMireds attribute is now stable at the value
250.

check ColorMode

3a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 2
(ColorTemperatureMireds).

3b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 2 (ColorTemperatureMireds).

[[_notestesting_considerations_108]]
=== link:#_notestesting_considerations_108[]Notes/Testing Considerations

[[_tc_cc_6_2_color_temperature_move_functionality_with_server_as_dut]]
=== link:#_tc_cc_6_2_color_temperature_move_functionality_with_server_as_dut[]26.3.15. [TC-CC-6.2] Color Temperature Move functionality with server as DUT

[[_category_108]]
==== link:#_category_108[]Category

Functional

[[_purpose_108]]
==== link:#_purpose_108[]Purpose

This test case verifies Color Temperature Move functionality of the
Color Control cluster server.

[[_pics_108]]
==== link:#_pics_108[]PICS

* CC.S

[[_preconditions_48]]
==== link:#_preconditions_48[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F04(CT) |
|===

[[_required_devices_108]]
==== link:#_required_devices_108[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_84]]
==== link:#_device_topology_84[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_96]]
==== link:#_test_setup_96[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The CT values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.
* For the _ColorTemperatureMinimumMireds_ and
_ColorTemperatureMaximumMireds_ fields of the _MoveColorTemperature_
command used in this test, use the values _ColorTempPhysicalMinMireds_
and _ColorTemperatureMaximumMireds_.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_108]]
==== link:#_test_procedure_108[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

1a

CC.S.A400b(ColorTempPhysicalMinMireds)

TH reads _ColorTempPhysicalMinMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

1b

CC.S.A400c(ColorTempPhysicalMaxMireds)

TH reads _ColorTempPhysicalMaxMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

1c

CC.S.A0007(ColorTemperatureMireds)

TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_.

MoveColorTemperature (up) starting midway between min/max; use a rate
that will take (about) 20s to get to max

2a

CC.S.C0a.Rsp(MoveToColorTemperature)

TH sends _MoveToColorTemperature command_ to DUT with
__ColorTemperatureMireds__=(_ColorTempPhysicalMinMireds_ +
_ColorTempPhysicalMaxMireds_)/2 and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C4b.Rsp(MoveColorTemperature)

TH sends _MoveColorTemperature command_ to DUT with _MoveMode_ = 0x01
(up), _Rate_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/40

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0007(ColorTemperatureMireds)

After 10 seconds, TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
(_ColorTempPhysicalMinMireds_ + _ColorTempPhysicalMaxMireds_)/2 +
10*(_ColorTempPhysicalMaxMireds_ - _ColorTempPhysicalMinMireds_)/40 =
3/4 * _ColorTempPhysicalMaxMireds_ + 1/4 * _ColorTempPhysicalMinMireds_
.

2d

CC.S.A0007(ColorTemperatureMireds)

After another 10 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
(_ColorTempPhysicalMinMireds_ + _ColorTempPhysicalMaxMireds_)/2 +
20*(_ColorTempPhysicalMaxMireds_ - _ColorTempPhysicalMinMireds_)/40 =
_ColorTempPhysicalMaxMireds_ .

2e

CC.S.A0007(ColorTemperatureMireds)

After another 5 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMaxMireds_ (stabilized since max reached).

MoveColorTemperature (down) starting at max; use a rate that will take
(about) 20s to get to min

3a

CC.S.C4b.Rsp(MoveColorTemperature)

TH sends _MoveColorTemperature command_ to DUT with _MoveMode_ =
0x03(down), _Rate_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/20

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A0007(ColorTemperatureMireds)

After 10 seconds, TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMaxMireds_ - 10*(_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/20 = (_ColorTempPhysicalMinMireds_ +
_ColorTempPhysicalMaxMireds_)/2 .

3c

CC.S.A0007(ColorTemperatureMireds)

After another 10 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMaxMireds_ - 20*(_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/20 = _ColorTempPhysicalMinMireds_ .

3d

CC.S.A0007(ColorTemperatureMireds)

After another 5 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMinMireds_ (stabilized since min reached).

MoveColorTemperature (up) starting at min; interrupt with 'stop' before
reaching max

4a

CC.S.C4b.Rsp(MoveColorTemperature)

TH sends _MoveColorTemperature command_ to DUT with _MoveMode_ =
0x01(up), _Rate_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/20

Verify DUT responds with a successful (value 0x00) status response.

4b

CC.S.C4b.Rsp(MoveColorTemperature)

After 10 seconds, TH sends _MoveColorTemperature command_ to DUT with
_MoveMode_ = 0x00(stop), _Rate_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/20

Verify DUT responds with a successful (value 0x00) status response.

4c

CC.S.A0007(ColorTemperatureMireds)

TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMinMireds_ + 10*(_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/20 = (_ColorTempPhysicalMinMireds_ +
_ColorTempPhysicalMaxMireds_)/2 .

4d

CC.S.A0007(ColorTemperatureMireds)

After another 2 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value = same as 4c (stabilized
since stopped).

check ColorMode

5a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 2
(ColorTemperatureMireds).

5b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 2 (ColorTemperatureMireds).

[[_notestesting_considerations_109]]
=== link:#_notestesting_considerations_109[]Notes/Testing Considerations

[[_tc_cc_6_3_color_temperature_step_functionality_with_server_as_dut]]
=== link:#_tc_cc_6_3_color_temperature_step_functionality_with_server_as_dut[]26.3.16. [TC-CC-6.3] Color Temperature Step functionality with server as DUT

[[_category_109]]
==== link:#_category_109[]Category

Functional

[[_purpose_109]]
==== link:#_purpose_109[]Purpose

This test case verifies Color Temperature Step functionality of the
Color Control cluster server.

[[_pics_109]]
==== link:#_pics_109[]PICS

* CC.S

[[_preconditions_49]]
==== link:#_preconditions_49[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F04(CT) |
|===

[[_required_devices_109]]
==== link:#_required_devices_109[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_85]]
==== link:#_device_topology_85[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_97]]
==== link:#_test_setup_97[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.
* The CT values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.
* For the _ColorTemperatureMinimumMireds_ and
_ColorTemperatureMaximumMireds_ fields of the _StepColorTemperature_
command used in this test, use the values _ColorTempPhysicalMinMireds_
and _ColorTemperatureMaximumMireds_.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_109]]
==== link:#_test_procedure_109[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

1a

CC.S.A400b(ColorTempPhysicalMinMireds)

TH reads _ColorTempPhysicalMinMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

1b

CC.S.A400c(ColorTempPhysicalMaxMireds)

TH reads _ColorTempPhysicalMaxMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

1c

CC.S.A0007(ColorTemperatureMireds)

TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_.

StepColorTemperature (up) starting midway between min/max; use a step
size that will take (about) 20s to get to max

2a

CC.S.C0a.Rsp(MoveToColorTemperature)

TH sends _MoveToColorTemperature command_ to DUT with
__ColorTemperatureMireds__=(_ColorTempPhysicalMinMireds_ +
_ColorTempPhysicalMaxMireds_)/2 and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C4c.Rsp(StepColorTemperature)

TH sends _StepColorTemperature command_ to DUT with _StepMode_ = 0x01
(up), _StepSize_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/2 and _TransitionTime_ = 200 (20s).

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A0007(ColorTemperatureMireds)

After 10 seconds, TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
(_ColorTempPhysicalMinMireds_ + _ColorTempPhysicalMaxMireds_)/2 +
(10/20)*(_ColorTempPhysicalMaxMireds_ - _ColorTempPhysicalMinMireds_)/2
= 3/4 * _ColorTempPhysicalMaxMireds_ + 1/4 *
_ColorTempPhysicalMinMireds_ .

2d

CC.S.A0007(ColorTemperatureMireds)

After another 10 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
(_ColorTempPhysicalMinMireds_ + _ColorTempPhysicalMaxMireds_)/2 +
(20/20)*(_ColorTempPhysicalMaxMireds_ - _ColorTempPhysicalMinMireds_)/2
= _ColorTempPhysicalMaxMireds_ .

2e

CC.S.A0007(ColorTemperatureMireds)

After another 5 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMaxMireds_ (stabilized since max reached).

StepColorTemperature (down) starting at max; use a step size that will
take (about) 20s to get to min

3a

CC.S.C4c.Rsp(StepColorTemperature)

TH sends _StepColorTemperature command_ to DUT with _StepMode_ = 0x03
(down), _StepSize_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_) and _TransitionTime_ = 200 (20s).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A0007(ColorTemperatureMireds)

After 10 seconds, TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMaxMireds_ - (10/20)*(_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_) = (_ColorTempPhysicalMinMireds_ +
_ColorTempPhysicalMaxMireds_)/2 .

3c

CC.S.A0007(ColorTemperatureMireds)

After another 10 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMaxMireds_ - (20/20)*(_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_) = _ColorTempPhysicalMinMireds_ .

3d

CC.S.A0007(ColorTemperatureMireds)

After another 5 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
_ColorTempPhysicalMinMireds_ (stabilized since min reached).

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 2
(ColorTemperatureMireds).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 2 (ColorTemperatureMireds).

[[_notestesting_considerations_110]]
=== link:#_notestesting_considerations_110[]Notes/Testing Considerations

[[_tc_cc_6_4_color_temperature_functionality_with_client_as_dut]]
=== link:#_tc_cc_6_4_color_temperature_functionality_with_client_as_dut[]26.3.17. [TC-CC-6.4] Color Temperature functionality with client as DUT

[[_category_110]]
==== link:#_category_110[]Category

Functional

[[_purpose_110]]
==== link:#_purpose_110[]Purpose

This test case verifies Color Temperature functionality of the Color
Control cluster client as DUT.

[[_pics_110]]
==== link:#_pics_110[]PICS

* CC.C

[[_preconditions_50]]
==== link:#_preconditions_50[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.C.F04(CT) |
|===

[[_required_devices_110]]
==== link:#_required_devices_110[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_86]]
==== link:#_device_topology_86[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_98]]
==== link:#_test_setup_98[]Test Setup

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission TH to DUT
|2 |Set TH OnOff to On
|===

[[_test_procedure_110]]
==== link:#_test_procedure_110[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |* TH provides a server implementation of Color Control with
F04(CT)=true and reasonable values of ColorTempPhysicalMinMireds (e.g.
153 (6500K), ColorTempPhysicalMaxMireds (e.g. 454 (2200K)) * DUT might
read attributes like ColorTempPhysicalMinMireds,
ColorTempPhysicalMaxMireds from TH (now or in later steps) to use those.
|

|2a | |CC.C.C0a.Tx(MoveToColorTemperature) |DUT sends
_MoveToColorTemperature command_ to TH |TH receives InvokeRequestMessage
with CommandID 0x0a CommandFields matches _MoveToColorTemperature
command_ parameters; Verify that the TH response contains with a
successful (value 0x00) status response.

|2b | |CC.C.C0a.Tx(MoveToColorTemperature) &
CC.C.A0007(ColorTemperatureMireds) |DUT reads _ColorTemperatureMired
attribute_ from TH (potentially multiple times) |TH receives read
request from Cluster 0x300 Attribute 0x0000_0007; Verify that the TH
response contains with a successful (value 0x00) status response.

|3a | |CC.C.C4b.Tx(MoveColorTemperature) |DUT sends
_MoveColorTemperature command_ to TH |TH receives InvokeRequestMessage
with CommandID 0x4b CommandFields matches _MoveColorTemperature command_
parameters; Verify that the TH response contains with a successful
(value 0x00) status response.

|3b | |CC.C.C4b.Tx(MoveColorTemperature) &
CC.C.A0007(ColorTemperatureMireds) |DUT reads _ColorTemperatureMired
attribute_ from TH (potentially multiple times) |TH receives read
request from Cluster 0x300 Attribute 0x0000_0007; Verify that the TH
response contains with a successful (value 0x00) status response.

|4a | |CC.C.C4c.Tx(StepColorTemperature) |DUT sends
_StepColorTemperature command_ to TH |TH receives InvokeRequestMessage
with CommandID 0x4c CommandFields matches _StepColorTemperature command_
parameters; Verify that the TH response contains with a successful
(value 0x00) status response.

|4b | |CC.C.C4c.Tx(StepColorTemperature) &
CC.C.A0007(ColorTemperatureMireds) |DUT reads _ColorTemperatureMired
attribute_ from TH (potentially multiple times) |TH receives read
request from Cluster 0x300 Attribute 0x0000_0007; Verify that the TH
response contains with a successful (value 0x00) status response.

|5a | |CC.C.C47.Tx(StopMoveStep) |DUT sends _StopMoveStep command_ to
TH. |TH receives InvokeRequestMessage with CommandID 0x47 CommandFields
matches _StopMoveStep command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

|5b | |CC.C.C47.Tx(StopMoveStep) & CC.C.A0007(ColorTemperatureMireds)
|DUT reads _ColorTemperatureMired attribute_ from TH (potentially
multiple times) |TH receives read request from Cluster 0x300 Attribute
0x0000_0007; Verify that the TH response contains with a successful
(value 0x00) status response.
|===

[[_notestesting_considerations_111]]
==== link:#_notestesting_considerations_111[]Notes/Testing Considerations

[[_tc_cc_6_5_color_temperature_startupcolortemperaturemireds_functionality_with_server_as_dut]]
=== link:#_tc_cc_6_5_color_temperature_startupcolortemperaturemireds_functionality_with_server_as_dut[]26.3.18. [TC-CC-6.5] Color Temperature StartUpColorTemperatureMireds functionality with server as DUT

[[_category_111]]
==== link:#_category_111[]Category

Functional

[[_purpose_111]]
==== link:#_purpose_111[]Purpose

This test case verifies Color Temperature StartUpColorTemperatureMireds
functionality of the Color Control cluster server.

[[_pics_111]]
==== link:#_pics_111[]PICS

* CC.S

[[_preconditions_51]]
==== link:#_preconditions_51[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F04(CT) |
|===

[[_required_devices_111]]
==== link:#_required_devices_111[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_87]]
==== link:#_device_topology_87[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_99]]
==== link:#_test_setup_99[]Test Setup

* The CT values used in this test are assumed to be in range of the
DUT’s capabilities. If the DUT does not support these values, adapt the
values accordingly.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_111]]
==== link:#_test_procedure_111[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|0a | |CC.S.A000f(Options) |TH writes 0x00 to the _Options attribute_ |

|0b | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds with a successful (value 0x00) status response.

|0c | |CC.S.A0007(ColorTemperatureMireds) |TH reads
_ColorTemperatureMireds attribute_ from DUT. |Verify that the DUT
response contains with _ColorTemperatureMireds attribute_ value.

|0d | |CC.S.A400b(ColorTempPhysicalMinMireds) |TH reads
_ColorTempPhysicalMinMireds attribute_ from DUT. |Verify that the DUT
response contains with _ColorTempPhysicalMinMireds attribute_ value.

|0e | |CC.S.A400c(ColorTempPhysicalMaxMireds) |TH reads
_ColorTempPhysicalMaxMireds attribute_ from DUT. |Verify that the DUT
response contains with _ColorTempPhysicalMaxMireds attribute_ value.

|1 |3.2.7.22 |CC.S.A4010(StartUpColorTemperatureMireds) |TH reads from
the DUT the _StartUpColorTemperatureMireds attribute_ |Verify that the
DUT response contains an uint16 [Min:0 Max:0xfeff or null]

|2a | |CC.S.A4010(StartUpColorTemperatureMireds) |If
_(ColorTempPhysicalMaxMireds - ColorTempPhysicalMinMireds)/2 +
ColorTempPhysicalMinMireds = ColorTemperatureMireds_ then
_StartUpColorTemperatureMireds = (ColorTempPhysicalMaxMireds -
ColorTempPhysicalMinMireds)/4 + ColorTempPhysicalMinMireds_; else
_StartUpColorTemperatureMireds = (ColorTempPhysicalMaxMireds -
ColorTempPhysicalMinMireds)/2 + ColorTempPhysicalMinMireds_. TH writes
to _StartUpColorTemperatureMireds attribute_ with value
_StartUpColorTemperatureMireds_ |Verify DUT responds with a successful
(value 0x00) status response.

|2b | |CC.S.A4010(StartUpColorTemperatureMireds) |TH reads from the DUT
the _StartUpColorTemperatureMireds attribute_ |Verify that the DUT
response contains _StartUpColorTemperatureMireds_ that matches the
_StartUpColorTemperatureMireds_ set in Step 2a

|3a | | |Power off DUT |

|3b | | |Power on DUT |

|4a | |CC.S.A4010(StartUpColorTemperatureMireds) |TH reads from the DUT
the _StartUpColorTemperatureMireds attribute_ |Verify that the DUT
response indicates that the StartUpColorTemperatureMireds attribute
matches the _StartUpColorTemperatureMireds_ set in Step 2a

|4b | |CC.S.A0007(ColorTemperatureMireds) |TH reads from the DUT the
_ColorTemperatureMireds attribute_ from DUT. |Verify that the DUT
response indicates that the ColorTemperatureMireds attribute is
_StartUpColorTemperatureMireds_

|5a | |CC.S.A0008(ColorMode) |TH reads _ColorMode attribute_ from DUT.
|Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 2
(ColorTemperatureMireds).

|5b | |CC.S.A4001(EnhancedColorMode) |TH reads _EnhancedColorMode
attribute_ from DUT. |Value has to be between a range of 0x00 to 0x03;
Verify that the DUT response indicates that the EnhancedColorMode
attribute has the expected value 2 (ColorTemperatureMireds).
|===

[[_notestesting_considerations_112]]
==== link:#_notestesting_considerations_112[]Notes/Testing Considerations

[[_tc_cc_7_1_enhanced_movetohue_functionality_with_server_as_dut]]
=== link:#_tc_cc_7_1_enhanced_movetohue_functionality_with_server_as_dut[]26.3.19. [TC-CC-7.1] Enhanced MoveToHue functionality with server as DUT

[[_category_112]]
==== link:#_category_112[]Category

Functional

[[_purpose_112]]
==== link:#_purpose_112[]Purpose

This test case verifies Enhanced MoveToHue functionality of the Color
Control cluster server.

[[_pics_112]]
==== link:#_pics_112[]PICS

* CC.S

[[_preconditions_52]]
==== link:#_preconditions_52[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F01(EHUE) |
|===

[[_required_devices_112]]
==== link:#_required_devices_112[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_88]]
==== link:#_device_topology_88[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_100]]
==== link:#_test_setup_100[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_112]]
==== link:#_test_procedure_112[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

EnhancedMoveToHue, shortest distance; from 6000 to 12000 (distance 6000)
over 30s, so increasing by 2000 units every 10s

2a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=6000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=12000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 8000 (6000+(12000-6000)*(10/30)).

2d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 10000 (6000+(12000-6000)*(20/30)).

2e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 12000 (6000+(12000-6000)*(30/30)).

2f

CC.S.A4000(EnhancedCurrentHue)

After another 5 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute is now stable
at the value 12000.

EnhancedMoveToHue, longest distance; from 6000 to 54000, distance =
48000, so increasing by 16000 units every 10s

3a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=6000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=54000,
__Direction__=0x01 (longest distance) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 22000 (6000 + (48000-6000)*(10/30).

3d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 38000 (6000 + (48000-6000)*(20/30).

3e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 54000 (6000 + (48000-6000)*(30/30).

3f

CC.S.A4000(EnhancedCurrentHue)

After another 5 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute is now stable
at the value 54000.

EnhancedMoveToHue, up, from 6000 to 12000 (distance 6000) in 30s so
increasing by 2000 units every 10s

4a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=6000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

4b

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=12000,
__Direction__=0x02 (up) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

4c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 8000 (6000+(12000-6000)*(10/30)).

4d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 10000 (6000+(12000-6000)*(20/30)).

4e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 12000 (6000+(12000-6000)*(30/30)).

4f

CC.S.A4000(EnhancedCurrentHue)

After another 5 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute is now stable
at the value 12000.

EnhancedMoveToHue, down, from 12000 to 6000 (distance 6000) in 30s so
decreasing by 2000 units every 10s

5a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=12000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

5b

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=6000,
__Direction__=0x03 (down) and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

5c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 10000 (12000-(12000-6000)*(10/30)).

5d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 8000 (12000-(12000-6000)*(20/30)).

5e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 6000 (12000-(12000-6000)*(30/30)).

5f

CC.S.A4000(EnhancedCurrentHue)

After another 5 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute is now stable
at the value 6000.

check ColorMode

6a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

6b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 3 (EnhancedCurrentHue and CurrentSaturation).

[[_notestesting_considerations_113]]
=== link:#_notestesting_considerations_113[]Notes/Testing Considerations

[[_tc_cc_7_2_enhanced_movehue_functionality_with_server_as_dut]]
=== link:#_tc_cc_7_2_enhanced_movehue_functionality_with_server_as_dut[]26.3.20. [TC-CC-7.2] Enhanced MoveHue functionality with server as DUT

[[_category_113]]
==== link:#_category_113[]Category

Functional

[[_purpose_113]]
==== link:#_purpose_113[]Purpose

This test case verifies Enhanced MoveHue functionality of the Color
Control cluster server.

[[_pics_113]]
==== link:#_pics_113[]PICS

* CC.S

[[_preconditions_53]]
==== link:#_preconditions_53[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F01(EHUE) |
|===

[[_required_devices_113]]
==== link:#_required_devices_113[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_89]]
==== link:#_device_topology_89[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_101]]
==== link:#_test_setup_101[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_113]]
==== link:#_test_procedure_113[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

EnhancedMoveHue (up) ; start at 20000 with 500 units/s and measuring
every 10s (so increases by 5000 units per 10s)

2a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=20000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C41.Rsp(EnhancedMoveHue)

TH sends _EnhancedMoveHue command_ to DUT with __MoveMode__=0x01 (up)
and __Rate__=500 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 25000 (20000 + 10*500).

2d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 30000 (20000 + 20*500).

2e

CC.S.C41.Rsp(EnhancedMoveHue)

After another 10 seconds, TH sends _EnhancedMoveHue command_ to DUT with
__MoveMode__=0x00 (stop) and __Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2f

CC.S.A4000(EnhancedCurrentHue)

TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 35000 (20000 + 30*500).

2g

CC.S.A4000(EnhancedCurrentHue)

After another 2 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has stabilized
at the expected value 35000.

EnhancedMoveHue (down) ; start at 25000 with 500 units/s and measuring
every 10s (so decreases by 5000 units per 10s)

3a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=25000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C41.Rsp(EnhancedMoveHue)

TH sends _EnhancedMoveHue command_ to DUT with __MoveMode__=0x03 (down)
and __Rate__=500 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 20000 (25000 - 10*500).

3d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 15000 (25000 - 20*500).

3e

CC.S.C41.Rsp(EnhancedMoveHue)

After another 10 seconds, TH sends _EnhancedMoveHue command_ to DUT with
__MoveMode__=0x00 (stop) and __Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

3f

CC.S.A4000(EnhancedCurrentHue)

TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 10000 (25000 - 30*500).

3g

CC.S.A4000(EnhancedCurrentHue)

After another 2 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has stabilized
at the expected value 10000.

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 3 (EnhancedCurrentHue and CurrentSaturation).

[[_notestesting_considerations_114]]
=== link:#_notestesting_considerations_114[]Notes/Testing Considerations

[[_tc_cc_7_3_enhanced_step_functionality_with_server_as_dut]]
=== link:#_tc_cc_7_3_enhanced_step_functionality_with_server_as_dut[]26.3.21. [TC-CC-7.3] Enhanced Step functionality with server as DUT

[[_category_114]]
==== link:#_category_114[]Category

Functional

[[_purpose_114]]
==== link:#_purpose_114[]Purpose

This test case verifies Enhanced Step functionality of the Color Control
cluster server.

[[_pics_114]]
==== link:#_pics_114[]PICS

* CC.S

[[_preconditions_54]]
==== link:#_preconditions_54[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F01(EHUE) |
|===

[[_required_devices_114]]
==== link:#_required_devices_114[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_90]]
==== link:#_device_topology_90[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_102]]
==== link:#_test_setup_102[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_114]]
==== link:#_test_procedure_114[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

EnhancedStepHue, up, from 6000 to 12000 (distance 6000) in 30s so
increasing by 2000 units every 10s

2a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=6000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C42.Rsp(EnhancedStepHue)

TH sends _EnhancedStepHue command_ to DUT with __StepMode__=0x01 (up),
__StepSize__=6000 and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 8000 (6000+(12000-6000)*(10/30)).

2d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 10000 (6000+(12000-6000)*(20/30)).

2e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 12000 (6000+(12000-6000)*(30/30)).

2f

CC.S.A4000(EnhancedCurrentHue)

After another 5 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute is now stable
at the value 12000.

EnhancedStepHue, down, from 12000 to 6000 (distance 6000) in 30s so
decreasing by 2000 units every 10s

5a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=12000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C42.Rsp(EnhancedStepHue)

TH sends _EnhancedStepHue command_ to DUT with __StepMode__=0x03 (down),
__StepSize__=6000 and __TransitionTime__=300 (30s).

Verify DUT responds with a successful (value 0x00) status response.

5c

CC.S.A4000(EnhancedCurrentHue)

After 10 seconds, TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 10000 (12000-(12000-6000)*(10/30)).

5d

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 8000 (12000-(12000-6000)*(20/30)).

5e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 6000 (12000-(12000-6000)*(30/30)).

5f

CC.S.A4000(EnhancedCurrentHue)

After another 5 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute is now stable
at the value 6000.

check ColorMode

6a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

6b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 3 (EnhancedCurrentHue and CurrentSaturation).

[[_notestesting_considerations_115]]
=== link:#_notestesting_considerations_115[]Notes/Testing Considerations

[[_tc_cc_7_4_movetoenhancedhueandsaturation_functionality_with_server_as_dut]]
=== link:#_tc_cc_7_4_movetoenhancedhueandsaturation_functionality_with_server_as_dut[]26.3.22. [TC-CC-7.4] MoveToEnhancedHueAndSaturation functionality with server as DUT

[[_category_115]]
==== link:#_category_115[]Category

Functional

[[_purpose_115]]
==== link:#_purpose_115[]Purpose

This test case verifies MoveToEnhancedHueAndSaturation functionality of
the Color Control cluster server.

[[_pics_115]]
==== link:#_pics_115[]PICS

* CC.S

[[_preconditions_55]]
==== link:#_preconditions_55[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F01(EHUE) |
|===

[[_required_devices_115]]
==== link:#_required_devices_115[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_91]]
==== link:#_device_topology_91[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_103]]
==== link:#_test_setup_103[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_115]]
==== link:#_test_procedure_115[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

1b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

set starting point

2a

CC.S.C43.Rsp(EnhancedMoveToHueAndSaturation)

TH sends _EnhancedMoveToHueAndSaturation command_ to DUT with
__EnhancedHue__=20000, __Saturation__=50 and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.A4000(EnhancedCurrentHue) & CC.S.A0001(CurrentSaturation)

TH reads _EnhancedCurrentHue and CurrentSaturation attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xffff resp 0x00..0xfe.
Values match what was written in step 2a.

EnhancedMoveToHueAndSaturation with transition time

3a

CC.S.C43.Rsp(EnhancedMoveToHueAndSaturation)

TH sends _EnhancedMoveToHueAndSaturation command_ to DUT with
__EnhancedHue__=16000, __Saturation__=80 and __TransitionTime__=200
(20s).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.A4000(EnhancedCurrentHue) & CC.S.A0001(CurrentSaturation)

After 10 seconds, TH reads _EnhancedCurrentHue and CurrentSaturation
attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xffff resp 0x00..0xfe.
Values are in transition between values written in 2a and 3a (i.e. DUT
is in transition).

3c

CC.S.A4000(EnhancedCurrentHue) & CC.S.A0001(CurrentSaturation)

After another 10 seconds, TH reads _EnhancedCurrentHue and
CurrentSaturation attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xffff resp 0x00..0xfe.
Values are expected to be as written in 3a.

3d

CC.S.A4000(EnhancedCurrentHue) & CC.S.A0001(CurrentSaturation)

After another 5 seconds, TH reads _EnhancedCurrentHue and
CurrentSaturation attributes_ from DUT.

Value has to be between a range of 0x0000 to 0xffff resp 0x00..0xfe.
Values are expected to have stabilized as written in 3a.

check ColorMode

4a

CC.S.A0008(ColorMode)

TH reads _ColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x02; Verify that the DUT
response indicates that the ColorMode attribute has the expected value 0
(CurrentHue and CurrentSaturation).

4b

CC.S.A4001(EnhancedColorMode)

TH reads _EnhancedColorMode attribute_ from DUT.

Value has to be between a range of 0x00 to 0x03; Verify that the DUT
response indicates that the EnhancedColorMode attribute has the expected
value 3 (EnhancedCurrentHue and CurrentSaturation).

[[_notestesting_considerations_116]]
=== link:#_notestesting_considerations_116[]Notes/Testing Considerations

[[_tc_cc_7_5_enhanced_hue_functionality_with_client_as_dut]]
=== link:#_tc_cc_7_5_enhanced_hue_functionality_with_client_as_dut[]26.3.23. [TC-CC-7.5] Enhanced Hue functionality with client as DUT

[[_category_116]]
==== link:#_category_116[]Category

Functional

[[_purpose_116]]
==== link:#_purpose_116[]Purpose

This test case verifies Enhanced Hue functionality of the Color Control
cluster client.

[[_pics_116]]
==== link:#_pics_116[]PICS

* CC.C

[[_preconditions_56]]
==== link:#_preconditions_56[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.C.F01(EHUE) |
|===

[[_required_devices_116]]
==== link:#_required_devices_116[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_92]]
==== link:#_device_topology_92[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_104]]
==== link:#_test_setup_104[]Test Setup

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission TH to DUT
|2 |Set TH OnOff to On
|===

[[_test_procedure_116]]
==== link:#_test_procedure_116[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | |CC.C.C40.Tx(EnhancedMoveToHue) |DUT sends _EnhancedMoveToHue
command_ to TH |TH receives InvokeRequestMessage with CommandID 0x40
CommandFields matches _EnhancedMoveToHue command_ parameters; Verify
that the TH response contains with a successful (value 0x00) status
response.

|1b | |CC.C.C40.Tx(EnhancedMoveToHue) & CC.C.A4000(EnhancedCurrentHue)
|DUT reads _EnhancedCurrentHue attribute_ from TH (potentially multiple
times) |TH receives read request from Cluster 0x300 Attribute
0x0000_4000; Verify that the TH response contains with a successful
(value 0x00) status response.

|2a | |CC.C.C41.Tx(EnhancedMoveHue) |DUT sends _EnhancedMoveHue command_
to TH |TH receives InvokeRequestMessage with CommandID 0x41
CommandFields matches _EnhancedMoveHue command_ parameters; Verify that
the TH response contains with a successful (value 0x00) status response.

|2b | |CC.C.C41.Tx(EnhancedMoveHue) & CC.C.A4000(EnhancedCurrentHue)
|DUT reads _EnhancedCurrentHue attribute_ (potentially multiple times)
|TH receives read request from Cluster 0x300 Attribute 0x0000_4000;
Verify that the TH response contains with a successful (value 0x00)
status response.

|3a | |CC.C.C42.Tx(EnhancedStepHue) |DUT sends _EnhancedStepHue command_
to TH |TH receives InvokeRequestMessage with CommandID 0x42
CommandFields matches _EnhancedStepHue command_ parameters; Verify that
the TH response contains with a successful (value 0x00) status response.

|3b | |CC.C.C42.Tx(EnhancedStepHue) & CC.C.A4000(EnhancedCurrentHue)
|DUT reads _EnhancedCurrentHue attribute_ from TH (potentially multiple
times) |TH receives read request from Cluster 0x300 Attribute
0x0000_4000; Verify that the TH response contains with a successful
(value 0x00) status response.

|4a | |CC.C.C43.Tx(EnhancedMoveToHueAndSaturation) |DUT sends
_EnhancedMoveToHueAndSaturation command_ to TH |T TH receives
InvokeRequestMessage with CommandID 0x43 CommandFields matches
_EnhancedMoveToHueAndSaturation command_ parameters; Verify that the TH
response contains with a successful (value 0x00) status response.

|4b | |CC.C.C43.Tx(EnhancedMoveToHueAndSaturation) &
CC.C.A4000(EnhancedCurrentHue) & CC.C.A0001(CurrentSaturation) |DUT
reads _EnhancedCurrentHue and CurrentSaturation attributes_ from TH
(potentially multiple times) |TH receives read request from Cluster
0x300 Attribute 0x0000_4000 and 0x0000_0001; Verify that the TH response
contains with a successful (value 0x00) status response.

|5a | |CC.C.C47.Tx(StopMoveStep) |DUT sends _StopMoveStep command_ to
TH. |TH receives InvokeRequestMessage with CommandID 0x47 CommandFields
matches _StopMoveStep command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

|5b | |CC.C.C47.Tx(StopMoveStep) & CC.C.A4000(EnhancedCurrentHue) |Over
_TransitionTime_, DUT reads _EnhancedCurrentHue attribute_ from TH. |TH
receives read request from Cluster 0x300 Attribute 0x0000_4000; Verify
that the TH response contains with a successful (value 0x00) status
response.
|===

[[_notestesting_considerations_117]]
==== link:#_notestesting_considerations_117[]Notes/Testing Considerations

[[_tc_cc_8_1_stopmovestep_functionality_with_server_as_dut]]
=== link:#_tc_cc_8_1_stopmovestep_functionality_with_server_as_dut[]26.3.24. [TC-CC-8.1] StopMoveStep functionality with server as DUT

[[_category_117]]
==== link:#_category_117[]Category

Functional

[[_purpose_117]]
==== link:#_purpose_117[]Purpose

This test case verifies StopMoveStep functionality of the Color Control
cluster server.

[[_pics_117]]
==== link:#_pics_117[]PICS

* CC.S

[[_required_devices_117]]
==== link:#_required_devices_117[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_93]]
==== link:#_device_topology_93[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_105]]
==== link:#_test_setup_105[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH
|2 |Set DUT OnOff to On
|===

[[_test_procedure_117]]
==== link:#_test_procedure_117[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

0a

CC.S.A000f(Options)

TH writes 0x00 to the _Options attribute_

0b

OO.S.C01.Rsp(On)

TH sends _On command_ to DUT

Verify DUT responds with a successful (value 0x00) status response.

MoveHue (up) ; start at 200 with 5 units/s and stopping after 10s (so
increases by 50 units per 10s)

2a

CC.S.C00.Rsp(MoveToHue)

TH sends _MoveToHue command_ to DUT with __Hue__=200, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

2b

CC.S.C01.Rsp(MoveHue)

TH sends _MoveHue command_ to DUT with __MoveMode__=0x01 (up) and
__Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

2c

CC.S.C47.Rsp(StopMoveStep)

After 10 seconds, TH sends _StopMoveStep command_ to DUT.

Verify DUT responds with a successful (value 0x00) status response.

2d

CC.S.A0000(CurrentHue)

TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has the expected value
250 (200 + 10*5).

2e

CC.S.A0000(CurrentHue)

After another 2 seconds, TH reads _CurrentHue attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentHue attribute has stabilized at the
expected value 250.

MoveSaturation (up) ; start at 150 with 5 units/s and stopping after 10s
(so increases by 50 units per 10s)

3a

CC.S.C03.Rsp(MoveToSaturation)

TH sends _MoveToSaturation command_ to DUT with __Saturation__=150 and
__TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

3b

CC.S.C04.Rsp(MoveSaturation)

TH sends _MoveSaturation command_ to DUT with __MoveMode__=0x01 (up) and
__Rate__=5 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

3c

CC.S.C47.Rsp(StopMoveStep)

After 10 seconds, TH sends _StopMoveStep command_ to DUT.

Verify DUT responds with a successful (value 0x00) status response.

3d

CC.S.A0001(CurrentSaturation)

TH reads _CurrentSaturation attribute_ from DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has the expected
value 200 (150 + 10*5).

3e

CC.S.A0001(CurrentSaturation)

After another 2 seconds, TH reads _CurrentSaturation attribute_ from
DUT.

Value has to be between a range of 0x00 to 0xfe; Verify that the DUT
response indicates that the CurrentSaturation attribute has stabilized
at the expected value 200.

MoveColorTemperature (up) starting midway between min/max; use a rate
that will take (about) 20s to get to max; stop after 10s

4a

CC.S.A400b(ColorTempPhysicalMinMireds)

TH reads _ColorTempPhysicalMinMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

4b

CC.S.A400c(ColorTempPhysicalMaxMireds)

TH reads _ColorTempPhysicalMaxMireds attribute_ from DUT.

Value has to be between a range of 0 to 0xfeff.

4c

CC.S.C0a.Rsp(MoveToColorTemperature)

TH sends _MoveToColorTemperature command_ to DUT with
__ColorTemperatureMireds__=(_ColorTempPhysicalMinMireds_ +
_ColorTempPhysicalMaxMireds_)/2 and __TransitionTime__=0 (immediately).

Verify DUT responds with a successful (value 0x00) status response.

4d

CC.S.C4b.Rsp(MoveColorTemperature)

TH sends _MoveColorTemperature command_ to DUT with _MoveMode_ = 0x01
(up), _Rate_ = (_ColorTempPhysicalMaxMireds_ -
_ColorTempPhysicalMinMireds_)/40

Verify DUT responds with a successful (value 0x00) status response.

4e

CC.S.C47.Rsp(StopMoveStep)

After 10 seconds, TH sends _StopMoveStep command_ to DUT.

Verify DUT responds with a successful (value 0x00) status response.

4f

CC.S.A0007(ColorTemperatureMireds)

TH reads _ColorTemperatureMireds attribute_ from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Expected value =
(_ColorTempPhysicalMinMireds_ + _ColorTempPhysicalMaxMireds_)/2 +
10*(_ColorTempPhysicalMaxMireds_ - _ColorTempPhysicalMinMireds_)/40 =
3/4 * _ColorTempPhysicalMaxMireds_ + 1/4 * _ColorTempPhysicalMinMireds_
.

4g

CC.S.A0007(ColorTemperatureMireds)

After another 2 seconds, TH reads _ColorTemperatureMireds attribute_
from DUT.

Value has to be between a range of _ColorTempPhysicalMinMireds_ to
_ColorTempPhysicalMaxMireds_; Verify that the DUT response indicates
that the ColorTemperatureMireds attribute has stabilized at the expected
value of 4f.

EnhancedMoveHue (up) ; start at 20000 with 500 units/s and stopping
after every 10s (so increases by 5000 units per 10s)

5a

CC.S.C40.Rsp(EnhancedMoveToHue)

TH sends _EnhancedMoveToHue command_ to DUT with __EnhancedHue__=20000,
__Direction__=0x00 (shortest distance) and __TransitionTime__=0
(immediately).

Verify DUT responds with a successful (value 0x00) status response.

5b

CC.S.C41.Rsp(EnhancedMoveHue)

TH sends _EnhancedMoveHue command_ to DUT with __MoveMode__=0x01 (up)
and __Rate__=500 (units/s)

Verify DUT responds with a successful (value 0x00) status response.

5c

CC.S.C47.Rsp(StopMoveStep)

After 10 seconds, TH sends _StopMoveStep command_ to DUT.

Verify DUT responds with a successful (value 0x00) status response.

5d

CC.S.A4000(EnhancedCurrentHue)

TH reads _EnhancedCurrentHue attribute_ from DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has the
expected value 25000 (20000 + 10*500).

5e

CC.S.A4000(EnhancedCurrentHue)

After another 10 seconds, TH reads _EnhancedCurrentHue attribute_ from
DUT.

Value has to be between a range of 0x0000 to 0xffff; Verify that the DUT
response indicates that the EnhancedCurrentHue attribute has stabilized
at the expected value 25000.

[[_notestesting_considerations_118]]
=== link:#_notestesting_considerations_118[]Notes/Testing Considerations

[[_tc_cc_9_1_colorloopset_validation]]
=== link:#_tc_cc_9_1_colorloopset_validation[]26.3.25. [TC-CC-9.1] ColorLoopSet Validation

[[_category_118]]
==== link:#_category_118[]Category

Functional

[[_purpose_118]]
==== link:#_purpose_118[]Purpose

This test case verifies ColorLoopSet functionality of the Color Control
cluster server.

[[_pics_118]]
==== link:#_pics_118[]PICS

* CC.S

[[_preconditions_57]]
==== link:#_preconditions_57[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F02(CL) and CC.S.F01(EHUE) |
|===

[[_required_devices_118]]
==== link:#_required_devices_118[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_94]]
==== link:#_device_topology_94[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_106]]
==== link:#_test_setup_106[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH

|2 |Set DUT OnOff to On (see step 0b)

|3 |Set DUT _EnhancedCurrentHue_ to 0x4000 using _EnhancedMoveToHue
command_ (see step 0c)
|===

[[_test_procedure_118]]
==== link:#_test_procedure_118[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|0a | |CC.S.A000f(Options) |TH writes 0x00 to the _Options attribute_ |

|0b | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds with a successful (value 0x00) status response.

|0c | |CC.S.C40.Rsp(EnhancedMoveToHue) |TH sends _EnhancedMoveToHue
command_ to DUT with __EnhancedHue__=0x4000, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately). |Verify DUT
responds with a successful (value 0x00) status response.

|1a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|1b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|2a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x2_ (UpdateDirection) and _Direction
attribute_ to _0x0_ (decrement hue) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|2b | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x0_. Color Loop Direction is set to
down.

|3a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x4_ (UpdateTime) and _Time attribute_
to _30_ (30s for one loop) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|3b | |CC.S.A4004(ColorLoopTime) |TH read _ColorLoopTime attribute_ from
DUT. |Value is 30. Color Loop Time is set to 30 seconds.

|4a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x8_ (UpdateStartHue) and _StartHue
attribute_ to _0x00A0_ to DUT. |Verify DUT responds with a successful
(value 0x00) status response.

|4b | |CC.S.A4005(ColorLoopStartEnhancedHue) |TH read
_ColorLoopStartEnhancedHue attribute_ from DUT. |Value is _0x00A0_.
ColorLoopStartEnhancedHue is set to 0x00A0.

|5a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x1_ (start from ColorLoopStartEnhancedHue) to DUT.
|Verify DUT responds with a successful (value 0x00) status response.

|5b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x1_. Color Loop is activated.

|5c | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH read
_ColorLoopStoredEnhancedHue attribute_ from DUT. |Value is the same as
_EnhancedCurrentHue attribute (0x4000)_ set in step 0c.

|5d | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, at 5 second
intervals, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should decrease and wraparound and continue from
max allowed EnhancedHue (0xffff) if reaching 0. After 30 sec, it should
return to _ColorLoopStartEnhancedHue_ (the starting point).

|5e | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, at 5
second intervals, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|6a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|6b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|6c | |CC.S.A4000(EnhancedCurrentHue) |TH read _EnhancedCurrentHue
attribute_ from DUT. |Value is set to _ColorLoopStoredEnhancedHue_.

|7a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x2_ (UpdateDirection) and _Direction
attribute_ to _0x1_ (increment hue) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|7b | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x1_. Color Loop Direction is set to up.

|8a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x1_ (start from ColorLoopStartEnhancedHue) to DUT.
|Verify DUT responds with a successful (value 0x00) status response.

|8b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x1_. Color Loop is activated using
_ColorLoopStartEnhancedHue_.

|8c | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH read
_ColorLoopStoredEnhancedHue attribute_ from DUT. |Value is the same as
_EnhancedCurrentHue attribute (0x4000)_ set in step 0c.

|8d | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, TH read
_EnhancedCurrentHue attribute_ from DUT. |_EnhancedCurrentHue_ should
increase and wraparound and continue from 0 if reach max allowed
EnhancedHue (0xffff). After 30 sec, it should return to
_ColorLoopStartEnhancedHue_ (the starting point).

|8e | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, TH
read _EnhancedCurrentHue attribute_ from DUT. |_EnhancedCurrentHue_
continues the Loop as in Step above.

|9a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|9b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|9c | |CC.S.A4000(EnhancedCurrentHue) |TH read _EnhancedCurrentHue
attribute_ from DUT. |Value is set to _ColorLoopStoredEnhancedHue_.

|10a | |CC.S.C40.Rsp(EnhancedMoveToHue) |TH sends _EnhancedMoveToHue
command_ to DUT with __EnhancedHue__=0x4000, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately). |Verify DUT
responds with a successful (value 0x00) status response.

|10b | |CC.S.A4000(EnhancedCurrentHue) |TH reads _EnhancedCurrentHue
attribute_ from DUT. |Value is _0x4000_.

|11a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x2_ (UpdateDirection) and _Direction
attribute_ to _0x0_ (decrement hue) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|11b | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x0_. Color Loop Direction is set to
down.

|12a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x2_ (start from EnhancedCurrentHue) to DUT. |Verify DUT
responds with a successful (value 0x00) status response.

|12b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x1_. Color Loop is activated using
_EnhancedCurrentHue_.

|12c | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH read
_ColorLoopStoredEnhancedHue attribute_ from DUT. |Value is the same as
_EnhancedCurrentHue attribute (0x4000)_ set in step 0c.

|12d | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should decrease and wraparound and continue from
max allowed EnhancedHue (0xffff) if reaching 0. After 30 sec, it should
return to _ColorLoopStartEnhancedHue_.

|12e | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, at
5 seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|13a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|13b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|13c | |CC.S.A4000(EnhancedCurrentHue) |TH read _EnhancedCurrentHue
attribute_ from DUT. |Value is set to _ColorLoopStoredEnhancedHue_.

|14a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x2_ (UpdateDirection) and _Direction
attribute_ to _0x1_ (increment hue) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|14b | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x1_. Color Loop Direction is set to up.

|15a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x2_ (start from EnhancedCurrentHue) to DUT. |Verify DUT
responds with a successful (value 0x00) status response.

|15b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x1_. Color Loop is activated using
_EnhancedCurrentHue_.

|15c | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH read
_ColorLoopStoredEnhancedHue attribute_ from DUT. |Value is the same as
_EnhancedCurrentHue attribute (0x4000)_ set in step 0c.

|15d | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should increase and wraparound and continue from 0
if reach max allowed EnhancedHue (0xffff). After 30 sec, it should
return to _ColorLoopStartEnhancedHue_.

|15e | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, at
5 seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|16a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|16b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_.

|16C | |CC.S.A4000(EnhancedCurrentHue) |TH read _EnhancedCurrentHue
attribute_ from DUT. |Value is set to _ColorLoopStoredEnhancedHue_.
|===

[[_notestesting_considerations_119]]
==== link:#_notestesting_considerations_119[]Notes/Testing Considerations

[[_tc_cc_9_2_colorloopset_validation_change_direction_without_stop]]
=== link:#_tc_cc_9_2_colorloopset_validation_change_direction_without_stop[]26.3.26. [TC-CC-9.2] ColorLoopSet Validation - change Direction without Stop

[[_category_119]]
==== link:#_category_119[]Category

Functional

[[_purpose_119]]
==== link:#_purpose_119[]Purpose

This test case verifies ColorLoopSet functionality of the Color Control
cluster server changes Direction without Stop.

[[_pics_119]]
==== link:#_pics_119[]PICS

* CC.S

[[_preconditions_58]]
==== link:#_preconditions_58[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F02(CL) and CC.S.F01(EHUE) |
|===

[[_required_devices_119]]
==== link:#_required_devices_119[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_95]]
==== link:#_device_topology_95[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_107]]
==== link:#_test_setup_107[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH

|2 |Set DUT OnOff to On (see step 0b)

|3 |Set DUT _EnhancedCurrentHue_ to 0x4000 using _EnhancedMoveToHue
command_ (see step 0c)
|===

[[_test_procedure_119]]
==== link:#_test_procedure_119[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|0a | |CC.S.A000f(Options) |TH writes 0x00 to the _Options attribute_ |

|0b | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds with a successful (value 0x00) status response.

|0c | |CC.S.C40.Rsp(EnhancedMoveToHue) |TH sends _EnhancedMoveToHue
command_ to DUT with __EnhancedHue__=0x4000, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately). |Verify DUT
responds with a successful (value 0x00) status response.

|1a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0xF_, _Action attribute_ to _0x0_
(De-activate), _Direction attribute_ to _0x0_ (decrement hue), _Time
attribute_ to _30_, and _StartHue attribute_ to _0x00A0_ to DUT. |Verify
DUT responds with a successful (value 0x00) status response.

|1b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|1c | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x0_. Color Loop Direction is set to
down.

|1d | |CC.S.A4004(ColorLoopTime) |TH read _ColorLoopTime attribute_ from
DUT. |Value is 30. Color Loop Time is set to 30 seconds.

|1e | |CC.S.A4005(ColorLoopStartEnhancedHue) |TH read
_ColorLoopStartEnhancedHue attribute_ from DUT. |Value is _0x00A0_.
Color Loop Start Enhanced Hue is set to 0xA0.

|2a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x1_ (start from ColorLoopStartEnhancedHue) to DUT.
|Verify DUT responds with a successful (value 0x00) status response.

|2b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x1_. Color Loop is activated using
_ColorLoopStartEnhancedHue_.

|2c | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH read
_ColorLoopStoredEnhancedHue attribute_ from DUT. |Value is the same as
_EnhancedCurrentHue attribute (0x4000)_ set in step 0c.

|2d | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should decrease and wraparound and continue from
max allowed EnhancedHue (0xffff) if reaching 0. After 30 sec, it should
return to _ColorLoopStartEnhancedHue_.

|2e | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|3a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x2_ (UpdateDirection) and _Direction
attribute_ to _0x1_ (increment hue) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|3b | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x1_. Color Loop Direction is set to up.

|3c | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should increase and wraparound and continue from 0
if reach max allowed EnhancedHue (0xffff). After 30 sec, it should
return to _ColorLoopStartEnhancedHue_.

|3d | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|4a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|4b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|4c | |CC.S.A4000(EnhancedCurrentHue) |TH read _EnhancedCurrentHue
attribute_ from DUT. |Value is set to _ColorLoopStoredEnhancedHue_.
|===

[[_notestesting_considerations_120]]
==== link:#_notestesting_considerations_120[]Notes/Testing Considerations

[[_tc_cc_9_3_colorloopset_validation_change_time_without_stop]]
=== link:#_tc_cc_9_3_colorloopset_validation_change_time_without_stop[]26.3.27. [TC-CC-9.3] ColorLoopSet Validation - change Time without Stop

[[_category_120]]
==== link:#_category_120[]Category

Functional

[[_purpose_120]]
==== link:#_purpose_120[]Purpose

This test case verifies ColorLoopSet functionality of the Color Control
cluster server changes Time without Stop.

[[_pics_120]]
==== link:#_pics_120[]PICS

* CC.S

[[_preconditions_59]]
==== link:#_preconditions_59[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.S.F02(CL) and CC.S.F01(EHUE) |
|===

[[_required_devices_120]]
==== link:#_required_devices_120[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_96]]
==== link:#_device_topology_96[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_108]]
==== link:#_test_setup_108[]Test Setup

* For all commands used in this test, use fields OptionsMask=0x00 and
OptionsOverride=0x00.

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH

|2 |Set DUT OnOff to On (see step 0b)

|3 |Set DUT _EnhancedCurrentHue_ to 0x4000 using _EnhancedMoveToHue
command_ (see step 0c)
|===

[[_test_procedure_120]]
==== link:#_test_procedure_120[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|0a | |CC.S.A000f(Options) |TH writes 0x00 to the _Options attribute_ |

|0b | |OO.S.C01.Rsp(On) |TH sends _On command_ to DUT |Verify DUT
responds with a successful (value 0x00) status response.

|0c | |CC.S.C40.Rsp(EnhancedMoveToHue) |TH sends _EnhancedMoveToHue
command_ to DUT with __EnhancedHue__=0x4000, __Direction__=0x00
(shortest distance) and __TransitionTime__=0 (immediately). |Verify DUT
responds with a successful (value 0x00) status response.

|1a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0xF_, _Action attribute_ to _0x0_
(De-activate), _Direction attribute_ to _0x0_ (decrement hue), _Time
attribute_ to _30_, and _StartHue attribute_ to _0x00A0_ to DUT. |Verify
DUT responds with a successful (value 0x00) status response.

|1b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|1c | |CC.S.A4003(ColorLoopDirection) |TH read _ColorLoopDirection
attribute_ from DUT. |Value is _0x0_. Color Loop Direction is set to
down.

|1d | |CC.S.A4004(ColorLoopTime) |TH read _ColorLoopTime attribute_ from
DUT. |Value is 30. Color Loop Time is set to 30 seconds.

|1e | |CC.S.A4005(ColorLoopStartEnhancedHue) |TH read
_ColorLoopStartEnhancedHue attribute_ from DUT. |Value is _0x00A0_.
Color Loop Start Enhanced Hue is set to 0xA0.

|2a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x1_ (start from ColorLoopStartEnhancedHue) to DUT.
|Verify DUT responds with a successful (value 0x00) status response.

|2b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x1_. Color Loop is activated using
_ColorLoopStartEnhancedHue_.

|2c | |CC.S.A4006(ColorLoopStoredEnhancedHue) |TH read
_ColorLoopStoredEnhancedHue attribute_ from DUT. |Value is the same as
_EnhancedCurrentHue attribute (0x4000)_ set in step 0c.

|2d | |CC.S.A4000(EnhancedCurrentHue) |Over next 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should decrease and wraparound and continue from
max allowed EnhancedHue (0xffff) if reaching 0. After 30 sec, it should
return to _ColorLoopStartEnhancedHue_.

|2e | |CC.S.A4000(EnhancedCurrentHue) |Continue another 30 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|3a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x4_ and _Time attribute_ to _60_ to
DUT. |Verify DUT responds with a successful (value 0x00) status
response.

|3b | |CC.S.A4004(ColorLoopTime) |TH read _ColorLoopTime attribute_ from
DUT. |Value is 60. Color Loop Time is set to 60 seconds.

|3c | |CC.S.A4000(EnhancedCurrentHue) |Over next 60 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ should decrease and wraparound and continue from
max allowed EnhancedHue (0xffff) if reaching 0 and complete the Loop in
60 sec.

|3d | |CC.S.A4000(EnhancedCurrentHue) |Continue another 60 seconds, at 5
seconds interval, TH read _EnhancedCurrentHue attribute_ from DUT.
|_EnhancedCurrentHue_ continues the Loop as in Step above.

|4a | |CC.S.C44.Rsp(ColorLoopSet) |TH sends _ColorLoopSet command_ to
with _UpdateFlag attribute_ to _0x1_ (UpdateAction) and _Action
attribute_ to _0x0_ (De-activate) to DUT. |Verify DUT responds with a
successful (value 0x00) status response.

|4b | |CC.S.A4002(ColorLoopActive) |TH read _ColorLoopActive attribute_
from DUT. |Value is _0x0_. Color Loop is deactivated.

|4c | |CC.S.A4000(EnhancedCurrentHue) |TH read _EnhancedCurrentHue
attribute_ from DUT. |Value is set to _ColorLoopStoredEnhancedHue_.
|===

[[_notestesting_considerations_121]]
==== link:#_notestesting_considerations_121[]Notes/Testing Considerations

[[_tc_cc_9_4_colorloopset_validation_with_client_as_dut]]
=== link:#_tc_cc_9_4_colorloopset_validation_with_client_as_dut[]26.3.28. [TC-CC-9.4] ColorLoopSet Validation with client as DUT

[[_category_121]]
==== link:#_category_121[]Category

Functional

[[_purpose_121]]
==== link:#_purpose_121[]Purpose

This test case verifies ColorLoopSet functionality of the Color Control
cluster client.

[[_pics_121]]
==== link:#_pics_121[]PICS

* CC.C

[[_preconditions_60]]
==== link:#_preconditions_60[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports CC.C.F02(CL) and CC.C.F01(EHUE) |
|===

[[_required_devices_121]]
==== link:#_required_devices_121[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_97]]
==== link:#_device_topology_97[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_109]]
==== link:#_test_setup_109[]Test Setup

[width="100%",cols="5%,95%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission TH to DUT
|2 |Set TH OnOff to On
|===

[[_test_procedure_121]]
==== link:#_test_procedure_121[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

During this test, the DUT will send the ColorLoopSet command with
various field values (as supported by DUT) as in step 1, and may read
attributes as in steps 2a-e. TH shall simulate the ColorLoop feature and
provide attribute values fitting with the command(s) received. The order
of the commands and attribute reads may vary under DUT control, TH shall
adapt.

1

CC.C.C44.Tx(ColorLoopSet)

DUT sends _ColorLoopSet command_ to TH.

TH receives InvokeRequestMessage with CommandID 0x44 CommandFields
matches _ColorLoopSet command_ parameters; Verify that the TH response
contains with a successful (value 0x00) status response.

2a

CC.C.A4002(ColorLoopActive)

DUT read _ColorLoopActive attribute_ from TH.

TH receives read request from Cluster 0x300 Attribute 0x0000_4002;
Verify that the TH response contains with a successful (value 0x00)
status response.

2b

CC.C.A4003(ColorLoopDirection)

DUT read _ColorLoopDirection attribute_ from TH.

TH receives read request from Cluster 0x300 Attribute 0x0000_4003;
Verify that the TH response contains with a successful (value 0x00)
status response.

2c

CC.C.A4004(ColorLoopTime)

DUT read _ColorLoopTime attribute_ from TH.

TH receives read request from Cluster 0x300 Attribute 0x0000_4004;
Verify that the TH response contains with a successful (value 0x00)
status response.

2d

CC.C.A4005(ColorLoopStartEnhancedHue)

DUT read _ColorLoopStartEnhancedHue attribute_ from TH.

TH receives read request from Cluster 0x300 Attribute 0x0000_4005;
Verify that the TH response contains with a successful (value 0x00)
status response.

2e

CC.C.A4000(EnhancedCurrentHue)

Over next 30 seconds, at 5 seconds interval, DUT read
_EnhancedCurrentHue attribute_ from TH.

TH receives read request from Cluster 0x300 Attribute 0x0000_4000;
Verify that the TH response contains with a successful (value 0x00)
status response.

[[_notestesting_considerations_122]]
=== link:#_notestesting_considerations_122[]Notes/Testing Considerations

'''''

[[_occupancy_sensing_cluster_test_plan]]
== link:#_occupancy_sensing_cluster_test_plan[]**Occupancy Sensing Cluster Test Plan**

[[_pics_definition_9]]
=== link:#_pics_definition_9[]27. PICS Definition

This section covers the Occupancy Sensing Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_9]]
==== link:#_role_9[]27.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OCC.S |Does the device implement the Occupancy Sensing cluster as a
server? |Optional |

|OCC.C |Does the device implement the Occupancy Sensing cluster as a
client? |Optional |
|===

[[_server_9]]
==== link:#_server_9[]27.2. Server

[[_attributes_10]]
===== link:#_attributes_10[]27.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OCC.S.A0000(Occupancy) |Does the device implement the Occupancy
attribute? |OCC.S: Mandatory |

|OCC.S.A0001(OccupancySensorType) |Does the device implement the
OccupancySensorType attribute? |OCC.S: Mandatory |

|OCC.S.A0002(OccupancySensorTypeBitmap) |Does the device implement the
OccupancySensorTypeBitmap attribute? |OCC.S: Mandatory |

|OCC.S.A0010(PIROccupiedToUnoccupiedDelay) |Does the device implement
the PIROccupiedToUnoccupiedDelay attribute? |OCC.S: Optional |

|OCC.S.A0011(PIRUnoccupiedToOccupiedDelay) |Does the device implement
the PIRUnoccupiedToOccupiedDelay attribute? |OCC.S: Optional |

|OCC.S.A0012(PIRUnoccupiedToOccupiedThreshold) |Does the device
implement the PIRUnoccupiedToOccupiedThreshold attribute? |OCC.S:
Optional |

|OCC.S.A0020(UltrasonicOccupiedToUnoccupiedDelay) |Does the device
implement the UltrasonicOccupiedToUnoccupiedDelay attribute? |OCC.S:
Optional |

|OCC.S.A0021(UltrasonicUnoccupiedToOccupiedDelay) |Does the device
implement the UltrasonicUnoccupiedToOccupiedDelay attribute? |OCC.S:
Optional |

|OCC.S.A0022(UltrasonicUnoccupiedToOccupiedThreshold) |Does the device
implement the UltrasonicUnoccupiedToOccupiedThreshold attribute? |OCC.S:
Optional |

|OCC.S.A0030(PhysicalContactOccupiedToUnoccupiedDelay) |Does the device
implement the PhysicalContactOccupiedToUnoccupiedDelay attribute?
|OCC.S: Optional |

|OCC.S.A0031(PhysicalContactUnoccupiedToOccupiedDelay) |Does the device
implement the PhysicalContactUnoccupiedToOccupiedDelay attribute?
|OCC.S: Optional |

|OCC.S.A0032(PhysicalContactUnoccupiedToOccupiedThreshold) |Does the
device implement the PhysicalContactUnoccupiedToOccupiedThreshold
attribute? |OCC.S: Optional |
|===

[[_manual_controllable_6]]
===== link:#_manual_controllable_6[]27.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OCC.M.OccupancyChange |Can the Occupancy attribute changed by physical
control at the device? |OCC.S: Optional |
|===

[[_client_4]]
==== link:#_client_4[]27.3. Client

[[_attributes_11]]
===== link:#_attributes_11[]27.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OCC.C.A0000(Occupancy) |Does the device implement the Occupancy
attribute? |O |

|OCC.C.A0001(OccupancySensorType) |Does the device implement the
OccupancySensorType attribute? |O |

|OCC.C.A0002(OccupancySensorTypeBitmap) |Does the device implement the
OccupancySensorTypeBitmap attribute? |O |

|OCC.C.A0010(PIROccupiedToUnoccupiedDelay) |Does the device implement
the PIROccupiedToUnoccupiedDelay attribute? |O |

|OCC.C.A0011(PIRUnoccupiedToOccupiedDelay) |Does the device implement
the PIRUnoccupiedToOccupiedDelay attribute? |O |

|OCC.C.A0012(PIRUnoccupiedToOccupiedThreshold) |Does the device
implement the PIRUnoccupiedToOccupiedThreshold attribute? |O |

|OCC.C.A0020(UltrasonicOccupiedToUnoccupiedDelay) |Does the device
implement the UltrasonicOccupiedToUnoccupiedDelay attribute? |O |

|OCC.C.A0021(UltrasonicUnoccupiedToOccupiedDelay) |Does the device
implement the UltrasonicUnoccupiedToOccupiedDelay attribute? |O |

|OCC.C.A0022(UltrasonicUnoccupiedToOccupiedThreshold) |Does the device
implement the UltrasonicUnoccupiedToOccupiedThreshold attribute? |O |

|OCC.C.A0030(PhysicalContactOccupiedToUnoccupiedDelay) |Does the device
implement the PhysicalContactOccupiedToUnoccupiedDelay attribute? |O |

|OCC.C.A0031(PhysicalContactUnoccupiedToOccupiedDelay) |Does the device
implement the PhysicalContactUnoccupiedToOccupiedDelay attribute? |O |

|OCC.C.A0032(PhysicalContactUnoccupiedToOccupiedThreshold) |Does the
device implement the PhysicalContactUnoccupiedToOccupiedThreshold
attribute? |O |
|===

[[_test_case_list_9]]
=== link:#_test_case_list_9[]28. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-OCC-1.1 |Global attributes with server as DUT

|TC-OCC-2.1 |Attributes with server as DUT

|TC-OCC-2.3 |OccupancySensorTypeBitmap and OccupancySensorType
interdependency with server as DUT

|TC-OCC-2.4 |OccupancySensorTypeBitmap and OccupancySensorType
interdependency with client as DUT

|TC-OCC-3.1 |Primary functionality with server as DUT
|===

[[_test_cases_9]]
=== link:#_test_cases_9[]29. Test Cases

'''''

[[_global_attributes_2]]
==== link:#_global_attributes_2[]29.1. Global Attributes

'''''

[[_tc_occ_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_occ_1_1_global_attributes_with_server_as_dut[]29.1.1. [TC-OCC-1.1] Global attributes with server as DUT

[[_category_122]]
====== link:#_category_122[]Category

Functional conformance

[[_purpose_122]]
====== link:#_purpose_122[]Purpose

This test case verifies the Occupancy Sensing Global attributes

[[_pics_122]]
====== link:#_pics_122[]PICS

* OCC.S

[[_required_devices_122]]
====== link:#_required_devices_122[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as client
|2 |DUT |DUT as server
|===

[[_test_procedure_122]]
====== link:#_test_procedure_122[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | | |TH reads from the DUT the (0xFFFD) _ClusterRevision attribute_
|Verify that the DUT response contains a minimal revision of 3

|3 | | |TH reads from the DUT the (0xFFFC) _FeatureMap attribute_
|Verify that the DUT response contains valid feature map of 0

|4 | | |TH reads from the DUT the (0xFFFB) _AttributeList attribute_ a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support:

- (0) Occupancy (mandatory)

- (1) OccupancySensorType (mandatory)

- (2) OccupancySensorTypeBitmap (mandatory)

- It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

- for operational attributes see PICS

|5 | | |TH reads from the DUT the (0xFFFA) _EventList attribute_ |Verify
that the DUT response contains a list of supported events empty for this
cluster.

|6 | | |TH reads from the DUT the (0xFFF9) _AcceptedCommandList
attribute_ |Verify that the DUT response contains a list of Accepted
commands empty for this cluster.

|7 | | |TH reads from the DUT the (0xFFF8) _GeneratedCommandList
attribute_ |Verify that the DUT response contains a list of Generated
commands empty for this cluster.
|===

[[_notestesting_considerations_123]]
====== link:#_notestesting_considerations_123[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK. e3f621c5e on April 22 '''

[[_cluster_attributes_2]]
==== link:#_cluster_attributes_2[]29.2. Cluster Attributes

'''''

[[_tc_occ_2_1_attributes_with_server_as_dut]]
===== link:#_tc_occ_2_1_attributes_with_server_as_dut[]29.2.1. [TC-OCC-2.1] Attributes with server as DUT

[[_category_123]]
====== link:#_category_123[]Category

Functional conformance

[[_purpose_123]]
====== link:#_purpose_123[]Purpose

This test case verifies the Occupancy Sensing Cluster attributes with
server as DUT

[[_pics_123]]
====== link:#_pics_123[]PICS

* OCC.S

[[_required_devices_123]]
====== link:#_required_devices_123[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as client
|2 |DUT |DUT as server
|===

[[_test_procedure_123]]
====== link:#_test_procedure_123[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |OCC.S.A0000(Occupancy) |TH reads from the DUT the (0x0000)
_Occupancy attribute_ a|
Verify that the DUT response contains a bitmap8:

1 = occupied

0 = unoccupied.

|3 | |OCC.S.A0001(OccupancySensorType) |TH reads from the DUT the
(0x0001) _OccupancySensorType attribute_ a|
Verify that the DUT response contains a enum8:

0 = PIR

1 = Ultrasonic

2 = PIR and ultrasonic

3 = physical contact

|4 | |OCC.S.A0002(OccupancySensorTypeBitmap) |TH reads from the DUT the
(0x0002) _OccupancySensorTypeBitmap attribute_ a|
Verify that the DUT response contains a bitmap8:

PIR - 0000 0001

Ultrasonic - 0000 0010

PIR and ultrasonic - 0000 0011

Physical contact and PIR - 0000 0101

Physical contact and ultrasonic - 0000 0110

Physical contact and PIR and ultrasonic - 0000 0111

|5 | |OCC.S.A0010(PIROccupiedToUnoccupiedDelay) |TH reads from the DUT
the (0x0010) _PIROccupiedToUnoccupiedDelay optional attribute_, if PIR
sensor |Verify that the DUT response contains a uint16

|6 | |OCC.S.A0011(PIRUnoccupiedToOccupiedDelay) |TH reads from the DUT
the (0x0011) _PIRUnoccupiedToOccupiedDelay optional attribute_, if PIR
sensor |Verify that the DUT response contains a uint16

|7 | |OCC.S.A0012(PIRUnoccupiedToOccupiedThreshold) |TH reads from the
DUT the (0x0012) _PIRUnoccupiedToOccupiedThreshold optional attribute_,
if PIR sensor |Verify that the DUT response contains a uint8 [min:1
max:254]

|8 | |OCC.S.A0020(UltrasonicOccupiedToUnoccupiedDelay) |TH reads from
the DUT the (0x0020) _UltrasonicOccupiedToUnoccupiedDelay optional
attribute_, if ultrasonic sensor |Verify that the DUT response contains
a uint16

|9 | |OCC.S.A0021(UltrasonicUnoccupiedToOccupiedDelay) |TH reads from
the DUT the (0x0021) _UltrasonicUnoccupiedToOccupiedDelay optional
attribute_, if ultrasonic sensor |Verify that the DUT response contains
a uint16

|10 | |OCC.S.A0022(UltrasonicUnoccupiedToOccupiedThreshold) |TH reads
from the DUT the (0x0022) _UltrasonicUnoccupiedToOccupiedThreshold
optional attribute_, if ultrasonic sensor |Verify that the DUT response
contains a uint8 [min:1 max:254]

|11 | |OCC.S.A0030(PhysicalContactOccupiedToUnoccupiedDelay) |TH reads
from the DUT the (0x0030) _PhysicalContactOccupiedToUnoccupiedDelay
optional attribute_, if Physical Contact sensor |Verify that the DUT
response contains a uint16

|12 | |OCC.S.A0031(PhysicalContactUnoccupiedToOccupiedDelay) |TH reads
from the DUT the (0x0031) _PhysicalContactUnoccupiedToOccupiedDelay
optional attribute_, if Physical Contact sensor |Verify that the DUT
response contains a uint16

|13 | |OCC.S.A0032(PhysicalContactUnoccupiedToOccupiedThreshold) |TH
reads from the DUT the (0x0032)
_PhysicalContactUnoccupiedToOccupiedThreshold optional attribute_, if
Physical Contact sensor |Verify that the DUT response contains a uint8
[min:1 max:254]
|===

[[_notestesting_considerations_124]]
====== link:#_notestesting_considerations_124[]Notes/Testing Considerations

e3f621c5e on April 22 Test Steps #5 to #13 cannot be executed with V1.0
SDK

'''''

[[_functional_tests]]
==== link:#_functional_tests[]29.3. Functional Tests

'''''

[[_tc_occ_2_3_occupancysensortypebitmap_and_occupancysensortype_interdependency_with_server_as_dut]]
===== link:#_tc_occ_2_3_occupancysensortypebitmap_and_occupancysensortype_interdependency_with_server_as_dut[]29.3.1. [TC-OCC-2.3] OccupancySensorTypeBitmap and OccupancySensorType interdependency with server as DUT

[[_category_124]]
====== link:#_category_124[]Category

Functional

[[_purpose_124]]
====== link:#_purpose_124[]Purpose

This test case verifies the OccupancySensorTypeBitmap and
OccupancySensorType interdependency of the Occupancy Sensing cluster
server.

[[_pics_124]]
====== link:#_pics_124[]PICS

* OCC.S

[[_required_devices_124]]
====== link:#_required_devices_124[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_98]]
====== link:#_device_topology_98[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_110]]
====== link:#_test_setup_110[]Test Setup

Commission DUT to TH

[[_test_procedure_124]]
====== link:#_test_procedure_124[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |OCC.S.A0001(OccupancySensorType) |TH reads _OccupancySensorType
attribute_ from DUT |Verify _OccupancySensorType_ is set to one of the
non-reserved values: 0-PIR, 1-Ultrasonic, 2-PIR and ultrasonic, and
3-Physical contact.

|3 | |OCC.S.A0002(OccupancySensorTypeBitmap) |TH reads
_OccupancySensorTypeBitmap attribute_ from DUT |Verify the value of
_OccupancySensorTypeBitmap_ and _OccupancySensorType_ are aligned
|===

[[_notestesting_considerations_125]]
====== link:#_notestesting_considerations_125[]Notes/Testing Considerations

2130b3610 on Nov 26

[[_tc_occ_2_4_occupancysensortypebitmap_and_occupancysensortype_interdependency_with_client_as_dut]]
===== link:#_tc_occ_2_4_occupancysensortypebitmap_and_occupancysensortype_interdependency_with_client_as_dut[]29.3.2. [TC-OCC-2.4] OccupancySensorTypeBitmap and OccupancySensorType interdependency with client as DUT

[[_category_125]]
====== link:#_category_125[]Category

Functional

[[_purpose_125]]
====== link:#_purpose_125[]Purpose

This test case verifies the OccupancySensorTypeBitmap and
OccupancySensorType interdependency of the Occupancy Sensing cluster
server.

[[_pics_125]]
====== link:#_pics_125[]PICS

* OCC.C

[[_required_devices_125]]
====== link:#_required_devices_125[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_99]]
====== link:#_device_topology_99[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_111]]
====== link:#_test_setup_111[]Test Setup

Commission DUT to TH

[[_test_procedure_125]]
====== link:#_test_procedure_125[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission TH to DUT |

|2 | |OCC.C.A0001(OccupancySensorType) |DUT reads _OccupancySensorType
attribute_ from TH a|
Verify TH receives ReadRequestMessage of

Endpoint = 0x1

Cluster = 0x406

Attribute = 0x0000_0001

|3 | |OCC.C.A0002(OccupancySensorTypeBitmap) |DUT reads
_OccupancySensorTypeBitmap attribute_ from TH a|
Verify TH receives ReadRequestMessage of

Endpoint = 0x1

Cluster = 0x406

Attribute = 0x0000_0002

|===

[[_notestesting_considerations_126]]
====== link:#_notestesting_considerations_126[]Notes/Testing Considerations

0c965a656 on Feb 14

[[_tc_occ_3_1_primary_functionality_with_server_as_dut]]
===== link:#_tc_occ_3_1_primary_functionality_with_server_as_dut[]29.3.3. [TC-OCC-3.1] Primary functionality with server as DUT

[[_category_126]]
====== link:#_category_126[]Category

Functional

[[_purpose_126]]
====== link:#_purpose_126[]Purpose

This test case verifies the primary functionality of the Occupancy
Sensing cluster server.

[[_pics_126]]
====== link:#_pics_126[]PICS

* OCC.S

[[_required_devices_126]]
====== link:#_required_devices_126[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_100]]
====== link:#_device_topology_100[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_112]]
====== link:#_test_setup_112[]Test Setup

Commission DUT to TH

[[_test_procedure_126]]
====== link:#_test_procedure_126[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |OCC.S.A0000(Occupancy) |TH reads _Occupancy attribute_ from DUT
|Verify the read is successful and value reads 0 = unoccupied, 1 =
occupied

|3 | |OCC.M.OccupancyChange |Operate on DUT to change the occupancy
status |

|4 | |OCC.S.A0000(Occupancy) |after a few seconds, TH reads _Occupancy
attribute_ from DUT |Value read has to be different from status in step
2
|===

[[_notestesting_considerations_127]]
====== link:#_notestesting_considerations_127[]Notes/Testing Considerations

708ad6f1 on July 14

'''''

[[_flow_measurement_cluster_test_plan]]
== link:#_flow_measurement_cluster_test_plan[]**Flow Measurement Cluster Test Plan**

[[_pics_definition_10]]
=== link:#_pics_definition_10[]30. PICS Definition

This section covers the Flow Measurement Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_10]]
==== link:#_role_10[]30.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLW.S |Does the device implement the Flow Measurement cluster as a
server? |O |
|===

[[_server_10]]
==== link:#_server_10[]30.2. Server

[[_attributes_12]]
===== link:#_attributes_12[]30.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLW.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |M |

|FLW.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |M |

|FLW.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |M |

|FLW.S.A0003(Tolerance) |Does the device implement the _Tolerance_
attribute? |O |
|===

[[_manual_controllable_7]]
===== link:#_manual_controllable_7[]30.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLW.M.FlowChange |Can the _MeasuredValue_ attribute changed by physical
control at the device? |O |
|===

[[_test_case_list_10]]
=== link:#_test_case_list_10[]31. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-FLW-1.1 |Global Attributes with DUT as Server
|TC-FLW-2.1 |Attributes with Server as DUT
|TC-FLW-2.2 |Primary Functionality with Server as DUT
|===

[[_test_cases_10]]
=== link:#_test_cases_10[]32. Test Cases

'''''

[[_generic_test_cases_7]]
==== link:#_generic_test_cases_7[]32.1. Generic Test Cases

'''''

[[_tc_flw_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_flw_1_1_global_attributes_with_dut_as_server[]32.1.1. [TC-FLW-1.1] Global Attributes with DUT as Server

[[_category_127]]
====== link:#_category_127[]Category

Functional conformance.

[[_purpose_127]]
====== link:#_purpose_127[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_127]]
====== link:#_pics_127[]PICS

* FLW.S

[[_required_devices_127]]
====== link:#_required_devices_127[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_127]]
====== link:#_test_procedure_127[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0003: SHALL be included if and only if FLW.S.A0003(Tolerance)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_128]]
====== link:#_notestesting_considerations_128[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_dut_as_server_2]]
==== link:#_dut_as_server_2[]32.2. DUT as Server

[[_tc_flw_2_1_attributes_with_server_as_dut]]
===== link:#_tc_flw_2_1_attributes_with_server_as_dut[]32.2.1. [TC-FLW-2.1] Attributes with Server as DUT

[[_category_128]]
====== link:#_category_128[]Category

Functional.

[[_purpose_128]]
====== link:#_purpose_128[]Purpose

This test case verifies the non-global attributes of the Flow
Measurement cluster server.

[[_pics_128]]
====== link:#_pics_128[]PICS

* FLW.S

[[_required_devices_128]]
====== link:#_required_devices_128[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_101]]
====== link:#_device_topology_101[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_113]]
====== link:#_test_setup_113[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_128]]
====== link:#_test_procedure_128[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.5.4.2 |FLW.S.A0001(MinMeasuredValue) |TH reads from the DUT the
_MinMeasuredValue_ attribute. a|
Verify that the DUT response contains either +
null +
or +
a uint16 where +
0 ≤ _MinMeasuredValue_ ≤ 65533. +

Note the value for usage in later steps as FLW~min~. +
If _MinMeasuredValue_ is null note 0.

|3 |AC.2.5.4.3 |FLW.S.A0002(MaxMeasuredValue) |TH reads from the DUT the
_MaxMeasuredValue_ attribute. a|
Verify that the DUT response contains either +
null +
or +
a uint16 where +
FLW~min~ < _MaxMeasuredValue_ ≤ 65534. +

Note the value for usage in later steps as FLW~max~. +
If _MaxMeasuredValue_ is null note 65534.

|4 |AC.2.5.4.1 |FLW.S.A0000(MeasuredValue) |TH reads from the DUT the
_MeasuredValue_ attribute. |Verify that the DUT response contains
either +
null +
or +
a uint16 where +
FLW~min~ ≤ _MeasuredValue_ ≤ FLW~max~.

|5 |AC.2.5.4.4 |FLW.S.A0003(Tolerance) |TH reads from the DUT the
_Tolerance_ attribute. |Verify that the DUT response contains a uint16
value. Value has to be between a range of 0 and 2048.
|===

[[_notestesting_considerations_129]]
====== link:#_notestesting_considerations_129[]Notes/Testing Considerations

[[_tc_flw_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_flw_2_2_primary_functionality_with_server_as_dut[]32.2.2. [TC-FLW-2.2] Primary Functionality with Server as DUT

[[_category_129]]
====== link:#_category_129[]Category

Functional.

[[_purpose_129]]
====== link:#_purpose_129[]Purpose

This test case verifies the primary functionality of the Flow
Measurement cluster server.

[[_pics_129]]
====== link:#_pics_129[]PICS

* FLW.S

[[_required_devices_129]]
====== link:#_required_devices_129[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_102]]
====== link:#_device_topology_102[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_114]]
====== link:#_test_setup_114[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_129]]
====== link:#_test_procedure_129[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.5.4.1 |FLW.S.A0000(MeasuredValue) |TH reads from the DUT the
_MeasuredValue_ attribute. |Verify the read is successful and note down
the value read.

|3 | |FLW.M.FlowChange |Operate on device to change the flow
significantly. |

|4 |AC.2.5.4.1 |FLW.S.A0000(MeasuredValue) |After a few seconds, TH
reads from the DUT the _MeasuredValue_ attribute. |Value read has to be
different from value measure in step 2.
|===

[[_notestesting_considerations_130]]
====== link:#_notestesting_considerations_130[]Notes/Testing Considerations

[[_pressure_measurement_cluster_test_plan]]
== link:#_pressure_measurement_cluster_test_plan[]**Pressure Measurement Cluster Test Plan**

[[_pics_definition_11]]
=== link:#_pics_definition_11[]33. PICS Definition

This section covers the Pressure Measurement Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_11]]
==== link:#_role_11[]33.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PRS.S |Does the device implement the Pressure Measurement cluster as a
server? |O |
|===

[[_server_11]]
==== link:#_server_11[]33.2. Server

[[_features_7]]
===== link:#_features_7[]33.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PRS.S.F00(EXT) |Does the device support extended range and resolution?
|O |
|===

[[_attributes_13]]
===== link:#_attributes_13[]33.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PRS.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |M |

|PRS.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |M |

|PRS.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |M |

|PRS.S.A0003(Tolerance) |Does the device implement the _Tolerance_
attribute? |O |

|PRS.S.A0010(ScaledValue) |Does the device implement the _ScaledValue_
attribute? |EXT |

|PRS.S.A0011(MinScaledValue) |Does the device implement the
_MinScaledValue_ attribute? |EXT |

|PRS.S.A0012(MaxScaledValue) |Does the device implement the
_MaxScaledValue_ attribute? |EXT |

|PRS.S.A0013(ScaledTolerance) |Does the device implement the
_ScaledTolerance_ attribute? |[EXT] |

|PRS.S.A0014(Scale) |Does the device implement the _Scale_ attribute?
|EXT |
|===

[[_manual_controllable_8]]
===== link:#_manual_controllable_8[]33.2.3. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PRS.M.PressureChange |Can the _MeasuredValue_ attribute changed by
physical control at the device? |O |
|===

[[_test_case_list_11]]
=== link:#_test_case_list_11[]34. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-PRS-1.1 |Global Attributes with DUT as Server
|TC-PRS-2.1 |Attributes with Server as DUT
|TC-PRS-2.2 |Primary Functionality with Server as DUT
|===

[[_test_cases_11]]
=== link:#_test_cases_11[]35. Test Cases

'''''

[[_generic_test_cases_8]]
==== link:#_generic_test_cases_8[]35.1. Generic Test Cases

'''''

[[_tc_prs_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_prs_1_1_global_attributes_with_dut_as_server[]35.1.1. [TC-PRS-1.1] Global Attributes with DUT as Server

[[_category_130]]
====== link:#_category_130[]Category

Functional conformance.

[[_purpose_130]]
====== link:#_purpose_130[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_130]]
====== link:#_pics_130[]PICS

* PRS.S

[[_required_devices_130]]
====== link:#_required_devices_130[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_130]]
====== link:#_test_procedure_130[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if PRS.S.F00(EXT)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0003: SHALL be included if and only if PRS.S.A0003(Tolerance)

The list include entries based on feature support: +
- 0x0010: SHALL be included if PRS.S.F00(EXT) and SHALL NOT be included
otherwise.

- 0x0011: SHALL be included if PRS.S.F00(EXT) and SHALL NOT be included
otherwise.

- 0x0012: SHALL be included if PRS.S.F00(EXT) and SHALL NOT be included
otherwise.

- 0x0013: SHALL be included if (PRS.S.F00(EXT) &
PRS.S.A0013(ScaledTolerance)) and SHALL NOT be included otherwise.

- 0x0014: SHALL be included if PRS.S.F00(EXT) and SHALL NOT be included
otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_131]]
====== link:#_notestesting_considerations_131[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_dut_as_server_3]]
==== link:#_dut_as_server_3[]35.2. DUT as Server

'''''

[[_tc_prs_2_1_attributes_with_server_as_dut]]
===== link:#_tc_prs_2_1_attributes_with_server_as_dut[]35.2.1. [TC-PRS-2.1] Attributes with Server as DUT

[[_category_131]]
====== link:#_category_131[]Category

Functional.

[[_purpose_131]]
====== link:#_purpose_131[]Purpose

This test case verifies the non-global attributes of the Pressure
Measurement cluster server.

[[_pics_131]]
====== link:#_pics_131[]PICS

* PRS.S

[[_required_devices_131]]
====== link:#_required_devices_131[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_103]]
====== link:#_device_topology_103[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_115]]
====== link:#_test_setup_115[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_131]]
====== link:#_test_procedure_131[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.4.5.2 |PRS.S.A0001(MinMeasuredValue) |TH reads from the DUT the
_MinMeasuredValue_ attribute. a|
Verify that the DUT response contains either +
null +
or +
an int16 where +
-32767 ≤ _MinMeasuredValue_ ≤ 32766. +

Note the value for usage in later steps as PRS~min~. +
If _MinMeasuredValue_ is null note -32767.

|3 |AC.2.4.5.3 |PRS.S.A0002(MaxMeasuredValue) |TH reads from the DUT the
_MaxMeasuredValue_ attribute. a|
Verify that the DUT response contains either +
null +
or +
an int16 where +
PRS~min~ < _MaxMeasuredValue_ ≤ 32767. +

Note the value for usage in later steps as PRS~max~. +
If _MaxMeasuredValue_ is null note 32767.

|4 |AC.2.4.5.1 |PRS.S.A0000(MeasuredValue) |TH reads from the DUT the
_MeasuredValue_ attribute. |Verify that the DUT response contains
either +
null +
or +
a int16 where +
PRS~min~ ≤ _MeasuredValue_ ≤ PRS~max~.

|5 |AC.2.4.5.4 |PRS.S.A0003(Tolerance) |TH reads from the DUT the
_Tolerance_ attribute. |Verify that the DUT response contains a uint16
value. Value has to be between a range of 0 and 2048.

|6 |AC.2.4.5.6 |PRS.S.A0011(MinScaledValue) |TH reads from the DUT the
_MinScaledValue_ attribute. a|
Verify that the DUT response contains either +
null +
or +
an int16 where +
-32767 ≤ _MinScaledValue_ ≤ 32766. +

Note the value for usage in later steps as PRS_Scaled~min~. +
If _MinScaledValue_ is null note -32767.

|7 |AC.2.4.5.7 |PRS.S.A0012(MaxScaledValue) |TH reads from the DUT the
_MaxScaledValue_ attribute. a|
Verify that the DUT response contains either +
null +
or +
an int16 where +
PRS~min~ < _MaxScaledValue_ ≤ 32767. +

Note the value for usage in later steps as PRS_Scaled~max~. +
If _MaxScaledValue_ is null note 32767.

|8 |AC.2.4.5.5 |PRS.S.A0010(ScaledValue) |TH reads from the DUT the
_ScaledValue_ attribute. |Verify that the DUT response contains either +
null +
or +
a int16 where +
PRS_Scaled~min~ ≤ _ScaledValue_ ≤ PRS_Scaled~max~.

|9 |AC.2.4.5.8 |PRS.S.A0013(ScaledTolerance) |TH reads from the DUT the
_ScaledTolerance_ attribute. |Verify that the DUT response contains a
uint16 value. Value has to be between a range of 0 and 2048.

|10 |AC.2.4.5.9 |PRS.S.A0014(Scale) |TH reads from the DUT the _Scale_
attribute. |Verify that the DUT response contains an int8 value. Value
has to be between a range of -127 and 127.
|===

[[_notestesting_considerations_132]]
====== link:#_notestesting_considerations_132[]Notes/Testing Considerations

Test Steps #5 to #10 cannot be executed with V1.0 SDK

[[_tc_prs_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_prs_2_2_primary_functionality_with_server_as_dut[]35.2.2. [TC-PRS-2.2] Primary Functionality with Server as DUT

[[_category_132]]
====== link:#_category_132[]Category

Functional.

[[_purpose_132]]
====== link:#_purpose_132[]Purpose

This test case verifies the primary functionality of the Pressure
Measurement cluster server.

[[_pics_132]]
====== link:#_pics_132[]PICS

* PRS.S

[[_required_devices_132]]
====== link:#_required_devices_132[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_104]]
====== link:#_device_topology_104[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_116]]
====== link:#_test_setup_116[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_132]]
====== link:#_test_procedure_132[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.4.5.1 |PRS.S.A0000(MeasuredValue) |TH reads from the DUT the
_MeasuredValue_ attribute. |Verify the read is successful and note down
the value read.

|3 | |PRS.M.PressureChange |Operate on device to change the pressure
significantly. |

|4 |AC.2.4.5.1 |PRS.S.A0000(MeasuredValue) |After a few seconds, TH
reads from the DUT the _MeasuredValue_ attribute. |Value read has to be
different from value measure in step 2.
|===

[[_notestesting_considerations_133]]
====== link:#_notestesting_considerations_133[]Notes/Testing Considerations

[[_window_covering_cluster_test_plan]]
== link:#_window_covering_cluster_test_plan[]**Window Covering Cluster Test Plan**

[[_pics_definition_12]]
=== link:#_pics_definition_12[]36. PICS Definition

This section covers the Window Covering cluster’s Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_12]]
==== link:#_role_12[]36.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.S |Does the device implement the Window Covering cluster as a
server? |O |

|WNCV.C |Does the device implement the Window Covering cluster as a
client? |O |
|===

[[_server_12]]
==== link:#_server_12[]36.2. Server

[[_features_8]]
===== link:#_features_8[]36.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.S.F00(LF) |Does the device implement the Lift feature ? |O.a+ |at
least one of `a` is True

|WNCV.S.F01(TL) |Does the device implement the Tilt feature ? |O.a+ |at
least one of `a` is True

|WNCV.S.F02(PA_LF) |Does the device implement the Position Aware Lift
feature ? |[WNCV.S.F00(LF)] |

|WNCV.S.F03(ABS) |Does the device implement the Absolute positioning
feature ? |O |

|WNCV.S.F04(PA_TL) |Does the device implement the Position Aware Tilt
feature ? |[WNCV.S.F01(TL)] |
|===

[[_manual_controllable_9]]
===== link:#_manual_controllable_9[]36.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.S.M.Reversal |Does the device support reversal of lift movement ?
|[WNCV.S.F00(LF)] |Declared by manufacturer

|WNCV.S.M.Calibration |Does the device support a calibration mode/state
? |O |Declared by manufacturer

|WNCV.S.M.Maintenance |Does the device support a maintenance mode/state
? |O |Declared by manufacturer
|===

[[_attributes_14]]
===== link:#_attributes_14[]36.2.3. Attributes

[width="100%",cols="26%,43%,25%,6%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.S.A0000(Type) |Does the device implement the Type attribute ? |M |

|WNCV.S.A0001(PhysicalClosedLimitLift) |Does the device implement the
PhysicalClosedLimitLift attribute ? |[WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)
& WNCV.S.F03(ABS)] |

|WNCV.S.A0002(PhysicalClosedLimitTilt) |Does the device implement the
PhysicalClosedLimitTilt attribute ? |[WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)
& WNCV.S.F03(ABS)] |

|WNCV.S.A0003(CurrentPositionLift) |Does the device implement the
CurrentPositionLift attribute ? |[WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) &
WNCV.S.F03(ABS)] |

|WNCV.S.A0004(CurrentPositionTilt) |Does the device implement the
CurrentPositionTilt attribute ? |[WNCV.S.F01(TL) & WNCV.S.F04(PA_TL) &
WNCV.S.F03(ABS)] |

|WNCV.S.A0005(NumberOfActuationsLift) |Does the device implement the
NumberOfActuationsLift attribute ? |[WNCV.S.F00(LF)] |

|WNCV.S.A0006(NumberOfActuationsTilt) |Does the device implement the
NumberOfActuationsTilt attribute ? |[WNCV.S.F01(TL)] |

|WNCV.S.A0007(ConfigStatus) |Does the device implement the ConfigStatus
attribute ? |M |

|WNCV.S.A0008(CurrentPositionLiftPercentage) |Does the device implement
the CurrentPositionLiftPercentage attribute ? |[WNCV.S.F00(LF) &
WNCV.S.F02(PA_LF)] |

|WNCV.S.A0009(CurrentPositionTiltPercentage) |Does the device implement
the CurrentPositionTiltPercentage attribute ? |[WNCV.S.F01(TL) &
WNCV.S.F04(PA_TL)] |

|WNCV.S.A000a(OperationalStatus) |Does the device implement the
OperationalStatus attribute ? |M |

|WNCV.S.A000b(TargetPositionLiftPercent100ths) |Does the device
implement the TargetPositionLiftPercent100ths attribute ?
|WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) |

|WNCV.S.A000c(TargetPositionTiltPercent100ths) |Does the device
implement the TargetPositionTiltPercent100ths attribute ?
|WNCV.S.F01(TL) & WNCV.S.F04(PA_TL) |

|WNCV.S.A000d(EndProductType) |Does the device implement the
EndProductType attribute ? |M |

|WNCV.S.A000e(CurrentPositionLiftPercent100ths) |Does the device
implement the CurrentPositionLiftPercent100ths attribute ?
|WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) |

|WNCV.S.A000f(CurrentPositionTiltPercent100ths) |Does the device
implement the CurrentPositionTiltPercent100ths attribute ?
|WNCV.S.F01(TL) & WNCV.S.F04(PA_TL) |

|WNCV.S.A0010(InstalledOpenLimitLift) |Does the device implement the
InstalledOpenLimitLift attribute ? |WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) &
WNCV.S.F03(ABS) |

|WNCV.S.A0011(InstalledClosedLimitLift) |Does the device implement the
InstalledClosedLimitLift attribute ? |WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)
& WNCV.S.F03(ABS) |

|WNCV.S.A0012(InstalledOpenLimitTilt) |Does the device implement the
InstalledOpenLimitTilt attribute ? |WNCV.S.F01(TL) & WNCV.S.F04(PA_TL) &
WNCV.S.F03(ABS) |

|WNCV.S.A0013(InstalledClosedLimitTilt) |Does the device implement the
InstalledClosedLimitTilt attribute ? |WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)
& WNCV.S.F03(ABS) |

|WNCV.S.A0017(Mode) |Does the device implement the Mode attribute ? |M |

|WNCV.S.A001a(SafetyStatus) |Does the device implement the SafetyStatus
attribute ? |M |

|WNCV.S.A0011.Scene(TargetPositionLiftPercent100ths) |Does the device
support scene via the TargetPositionLiftPercent100ths attribute ?
|[WNCV.S.F00(LF)] |

|WNCV.S.A0012.Scene(TargetPositionTiltPercent100ths) |Does the device
support scene via the TargetPositionTiltPercent100ths attribute ?
|[WNCV.S.F01(TL)] |
|===

[[_commands_received_5]]
===== link:#_commands_received_5[]36.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.S.C00.Rsp(UpOrOpen) |Does the device implement receiving the
UpOrOpen command ? |M |

|WNCV.S.C01.Rsp(DownOrClose) |Does the device implement receiving the
DownOrClose command ? |M |

|WNCV.S.C02.Rsp(StopMotion) |Does the device implement receiving the
StopMotion command ? |M |

|WNCV.S.C04.Rsp(GoToLiftValue) |Does the device implement receiving the
GoToLiftValue command ? |[WNCV.S.F00(LF) & WNCV.S.F03(ABS)] |

|WNCV.S.C05.Rsp(GoToLiftPercentage) |Does the device implement receiving
the GoToLiftPercentage command ? |WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) |

|WNCV.S.C07.Rsp(GoToTiltValue) |Does the device implement receiving the
GoToTiltValue command ? |[WNCV.S.F01(TL) & WNCV.S.F03(ABS)] |

|WNCV.S.C08.Rsp(GoToTiltPercentage) |Does the device implement receiving
the GoToTiltPercentage command ? |WNCV.S.F01(TL) & WNCV.S.F04(PA_TL) |
|===

[[_client_5]]
==== link:#_client_5[]36.3. Client

[[_attributes_15]]
===== link:#_attributes_15[]36.3.1. Attributes

[width="100%",cols="26%,43%,25%,6%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.C.A0000(Type) |Does the DUT(client) have access privileges for the
Type attribute implemented on the server ? |O |

|WNCV.C.A0001(PhysicalClosedLimitLift) |Does the DUT(client) have access
privileges for the PhysicalClosedLimitLift attribute implemented on the
server ? |O |

|WNCV.C.A0002(PhysicalClosedLimitTilt) |Does the DUT(client) have access
privileges for the PhysicalClosedLimitTilt attribute implemented on the
server ? |O |

|WNCV.C.A0003(CurrentPositionLift) |Does the DUT(client) have access
privileges for the CurrentPositionLift attribute implemented on the
server ? |O |

|WNCV.C.A0004(CurrentPositionTilt) |Does the DUT(client) have access
privileges for the CurrentPositionTilt attribute implemented on the
server ? |O |

|WNCV.C.A0005(NumberOfActuationsLift) |Does the DUT(client) have access
privileges for the NumberOfActuationsLift attribute implemented on the
server ? |O |

|WNCV.C.A0006(NumberOfActuationsTilt) |Does the DUT(client) have access
privileges for the NumberOfActuationsTilt attribute implemented on the
server ? |O |

|WNCV.C.A0007(ConfigStatus) |Does the DUT(client) have access privileges
for the ConfigStatus attribute implemented on the server ? |O |

|WNCV.C.A0008(CurrentPositionLiftPercentage) |Does the DUT(client) have
access privileges for the CurrentPositionLiftPercentage attribute
implemented on the server ? |O |

|WNCV.C.A0009(CurrentPositionTiltPercentage) |Does the DUT(client) have
access privileges for the CurrentPositionTiltPercentage attribute
implemented on the server ? |O |

|WNCV.C.A000a(OperationalStatus) |Does the DUT(client) have access
privileges for the OperationalStatus attribute implemented on the server
? |O |

|WNCV.C.A000b(TargetPositionLiftPercent100ths) |Does the DUT(client)
have access privileges for the TargetPositionLiftPercent100ths attribute
implemented on the server ? |O |

|WNCV.C.A000c(TargetPositionTiltPercent100ths) |Does the DUT(client)
have access privileges for the TargetPositionTiltPercent100ths attribute
implemented on the server ? |O |

|WNCV.C.A000d(EndProductType) |Does the DUT(client) have access
privileges for the EndProductType attribute implemented on the server ?
|O |

|WNCV.C.A000e(CurrentPositionLiftPercent100ths) |Does the DUT(client)
have access privileges for the CurrentPositionLiftPercent100ths
attribute implemented on the server ? |O |

|WNCV.C.A000f(CurrentPositionTiltPercent100ths) |Does the DUT(client)
have access privileges for the CurrentPositionTiltPercent100ths
attribute implemented on the server ? |O |

|WNCV.C.A0010(InstalledOpenLimitLift) |Does the DUT(client) have access
privileges for the InstalledOpenLimitLift attribute implemented on the
server ? |O |

|WNCV.C.A0011(InstalledClosedLimitLift) |Does the DUT(client) have
access privileges for the InstalledClosedLimitLift attribute implemented
on the server ? |O |

|WNCV.C.A0012(InstalledOpenLimitTilt) |Does the DUT(client) have access
privileges for the InstalledOpenLimitTilt attribute implemented on the
server ? |O |

|WNCV.C.A0013(InstalledClosedLimitTilt) |Does the DUT(client) have
access privileges for the InstalledClosedLimitTilt attribute implemented
on the server ? |O |

|WNCV.C.A0017(Mode) |Does the DUT(client) have access privileges for the
Mode attribute implemented on the server ? |O |

|WNCV.C.A001a(SafetyStatus) |Does the DUT(client) have access privileges
for the SafetyStatus attribute implemented on the server ? |O |
|===

[[_commands_generated_4]]
===== link:#_commands_generated_4[]36.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WNCV.C.C00.Tx(UpOrOpen) |Does the device implement sending the UpOrOpen
command ? |O |

|WNCV.C.C01.Tx(DownOrClose) |Does the device implement sending the
DownOrClose command ? |O |

|WNCV.C.C02.Tx(StopMotion) |Does the device implement sending the
StopMotion command ? |O |

|WNCV.C.C04.Tx(GoToLiftValue) |Does the device implement sending the
GoToLiftValue command ? |O |

|WNCV.C.C05.Tx(GoToLiftPercentage) |Does the device implement sending
the GoToLiftPercentage command ? |O |

|WNCV.C.C07.Tx(GoToTiltValue) |Does the device implement sending the
GoToTiltValue command ? |O |

|WNCV.C.C08.Tx(GoToTiltPercentage) |Does the device implement sending
the GoToTiltPercentage command ? |O |
|===

[[_pixit_definition_3]]
=== link:#_pixit_definition_3[]37. PIXIT Definition

This section covers the Window Covering cluster’s Test Plan related
PIXIT items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.WNCV.FULLMOTION |Full motion duration (in seconds) required for
the DUT |WNCV.S |
|===

[[_test_case_list_12]]
=== link:#_test_case_list_12[]38. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-WNCV-1.1 |Global attributes

|TC-WNCV-2.1 |Cluster Attributes [DUT as Server]

|TC-WNCV-2.2 |ConfigStatus attribute [DUT as Server]

|TC-WNCV-2.3 |Mode attribute [DUT as Server]

|TC-WNCV-2.4 |Type attribute [DUT as Server]

|TC-WNCV-2.5 |EndProductType attribute [DUT as Server]

|TC-WNCV-3.1 |UpOrOpen command & OperationalStatus attribute
Verification [DUT as Server]

|TC-WNCV-3.2 |DownOrClose command & OperationalStatus attribute
Verification [DUT as Server]

|TC-WNCV-3.3 |StopMotion command & OperationalStatus attribute
Verification [DUT as Server]

|TC-WNCV-3.4 |UpOrOpen command Long-Run Verification [DUT as Server]

|TC-WNCV-3.5 |DownOrClose command Long-Run Verification [DUT as Server]

|TC-WNCV-4.1 |GoToLiftPercentage command Long-Run Verification [DUT as
Server]

|TC-WNCV-4.2 |GoToTiltPercentage command Long-Run Verification [DUT as
Server]

|TC-WNCV-4.3 |GoToLiftPercentage command Limits Verification [DUT as
Server]

|TC-WNCV-4.4 |GoToTiltPercentage command Limits Verification [DUT as
Server]

|TC-WNCV-4.5 |Positions Storage Verification [DUT as Server]

|TC-WNCV-5.1 |Mandatory Attributes Verification [DUT as Client]

|TC-WNCV-6.1 |Basic Commands Verification [DUT as Client]

|TC-WNCV-7.1 |GoToPercentage Commands Verification [DUT as Client]
|===

Note: _Long-Run_ tests are the ones running over long period of time to
be successful, they require specific tweaking with PIXIT.WNCV.FULLMOTION

[[_test_cases_12]]
=== link:#_test_cases_12[]39. Test Cases

'''''

[[_generic_test_cases_9]]
==== link:#_generic_test_cases_9[]39.1. Generic Test Cases

'''''

[[_tc_wncv_1_1_global_attributes_dut_as_server]]
===== link:#_tc_wncv_1_1_global_attributes_dut_as_server[]39.1.1. [TC-WNCV-1.1] Global attributes [DUT as Server]

[[_category_133]]
====== link:#_category_133[]Category

Functional conformance

[[_purpose_133]]
====== link:#_purpose_133[]Purpose

This test case verifies the WindowCovering Global attributes

[[_pics_133]]
====== link:#_pics_133[]PICS

* WNCV.S

[[_required_devices_133]]
====== link:#_required_devices_133[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_133]]
====== link:#_test_procedure_133[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | | |TH reads from the DUT the (0xFFFD) ClusterRevision attribute
|Verify that the DUT response contains a minimal revision of 5

|3 | | |TH reads from the DUT the (0xFFFC) FeatureMap attribute a|
Verify that the DUT response contains the following bitmap32 w/:

- bit 0 is set to 1 If WNCV.S.F00(LF) is true.

- bit 1 is set to 1 If WNCV.S.F01(TL) is true.

- bit 2 is set to 1 If WNCV.S.F02(PA_LF) is true.

- bit 3 is set to 1 If WNCV.S.F03(ABS) is true.

- bit 4 is set to 1 If WNCV.S.F04(PA_TL) is true.

|4 | | |TH reads from the DUT the (0xFFFB) AttributeList attribute a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support:

- (0) Type (M)

- (7) ConfigStatus (M)

- (10) OperationalStatus (M)

- (13) EndProductType (M)

- (23) Mode (M)

- (26) SafetyStatus (O)

- for others see PICS

- It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 | | |TH reads from the DUT the (0xFFFA) EventList attribute |Verify
that the DUT response contains a list of supported events empty for this
cluster.

|6 | | |TH reads from the DUT the (0xFFF9) AcceptedCommandList attribute
a|
Verify that the DUT response contains a list of Accepted commands (C2S)
based on its PICS support.

- (0) UpOrOpen (M)

- (1) DownOrClose (M)

- (2) StopMotion (M)

- for others see PICS

|7 | | |TH reads from the DUT the (0xFFF8) GeneratedCommandList
attribute |Verify that the DUT response contains a list of Generated
commands (S2C) empty for this cluster.
|===

[[_notestesting_considerations_134]]
====== link:#_notestesting_considerations_134[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_cluster_attributes_test_cases]]
==== link:#_cluster_attributes_test_cases[]39.2. Cluster Attributes Test Cases

'''''

[[_tc_wncv_2_1_attributes_dut_as_server]]
===== link:#_tc_wncv_2_1_attributes_dut_as_server[]39.2.1. [TC-WNCV-2.1] Attributes [DUT as Server]

[[_category_134]]
====== link:#_category_134[]Category

Functional conformance

[[_purpose_134]]
====== link:#_purpose_134[]Purpose

This test case verifies the WindowCovering cluster attributes

[[_pics_134]]
====== link:#_pics_134[]PICS

* WNCV.S

[[_required_devices_134]]
====== link:#_required_devices_134[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_134]]
====== link:#_test_procedure_134[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*MANDATORY Attributes* |

|1a |5.3.5 |WNCV.S.A0000(Type) |TH reads from the DUT the ( 0) Type
attribute |Verify that the DUT response contains an enum8

|1b |5.3.5 |WNCV.S.A0007(ConfigStatus) |TH reads from the DUT the ( 7)
ConfigStatus attribute |Verify that the DUT response contains a bitmap8

|1c |5.3.5 |WNCV.S.A000a(OperationalStatus) |TH reads from the DUT the
(10) OperationalStatus attribute |Verify that the DUT response contains
a bitmap8

|1d |5.3.5 |WNCV.S.A000d(EndProductType) |TH reads from the DUT the (13)
EndProductType attribute |Verify that the DUT response contains an enum8

|1e |5.3.5 |WNCV.S.A0017(Mode) |TH reads from the DUT the (23) Mode
attribute |Verify that the DUT response contains a bitmap8

|1f |5.3.5 |WNCV.S.A0017(Mode) |TH writes to (23) Mode attribute the
value 0 |Verify DUT responds w/ status SUCCESS(0x00)

|*2* | | |*CONDITIONALLY MANDATORY Attributes* |

|2a |5.3.5 |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads from
the DUT the (11) TargetPositionLiftPercent100ths attribute |Verify that
the DUT response contains a nullable Percent100ths (uint16), Value has
to be between a range of [min=0, max=10000]

|2b |5.3.5 |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads from
the DUT the (12) TargetPositionTiltPercent100ths attribute |Verify that
the DUT response contains a nullable Percent100ths (uint16), Value has
to be between a range of [min=0, max=10000]

|2c |5.3.5 |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
from the DUT the (14) CurrentPositionLiftPercent100ths attribute |Verify
that the DUT response contains a nullable Percent100ths (uint16), Value
has to be between a range of [min=0, max=10000]

|2d |5.3.5 |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
from the DUT the (15) CurrentPositionTiltPercent100ths attribute |Verify
that the DUT response contains a nullable Percent100ths (uint16), Value
has to be between a range of [min=0, max=10000]

|2e |5.3.5 |WNCV.S.A0010(InstalledOpenLimitLift) |TH reads from the DUT
the (16) InstalledOpenLimitLift attribute |Verify that the DUT response
contains an uint16

|2f |5.3.5 |WNCV.S.A0011(InstalledClosedLimitLift) |TH reads from the
DUT the (17) InstalledClosedLimitLift attribute |Verify that the DUT
response contains an uint16

|2g |5.3.5 |WNCV.S.A0012(InstalledOpenLimitTilt) |TH reads from the DUT
the (18) InstalledOpenLimitTilt attribute |Verify that the DUT response
contains an uint16

|2h |5.3.5 |WNCV.S.A0013(InstalledClosedLimitTilt) |TH reads from the
DUT the (19) InstalledClosedLimitTilt attribute |Verify that the DUT
response contains an uint16

|*3* | | |*CONDITIONALLY and PURELY OPTIONAL Attributes* |

|3a |5.3.5 |WNCV.S.A001a(SafetyStatus) |TH reads from the DUT the (26)
SafetyStatus attribute |Verify that the DUT response contains a bitmap16

|3b |5.3.5 |WNCV.S.A0001(PhysicalClosedLimitLift) |TH reads from the DUT
the ( 1) PhysicalClosedLimitLift attribute |Verify that the DUT response
contains an uint16

|3c |5.3.5 |WNCV.S.A0002(PhysicalClosedLimitTilt) |TH reads from the DUT
the ( 2) PhysicalClosedLimitTilt attribute |Verify that the DUT response
contains an uint16

|3d |5.3.5 |WNCV.S.A0003(CurrentPositionLift) |TH reads from the DUT the
( 3) CurrentPositionLift attribute |Verify that the DUT response
contains a nullable uint16

|3e |5.3.5 |WNCV.S.A0004(CurrentPositionTilt) |TH reads from the DUT the
( 4) CurrentPositionTilt attribute |Verify that the DUT response
contains a nullable uint16

|3f |5.3.5 |WNCV.S.A0005(NumberOfActuationsLift) |TH reads from the DUT
the ( 5) NumberOfActuationsLift attribute |Verify that the DUT response
contains an uint16

|3g |5.3.5 |WNCV.S.A0006(NumberOfActuationsTilt) |TH reads from the DUT
the ( 6) NumberOfActuationsTilt attribute |Verify that the DUT response
contains an uint16

|3h |5.3.5 |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads from
the DUT the ( 8) CurrentPositionLiftPercentage attribute |Verify that
the DUT response contains a nullable Percent (uint8), Value has to be
between a range of [min=0, max=100]

|3i |5.3.5 |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads from
the DUT the ( 9) CurrentPositionTiltPercentage attribute |Verify that
the DUT response contains a nullable Percent (uint8), Value has to be
between a range of [min=0, max=100]
|===

[[_notestesting_considerations_135]]
====== link:#_notestesting_considerations_135[]Notes/Testing Considerations

[[_tc_wncv_2_2_configstatus_attribute_dut_as_server]]
===== link:#_tc_wncv_2_2_configstatus_attribute_dut_as_server[]39.2.2. [TC-WNCV-2.2] ConfigStatus attribute [DUT as Server]

[[_category_135]]
====== link:#_category_135[]Category

Functional

[[_purpose_135]]
====== link:#_purpose_135[]Purpose

This test case verifies the ConfigStatus attribute behavior of the
Window Covering cluster server.

[[_pics_135]]
====== link:#_pics_135[]PICS

* WNCV.S

[[_required_devices_135]]
====== link:#_required_devices_135[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_105]]
====== link:#_device_topology_105[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_117]]
====== link:#_test_setup_117[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_135]]
====== link:#_test_procedure_135[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT a|
verify these bits:

- if (WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)) value of bit 3 must be 1b else
0b,

- if (WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)) value of bit 4 must be 1b else
0b,

- value of bit 0 must be 1b (operational)

|===

[[_notestesting_considerations_136]]
====== link:#_notestesting_considerations_136[]Notes/Testing Considerations

`dbafb4f` on Dec 1

[[_tc_wncv_2_3_mode_attribute_dut_as_server]]
===== link:#_tc_wncv_2_3_mode_attribute_dut_as_server[]39.2.3. [TC-WNCV-2.3] Mode attribute [DUT as Server]

[[_category_136]]
====== link:#_category_136[]Category

Functional

[[_purpose_136]]
====== link:#_purpose_136[]Purpose

This test case verifies the Mode attribute behavior of the Window
Covering cluster server.

[[_pics_136]]
====== link:#_pics_136[]PICS

* WNCV.S

[[_required_devices_136]]
====== link:#_required_devices_136[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_106]]
====== link:#_device_topology_106[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_118]]
====== link:#_test_setup_118[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_136]]
====== link:#_test_procedure_136[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | |WNCV.S.M.Reversal |*Check Lift Reversal (If WNCV.S.M.Reversal)*
|

|1a | |WNCV.S.A0017(Mode) |TH set the Mode attribute bit0 of the DUT |

|1b | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT |Value of bit2 must be 1b

|1c | |WNCV.S.A0017(Mode) |TH clear the Mode attribute bit0 of the DUT |

|1d | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT |Value of bit2 must be 0b

|*2* | |WNCV.S.M.Calibration |*Check Calibration (If
WNCV.S.M.Calibration)* |

|2a | |WNCV.S.A0017(Mode) |TH set the Mode attribute bit1 of the DUT |

|2b | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT |

|2c | |WNCV.S.C01.Rsp(DownOrClose) |If (ConfigStatus bit0 == 0) TH sends
DownOrClose command to DUT |Verify DUT responds w/ status FAILURE(0x01)

|2d | |WNCV.S.A0017(Mode) |Clear the Mode attribute bit1 by performing a
calibration of the DUT or via TH clear the Mode attribute bit1 of the
DUT. Refer to manufacturer provided instructions for how a calibration
is performed. |Calibration should be performed if supported or aborted

|2e | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT |Value of bit0 must be 1b

|2f | |WNCV.S.A0017(Mode) |TH reads Mode attribute from DUT |Value of
bit1 must be 0b

|2g | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|*3* | |WNCV.S.M.Maintenance |*Check Maintenance (If
WNCV.S.M.Maintenance)* |

|3a | |WNCV.S.A0017(Mode) |TH set the Mode attribute bit2 of the DUT |

|3b | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status BUSY(0x9c)

|3c | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT |Value of bit0 must be 0b

|3d | |WNCV.S.A0017(Mode) |TH clear the Mode attribute bit2 of the DUT |

|3e | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|3f | |WNCV.S.A0007(ConfigStatus) |TH reads ConfigStatus attribute from
DUT |Value of bit0 must be 1b
|===

[[_notestesting_considerations_137]]
====== link:#_notestesting_considerations_137[]Notes/Testing Considerations

`dbafb4f` on Dec 1

[[_tc_wncv_2_4_type_attribute_dut_as_server]]
===== link:#_tc_wncv_2_4_type_attribute_dut_as_server[]39.2.4. [TC-WNCV-2.4] Type attribute [DUT as Server]

[[_category_137]]
====== link:#_category_137[]Category

Functional

[[_purpose_137]]
====== link:#_purpose_137[]Purpose

This test case verifies the Type attribute behavior of the Window
Covering cluster server.

[[_pics_137]]
====== link:#_pics_137[]PICS

* WNCV.S

[[_required_devices_137]]
====== link:#_required_devices_137[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_107]]
====== link:#_device_topology_107[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_119]]
====== link:#_test_setup_119[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_137]]
====== link:#_test_procedure_137[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | |WNCV.S.A0000(Type) |TH reads Type attribute from DUT a|
verify these elements:

- Value has to be between a range of [min=0, max=9] ^*^

- If (WNCV.S.F00(LF) & !WNCV.S.F01(TL)) value must be between [min=0,
max=5] or equals to 9,

- If (!WNCV.S.F00(LF) & WNCV.S.F01(TL)) value must be only equal to 7,

- If (WNCV.S.F00(LF) & WNCV.S.F01(TL)) value is either 6 or 8

|===

^*^This range will certainly increase and depends of the Matter’s
specification version #

[[_notestesting_considerations_138]]
====== link:#_notestesting_considerations_138[]Notes/Testing Considerations

7664cab9 on June 17

[[_tc_wncv_2_5_endproducttype_attribute_dut_as_server]]
===== link:#_tc_wncv_2_5_endproducttype_attribute_dut_as_server[]39.2.5. [TC-WNCV-2.5] EndProductType attribute [DUT as Server]

[[_category_138]]
====== link:#_category_138[]Category

Functional

[[_purpose_138]]
====== link:#_purpose_138[]Purpose

This test case verifies the EndProductType attribute behavior of the
Window Covering cluster server.

[[_pics_138]]
====== link:#_pics_138[]PICS

* WNCV.S

[[_required_devices_138]]
====== link:#_required_devices_138[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_108]]
====== link:#_device_topology_108[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_120]]
====== link:#_test_setup_120[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_138]]
====== link:#_test_procedure_138[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | |WNCV.S.A000d(EndProductType) |TH reads EndProductType attribute
from DUT |Value has to be between a range of [min=0, max=23] ^*^
|===

^*^This range will certainly increase and depends of the Matter’s
specification version #

[[_notestesting_considerations_139]]
====== link:#_notestesting_considerations_139[]Notes/Testing Considerations

7664cab9 on June 17

'''''

[[_basic_commands_test_cases]]
==== link:#_basic_commands_test_cases[]39.3. Basic Commands Test Cases

'''''

[[_tc_wncv_3_1_uporopen_command_operationalstatus_attribute_verification_dut_as_server]]
===== link:#_tc_wncv_3_1_uporopen_command_operationalstatus_attribute_verification_dut_as_server[]39.3.1. [TC-WNCV-3.1] UpOrOpen command & OperationalStatus attribute Verification [DUT as Server]

[[_category_139]]
====== link:#_category_139[]Category

Functional

[[_purpose_139]]
====== link:#_purpose_139[]Purpose

This test case verifies the UpOrOpen command functionality of the Window
Covering cluster server with the expected changes on attributes.

[[_pics_139]]
====== link:#_pics_139[]PICS

* WNCV.S

[[_preconditions_61]]
====== link:#_preconditions_61[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support at least one of these (0xFFFC) FeatureMap
attribute’s flag WNCV.S.F00(LF) and/or WNCV.S.F01(TL) |
|===

[[_required_devices_139]]
====== link:#_required_devices_139[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_109]]
====== link:#_device_topology_109[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_121]]
====== link:#_test_setup_121[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_139]]
====== link:#_test_procedure_139[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for 5-15 seconds movement(s) on the DUT |DUT adjusts
to a non-open position

|1c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value must not be
0.00% (0x0000) [min=1, max=10000]

|1d | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value must not be 0%
(0x00) [min=1, max=100 ]

|1e | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value must not be
0.00% (0x0000) [min=1, max=10000]

|1f | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value must not be 0%
(0x00) [min=1, max=100 ]

|*2* | | |*Check UpOrOpen command Fast effects* |

|2a | |WNCV.S.C00.Rsp(UpOrOpen) |TH sends UpOrOpen command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|2b | | |TH waits for 100-1000 ms |DUT updates its attributes

|2c | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Value has to be
0.00% (0x0000)

|2d | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Value has to be
0.00% (0x0000)

|2e | | |TH waits for 1-5 seconds movement(s) on the DUT |DUT moves
toward the open position

|*3* | | |*Check UpOrOpen command Mid-Term effects* |

|3a | |WNCV.S.A000a(OperationalStatus) |TH reads OperationalStatus
attribute from DUT |Value of bit 0..1 must be 01b & if WNCV.S.F00(LF)
value of bit 2..3 must be 01b else 00b & if WNCV.S.F01(TL) value of bit
4..5 must be 01b else 00b

|3b | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value must not be
100.00% (0x2710) [min=0, max=9999]

|3c | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value must not be 100%
(0x64) [min=0, max=99 ]

|3d | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value must not be
100.00% (0x2710) [min=0, max=9999]

|3e | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value must not be 100%
(0x64) [min=0, max=99 ]

|*4* | | |*Check StopMotion command Fast effects* |

|4a | |WNCV.S.C02.Rsp(StopMotion) |TH sends a StopMotion command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|4b | | |TH waits for 1-5 seconds end of motion(s) on the DUT |DUT slow
down and stop any movement (inertia depends of the product)

|4c | |WNCV.S.A000a(OperationalStatus) |TH reads OperationalStatus
attribute from DUT |Value of bits 0..5 must be xx000000b

|*5* | | |*Check StopMotion command longer period effects* |

|5a | | |TH waits for 100-1000 ms |DUT updates its attributes

|5b | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Value has to be
between a range of [min=0, max=9999]

|5c | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Value has to be
between a range of [min=0, max=9999]
|===

[[_notestesting_considerations_140]]
====== link:#_notestesting_considerations_140[]Notes/Testing Considerations

34d1629a on Nov 16

'''''

[[_tc_wncv_3_2_downorclose_command_operationalstatus_attribute_verification_dut_as_server]]
===== link:#_tc_wncv_3_2_downorclose_command_operationalstatus_attribute_verification_dut_as_server[]39.3.2. [TC-WNCV-3.2] DownOrClose command & OperationalStatus attribute Verification [DUT as Server]

[[_category_140]]
====== link:#_category_140[]Category

Functional

[[_purpose_140]]
====== link:#_purpose_140[]Purpose

This test case verifies the DownOrClose command functionality of the
Window Covering cluster server with the expected changes on attributes.

[[_pics_140]]
====== link:#_pics_140[]PICS

* WNCV.S

[[_preconditions_62]]
====== link:#_preconditions_62[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support at least one of these (0xFFFC) FeatureMap
attribute’s flag WNCV.S.F00(LF) and/or WNCV.S.F01(TL) |
|===

[[_required_devices_140]]
====== link:#_required_devices_140[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_110]]
====== link:#_device_topology_110[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_122]]
====== link:#_test_setup_122[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_140]]
====== link:#_test_procedure_140[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C00.Rsp(UpOrOpen) |TH sends UpOrOpen command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for 5-15 seconds movement(s) on the DUT |DUT adjusts
to a non-open position

|1c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value must not be
100.00% (0x2710) [min=0, max=9999]

|1d | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value must not be 100%
(0x64) [min=0, max=99 ]

|1e | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value must not be
100.00% (0x2710) [min=0, max=9999]

|1f | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value must not be 100%
(0x64) [min=0, max=99 ]

|*2* | | |*Check DownOrClose command Fast effects* |

|2a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|2b | | |TH waits for 100-1000 ms |DUT updates its attributes

|2c | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Value has to be
100.00% (0x2710)

|2d | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Value has to be
100.00% (0x2710)

|2e | | |TH waits for 1-5 seconds movement(s) on the DUT |DUT moves
toward the closed position

|*3* | | |*Check DownOrClose command Mid-Term effects* |

|3a | |WNCV.S.A000a(OperationalStatus) |TH reads OperationalStatus
attribute from DUT |Value of bit 0..1 must be 10b & if WNCV.S.F00(LF)
value of bit 2..3 must be 10b else 00b & if WNCV.S.F01(TL) value of bit
4..5 must be 10b else 00b

|3b | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value must not be
0.00% (0x0000) [min=1, max=10000]

|3c | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value must not be 0%
(0x00) [min=1, max=100 ]

|3d | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value must not be
0.00% (0x0000) [min=1, max=10000]

|3e | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value must not be 0%
(0x00) [min=1, max=100 ]

|*4* | | |*Check StopMotion command Fast effects* |

|4a | |WNCV.S.C02.Rsp(StopMotion) |TH sends a StopMotion command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|4b | | |TH waits for 1-5 seconds end of motion(s) on the DUT |DUT slow
down and stop any movement (inertia depends of the product)

|4c | |WNCV.S.A000a(OperationalStatus) |TH reads OperationalStatus
attribute from DUT |Value of bits 0..5 must be xx000000b

|*5* | | |*Check StopMotion command longer period effects* |

|5a | | |TH waits for 100-1000 ms |DUT updates its attributes

|5b | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Value has to be
between a range of [min=1, max=10000]

|5c | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Value has to be
between a range of [min=1, max=10000]
|===

[[_notestesting_considerations_141]]
====== link:#_notestesting_considerations_141[]Notes/Testing Considerations

34d1629a on Nov 16

'''''

[[_tc_wncv_3_3_stopmotion_command_operationalstatus_attribute_verification_dut_as_server]]
===== link:#_tc_wncv_3_3_stopmotion_command_operationalstatus_attribute_verification_dut_as_server[]39.3.3. [TC-WNCV-3.3] StopMotion command & OperationalStatus attribute Verification [DUT as Server]

[[_category_141]]
====== link:#_category_141[]Category

Functional

[[_purpose_141]]
====== link:#_purpose_141[]Purpose

This test case verifies the StopMotion command functionality of the
Window Covering cluster server.

[[_pics_141]]
====== link:#_pics_141[]PICS

* WNCV.S

[[_preconditions_63]]
====== link:#_preconditions_63[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support at least one of these (0xFFFC) FeatureMap
attribute’s flag WNCV.S.F00(LF) and/or WNCV.S.F01(TL) |
|===

[[_required_devices_141]]
====== link:#_required_devices_141[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_111]]
====== link:#_device_topology_111[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_123]]
====== link:#_test_setup_123[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_141]]
====== link:#_test_procedure_141[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for 6-8 seconds movement(s) on the DUT |DUT adjusts to
a non-close position

|1c | |WNCV.S.C00.Rsp(UpOrOpen) |TH sends UpOrOpen command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1d | | |TH waits for 1-5 seconds revert motion(s) on the DUT |DUT
adjusts to a close position

|1e | |WNCV.S.A000a(OperationalStatus) |TH reads OperationalStatus
attribute from DUT |Value must not be 0x00.

|1f | | |TH waits for 2 seconds |DUT go on for a few seconds

|*2* | | |*Check StopMotion command Fast effects* |

|2a | |WNCV.S.C02.Rsp(StopMotion) |TH sends StopMotion command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|2b | | |TH waits for 1-5 seconds end of motion(s) on the DUT |DUT slow
down and stop any movement (inertia depends of the product)

|2c | |WNCV.S.A000a(OperationalStatus) |TH reads OperationalStatus
attribute from DUT |Value of bits 0..5 must be xx000000b

|*3* | | |*Verify StopMotion command longer period effects on Lift*
|Category only for Position Aware DUT

|3a | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Store this value
for step 3c

|3b | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Store this value for
step 3c

|3c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) &
WNCV.S.A000b(TargetPositionLiftPercent100ths) |If (WNCV.S.F00(LF) &
WNCV.S.F02(PA_LF)) TH compare TargetPositionLiftPercent100ths attribute
and CurrentPositionLiftPercent100ths attribute from DUT
|TargetPositionLiftPercent100ths attribute must be equal to
CurrentPositionLiftPercent100ths attribute +/- tolerance^*^ and both
within the valid range of [min=0, max=10000]

|*4* | | |*Verify StopMotion command longer period effects on Tilt*
|Category only for Position Aware DUT

|4a | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Store this value
for step 4c

|4b | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Store this value for
step 4c

|4c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) &
WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH compare
TargetPositionTiltPercent100ths attribute and
CurrentPositionTiltPercent100ths attribute from DUT
|TargetPositionTiltPercent100ths attribute must be equal to
CurrentPositionTiltPercent100ths attribute +/- tolerance^*^ and both
within the valid range of [min=0, max=10000]
|===

^*^no actuator tolerance percentage is allowed → 0% !

[[_notestesting_considerations_142]]
====== link:#_notestesting_considerations_142[]Notes/Testing Considerations

7664cab9 on June 17

[[_tc_wncv_3_4_uporopen_command_long_run_verification_dut_as_server]]
===== link:#_tc_wncv_3_4_uporopen_command_long_run_verification_dut_as_server[]39.3.4. [TC-WNCV-3.4] UpOrOpen command Long-Run Verification [DUT as Server]

[[_category_142]]
====== link:#_category_142[]Category

Functional

[[_purpose_142]]
====== link:#_purpose_142[]Purpose

Since this category of DUT can perform very long and slow operations.
This test case verifies the UpOrOpen command functionality over a long
period of the Window Covering cluster server.

[[_pics_142]]
====== link:#_pics_142[]PICS

* WNCV.S

[[_preconditions_64]]
====== link:#_preconditions_64[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support at least one of these (0xFFFC) FeatureMap
attribute’s flag WNCV.S.F00(LF) and/or WNCV.S.F01(TL) |
|===

[[_required_devices_142]]
====== link:#_required_devices_142[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_112]]
====== link:#_device_topology_112[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_124]]
====== link:#_test_setup_124[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_142]]
====== link:#_test_procedure_142[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for 5-15 seconds movement(s) on the DUT |DUT adjusts
to a non-open position

|*2* | | |*Check UpOrOpen command Long-Run effects* |

|2a | |WNCV.S.C00.Rsp(UpOrOpen) |TH sends UpOrOpen command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|2b | | |TH waits for PIXIT.WNCV.FULLMOTION on the DUT |DUT moves toward
its fully-open position

|2c | |WNCV.S.A000a(OperationalStatus) |TH checks OperationalStatus
attribute from DUT |Motion should be over with _OperationalStatus_ Value
of bits 0..5 must be xx000000b

|*3* | | |*Verify the DUT has reached its fully-open limits* |Category
only for Position Aware DUT

|3a | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value has to be
0.00% (0x0000)

|3b | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value has to be 0%
(0x00)

|3c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value has to be
0.00% (0x0000)

|3d | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value has to be 0%
(0x00)
|===

[[_notestesting_considerations_143]]
====== link:#_notestesting_considerations_143[]Notes/Testing Considerations

34d1629a on Nov 16

[[_tc_wncv_3_5_downorclose_command_long_run_verification_dut_as_server]]
===== link:#_tc_wncv_3_5_downorclose_command_long_run_verification_dut_as_server[]39.3.5. [TC-WNCV-3.5] DownOrClose command Long-Run Verification [DUT as Server]

[[_category_143]]
====== link:#_category_143[]Category

Functional

[[_purpose_143]]
====== link:#_purpose_143[]Purpose

Since this category of DUT can perform very long and slow operations.
This test case verifies the DownOrClose command functionality over a
long period of the Window Covering cluster server.

[[_pics_143]]
====== link:#_pics_143[]PICS

* WNCV.S

[[_preconditions_65]]
====== link:#_preconditions_65[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support at least one of these (0xFFFC) FeatureMap
attribute’s flag WNCV.S.F00(LF) and/or WNCV.S.F01(TL) |
|===

[[_required_devices_143]]
====== link:#_required_devices_143[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_113]]
====== link:#_device_topology_113[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_125]]
====== link:#_test_setup_125[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_143]]
====== link:#_test_procedure_143[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C00.Rsp(UpOrOpen) |TH sends UpOrOpen command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for 5-15 seconds movement(s) on the DUT |DUT adjusts
to a non-closed position

|*2* | | |*Check DownOrClose command Long-Run effects* |

|2a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|2b | | |TH waits for PIXIT.WNCV.FULLMOTION on the DUT |DUT moves toward
its fully-closed position

|2c | |WNCV.S.A000a(OperationalStatus) |TH checks OperationalStatus
attribute from DUT |Motion should be over with _OperationalStatus_ Value
of bits 0..5 must be xx000000b

|*3* | | |*Verify the DUT has reached its fully-closed limits* |Category
only for Position Aware DUT

|3a | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value has to be
100.00% (0x2710)

|3b | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value has to be 100%
(0x64)

|3c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value has to be
100.00% (0x2710)

|3d | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value has to be 100%
(0x64)
|===

[[_notestesting_considerations_144]]
====== link:#_notestesting_considerations_144[]Notes/Testing Considerations

34d1629a on Nov 16

'''''

[[_advanced_commands_test_cases]]
==== link:#_advanced_commands_test_cases[]39.4. Advanced Commands Test Cases

'''''

[[_tc_wncv_4_1_gotoliftpercentage_command_long_run_verification_dut_as_server]]
===== link:#_tc_wncv_4_1_gotoliftpercentage_command_long_run_verification_dut_as_server[]39.4.1. [TC-WNCV-4.1] GoToLiftPercentage command Long-Run Verification [DUT as Server]

[[_category_144]]
====== link:#_category_144[]Category

Functional

[[_purpose_144]]
====== link:#_purpose_144[]Purpose

This test case verifies the GoToLiftPercentage command functionality
over a long period of the Window Covering cluster server.

[[_pics_144]]
====== link:#_pics_144[]PICS

* WNCV.S

[[_preconditions_66]]
====== link:#_preconditions_66[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support the (0xFFFC) FeatureMap attribute’s flag
WNCV.S.F00(LF) |
|===

[[_required_devices_144]]
====== link:#_required_devices_144[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_114]]
====== link:#_device_topology_114[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_126]]
====== link:#_test_setup_126[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_144]]
====== link:#_test_procedure_144[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for x^1^ seconds movement(s) on the DUT |DUT adjusts
to a non-open position

|1c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value must not be
0.00% (0x0000) [min=1, max=10000]

|*2* | | |*Check GoToLiftPercentage command 25% Long-Run effects* |

|2a | |WNCV.S.C05.Rsp(GoToLiftPercentage) |TH sends GoToLiftPercentage
command with 25% to DUT |Parameter value is 2500 Percent100ths, If
(WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)) Verify DUT responds w/ status
SUCCESS(0x00) or If only (WNCV.S.F00(LF)) DUT can responds either status
SUCCESS(0x00) or status UNSUPPORTED_COMMAND(0x81).

|2b | | |TH waits for 100-1000 ms |DUT updates its attributes

|2c | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Value has to be
equals 2500 the previous parameter

|*3* | | |*Verify the DUT has reached its 25%* |

|3a | | |TH waits for PIXIT.WNCV.FULLMOTION on the DUT |DUT moves toward
its 25% position

|3b | |WNCV.S.A000a(OperationalStatus) |TH checks OperationalStatus
attribute from DUT |Motion should be over with _OperationalStatus_ Value
of bits 0..5 must be xx000000b

|3c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value has to be
between a range of [2500 +/- tolerance^*^]

|3d | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value has to be
between a range of [25 +/- tolerance^*^]

|*4* | | |*Check GoToLiftPercentage command 75.2% Long-Run effects* |

|4a | |WNCV.S.C05.Rsp(GoToLiftPercentage) |TH sends GoToLiftPercentage
command with 75.2% to DUT |Parameter value is 7520 Percent100ths, If
(WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)) Verify DUT responds w/ status
SUCCESS(0x00) or If only (WNCV.S.F00(LF)) DUT can responds either status
SUCCESS(0x00) or status UNSUPPORTED_COMMAND(0x81).

|4b | | |TH waits for 100-1000 ms |DUT updates its attributes

|4c | |WNCV.S.A000b(TargetPositionLiftPercent100ths) |TH reads
TargetPositionLiftPercent100ths attribute from DUT |Value has to be
equals 7520 the previous parameter

|*5* | | |*Verify the DUT has reached its 75.2%* |

|5a | | |TH waits for PIXIT.WNCV.FULLMOTION on the DUT |DUT moves toward
its 75.2% position

|5b | |WNCV.S.A000a(OperationalStatus) |TH checks OperationalStatus
attribute from DUT |Motion should be over with _OperationalStatus_ Value
of bits 0..5 must be xx000000b

|5c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Value has to be
between a range of [7520 +/- tolerance^*^]

|5d | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Value has to be
between a range of [75 +/- tolerance^*^]
|===

^*^no actuator tolerance percentage is allowed → 0% !,

[[_notestesting_considerations_145]]
====== link:#_notestesting_considerations_145[]Notes/Testing Considerations

34d1629a on Nov 16, 2021

'''''

[[_tc_wncv_4_2_gototiltpercentage_command_long_run_verification_dut_as_server]]
===== link:#_tc_wncv_4_2_gototiltpercentage_command_long_run_verification_dut_as_server[]39.4.2. [TC-WNCV-4.2] GoToTiltPercentage command Long-Run Verification [DUT as Server]

[[_category_145]]
====== link:#_category_145[]Category

Functional

[[_purpose_145]]
====== link:#_purpose_145[]Purpose

This test case verifies the GoToTiltPercentage command functionality
over a long period of the Window Covering cluster server.

[[_pics_145]]
====== link:#_pics_145[]PICS

* WNCV.S

[[_preconditions_67]]
====== link:#_preconditions_67[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support the (0xFFFC) FeatureMap attribute’s flag
WNCV.S.F01(TL) |
|===

[[_required_devices_145]]
====== link:#_required_devices_145[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_115]]
====== link:#_device_topology_115[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_127]]
====== link:#_test_setup_127[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_145]]
====== link:#_test_procedure_145[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Initialize Position(s) Phase* |

|1a | |WNCV.S.C01.Rsp(DownOrClose) |TH sends DownOrClose command to DUT
|Verify DUT responds w/ status SUCCESS(0x00)

|1b | | |TH waits for x^1^ seconds movement(s) on the DUT |DUT adjusts
to a non-open position

|1c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value must not be
0.00% (0x0000) [min=1, max=10000]

|*2* | | |*Check GoToTiltPercentage 30% Long-Run effects* |

|2a | |WNCV.S.C08.Rsp(GoToTiltPercentage) |TH sends GoToTiltPercentage
command with 30% to DUT |Parameter value is 3000 Percent100ths, If
(WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)) Verify DUT responds w/ status
SUCCESS(0x00) or If only (WNCV.S.F01(TL)) DUT can responds either status
SUCCESS(0x00) or status UNSUPPORTED_COMMAND(0x81).

|2b | | |TH waits for 100-1000 ms |DUT updates its attributes

|2c | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Value has to be
equals 3000 the previous parameter

|*3* | | |*Verify the DUT has reached its 30%* |

|3a | | |TH waits for PIXIT.WNCV.FULLMOTION on the DUT |DUT moves toward
its 30% position

|3b | |WNCV.S.A000a(OperationalStatus) |TH checks OperationalStatus
attribute from DUT |Motion should be over with _OperationalStatus_ Value
of bits 0..5 must be xx000000b

|3c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value has to be
between a range of [3000 +/- tolerance^*^]

|3d | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value has to be
between a range of [30 +/- tolerance^*^]

|*4* | | |*Check GoToTiltPercentage 60.05% Long-Run effects* |

|4a | |WNCV.S.C08.Rsp(GoToTiltPercentage) |TH sends GoToTiltPercentage
command with 60.05% to DUT |Parameter value is 6005 Percent100ths, If
(WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)) Verify DUT responds w/ status
SUCCESS(0x00) or If only (WNCV.S.F01(TL)) DUT can responds either status
SUCCESS(0x00) or status UNSUPPORTED_COMMAND(0x81).

|4b | | |TH waits for 100-1000 ms |DUT updates its attributes

|4c | |WNCV.S.A000c(TargetPositionTiltPercent100ths) |TH reads
TargetPositionTiltPercent100ths attribute from DUT |Value has to be
equals 6005 the previous parameter

|*5* | | |*Verify the DUT has reached its 60.05%* |

|5a | | |TH waits for PIXIT.WNCV.FULLMOTION on the DUT |DUT moves toward
its 60.05% position

|5b | |WNCV.S.A000a(OperationalStatus) |TH checks OperationalStatus
attribute from DUT |Motion should be over with _OperationalStatus_ Value
of bits 0..5 must be xx000000b

|5c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Value has to be
between a range of [6005 +/- tolerance^*^]

|5d | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Value has to be
between a range of [60 +/- tolerance^*^]
|===

^*^no actuator tolerance percentage is allowed → 0% !,

[[_notestesting_considerations_146]]
====== link:#_notestesting_considerations_146[]Notes/Testing Considerations

34d1629a on Nov 16, 2021

[[_tc_wncv_4_3_gotoliftpercentage_command_limits_verification_dut_as_server]]
===== link:#_tc_wncv_4_3_gotoliftpercentage_command_limits_verification_dut_as_server[]39.4.3. [TC-WNCV-4.3] GoToLiftPercentage command Limits Verification [DUT as Server]

[[_category_146]]
====== link:#_category_146[]Category

Functional

[[_purpose_146]]
====== link:#_purpose_146[]Purpose

This test case verifies the GoToLiftPercentage command functionality of
the Window Covering cluster server with non expected parameters.

[[_pics_146]]
====== link:#_pics_146[]PICS

* WNCV.S

[[_preconditions_68]]
====== link:#_preconditions_68[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support the (0xFFFC) FeatureMap attribute’s flag
WNCV.S.F00(LF) |
|===

[[_required_devices_146]]
====== link:#_required_devices_146[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_116]]
====== link:#_device_topology_116[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_128]]
====== link:#_test_setup_128[]Test Setup

[[_test_procedure_146]]
====== link:#_test_procedure_146[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Verify the Lift Percent100ths and Percent attributes* |

|1a | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Store this value
for step 1c

|1b | |WNCV.S.A0008(CurrentPositionLiftPercentage) |TH reads
CurrentPositionLiftPercentage attribute from DUT |Store this value for
step 1c

|1c | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) &
WNCV.S.A0008(CurrentPositionLiftPercentage) |TH compare
CurrentPositionLiftPercent100ths attribute and
CurrentPositionLiftPercentage attribute from DUT
|CurrentPositionLiftPercentage attribute must be equal to
CurrentPositionLiftPercent100ths attribute / 100 and both within their
valid ranges of [min=0, max=100 and max=10000]

|*2* | | |*Verify the GoToLiftPercentage command with a _BadParam_* |

|2a | | |TH generates a random _BadParam_ outside the valid range e.g
(0x3000) |Store this value for step 2b

|2b | |WNCV.S.C05.Rsp(GoToLiftPercentage) |TH sends GoToLiftPercentage
command with __BadParam__^*^ to DUT |If (WNCV.S.F00(LF) &
WNCV.S.F02(PA_LF)) Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)
or If only (WNCV.S.F00(LF)) DUT can responds either status
CONSTRAINT_ERROR(0x87) or status UNSUPPORTED_COMMAND(0x81).

|*3* | | |*Verify the GoToLiftPercentage command with 10001 as
parameter* |

|3a | |WNCV.S.C05.Rsp(GoToLiftPercentage) |TH sends GoToLiftPercentage
command with 10001^*^ to DUT |If (WNCV.S.F00(LF) & WNCV.S.F02(PA_LF))
Verify DUT responds w/ status CONSTRAINT_ERROR(0x87) or If only
(WNCV.S.F00(LF)) DUT can responds either status CONSTRAINT_ERROR(0x87)
or status UNSUPPORTED_COMMAND(0x81).

|*4* | | |*Verify the GoToLiftPercentage command with 0xFFFF as
parameter* |

|4a | |WNCV.S.C05.Rsp(GoToLiftPercentage) |TH sends GoToLiftPercentage
command with 0xFFFF^*^ to DUT |If (WNCV.S.F00(LF) & WNCV.S.F02(PA_LF))
Verify DUT responds w/ status CONSTRAINT_ERROR(0x87) or If only
(WNCV.S.F00(LF)) DUT can responds either status CONSTRAINT_ERROR(0x87)
or status UNSUPPORTED_COMMAND(0x81).
|===

^*^Value refers to liftPercent100thsValue and liftPercentageValue equals
liftPercent100thsValue / 100

[[_notestesting_considerations_147]]
====== link:#_notestesting_considerations_147[]Notes/Testing Considerations

34d1629a on Nov 16, 2021

[[_tc_wncv_4_4_gototiltpercentage_command_limits_verification_dut_as_server]]
===== link:#_tc_wncv_4_4_gototiltpercentage_command_limits_verification_dut_as_server[]39.4.4. [TC-WNCV-4.4] GoToTiltPercentage command Limits Verification [DUT as Server]

[[_category_147]]
====== link:#_category_147[]Category

Functional

[[_purpose_147]]
====== link:#_purpose_147[]Purpose

This test case verifies the GoToTiltPercentage command functionality of
the Window Covering cluster server with non expected parameters.

[[_pics_147]]
====== link:#_pics_147[]PICS

* WNCV.S

[[_preconditions_69]]
====== link:#_preconditions_69[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support the (0xFFFC) FeatureMap attribute’s flag
WNCV.S.F01(TL) |
|===

[[_required_devices_147]]
====== link:#_required_devices_147[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_117]]
====== link:#_device_topology_117[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_129]]
====== link:#_test_setup_129[]Test Setup

[[_test_procedure_147]]
====== link:#_test_procedure_147[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Verify the Tilt Percent100ths and Percent attributes* |

|1a | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Store this value
for step 1c

|1b | |WNCV.S.A0009(CurrentPositionTiltPercentage) |TH reads
CurrentPositionTiltPercentage attribute from DUT |Store this value for
step 1c

|1c | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) &
WNCV.S.A0009(CurrentPositionTiltPercentage) |TH compare
CurrentPositionTiltPercent100ths attribute and
CurrentPositionTiltPercentage attribute from DUT
|CurrentPositionTiltPercentage attribute must be equal to
CurrentPositionTiltPercent100ths attribute / 100 and both within their
valid ranges of [min=0, max=100 and max=10000]

|*2* | | |*Verify the GoToTiltPercentage command with a _BadParam_* |

|2a | | |TH generates a random _BadParam_ outside the valid range e.g
(0x3000) |Store this value for step 2b

|2b | |WNCV.S.C08.Rsp(GoToTiltPercentage) |TH sends GoToTiltPercentage
command with __BadParam__^*^ to DUT |If (WNCV.S.F01(TL) &
WNCV.S.F04(PA_TL)) Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)
or If only (WNCV.S.F01(TL)) DUT can responds either status
CONSTRAINT_ERROR(0x87) or status UNSUPPORTED_COMMAND(0x81).

|*3* | | |*Verify the GoToTiltPercentage command with 10001 as
parameter* |

|3a | |WNCV.S.C08.Rsp(GoToTiltPercentage) |TH sends GoToTiltPercentage
command with 10001^*^ to DUT |If (WNCV.S.F01(TL) & WNCV.S.F04(PA_TL))
Verify DUT responds w/ status CONSTRAINT_ERROR(0x87) or If only
(WNCV.S.F01(TL)) DUT can responds either status CONSTRAINT_ERROR(0x87)
or status UNSUPPORTED_COMMAND(0x81).

|*4* | | |*Verify the GoToTiltPercentage command with 0xFFFF as
parameter* |

|4a | |WNCV.S.C08.Rsp(GoToTiltPercentage) |TH sends GoToTiltPercentage
command with 0xFFFF^*^ to DUT |If (WNCV.S.F01(TL) & WNCV.S.F04(PA_TL))
Verify DUT responds w/ status CONSTRAINT_ERROR(0x87) or If only
(WNCV.S.F01(TL)) DUT can responds either status CONSTRAINT_ERROR(0x87)
or status UNSUPPORTED_COMMAND(0x81).
|===

^*^Value refers to tiltPercent100thsValue and tiltPercentageValue equals
tiltPercent100thsValue / 100

[[_notestesting_considerations_148]]
====== link:#_notestesting_considerations_148[]Notes/Testing Considerations

34d1629a on Nov 16, 2021

[[_tc_wncv_4_5_positions_storage_verification_dut_as_server]]
===== link:#_tc_wncv_4_5_positions_storage_verification_dut_as_server[]39.4.5. [TC-WNCV-4.5] Positions Storage Verification [DUT as Server]

[[_category_148]]
====== link:#_category_148[]Category

Functional

[[_purpose_148]]
====== link:#_purpose_148[]Purpose

This test case verifies that positions are saved in non-volatile memory
for a Window Covering cluster server.

[[_pics_148]]
====== link:#_pics_148[]PICS

* WNCV.S

[[_preconditions_70]]
====== link:#_preconditions_70[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |DUT must support the (0xFFFC) FeatureMap attribute’s flag
WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) and/or WNCV.S.F01(TL) &
WNCV.S.F04(PA_TL) |
|===

[[_required_devices_148]]
====== link:#_required_devices_148[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_118]]
====== link:#_device_topology_118[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_130]]
====== link:#_test_setup_130[]Test Setup

[[_test_procedure_148]]
====== link:#_test_procedure_148[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Check GoToLiftPercentage command NVM effects* |

|1a | |WNCV.S.C05.Rsp(GoToLiftPercentage) |TH sends GoToLiftPercentage
command with 90% to DUT |Parameter value is 9000 Percent100ths, If
(WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)) Verify DUT responds w/ status
SUCCESS(0x00) or If only (WNCV.S.F00(LF)) DUT can responds either status
SUCCESS(0x00) or status UNSUPPORTED_COMMAND(0x81).

|1b | | |TH waits for 100-1000 ms |DUT updates its attributes

|1c | |WNCV.S.C02.Rsp(StopMotion) |TH sends StopMotion command to DUT
|DUT stop all motions

|1d | | |TH waits for 100-1000 ms |DUT updates its attributes

|*2* | | |*Check GoToTiltPercentage command NVM effects* |

|2a | |WNCV.S.C08.Rsp(GoToTiltPercentage) |TH sends GoToTiltPercentage
command with 90% to DUT |Parameter value is 9000 Percent100ths, If
(WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)) Verify DUT responds w/ status
SUCCESS(0x00) or If only (WNCV.S.F01(TL)) DUT can responds either status
SUCCESS(0x00) or status UNSUPPORTED_COMMAND(0x81).

|2b | | |TH waits for 100-1000 ms |DUT updates its attributes

|2c | |WNCV.S.C02.Rsp(StopMotion) |TH sends StopMotion command to DUT
|DUT stop all motions

|2d | | |TH waits for 100-1000 ms |DUT updates its attributes

|*3* | | |*Store positions and reboot* |

|3a | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Store this value
for step 3e

|3b | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Store this value
for step 3f

|3c | | |TH reboot/restart the DUT |DUT turn off

|3d | | |TH waits for 1-5 s |DUT boots

|3e | |WNCV.S.A000e(CurrentPositionLiftPercent100ths) |TH reads
CurrentPositionLiftPercent100ths attribute from DUT |Compare read value
equals w/ step 3a

|3f | |WNCV.S.A000f(CurrentPositionTiltPercent100ths) |TH reads
CurrentPositionTiltPercent100ths attribute from DUT |Compare read value
equals w/ step 3b
|===

[[_notestesting_considerations_149]]
====== link:#_notestesting_considerations_149[]Notes/Testing Considerations

`f3acdfa8` on Feb 02, 2021

'''''

[[_tc_wncv_5_1_mandatory_attributes_verification_dut_as_client]]
===== link:#_tc_wncv_5_1_mandatory_attributes_verification_dut_as_client[]39.4.6. [TC-WNCV-5.1] Mandatory Attributes Verification [DUT as Client]

[[_category_149]]
====== link:#_category_149[]Category

Functional

[[_purpose_149]]
====== link:#_purpose_149[]Purpose

This test case verifies the mandatory Attributes access of the Window
Covering cluster client with the expected values on TH server
attributes.

[[_pics_149]]
====== link:#_pics_149[]PICS

* WNCV.C

[[_required_devices_149]]
====== link:#_required_devices_149[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Server.
|2 |DUT |DUT as Client.
|===

[[_device_topology_119]]
====== link:#_device_topology_119[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_131]]
====== link:#_test_setup_131[]Test Setup

Commission DUT to TH, if not done so already. Commission DUT to with a
TH with commissioner capabilities, if not done so already.

[[_test_procedure_149]]
====== link:#_test_procedure_149[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Check Attribute defining the cluster Features* |

|1a | |\{PICS_CA_FEATUREMAP}.Read |DUT reads the (0xFFFC) FeatureMap
attribute from TH |Verify data type is map32

|*2* | | |*Check Attributes defining the product* |

|2a | |WNCV.C.A0000(Type).Read |DUT reads the Type attribute from TH
|Verify data type is enum8

|2b | |WNCV.C.A000d(EndProductType).Read |DUT reads the EndProductType
attribute from TH |Verify data type is enum8

|*3* | | |*Check Attributes defining the working status* |

|3a | |WNCV.C.A0017(Mode).Read |DUT reads the Mode attribute from TH
|Verify data type is map8

|3b | |WNCV.C.A0007(ConfigStatus).Read |DUT reads the ConfigStatus
attribute from TH |Verify data type is map8
|===

[[_notestesting_considerations_150]]
====== link:#_notestesting_considerations_150[]Notes/Testing Considerations

`f3acdfa8` on Feb 02, 2021

'''''

[[_tc_wncv_6_1_basic_commands_verification_dut_as_client]]
===== link:#_tc_wncv_6_1_basic_commands_verification_dut_as_client[]39.4.7. [TC-WNCV-6.1] Basic Commands Verification [DUT as Client]

[[_category_150]]
====== link:#_category_150[]Category

Functional

[[_purpose_150]]
====== link:#_purpose_150[]Purpose

This test case verifies the UpOrOpen, DownOrClose, StopMotion
functionality of the Window Covering cluster client with the expected
changes on TH attributes.

[[_pics_150]]
====== link:#_pics_150[]PICS

* WNCV.C

[[_preconditions_71]]
====== link:#_preconditions_71[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |TH must support at least one of these (0xFFFC) FeatureMap
attribute’s flag WNCV.S.F00(LF) and/or WNCV.S.F01(TL) |
|===

[[_required_devices_150]]
====== link:#_required_devices_150[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Server.
|2 |DUT |DUT as Client.
|===

[[_device_topology_120]]
====== link:#_device_topology_120[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_132]]
====== link:#_test_setup_132[]Test Setup

Commission DUT to TH, if not done so already. Commission DUT to with a
TH with commissioner capabilities, if not done so already.

[[_test_procedure_150]]
====== link:#_test_procedure_150[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Check UpOrOpen command* |

|1a | |WNCV.C.C00.Tx(UpOrOpen).Invoke |DUT sends UpOrOpen command to TH
|Verify TH responds w/ status SUCCESS(0x00)

|*2* | | |*Check DownOrClose command* |

|2a | |WNCV.C.C01.Tx(DownOrClose).Invoke |DUT sends DownOrClose command
to TH |Verify TH responds w/ status SUCCESS(0x00)

|*3* | | |*Check StopMotion command* |

|3a | |WNCV.C.C02.Tx(StopMotion).Invoke |DUT sends a StopMotion command
to TH |Verify TH responds w/ status SUCCESS(0x00)
|===

[[_notestesting_considerations_151]]
====== link:#_notestesting_considerations_151[]Notes/Testing Considerations

`f3acdfa8` on Feb 02, 2021

'''''

[[_tc_wncv_7_1_gotopercentage_commands_verification_dut_as_client]]
===== link:#_tc_wncv_7_1_gotopercentage_commands_verification_dut_as_client[]39.4.8. [TC-WNCV-7.1] GoToPercentage Commands Verification [DUT as Client]

[[_category_151]]
====== link:#_category_151[]Category

Functional

[[_purpose_151]]
====== link:#_purpose_151[]Purpose

This test case verifies the GoToLiftPercentage command,
GoToTiltPercentage command functionality of the Window Covering cluster
client with the expected changes on TH attributes.

[[_pics_151]]
====== link:#_pics_151[]PICS

* WNCV.C

[[_preconditions_72]]
====== link:#_preconditions_72[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |TH must support at least one of these (0xFFFC) FeatureMap
attribute’s flags WNCV.S.F00(LF) & WNCV.S.F02(PA_LF) and/or
WNCV.S.F01(TL) & WNCV.S.F04(PA_TL) |
|===

[[_required_devices_151]]
====== link:#_required_devices_151[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Server.
|2 |DUT |DUT as Client.
|===

[[_device_topology_121]]
====== link:#_device_topology_121[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_133]]
====== link:#_test_setup_133[]Test Setup

Commission DUT to TH, if not done so already. Commission DUT to with a
TH with commissioner capabilities, if not done so already.

[[_test_procedure_151]]
====== link:#_test_procedure_151[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|*1* | | |*Check GoToLiftPercentage command 50%* |

|1a | |WNCV.C.C05.Tx(GoToLiftPercentage).Invoke |DUT sends
GoToLiftPercentage command with 50% to TH |Parameter value is 5000
Percent100ths, If (WNCV.S.F00(LF) & WNCV.S.F02(PA_LF)) Verify DUT
responds w/ status SUCCESS(0x00) or If only (WNCV.S.F00(LF)) DUT can
responds either status SUCCESS(0x00) or status
UNSUPPORTED_COMMAND(0x81).

|*2* | | |*Check GoToTiltPercentage command 50%* |

|2a | |WNCV.C.C08.Tx(GoToTiltPercentage).Invoke |DUT sends
GoToTiltPercentage command with 50% to TH |Parameter value is 5000
Percent100ths, If (WNCV.S.F01(TL) & WNCV.S.F04(PA_TL)) Verify DUT
responds w/ status SUCCESS(0x00) or If only (WNCV.S.F01(TL)) DUT can
responds either status SUCCESS(0x00) or status
UNSUPPORTED_COMMAND(0x81).
|===

[[_notestesting_considerations_152]]
====== link:#_notestesting_considerations_152[]Notes/Testing Considerations

`f3acdfa8` on Feb 02, 2021

[[_thermostat_cluster_test_plan]]
== link:#_thermostat_cluster_test_plan[]**Thermostat Cluster Test Plan**

[[_pics_definition_13]]
=== link:#_pics_definition_13[]40. PICS Definition

This section covers the Thermostat Cluster Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_13]]
==== link:#_role_13[]40.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.S |Does the device implement the Thermostat cluster as a server?
|O |

|TSTAT.C |Does the device implement the Thermostat cluster as a client?
|O |
|===

[[_server_13]]
==== link:#_server_13[]40.2. Server

[[_features_9]]
===== link:#_features_9[]40.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.S.F00(HEAT) |Thermostat is capable of managing a heating device
|O |

|TSTAT.S.F01(COOL) |Thermostat is capable of managing a cooling device
|O |

|TSTAT.S.F02(OCC) |Supports Occupied and Unoccupied setpoints |O |

|TSTAT.S.F03(SCH) |Supports a weekly schedule of setpoint transitions |O
|

|TSTAT.S.F04(SB) |Supports configurable setback (or span) |O |

|TSTAT.S.F05(AUTO) |Supports a System Mode of Auto |O |

|TSTAT.S.F06(LTNE) |Supports a local temperature not exposed |O |
|===

[[_manual_controllable_10]]
===== link:#_manual_controllable_10[]40.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.S.M.HVACSystemTypeConfigurationWritable |Is the
HVACSystemTypeConfiguration attribute writeable?
|[TSTAT.S.A0009(HVACSystemTypeConfiguration)] |

|TSTAT.S.M.MinSetpointDeadBandWritable |Is the MinSetpointDeadBand
attribute writeable? |[TSTAT.S.A0019(MinSetpointDeadBand)] |
|===

[[_attributes_16]]
===== link:#_attributes_16[]40.2.3. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.S.A0000(LocalTemperature) |Does the device implement the
LocalTemperature attribute? |M |

|TSTAT.S.A0001(OutdoorTemperature) |Does the device implement the
OutdoorTemperature attribute? |O |

|TSTAT.S.A0002(Occupancy) |Does the device implement the Occupancy
attribute? |TSTAT.S.F02(OCC) |

|TSTAT.S.A0003(AbsMinHeatSetpointLimit) |Does the device implement the
AbsMinHeatSetpointLimit attribute? |[TSTAT.S.F00(HEAT)] |

|TSTAT.S.A0004(AbsMaxHeatSetpointLimit) |Does the device implement the
AbsMaxHeatSetpointLimit attribute? |[TSTAT.S.F00(HEAT)] |

|TSTAT.S.A0005(AbsMinCoolSetpointLimit) |Does the device implement the
AbsMinCoolSetpointLimit attribute? |[TSTAT.S.F01(COOL)] |

|TSTAT.S.A0006(AbsMaxCoolSetpointLimit) |Does the device implement the
AbsMaxCoolSetpointLimit attribute? |[TSTAT.S.F01(COOL)] |

|TSTAT.S.A0007(PICoolingDemand) |Does the device implement the
PICoolingDemand attribute? |[TSTAT.S.F01(COOL)] |

|TSTAT.S.A0008(PIHeatingDemand) |Does the device implement the
PIHeatingDemand attribute? |[TSTAT.S.F00(HEAT)] |

|TSTAT.S.A0009(HVACSystemTypeConfiguration) |Does the device implement
the HVACSystemTypeConfiguration attribute? |O |

|TSTAT.S.A0010(LocalTemperatureCalibration) |Does the device implement
the LocalTemperatureCalibration attribute? |O |

|TSTAT.S.A0011(OccupiedCoolingSetpoint) |Does the device implement the
OccupiedCoolingSetpoint attribute? |TSTAT.S.F01(COOL) |

|TSTAT.S.A0012(OccupiedHeatingSetpoint) |Does the device implement the
OccupiedHeatingSetpoint attribute? |TSTAT.S.F00(HEAT) |

|TSTAT.S.A0013(UnoccupiedCoolingSetpoint) |Does the device implement the
UnoccupiedCoolingSetpoint attribute? |TSTAT.S.F01(COOL) &
TSTAT.S.F02(OCC) |

|TSTAT.S.A0014(UnoccupiedHeatingSetpoint) |Does the device implement the
UnoccupiedHeatingSetpoint attribute? |TSTAT.S.F00(HEAT) &
TSTAT.S.F02(OCC) |

|TSTAT.S.A0015(MinHeatSetpointLimit) |Does the device implement the
MinHeatSetpointLimit attribute? |[TSTAT.S.F00(HEAT)] |

|TSTAT.S.A0016(MaxHeatSetpointLimit) |Does the device implement the
MaxHeatSetpointLimit attribute? |[TSTAT.S.F00(HEAT)] |

|TSTAT.S.A0017(MinCoolSetpointLimit) |Does the device implement the
MinCoolSetpointLimit attribute? |[TSTAT.S.F01(COOL)] |

|TSTAT.S.A0018(MaxCoolSetpointLimit) |Does the device implement the
MaxCoolSetpointLimit attribute? |[TSTAT.S.F01(COOL)] |

|TSTAT.S.A0019(MinSetpointDeadBand) |Does the device implement the
MinSetpointDeadBand attribute? |TSTAT.S.F05(AUTO) |

|TSTAT.S.A001a(RemoteSensing) |Does the device implement the
RemoteSensing attribute? |O |

|TSTAT.S.A001b(ControlSequenceOfOperation) |Does the device implement
the ControlSequenceOfOperation attribute? |M |

|TSTAT.S.A001c(SystemMode) |Does the device implement the SystemMode
attribute? |M |

|TSTAT.S.A001d(AlarmMask) |Does the device implement the AlarmMask
attribute? |O |

|TSTAT.S.A001e(ThermostatRunningMode) |Does the device implement the
ThermostatRunningMode attribute? |[TSTAT.S.F05(AUTO)] |

|TSTAT.S.A0020(StartOfWeek) |Does the device implement the StartOfWeek
attribute? |TSTAT.S.F03(SCH) |

|TSTAT.S.A0021(NumberOfWeeklyTransitions) |Does the device implement the
NumberOfWeeklyTransitions attribute? |TSTAT.S.F03(SCH) |

|TSTAT.S.A0022(NumberOfDailyTransitions) |Does the device implement the
NumberOfDailyTransitions attribute? |TSTAT.S.F03(SCH) |

|TSTAT.S.A0023(TemperatureSetpointHold) |Does the device implement the
TemperatureSetpointHold attribute? |O |

|TSTAT.S.A0024(TemperatureSetpointHoldDuration) |Does the device
implement the TemperatureSetpointHoldDuration attribute? |O |

|TSTAT.S.A0025(ThermostatProgrammingOperationMode) |Does the device
implement the ThermostatProgrammingOperationMode attribute? |O |

|TSTAT.S.A0029(ThermostatRunningState) |Does the device implement the
ThermostatRunningState attribute? |O |

|TSTAT.S.A0030(SetpointChangeSource) |Does the device implement the
SetpointChangeSource attribute? |O |

|TSTAT.S.A0031(SetpointChangeAmount) |Does the device implement the
SetpointChangeAmount attribute? |O |

|TSTAT.S.A0032(SetpointChangeSourceTimestamp) |Does the device implement
the SetpointChangeSourceTimestamp attribute? |O |

|TSTAT.S.A0034(OccupiedSetback) |Does the device implement the
OccupiedSetback attribute? |TSTAT.S.F04(SB) |

|TSTAT.S.A0035(OccupiedSetbackMin) |Does the device implement the
OccupiedSetbackMin attribute? |TSTAT.S.F04(SB) |

|TSTAT.S.A0036(OccupiedSetbackMax) |Does the device implement the
OccupiedSetbackMax attribute? |TSTAT.S.F04(SB) |

|TSTAT.S.A0037(UnoccupiedSetback) |Does the device implement the
UnoccupiedSetback attribute? |TSTAT.S.F04(SB) & TSTAT.S.F02(OCC) |

|TSTAT.S.A0038(UnoccupiedSetbackMin) |Does the device implement the
UnoccupiedSetbackMin attribute? |TSTAT.S.F04(SB) & TSTAT.S.F02(OCC) |

|TSTAT.S.A0039(UnoccupiedSetbackMax) |Does the device implement the
UnoccupiedSetbackMax attribute? |TSTAT.S.F04(SB) & TSTAT.S.F02(OCC) |

|TSTAT.S.A003a(EmergencyHeatDelta) |Does the device implement the
EmergencyHeatDelta attribute? |O |

|TSTAT.S.A0040(ACType) |Does the device implement the ACType attribute?
|O |

|TSTAT.S.A0041(ACCapacity) |Does the device implement the ACCapacity
attribute? |O |

|TSTAT.S.A0042(ACRefrigerantType) |Does the device implement the
ACRefrigerantType attribute? |O |

|TSTAT.S.A0043(ACCompressorType) |Does the device implement the
ACCompressorType attribute? |O |

|TSTAT.S.A0044(ACErrorCode) |Does the device implement the ACErrorCode
attribute? |O |

|TSTAT.S.A0045(ACLouverPosition) |Does the device implement the
ACLouverPosition attribute? |O |

|TSTAT.S.A0046(ACCoilTemperature) |Does the device implement the
ACCoilTemperature attribute? |O |

|TSTAT.S.A0047(ACCapacityFormat) |Does the device implement the
ACCapacityFormat attribute? |O |
|===

[[_commands_received_6]]
===== link:#_commands_received_6[]40.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.S.C00.Rsp(SetpointRaiseLower) |Does the device implement
receiving the SetpointRaiseLower command? |M |

|TSTAT.S.C01.Rsp(SetWeeklySchedule) |Does the device implement receiving
the SetWeeklySchedule command? |TSTAT.S.F03(SCH) |

|TSTAT.S.C02.Rsp(GetWeeklySchedule) |Does the device implement receiving
the GetWeeklySchedule command? |TSTAT.S.F03(SCH) |

|TSTAT.S.C03.Rsp(ClearWeeklySchedule) |Does the device implement
receiving the ClearWeeklySchedule command? |TSTAT.S.F03(SCH) |

|TSTAT.S.C04.Rsp(GetRelayStatusLog) |Does the device implement receiving
the GetRelayStatusLog command? |O |The GetRelayStatusLog command may not
supported in Matter 1.0.
|===

[[_commands_generated_5]]
===== link:#_commands_generated_5[]40.2.5. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.S.C00.Tx(GetWeeklyScheduleResponse) |Does the device implement
sending the GetWeeklyScheduleResponse command? |TSTAT.S.F03(SCH) |

|TSTAT.S.C01.Tx(GetRelayStatusLogResponse) |Does the device implement
sending the GetRelayStatusLogResponse command? |O |The
GetRelayStatusLogResponse command may not supported in Matter 1.0.
|===

[[_client_6]]
==== link:#_client_6[]40.3. Client

[[_commands_received_7]]
===== link:#_commands_received_7[]40.3.1. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.C.C00.Rsp(GetWeeklyScheduleResponse) |Does the device implement
receiving the GetWeeklyScheduleResponse command? |O |

|TSTAT.C.C01.Rsp(GetRelayStatusLogResponse) |Does the device implement
receiving the GetRelayStatusLogResponse command? |O |The
GetRelayStatusLogResponse command may not supported in Matter 1.0.
|===

[[_commands_generated_6]]
===== link:#_commands_generated_6[]40.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TSTAT.C.C00.Tx(SetpointRaiseLower) |Does the device implement sending
the SetpointRaiseLower command? |O |

|TSTAT.C.C01.Tx(SetWeeklySchedule) |Does the device implement sending
the SetWeeklySchedule command? |O |

|TSTAT.C.C02.Tx(GetWeeklySchedule) |Does the device implement sending
the GetWeeklySchedule command? |O |

|TSTAT.C.C03.Tx(ClearWeeklySchedule) |Does the device implement sending
the ClearWeeklySchedule command? |O |

|TSTAT.C.C04.Tx(GetRelayStatusLog) |Does the device implement sending
the GetRelayStatusLog command? |O |The GetRelayStatusLog command may not
supported in Matter 1.0.
|===

[[_test_case_list_13]]
=== link:#_test_case_list_13[]41. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-TSTAT-1.1 |Global attributes with server as DUT
|TC-TSTAT-2.1 |Attributes with server as DUT
|TC-TSTAT-2.2 |Setpoint Test Cases with server as DUT
|TC-TSTAT-3.2 |Functionality with client as DUT
|===

[[_test_cases_13]]
=== link:#_test_cases_13[]42. Test Cases

'''''

[[_generic_test_cases_10]]
==== link:#_generic_test_cases_10[]42.1. Generic test cases

'''''

[[_tc_tstat_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_tstat_1_1_global_attributes_with_server_as_dut[]42.1.1. [TC-TSTAT-1.1] Global attributes with server as DUT

[[_category_152]]
====== link:#_category_152[]Category

Functional conformance

[[_purpose_152]]
====== link:#_purpose_152[]Purpose

This test case verifies that the DUT can provide the Thermostat Cluster
global attributes

[[_pics_152]]
====== link:#_pics_152[]PICS

* TSTAT.S

[[_required_devices_152]]
====== link:#_required_devices_152[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_122]]
====== link:#_device_topology_122[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_134]]
====== link:#_test_setup_134[]Test Setup

Commission DUT to TH

[[_test_procedure_152]]
====== link:#_test_procedure_152[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | | |TH reads the _ClusterRevision attribute_ from the DUT |Verify
that the DUT response indicates that the ClusterRevision attribute has
the value 6.

|3 | | |TH reads the _FeatureMap attribute_ from the DUT |Verify that
the DUT response indicates that the FeatureMap attribute has +
* bit 0 set to 1 if the DUT is capable of managing a heating device
(TSTAT.S.F00(HEAT) is true) +
* bit 1 set to 1 if the DUT is capable of managing a cooling device
(TSTAT.S.F01(COOL) is true) +
* bit 2 set to 1 if the DUT supports Occupied and Unoccupied setpoints
(TSTAT.S.F02(OCC) is true) +
* bit 3 set to 1 if the DUT supports a weekly schedule of setpoint
transitions (TSTAT.S.F03(SCH) is true) +
* bit 4 set to 1 if the DUT supports configurable setback (or span)
(TSTAT.S.F04(SB) is true) +
* bit 5 set to 1 if the DUT supports a System Mode of Auto
(TSTAT.S.F05(AUTO) is true). * bit 6 set to 1 if the DUT supports local
temperature not exposed (TSTAT.S.F06(LTNE) is true).

|4 | | |TH reads the _AttributeList attribute_ from the DUT a|
Verify that the DUT response provides a list of supported attributes. +

This list SHALL include all mandatory attributes: 0, 27 and 28. +
Depending on its feature support it SHALL also contain following
mandatory attributes: +
if TSTAT.S.F01(COOL): 17 +
if TSTAT.S.F02(OCC): 2 +
if TSTAT.S.F00(HEAT): 18 +
if TSTAT.S.F01(COOL) & TSTAT.S.F02(OCC): 19 +
if TSTAT.S.F00(HEAT) & TSTAT.S.F02(OCC): 20 +
if TSTAT.S.F05(AUTO): 25 +
if TSTAT.S.F03(SCH): 32, 33 and 34 +
if TSTAT.S.F04(SB): 52, 53 and 54 +
if TSTAT.S.F04(SB) & TSTAT.S.F02(OCC): 55, 56 and 57. +
It should also include the global attributes ClusterRevision,
FeatureMap, AttributeList, AcceptedCommandList and GeneratedCommandList
(value 65533, 65532, 65531, 65529 and 65528) +

Further it may contain these optional attribute: 1, 9, 16, 26, 29, 35,
36, 37, 41, 48, 49, 50, 58, 64, 65, 66, 67, 68, 69, 70 and 71. +
Depending on its feature support it MAY also support following optional
attributes: +
if TSTAT.S.F00(HEAT): 3, 4, 8, 21 and 22 +
if TSTAT.S.F01(COOL): 5, 6, 7, 23 and 24 +
if TSTAT.S.F05(AUTO): 30. +

Optionally the list can also contain manufacturer specific attribute
IDs.

|5 | | |TH reads the _AcceptedCommandList attribute_ from the DUT a|
Verify that the DUT response provides a list of supported commands. +

This list SHALL include the mandatory command: 0. +

If TSTAT.S.F03(SCH) it SHALL also contain these mandatory commands: 1, 2
and 3. +

Optionally the list may also contain the command ID 4 or manufacturer
specific command IDs.

|6 | | |TH reads the _GeneratedCommandList attribute_ from the DUT
|Verify that the DUT response provides a list of supported commands. +
If the _AcceptedCommandList attribute_ contains a 2 (GetWeeklySchedule),
this attribute SHALL have a 0 (GetWeeklyScheduleResponse) in its list. +
If the _AcceptedCommandList attribute_ contains a 4 (GetRelayStatusLog),
this attribute SHALL have a 1 (GetRelayStatusLogResponse) in its list.

|7 | | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. +
For this cluster the list is usually empty but it can contain
manufacturer specific event IDs.
|===

[[_notestesting_considerations_153]]
====== link:#_notestesting_considerations_153[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec git revision
c4688d430620af534f51e6e002e2ac13deed2223

'''''

[[_server_as_dut_5]]
==== link:#_server_as_dut_5[]42.2. Server as DUT

'''''

[[_tc_tstat_2_1_attributes_with_server_as_dut]]
===== link:#_tc_tstat_2_1_attributes_with_server_as_dut[]42.2.1. [TC-TSTAT-2.1] Attributes with server as DUT

[[_category_153]]
====== link:#_category_153[]Category

Functional conformance

[[_purpose_153]]
====== link:#_purpose_153[]Purpose

This test case verifies that the DUT can respond to Thermostat Cluster
attribute read commands.

[[_pics_153]]
====== link:#_pics_153[]PICS

* TSTAT.S

[[_required_devices_153]]
====== link:#_required_devices_153[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_123]]
====== link:#_device_topology_123[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_135]]
====== link:#_test_setup_135[]Test Setup

Commission DUT to TH

[[_test_procedure_153]]
====== link:#_test_procedure_153[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |TSTAT.S.A0000(LocalTemperature) |TH reads the _LocalTemperature
attribute_ from the DUT |Verify that the DUT responds with an int16
value or NULL.

|3 | |TSTAT.S.A0001(OutdoorTemperature) |TH reads the
_OutdoorTemperature attribute_ from the DUT |Verify that the DUT
responds with an int16 value or NULL.

|4 | |TSTAT.S.A0002(Occupancy) |TH reads the _Occupancy attribute_ from
the DUT |Verify that the DUT responds with a map8 value. +
The value has to be 0x00 or 0x01.

|5 | |TSTAT.S.A0003(AbsMinHeatSetpointLimit) |TH reads the
_AbsMinHeatSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 1.

|6 | |TSTAT.S.A0004(AbsMaxHeatSetpointLimit) |TH reads the
_AbsMaxHeatSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 2.

|7 | |TSTAT.S.A0005(AbsMinCoolSetpointLimit) |TH reads the
_AbsMinCoolSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 1.

|8 | |TSTAT.S.A0006(AbsMaxCoolSetpointLimit) |TH reads the
_AbsMaxCoolSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 2.

|9 | |TSTAT.S.A0007(PICoolingDemand) |TH reads the _PICoolingDemand
attribute_ from the DUT |Verify that the DUT responds with a uint8
value. +
The value has to be in the range of 0 to 100.

|10 | |TSTAT.S.A0008(PIHeatingDemand) |TH reads the _PIHeatingDemand
attribute_ from the DUT |Verify that the DUT responds with a uint8
value. +
The value has to be in the range of 0 to 100.

|11 | |TSTAT.S.A0009(HVACSystemTypeConfiguration) |TH reads the
_HVACSystemTypeConfiguration attribute_ from the DUT |Verify that the
DUT responds with a map8 value. +
The value has to be in the range of 0x00 to 0x3f.

|12 | |TSTAT.S.A0010(LocalTemperatureCalibration) |TH reads the
_LocalTemperatureCalibration attribute_ from the DUT |Verify that the
DUT responds with an int8 value. +
The value has to be in the range of -25 to 25.

|13 | |TSTAT.S.A0011(OccupiedCoolingSetpoint) |TH reads the
_OccupiedCoolingSetpoint attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 5.

|14 | |TSTAT.S.A0012(OccupiedHeatingSetpoint) |TH reads the
_OccupiedHeatingSetpoint attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 5.

|15 | |TSTAT.S.A0013(UnoccupiedCoolingSetpoint) |TH reads the
_UnoccupiedCoolingSetpoint attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 6.

|16 | |TSTAT.S.A0014(UnoccupiedHeatingSetpoint) |TH reads the
_UnoccupiedHeatingSetpoint attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 6.

|17 | |TSTAT.S.A0015(MinHeatSetpointLimit) |TH reads the
_MinHeatSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 3.

|18 | |TSTAT.S.A0016(MaxHeatSetpointLimit) |TH reads the
_MaxHeatSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 4.

|19 | |TSTAT.S.A0017(MinCoolSetpointLimit) |TH reads the
_MinCoolSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 3.

|20 | |TSTAT.S.A0018(MaxCoolSetpointLimit) |TH reads the
_MaxCoolSetpointLimit attribute_ from the DUT |Verify that the DUT
responds with an int16 value. See also Note 4.

|21 | |TSTAT.S.A0019(MinSetpointDeadBand) |TH reads the
_MinSetpointDeadBand attribute_ from the DUT |Verify that the DUT
responds with an int8 value. +
The value has to be in the range of 0 to 25.

|22 | |TSTAT.S.A001a(RemoteSensing) |TH reads the _RemoteSensing
attribute_ from the DUT |Verify that the DUT responds with a map8
value. +
The value has to be in the range of 0x00 to 0x07.

|23 | |TSTAT.S.A001b(ControlSequenceOfOperation) |TH reads the
_ControlSequenceOfOperation attribute_ from the DUT |Verify that the DUT
responds with an enum8 value. +
The value has to be in the range of 0 to 5.

|24 | |TSTAT.S.A001c(SystemMode) |TH reads the _SystemMode attribute_
from the DUT |Verify that the DUT responds with an enum8 value. +
The value has to be in the range of 0 to 9.

|25 | |TSTAT.S.A001d(AlarmMask) |TH reads the _AlarmMask attribute_ from
the DUT |Verify that the DUT responds with a map8 value. +
The value has to be in the range of 0x00 to 0x07.

|26 | |TSTAT.S.A001e(ThermostatRunningMode) |TH reads the
_ThermostatRunningMode attribute_ from the DUT |Verify that the DUT
responds with an enum8 value. +
The value has to be 0, 3 or 4.

|27 | |TSTAT.S.A0020(StartOfWeek) |TH reads the _StartOfWeek attribute_
from the DUT |Verify that the DUT responds with an enum8 value. +
The value has to be in the range of 0 to 6.

|28 | |TSTAT.S.A0021(NumberOfWeeklyTransitions) |TH reads the
_NumberOfWeeklyTransitions attribute_ from the DUT |Verify that the DUT
responds with a uint8 value.

|29 | |TSTAT.S.A0022(NumberOfDailyTransitions) |TH reads the
_NumberOfDailyTransitions attribute_ from the DUT |Verify that the DUT
responds with a uint8 value.

|30 | |TSTAT.S.A0023(TemperatureSetpointHold) |TH reads the
_TemperatureSetpointHold attribute_ from the DUT |Verify that the DUT
responds with an enum8 value. +
The value has to 0 or 1

|31 | |TSTAT.S.A0024(TemperatureSetpointHoldDuration) |TH reads the
_TemperatureSetpointHoldDuration attribute_ from the DUT |Verify that
the DUT responds with a uint16 value or NULL. +
The value has to be in the range of 0 to 1440.

|32 | |TSTAT.S.A0025(ThermostatProgrammingOperationMode) |TH reads the
_ThermostatProgrammingOperationMode attribute_ from the DUT |Verify that
the DUT responds with a map8 value. +
The value has to be in the range of 0x00 to 0x07.

|33 | |TSTAT.S.A0029(ThermostatRunningState) |TH reads the
_ThermostatRunningState attribute_ from the DUT |Verify that the DUT
responds with a map16 value. +
The value has to be in the range of 0x00 to 0x7F.

|34 | |TSTAT.S.A0030(SetpointChangeSource) |TH reads the
_SetpointChangeSource attribute_ from the DUT |Verify that the DUT
responds with an enum8 value. +
The value has to be in the range of 0 to 2.

|35 | |TSTAT.S.A0031(SetpointChangeAmount) |TH reads the
_SetpointChangeAmount attribute_ from the DUT |Verify that the DUT
responds with an int16 value or NULL.

|36 | |TSTAT.S.A0032(SetpointChangeSourceTimestamp) |TH reads the
_SetpointChangeSourceTimestamp attribute_ from the DUT |Verify that the
DUT responds with a utc value.

|37 | |TSTAT.S.A0034(OccupiedSetback) |TH reads the _OccupiedSetback
attribute_ from the DUT |Verify that the DUT responds with a uint8 value
or NULL.

|38 | |TSTAT.S.A0035(OccupiedSetbackMin) |TH reads the
_OccupiedSetbackMin attribute_ from the DUT |Verify that the DUT
responds with a uint8 value or NULL.

|39 | |TSTAT.S.A0036(OccupiedSetbackMax) |TH reads the
_OccupiedSetbackMax attribute_ from the DUT |Verify that the DUT
responds with a uint8 value or NULL.

|40 | |TSTAT.S.A0037(UnoccupiedSetback) |TH reads the _UnoccupiedSetback
attribute_ from the DUT |Verify that the DUT responds with a uint8 value
or NULL.

|41 | |TSTAT.S.A0038(UnoccupiedSetbackMin) |TH reads the
_UnoccupiedSetbackMin attribute_ from the DUT |Verify that the DUT
responds with a uint8 value or NULL.

|42 | |TSTAT.S.A0039(UnoccupiedSetbackMax) |TH reads the
_UnoccupiedSetbackMax attribute_ from the DUT |Verify that the DUT
responds with a uint8 value or NULL.

|43 | |TSTAT.S.A003a(EmergencyHeatDelta) |TH reads the
_EmergencyHeatDelta attribute_ from the DUT |Verify that the DUT
responds with a uint8 value.

|44 | |TSTAT.S.A0040(ACType) |TH reads the _ACType attribute_ from the
DUT |Verify that the DUT responds with an enum8 value. +
The value has to be in the range of 0 to 4.

|45 | |TSTAT.S.A0041(ACCapacity) |TH reads the _ACCapacity attribute_
from the DUT |Verify that the DUT responds with a uint16 value.

|46 | |TSTAT.S.A0042(ACRefrigerantType) |TH reads the _ACRefrigerantType
attribute_ from the DUT |Verify that the DUT responds with an enum8
value. +
The value has to be in the range of 0 to 3.

|47 | |TSTAT.S.A0043(ACCompressorType) |TH reads the _ACCompressorType
attribute_ from the DUT |Verify that the DUT responds with an enum8
value. +
The value has to be in the range of 0 to 3.

|48 | |TSTAT.S.A0044(ACErrorCode) |TH reads the _ACErrorCode attribute_
from the DUT |Verify that the DUT responds with a map32 value.

|49 | |TSTAT.S.A0045(ACLouverPosition) |TH reads the _ACLouverPosition
attribute_ from the DUT |Verify that the DUT responds with an enum8
value. +
The value has to be in the range of 1 to 5.

|50 | |TSTAT.S.A0046(ACCoilTemperature) |TH reads the _ACCoilTemperature
attribute_ from the DUT |Verify that the DUT responds with an int16
value or NULL.

|51 | |TSTAT.S.A0047(ACCapacityFormat) |TH reads the _ACCapacityFormat
attribute_ from the DUT |Verify that the DUT responds with an enum8
value. +
The value has to be 0.
|===

[width="100%",cols="50%,50%",]
|===
a|
Note

a|
Constraints if the AUTO feature is supported

1 If TSTAT.S.F05(AUTO): AbsMinHeatSetpointLimit <=
(AbsMinCoolSetpointLimit - MinSetpointDeadBand)

2 If TSTAT.S.F05(AUTO): AbsMaxHeatSetpointLimit <=
(AbsMaxCoolSetpointLimit - MinSetpointDeadBand)

3 If TSTAT.S.F05(AUTO): MinHeatSetpointLimit <= (MinCoolSetpointLimit -
MinSetpointDeadBand)

4 If TSTAT.S.F05(AUTO): MaxHeatSetpointLimit <= (MaxCoolSetpointLimit -
MinSetpointDeadBand)

5 If TSTAT.S.F05(AUTO): OccupiedHeatingSetpoint <=
(OccupiedCoolingSetpoint - MinSetpointDeadBand)

6 If TSTAT.S.F05(AUTO): UnoccupiedHeatingSetpoint <=
(UnoccupiedCoolingSetpoint - MinSetpointDeadBand)

|===

[[_notestesting_considerations_154]]
====== link:#_notestesting_considerations_154[]Notes/Testing Considerations

Spec git revision c4688d430620af534f51e6e002e2ac13deed2223 Test Steps 3,
4, 9, 10, 11, 12, 15, 16, 22, 26 and 30 to 51 cannot be executed with
V1.0 SDK

[[_tc_tstat_2_2_setpoint_test_cases_with_server_as_dut]]
===== link:#_tc_tstat_2_2_setpoint_test_cases_with_server_as_dut[]42.2.2. [TC-TSTAT-2.2] Setpoint Test Cases with server as DUT

[[_category_154]]
====== link:#_category_154[]Category

Functional

[[_purpose_154]]
====== link:#_purpose_154[]Purpose

This test case verifies the setpoint functionality of the Thermostat
cluster server.

[[_pics_154]]
====== link:#_pics_154[]PICS

* TSTAT.S

[[_required_devices_154]]
====== link:#_required_devices_154[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_124]]
====== link:#_device_topology_124[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_136]]
====== link:#_test_setup_136[]Test Setup

Commission DUT to TH

[[_test_procedure_154]]
====== link:#_test_procedure_154[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2a | |TSTAT.S.A0011(OccupiedCoolingSetpoint) |Test Harness Client reads
OccupiedCoolingSetpoint from Server DUT and verifies that the value is
within range MinCoolSetpointLimit to MaxCoolSetpointLimit, writes a
value back that is different but valid^5^, then reads it back again to
confirm the successful write. |Read value have to to be equal to the
written value.

|2b | |TSTAT.S.A0011(OccupiedCoolingSetpoint) |Test Harness Client then
attempts to write OccupiedCoolingSetpoint below the MinCoolSetpointLimit
and above the MaxCoolSetpointLimit and confirms that the device does not
accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|2c | |TSTAT.S.A0011(OccupiedCoolingSetpoint) |If TSTAT.S.F05(AUTO) +
*LowerLimit* = Max(MinCoolSetpointLimit, (OccupiedHeatingSetpoint +
MinSetpointDeadBand)) +
else +
*LowerLimit* = MinCoolSetpointLimit +
 +
Test Harness Client then attempts to write OccupiedCoolingSetpoint to
both of the limits of *LowerLimit* & MaxCoolSetpointLimit and confirms
that the device does accept the value. See also Note 5. |Write command
should succeed without an error

|3a | |TSTAT.S.A0012(OccupiedHeatingSetpoint) |Test Harness Client reads
OccupiedHeatingSetpoint from Server DUT and verifies that the value is
within range MinHeatSetpointLimit to MaxHeatSetpointLimit, writes a
value back that is different but valid^5^, then reads it back again to
confirm the successful write. |Read value have to to be equal to the
written value.

|3b | |TSTAT.S.A0012(OccupiedHeatingSetpoint) |Test Harness Client then
attempts to write OccupiedHeatingSetpoint below the MinHeatSetpointLimit
and above the MaxHeatSetpointLimit and confirms that the device does not
accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|3c | |TSTAT.S.A0012(OccupiedHeatingSetpoint) |If TSTAT.S.F05(AUTO) +
*UpperLimit* = Min(MaxHeatSetpointLimit, (OccupiedCoolingSetpoint -
MinSetpointDeadBand)) +
else +
*UpperLimit* = MaxHeatSetpointLimit +
 +
Test Harness Client then attempts to write OccupiedHeatingSetpoint to
both of the limits of MinHeatSetpointLimit & *UpperLimit* and confirms
that the device does accept the value. See also Note 5. |Write command
should succeed without an error

|4a | |TSTAT.S.A0013(UnoccupiedCoolingSetpoint) |Test Harness Client
reads UnoccupiedCoolingSetpoint from Server DUT and verifies that the
value is within range MinCoolSetpointLimit to MaxCoolSetpointLimit,
writes a value back that is different but valid^6^, then reads it back
again to confirm the successful write. |Read value have to to be equal
to the written value.

|4b | |TSTAT.S.A0013(UnoccupiedCoolingSetpoint) |Test Harness Client
then attempts to write UnoccupiedCoolingSetpoint below the
MinCoolSetpointLimit and above the MaxCoolSetpointLimit and confirms
that the device does not accept the value. |Write command should return
the error CONSTRAINT_ERROR (0x87)

|4c | |TSTAT.S.A0013(UnoccupiedCoolingSetpoint) |If TSTAT.S.F05(AUTO) +
*LowerLimit* = Max(MinCoolSetpointLimit, (UnoccupiedCoolingSetpoint +
MinSetpointDeadBand)) +
else +
*LowerLimit* = MinCoolSetpointLimit +
 +
Test Harness Client then attempts to write UnoccupiedCoolingSetpoint to
both of the limits of *LowerLimit* & MaxCoolSetpointLimit and confirms
that the device does accept the value. See also Note 6. |Write command
should succeed without an error

|5a | |TSTAT.S.A0014(UnoccupiedHeatingSetpoint) |Test Harness Client
reads UnoccupiedHeatingSetpoint from Server DUT and verifies that the
value is within range MinHeatSetpointLimit to MaxHeatSetpointLimit,
writes a value back that is different but valid^6^, then reads it back
again to confirm the successful write. |Read value have to to be equal
to the written value.

|5b | |TSTAT.S.A0014(UnoccupiedHeatingSetpoint) |Test Harness Client
then attempts to write UnoccupiedHeatingSetpoint below the
MinHeatSetpointLimit and above the MaxHeatSetpointLimit and confirms
that the device does not accept the value. |Write command should return
the error CONSTRAINT_ERROR (0x87)

|5c | |TSTAT.S.A0014(UnoccupiedHeatingSetpoint) |If TSTAT.S.F05(AUTO) +
*UpperLimit* = Min(MaxHeatSetpointLimit, (UnoccupiedCoolingSetpoint -
MinSetpointDeadBand)) +
else +
*UpperLimit* = MaxHeatSetpointLimit +
 +
Test Harness Client then attempts to write UnoccupiedHeatingSetpoint to
both of the limits of MinHeatSetpointLimit & *UpperLimit* and confirms
that the device does accept the value. See also Note 6. |Write command
should succeed without an error

|6a | |TSTAT.S.A0015(MinHeatSetpointLimit) |Test Harness Client reads
MinHeatSetpointLimit from Server DUT and verifies that the value is
within range AbsMinHeatSetpointLimit to MaxHeatSetpointLimit, writes a
value back that is different but valid^3^, then reads it back again to
confirm the successful write. |Read value have to to be equal to the
written value.

|6b | |TSTAT.S.A0015(MinHeatSetpointLimit) |Test Harness Client then
attempts to write MinHeatSetpointLimit below the AbsMinHeatSetpointLimit
and above the MaxHeatSetpointLimit and confirms that the device does not
accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|6c | |TSTAT.S.A0015(MinHeatSetpointLimit) |If TSTAT.S.F05(AUTO) +
*UpperLimit* = Min(MaxHeatSetpointLimit, (MinCoolSetpointLimit -
MinSetpointDeadBand)) +
else +
*UpperLimit* = MaxHeatSetpointLimit +
 +
Test Harness Client then attempts to write MinHeatSetpointLimit to both
of the limits of AbsMinHeatSetpointLimit & *UpperLimit* and confirms
that the device does accept the value. See also Note 3. |Write command
should succeed without an error

|7a | |TSTAT.S.A0016(MaxHeatSetpointLimit) |Test Harness Client reads
MaxHeatSetpointLimit from Server DUT and verifies that the value is
within range MinHeatSetpointLimit to AbsMaxHeatSetpointLimit, writes a
value back that is different but valid^4^, then reads it back again to
confirm the successful write. |Read value have to to be equal to the
written value.

|7b | |TSTAT.S.A0016(MaxHeatSetpointLimit) |Test Harness Client then
attempts to write MaxHeatSetpointLimit below the MinHeatSetpointLimit
and above the AbsMaxHeatSetpointLimit and confirms that the device does
not accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|7c | |TSTAT.S.A0016(MaxHeatSetpointLimit) |If TSTAT.S.F05(AUTO) +
*UpperLimit* = Min(AbsMaxHeatSetpointLimit, (MaxCoolSetpointLimit -
MinSetpointDeadBand)) +
else +
*UpperLimit* = AbsMaxHeatSetpointLimit +
 +
Test Harness Client then attempts to write MaxHeatSetpointLimit to both
of the limits of MinHeatSetpointLimit & *UpperLimit* and confirms that
the device does accept the value. See also Note 4. |Write command should
succeed without an error

|8a | |TSTAT.S.A0017(MinCoolSetpointLimit) |Test Harness Client reads
MinCoolSetpointLimit from Server DUT and verifies that the value is
within range AbsMinCoolSetpointLimit to MaxCoolSetpointLimit, writes a
value back that is different but valid^3^, then reads it back again to
confirm the successful write. |Read value have to to be equal to the
written value.

|8b | |TSTAT.S.A0017(MinCoolSetpointLimit) |Test Harness Client then
attempts to write MinCoolSetpointLimit below the AbsMinCoolSetpointLimit
and above the MaxCoolSetpointLimit and confirms that the device does not
accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|8c | |TSTAT.S.A0017(MinCoolSetpointLimit) |If TSTAT.S.F05(AUTO) +
*LowerLimit* = Max(AbsMinCoolSetpointLimit, (MinHeatSetpointLimit +
MinSetpointDeadBand)) +
else +
*LowerLimit* = AbsMinCoolSetpointLimit +
 +
Test Harness Client then attempts to write MinCoolSetpointLimit to both
of the limits of *LowerLimit* & MaxCoolSetpointLimit and confirms that
the device does accept the value. See also Note 3. |Write command should
succeed without an error

|9a | |TSTAT.S.A0018(MaxCoolSetpointLimit) |Test Harness Client reads
MaxCoolSetpointLimit from Server DUT and verifies that the value is
within range MinCoolSetpointLimit to AbsMaxCoolSetpointLimit, writes a
value back that is different but valid^4^, then reads it back again to
confirm the successful write. |Read value have to to be equal to the
written value.

|9b | |TSTAT.S.A0018(MaxCoolSetpointLimit) |Test Harness Client then
attempts to write MaxCoolSetpointLimit below the MinCoolSetpointLimit
and above the AbsMaxCoolSetpointLimit and confirms that the device does
not accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|9c | |TSTAT.S.A0018(MaxCoolSetpointLimit) |If TSTAT.S.F05(AUTO) +
*LowerLimit* = Max(MinCoolSetpointLimit, (MaxHeatSetpointLimit +
MinSetpointDeadBand)) +
else +
*LowerLimit* = MinCoolSetpointLimit +
 +
Test Harness Client then attempts to write MaxCoolSetpointLimit to both
of the limits of *LowerLimit* & AbsMaxCoolSetpointLimit and confirms
that the device does accept the value. See also Note 4. |Write command
should succeed without an error

|10a | |TSTAT.S.A0015(MinHeatSetpointLimit)
TSTAT.S.A0016(MaxHeatSetpointLimit) |Set MinHeatSetpointLimit and
MaxHeatSetpointLimit back to reasonable values. (f.e. 700 & 3000 == 7°C
& 30°C) |Write command should succeed without an error

|10b | |TSTAT.S.A0017(MinCoolSetpointLimit)
TSTAT.S.A0018(MaxCoolSetpointLimit) |Set MinCoolSetpointLimit and
MaxCoolSetpointLimit back to reasonable values. (f.e. 1600 & 3200 ==
16°C & 32°C) |Write command should succeed without an error

|11a | |TSTAT.S.A0019(MinSetpointDeadBand),
TSTAT.S.M.MinSetpointDeadBandWritable |Test Harness Client reads
MinSetpointDeadBand from Server DUT and verifies that the value is
within range 0 (0°C) to 25 (2.5°C), writes a value back that is
different but valid^1,2,3,4,5,6^, then reads it back again to confirm
the successful write. |Read value have to to be equal to the written
value.

|11b | |TSTAT.S.A0019(MinSetpointDeadBand),
TSTAT.S.M.MinSetpointDeadBandWritable |Test Harness Client then attempts
to write MinSetpointDeadBand below 0 and above 25 and confirms that the
device does not accept the value. |Write command should return the error
CONSTRAINT_ERROR (0x87)

|11c | |TSTAT.S.A0019(MinSetpointDeadBand),
TSTAT.S.M.MinSetpointDeadBandWritable |Test Harness Client then attempts
to write MinSetpointDeadBand to both of the limits of 0 & 25 and
confirms that the device does accept the value. See also Note 1, 2, 3,
4, 5 and 6. |Write command should succeed without an error

|12 | |TSTAT.S.A001b(ControlSequenceOfOperation) a|
Valid values for ControlSequenceOfOperation: +
_TSTAT.S.F01(COOL)_: *CoolingOnly* (0), *CoolingWithReheat* (1) +
_TSTAT.S.F00(HEAT)_: *HeatingOnly* (2), *HeatingWithReheat* (3) +
_TSTAT.S.F01(COOL)_ & _TSTAT.S.F00(HEAT)_: *CoolingAndHeating* (4),
*CoolingAndHeatingWithReheat*(5)

Test Harness Client reads ControlSequenceOfOperation from Server DUT and
verifies that the value is valid. Test Harness sends a Write Attribute
command for ControlSequenceOfOperation with a new valid value, and then
reads it back again to confirm the successful write.

|Read value have to to be equal to the written value.

|13 | |TSTAT.S.C00.Rsp(SetpointRaiseLower) & TSTAT.S.F00(HEAT) |Test
Harness Client sets OccupiedHeatingSetpoint to default value. +
Test Harness sends Server DUT a SetpointRaiseLower command with the mode
field set to Heat (0x00), and the amount set to 0xE2 (-30 units = -3
degrees). +
Test Harness Client then reads back OccupiedHeatingSetpoint to confirm
the success of the write. |Read value have to to be equal to default
value - 3 degrees

|14 | |TSTAT.S.C00.Rsp(SetpointRaiseLower) & TSTAT.S.F00(HEAT) |Test
Harness Client sets OccupiedHeatingSetpoint to default value. +
Test Harness sends Server DUT a SetpointRaiseLower command with the mode
field set to Heat (0x00), and the amount set to 0x1E (+30 units = +3
degrees). Test Harness Client then reads back OccupiedHeatingSetpoint to
confirm the success of the write. |Read value have to to be equal to
default value + 3 degrees

|15 | |TSTAT.S.C00.Rsp(SetpointRaiseLower) & TSTAT.S.F01(COOL) |Test
Harness Client sets OccupiedCoolingSetpoint to default value. +
Test Harness Client sends Server DUT a SetpointRaiseLower command with
the mode field set to Cool (0x01), and the amount set to 0xE2 (-30 units
= -3 degrees). +
Test Harness Client then reads back OccupiedCoolingSetpoint to confirm
the success of the write. |Read value have to to be equal to default
value - 3 degrees

|16 | |TSTAT.S.C00.Rsp(SetpointRaiseLower) & TSTAT.S.F01(COOL) |Test
Harness Client sets OccupiedCoolingSetpoint to default value. +
Test Harness Client sends Server DUT a SetpointRaiseLower command with
the mode field set to Cool (0x01), and the amount set to 0x1E (+30 units
= +3 degrees). +
Test Harness Client then reads back OccupiedCoolingSetpoint to confirm
the success of the write. |Read value have to to be equal to default
value + 3 degrees

|17 | |TSTAT.S.C00.Rsp(SetpointRaiseLower) & TSTAT.S.F00(HEAT) &
TSTAT.S.F01(COOL) |Test Harness Client sets OccupiedCoolingSetpoint and
OccupiedHeatingSetpoint to default values. +
Test Harness Client sends Server DUT a SetpointRaiseLower command with
the mode field set to both (0x02), and the amount set to 0xE2 (-30 units
= -3 degrees) . +
Test Harness Client then reads back OccupiedCoolingSetpoint and
OccupiedHeatingSetpoint to confirm the success of the write. |Both read
values have to to be equal to its default value - 3 degrees

|18 | |TSTAT.S.C00.Rsp(SetpointRaiseLower) & TSTAT.S.F00(HEAT) &
TSTAT.S.F01(COOL) |Test Harness Client sets OccupiedCoolingSetpoint and
OccupiedHeatingSetpoint to default values. +
Test Harness Client sends Server DUT a SetpointRaiseLower command with
the mode field set to both (0x02), and the amount set to 0x1E (+30 units
= +3 degrees). +
Test Harness client then reads back OccupiedCoolingSetpoint and
OccupiedHeatingSetpoint to confirm the success of the write. |Both read
values have to to be equal to its default value + 3 degrees
|===

[width="100%",cols="50%,50%",]
|===
a|
Note

a|
Constraints if the AUTO feature is supported

1 If TSTAT.S.F05(AUTO): AbsMinHeatSetpointLimit <=
(AbsMinCoolSetpointLimit - MinSetpointDeadBand)

2 If TSTAT.S.F05(AUTO): AbsMaxHeatSetpointLimit <=
(AbsMaxCoolSetpointLimit - MinSetpointDeadBand)

3 If TSTAT.S.F05(AUTO): MinHeatSetpointLimit <= (MinCoolSetpointLimit -
MinSetpointDeadBand)

4 If TSTAT.S.F05(AUTO): MaxHeatSetpointLimit <= (MaxCoolSetpointLimit -
MinSetpointDeadBand)

5 If TSTAT.S.F05(AUTO): OccupiedHeatingSetpoint <=
(OccupiedCoolingSetpoint - MinSetpointDeadBand)

6 If TSTAT.S.F05(AUTO): UnoccupiedHeatingSetpoint <=
(UnoccupiedCoolingSetpoint - MinSetpointDeadBand)

|===

[[_notestesting_considerations_155]]
====== link:#_notestesting_considerations_155[]Notes/Testing Considerations

Spec git revision c4688d430620af534f51e6e002e2ac13deed2223

'''''

[[_client_as_dut_2]]
==== link:#_client_as_dut_2[]42.3. Client as DUT

'''''

[[_tc_tstat_3_2_functionality_with_client_as_dut]]
===== link:#_tc_tstat_3_2_functionality_with_client_as_dut[]42.3.1. [TC-TSTAT-3.2] Functionality with client as DUT

[[_category_155]]
====== link:#_category_155[]Category

Functional

[[_purpose_155]]
====== link:#_purpose_155[]Purpose

This test case verifies the functionality of the Thermostat cluster
client.

[[_pics_155]]
====== link:#_pics_155[]PICS

* TSTAT.C

[[_required_devices_155]]
====== link:#_required_devices_155[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_125]]
====== link:#_device_topology_125[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_137]]
====== link:#_test_setup_137[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_155]]
====== link:#_test_procedure_155[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |TSTAT.C.C00.Tx(SetpointRaiseLower) |DUT increases the temperature
by sending a SetpointRaiseLower command to the Test Harness, with a
valid Mode argument (0, 1 or 2) and a reasonable positive value that is
supported by the DUT. |If TSTAT.C.C00.Tx(SetpointRaiseLower), Test
Harness receives the SetpointRaiseLower command from the DUT. Verify the
command has two parameters: +
ID 0: the type is an enum8, the value has to be 0, 1 or 2. +
ID 1: the type is an int8, the value is between 1 and 127.

|2 | |TSTAT.C.C00.Tx(SetpointRaiseLower) |DUT lowers the temperature by
sending a SetpointRaiseLower command to the Test Harness, with a valid
Mode argument (0, 1 or 2) and a reasonable negative value that is
supported by the DUT. |If TSTAT.C.C00.Tx(SetpointRaiseLower), Test
Harness receives the SetpointRaiseLower command from the DUT. Verify the
command has two parameters: +
ID 0: the type is an enum8, the value has to be 0, 1 or 2. +
ID 1: the type is an int8, the value is between -127 and -1.

|3 | |TSTAT.C.C04.Tx(GetRelayStatusLog) |DUT sends a GetRelayStatusLog
command to the Test Harness. |If TSTAT.C.C04.Tx(GetRelayStatusLog), Test
Harness receives the GetRelayStatusLog command from the DUT. The command
has no parameters. +
The GetRelayStatusLog command may not supported in Matter 1.0.
|===

[[_notestesting_considerations_156]]
====== link:#_notestesting_considerations_156[]Notes/Testing Considerations

Spec git revision c4688d430620af534f51e6e002e2ac13deed2223

[[_software_diagnostics_cluster_test_plan]]
== link:#_software_diagnostics_cluster_test_plan[]**Software Diagnostics Cluster Test Plan**

[[_pics_definition_14]]
=== link:#_pics_definition_14[]43. PICS Definition

This section covers the Software Diagnostics Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_14]]
==== link:#_role_14[]43.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGSW.S |Does the device implement the Software Diagnostics cluster as a
server? |O |

|DGSW.C |Does the device implement the Software Diagnostics cluster as a
client? |O |
|===

[[_server_14]]
==== link:#_server_14[]43.2. Server

[[_features_10]]
===== link:#_features_10[]43.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGSW.S.F00(Watermarks) |The metrics for high watermark related to
memory consumption. |O |
|===

[[_attributes_17]]
===== link:#_attributes_17[]43.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGSW.S.A0000(ThreadMetrics) |Implement the ThreadMetrics struct
attribute. |O |

|DGSW.S.A0001(CurrentHeapFree) |Indicate the current amount of heap
memory, in bytes, that are free for allocation. |O |

|DGSW.S.A0002(CurrentHeapUsed) |Indicate the current amount of heap
memory, in bytes, that is being used. |O |

|DGSW.S.A0003(CurrentHeapHighWatermark) |Indicate the maximum amount of
heap memory, in bytes, that has been used by the Node.
|DGSW.S.F00(Watermarks) |
|===

[[_events_2]]
===== link:#_events_2[]43.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGSW.S.E00(SoftwareFault) |Implement the SoftwareFault event. |O |
|===

[[_commands_received_8]]
===== link:#_commands_received_8[]43.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGSW.S.C00.Rsp(ResetWatermarks) |Resets the StackFreeMinimum field of
the ThreadMetrics attribute and the CurrentHeapHighWatermark attribute.
|DGSW.S.F00(Watermarks) |
|===

[[_client_7]]
==== link:#_client_7[]43.3. Client

[[_commands_generated_7]]
===== link:#_commands_generated_7[]43.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGSW.C.C00.Tx(ResetWatermarks) |Resets the StackFreeMinimum field of
the ThreadMetrics attribute and the CurrentHeapHighWatermark attribute.
|O |
|===

[[_test_case_list_14]]
=== link:#_test_case_list_14[]44. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-DGSW-1.1 |Global Attributes with DUT as Server
|TC-DGSW-2.1 |Attributes [\{DUT_Sever}]
|TC-DGSW-2.2 |Event Functionality [\{DUT_Sever}]
|TC-DGSW-2.3 |Command Received [\{DUT_Sever}]
|TC-DGSW-3.2 |Commands Generated [DUT as Client]
|===

[[_test_cases_14]]
=== link:#_test_cases_14[]45. Test Cases

[[_generic_test_cases_11]]
==== link:#_generic_test_cases_11[]45.1. Generic Test Cases

[[_tc_dgsw_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_dgsw_1_1_global_attributes_with_dut_as_server[]45.1.1. [TC-DGSW-1.1] Global Attributes with DUT as Server

[[_category_156]]
====== link:#_category_156[]Category

Functional conformance.

[[_purpose_156]]
====== link:#_purpose_156[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_156]]
====== link:#_pics_156[]PICS

* DGSW.S

[[_required_devices_156]]
====== link:#_required_devices_156[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_156]]
====== link:#_test_procedure_156[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if DGSW.S.F00(Watermarks)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0000: SHALL be included if and only if DGSW.S.A0000(ThreadMetrics)

- 0x0001: SHALL be included if and only if DGSW.S.A0001(CurrentHeapFree)

- 0x0002: SHALL be included if and only if DGSW.S.A0002(CurrentHeapUsed)

The list include entries based on feature support: +
- 0x0003: SHALL be included if DGSW.S.F00(Watermarks) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list MAY include these optional entries: +
- 0x00: SHALL be included if and only if DGSW.S.E00(SoftwareFault)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list include entries based on feature support: +
- 0x00: SHALL be included if DGSW.S.F00(Watermarks) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_157]]
====== link:#_notestesting_considerations_157[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_6]]
==== link:#_server_as_dut_6[]45.2. Server as DUT

'''''

[[_tc_dgsw_2_1_attributes_dut_sever]]
===== link:#_tc_dgsw_2_1_attributes_dut_sever[]45.2.1. [TC-DGSW-2.1] Attributes [\{DUT_Sever}]

[[_category_157]]
====== link:#_category_157[]Category

Functional

[[_purpose_157]]
====== link:#_purpose_157[]Purpose

This test case verifies the behavior of the non-global attributes of the
software diagnostics cluster server.

[[_pics_157]]
====== link:#_pics_157[]PICS

* DGSW.S

[[_required_devices_157]]
====== link:#_required_devices_157[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_126]]
====== link:#_device_topology_126[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_138]]
====== link:#_test_setup_138[]Test Setup

Commission DUT to TH

[[_test_procedure_157]]
====== link:#_test_procedure_157[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.12.7.1 |DGSW.S.A0000(ThreadMetrics) |TH reads a list of
ThreadMetrics struct attribute from DUT. |The data type in each field of
the struct must match the value listed in the specification(s) Table in
11.12.6.1. ThreadMetrics Struct. The Id field of the list is mandatory
and shall match with Node assigned ID unique-per-thread. Name field
shall be set to vendor specific strings. StackFreeCurrent field shall
indicates the current amount of stack memory, in bytes, not being
utilized by the respective thread. StackFreeMinimum field shall indicate
the minimum amount of available stack memory in bytes. This value can be
reset by a node reboot. StackSize field shall indicate the amount of
memory allocated for use by the respective thread.

|3 |11.12.7.1 |DGSW.S.A0001(CurrentHeapFree) |TH reads an attribute
value from DUT. |The value will indicate the current amount of
unutilized heap memory in bytes.

|4 |11.12.7.1 |DGSW.S.A0002(CurrentHeapUsed) |TH reads an attribute
value from DUT. |The value will indicate the current amount of used heap
memory in bytes.

|5 |11.12.7.1 |DGSW.S.A0003(CurrentHeapHighWatermark) |TH reads an
attribute value from DUT. |The value will indicate the maximum amount of
heap memory being used in bytes. This value can be reset by a node
reboot.
|===

[[_notestesting_considerations_158]]
====== link:#_notestesting_considerations_158[]Notes/Testing Considerations

For 2, StackFreeCurrent, StackFreeMinimum, StackSize field of
ThreadMetrics struct are out of cope of SDK V1.0 implementation.
Validation of those fields will not be considered until post 1.0 SDK
implementation is complete.

[[_tc_dgsw_2_2_event_functionality_dut_sever]]
===== link:#_tc_dgsw_2_2_event_functionality_dut_sever[]45.2.2. [TC-DGSW-2.2] Event Functionality [\{DUT_Sever}]

[[_category_158]]
====== link:#_category_158[]Category

Functional

[[_purpose_158]]
====== link:#_purpose_158[]Purpose

This test case verifies the event reporting functionality of the
software diagnostics cluster server.

[[_pics_158]]
====== link:#_pics_158[]PICS

* DGSW.S

[[_required_devices_158]]
====== link:#_required_devices_158[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_127]]
====== link:#_device_topology_127[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_139]]
====== link:#_test_setup_139[]Test Setup

Commission DUT to TH

[[_test_procedure_158]]
====== link:#_test_procedure_158[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.12.8.1 |DGSW.S.E00(SoftwareFault) |DUT sends an event report to
TH. TH reads a list of SoftwareFault struct from DUT. |The data type in
each field of the struct must match the value listed in the
specification(s) Table in 11.12.8.1. SoftwareFault Struct. The Id field
of the struct is mandatory and shall be set with software thread ID that
last software fault occurred. Name field shall be set to vendor specific
name strings that last software fault occurred. FaultRecording field
shall be set by a vendor specific payload in octstr format.
|===

[[_notestesting_considerations_159]]
====== link:#_notestesting_considerations_159[]Notes/Testing Considerations

[[_tc_dgsw_2_3_command_received_dut_sever]]
===== link:#_tc_dgsw_2_3_command_received_dut_sever[]45.2.3. [TC-DGSW-2.3] Command Received [\{DUT_Sever}]

[[_category_159]]
====== link:#_category_159[]Category

Functional

[[_purpose_159]]
====== link:#_purpose_159[]Purpose

This test case verifies the command functionality of the software
diagnostics cluster server.

[[_pics_159]]
====== link:#_pics_159[]PICS

* DGSW.S

[[_required_devices_159]]
====== link:#_required_devices_159[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_128]]
====== link:#_device_topology_128[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_140]]
====== link:#_test_setup_140[]Test Setup

Commission DUT to TH

[[_test_procedure_159]]
====== link:#_test_procedure_159[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2a |11.12.7.2 |DGSW.S.C00.Rsp(ResetWatermarks) |TH sends
ResetWatermarks to DUT. |Upon DUT’s reception of this command, DUT will
reset StackFreeMinimum of ThreadMetrics attribute to StackFreeCurrent
and reset CurrentHeapHighWatermark attribute to CurrentHeapUsed
attribute.

|2b |11.12.7.1 |DGSW.S.A0000(ThreadMetrics) |TH reads a list of
ThreadMetrics struct attributes from DUT. |StackFreeMinimum and
StackFreeCurrent attribute values of ThreadMetrics are matched.

|2c |11.12.7.1 |DGSW.S.A0003(CurrentHeapHighWatermark) |TH reads
CurrentHeapHighWatermark attribute from DUT. |The CurrentHeapUsed is
less than or equal to the CurrentHeapHighWatermark.

|2d |11.12.7.1 |DGSW.S.A0002(CurrentHeapUsed) |TH reads a
CurrentHeapUsed attribute value from DUT. |The value will indicate the
current amount of used heap memory in bytes.
|===

[[_notestesting_considerations_160]]
====== link:#_notestesting_considerations_160[]Notes/Testing Considerations

For 2b, StackFreeCurrent and StackFreeMinimum of ThreadMetrics struct
are out of cope of SDK V1.0 implementation. Command execution of those
fields will not be considered until post 1.0 SDK implementation is
complete.

'''''

[[_client_as_dut_3]]
==== link:#_client_as_dut_3[]45.3. Client as DUT

'''''

[[_tc_dgsw_3_2_commands_generated_dut_as_client]]
===== link:#_tc_dgsw_3_2_commands_generated_dut_as_client[]45.3.1. [TC-DGSW-3.2] Commands Generated [DUT as Client]

[[_category_160]]
====== link:#_category_160[]Category

Functional

[[_purpose_160]]
====== link:#_purpose_160[]Purpose

This test case verifies a client can properly send software diagnostics
commands.

[[_pics_160]]
====== link:#_pics_160[]PICS

* DGSW.C

[[_required_devices_160]]
====== link:#_required_devices_160[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Server
|2 |DUT |DUT as Client
|===

[[_device_topology_129]]
====== link:#_device_topology_129[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_141]]
====== link:#_test_setup_141[]Test Setup

Commission TH to DUT

[[_test_procedure_160]]
====== link:#_test_procedure_160[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission TH to DUT |

|2 |11.12.7.2 |DGSW.C.C00.Tx(ResetWatermarks) |DUT sends ResetWatermarks
to TH. |Verify TH receives command and no errors are seen.
|===

[[_notestesting_considerations_161]]
====== link:#_notestesting_considerations_161[]Notes/Testing Considerations

'''''

[[_ethernet_network_diagnostics_cluster_test_plan]]
== link:#_ethernet_network_diagnostics_cluster_test_plan[]**Ethernet Network Diagnostics Cluster Test Plan**

[[_pics_definition_15]]
=== link:#_pics_definition_15[]46. PICS Definition

This section covers the Ethernet Network Diagnostics Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_15]]
==== link:#_role_15[]46.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGETH.S |Does the device implement the Ethernet Network Diagnostics
cluster as a server? |O |

|DGETH.C |Does the device implement the Ethernet Network Diagnostics
cluster as a client? |O |
|===

[[_server_15]]
==== link:#_server_15[]46.2. Server

[[_features_11]]
===== link:#_features_11[]46.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGETH.S.F00(PKTCNT) |Counts for the number of received and transmitted
packets on the ethernet interface. |O |

|DGETH.S.F01(ERRCNT) |Counts for the number of errors during the
reception and transmission of packets on the ethernet interface. |O |
|===

[[_attributes_18]]
===== link:#_attributes_18[]46.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGETH.S.A0000(PHYRate) |Does the device implement the PHYRate
attribute? |O |

|DGETH.S.A0001(FullDuplex) |Does the device implement the FullDuplex
attribute? |O |

|DGETH.S.A0002(PacketRxCount) |Does the device implement the
PacketRxCount attribute? |DGETH.S.F00(PKTCNT) |

|DGETH.S.A0003(PacketTxCount) |Does the device implement the
PacketTxCount attribute? |DGETH.S.F00(PKTCNT) |

|DGETH.S.A0004(TxErrCount) |Does the device implement the TxErrCount
attribute? |DGETH.S.F01(ERRCNT) |

|DGETH.S.A0005(CollisionCount) |Does the device implement the
CollisionCount attribute? |DGETH.S.F01(ERRCNT) |

|DGETH.S.A0006(OverrunCount) |Does the device implement the OverrunCount
attribute? |DGETH.S.F01(ERRCNT) |

|DGETH.S.A0007(CarrierDetect) |Does the device implement the
CarrierDetect attribute? |O |

|DGETH.S.A0008(TimeSinceReset) |Does the device implement the
TimeSinceReset attribute? |O |
|===

[[_commands_received_9]]
===== link:#_commands_received_9[]46.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGETH.S.C00.Rsp(ResetCount) |Does the device implement the ResetCounts
command? |DGETH.S.F00(PKTCNT) | DGETH.S.F01(ERRCNT) |
|===

[[_client_8]]
==== link:#_client_8[]46.3. Client

[[_commands_generated_8]]
===== link:#_commands_generated_8[]46.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGETH.C.C00.Tx(ResetCount) |Does the device implement the ResetCounts
command? |O |
|===

[[_test_case_list_15]]
=== link:#_test_case_list_15[]47. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-DGETH-1.1 |Global Attributes with DUT as Server
|TC-DGETH-2.1 |Attributes [DUT as Server]
|TC-DGETH-2.2 |Command Received [DUT as Server]
|TC-DGETH-3.2 |Command Generated [DUT as Client]
|===

[[_test_cases_15]]
=== link:#_test_cases_15[]48. Test Cases

[[_generic_test_cases_12]]
==== link:#_generic_test_cases_12[]48.1. Generic Test Cases

[[_tc_dgeth_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_dgeth_1_1_global_attributes_with_dut_as_server[]48.1.1. [TC-DGETH-1.1] Global Attributes with DUT as Server

[[_category_161]]
====== link:#_category_161[]Category

Functional conformance.

[[_purpose_161]]
====== link:#_purpose_161[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_161]]
====== link:#_pics_161[]PICS

* DGETH.S

[[_required_devices_161]]
====== link:#_required_devices_161[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_161]]
====== link:#_test_procedure_161[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if DGETH.S.F00(PKTCNT)

- bit 1: SHALL be 1 if and only if DGETH.S.F01(ERRCNT)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0000: SHALL be included if and only if DGETH.S.A0000(PHYRate)

- 0x0001: SHALL be included if and only if DGETH.S.A0001(FullDuplex)

- 0x0007: SHALL be included if and only if DGETH.S.A0007(CarrierDetect)

- 0x0008: SHALL be included if and only if DGETH.S.A0008(TimeSinceReset)

The list include entries based on feature support: +
- 0x0002: SHALL be included if DGETH.S.F00(PKTCNT) and SHALL NOT be
included otherwise.

- 0x0003: SHALL be included if DGETH.S.F00(PKTCNT) and SHALL NOT be
included otherwise.

- 0x0004: SHALL be included if DGETH.S.F01(ERRCNT) and SHALL NOT be
included otherwise.

- 0x0005: SHALL be included if DGETH.S.F01(ERRCNT) and SHALL NOT be
included otherwise.

- 0x0006: SHALL be included if DGETH.S.F01(ERRCNT) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list include entries based on feature support: +
- 0x00: SHALL be included if DGETH.S.F00(PKTCNT) or DGETH.S.F01(ERRCNT)
and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_162]]
====== link:#_notestesting_considerations_162[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_7]]
==== link:#_server_as_dut_7[]48.2. Server as DUT

'''''

[[_tc_dgeth_2_1_attributes_dut_as_server]]
===== link:#_tc_dgeth_2_1_attributes_dut_as_server[]48.2.1. [TC-DGETH-2.1] Attributes [DUT as Server]

[[_category_162]]
====== link:#_category_162[]Category

Functional

[[_purpose_162]]
====== link:#_purpose_162[]Purpose

This test case verifies the behavior of the non-global attributes of the
ethernet network diagnostics cluster server.

[[_pics_162]]
====== link:#_pics_162[]PICS

* DGETH.S

[[_required_devices_162]]
====== link:#_required_devices_162[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_130]]
====== link:#_device_topology_130[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_142]]
====== link:#_test_setup_142[]Test Setup

Commission DUT to TH

[[_test_procedure_162]]
====== link:#_test_procedure_162[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.15.4.1 |DGETH.S.A0000(PHYRate) |TH reads PHYRate attribute from
DUT. |The data type must match the value listed in the specification(s)
Table 11.15.3.1. PHYRate ENUM. If the interface is not configured or
operational, NULL should be read.

|3 |11.15.4.2 |DGETH.S.A0001(FullDuplex) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and indicates the node is utilizing the full-duplex
operation mode. If the interface is not configured or operational, NULL
should be read.

|4 |11.15.4.3 |DGETH.S.A0002(PacketRxCount) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the number of packets received
on ethernet network interface. Upon a node reboot, the value will be
reset to 0. The attribute should not be subscribed.

|5 |11.15.4.4 |DGETH.S.A0003(PacketTxCount) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the number of packets
successfully transferred on ethernet network interface. Upon a node
reboot, the value will be reset to 0. The attribute should not be
subscribed.

|6 |11.15.4.5 |DGETH.S.A0004(TxErrCount) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the number of failed packet
transmission on ethernet network interface. Upon a node reboot, the
value will be reset to 0. The attribute should not be subscribed.

|7 |11.15.4.6 |DGETH.S.A0005(CollisionCount) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the number of collision
occurred while transmitting packets on ethernet network interface. Upon
a node reboot, the value will be reset to 0. The attribute should not be
subscribed.

|8 |11.15.4.7 |DGETH.S.A0006(OverrunCount) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the number of packets dropped
due to lack of buffer memory on ethernet network interface. Upon a node
reboot, the value will be reset to 0. The attribute should not be
subscribed.

|9 |11.15.4.8 |DGETH.S.A0007(CarrierDetect) |TH reads a attribute value
from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the presence of carrier detect
control signal on ethernet network interface. The attribute should not
be subscribed. If the interface is not configured or operational, NULL
should be read.

|10 |11.15.4.9 |DGETH.S.A0008(TimeSinceReset) |TH reads a attribute
value from DUT. |The data type must match the value listed in the
specification(s) and the value indicates the duration of time, in
minutes, since the ethernet network interface has been reset for any
reason. The attribute should not be subscribed.
|===

[[_notestesting_considerations_163]]
====== link:#_notestesting_considerations_163[]Notes/Testing Considerations

[[_tc_dgeth_2_2_command_received_dut_as_server]]
===== link:#_tc_dgeth_2_2_command_received_dut_as_server[]48.2.2. [TC-DGETH-2.2] Command Received [DUT as Server]

[[_category_163]]
====== link:#_category_163[]Category

Functional

[[_purpose_163]]
====== link:#_purpose_163[]Purpose

This test case verifies the command functionality of the ethernet
network diagnostics cluster server.

[[_pics_163]]
====== link:#_pics_163[]PICS

* DGETH.S

[[_required_devices_163]]
====== link:#_required_devices_163[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_131]]
====== link:#_device_topology_131[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_143]]
====== link:#_test_setup_143[]Test Setup

Commission DUT to TH

[[_test_procedure_163]]
====== link:#_test_procedure_163[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2a |11.15.4.1 |DGETH.S.A0000(PHYRate) |TH reads PHYRate attribute from
DUT. Repeat this 10 times. |The purpose of this test step is to generate
some controllable CASE traffic to help evaluate "ResetCount" command
below.

|2b |11.15.4.3 |DGETH.S.A0002(PacketRxCount) |TH reads PacketRxCount
attribute value from DUT. |Record the value for comparison.

|2c |11.15.4.4 |DGETH.S.A0003(PacketTxCount) |TH reads PacketTxCount
attribute value from DUT. |Record the value for comparison.

|2d |11.15.4.5 |DGETH.S.A0004(TxErrCount) |TH reads TxErrCount attribute
value from DUT. |Record the value for comparison.

|2e |11.15.4.6 |DGETH.S.A0005(CollisionCount) |TH reads CollisionCount
attribute value from DUT. |Record the value for comparison.

|2f |11.15.4.7 |DGETH.S.A0006(OverrunCount) |TH reads OverrunCount
attribute value from DUT. |Record the value for comparison.

|2g |11.15.5 |DGETH.S.C00.Rsp(ResetCount) |TH sends ResetCounts to DUT
|Upon DUT’s reception of this command, DUT will reset PacketRxCount,
PacketTxCount, TxErrCount, CollisionCount, OverrunCount attribute
values.

|2h |11.15.4.3 |DGETH.S.A0002(PacketRxCount) |TH reads PacketRxCount
attribute value from DUT. |Check if the value read is less than the
value from step 2b.

|2i |11.15.4.4 |DGETH.S.A0003(PacketTxCount) |TH reads PacketTxCount
attribute value from DUT. |Check if the value read is less than the
value from step 2c.

|2j |11.15.4.5 |DGETH.S.A0004(TxErrCount) |TH reads TxErrCount attribute
value from DUT. |Check if the value read is less than or equal to the
value from step 2d.

|2k |11.15.4.6 |DGETH.S.A0005(CollisionCount) |TH reads CollisionCount
attribute value from DUT. |Check if the value read is less than or equal
to the value from step 2e.

|2l |11.15.4.7 |DGETH.S.A0006(OverrunCount) |TH reads OverrunCount
attribute value from DUT. |Check if the value read is less than or equal
to the value from step 2f.
|===

[[_notestesting_considerations_164]]
====== link:#_notestesting_considerations_164[]Notes/Testing Considerations

There are a few assumptions for this test case; no non-Matter traffic
and no packet loss on the network, and Matter traffic is all happening
over a single CASE connection under interactive chip-tool control.

[[_tc_dgeth_3_2_command_generated_dut_as_client]]
===== link:#_tc_dgeth_3_2_command_generated_dut_as_client[]48.2.3. [TC-DGETH-3.2] Command Generated DUT as Client]

[[_category_164]]
====== link:#_category_164[]Category

Functional

[[_purpose_164]]
====== link:#_purpose_164[]Purpose

This test case verifies a client can properly send ethernet network
diagnostics commands.

[[_pics_164]]
====== link:#_pics_164[]PICS

* DGETH.C

[[_required_devices_164]]
====== link:#_required_devices_164[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Server
|2 |DUT |DUT as Client
|===

[[_device_topology_132]]
====== link:#_device_topology_132[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_144]]
====== link:#_test_setup_144[]Test Setup

Commission TH to DUT.

[[_test_procedure_164]]
====== link:#_test_procedure_164[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission TH to DUT |

|2 |11.15.5 |DGETH.C.C00.Tx(ResetCount) |DUT sends ResetCounts to TH.
|Verify TH receives command and no errors are seen.
|===

[[_notestesting_considerations_165]]
====== link:#_notestesting_considerations_165[]Notes/Testing Considerations

[[_thread_network_diagnostics_cluster_test_plan]]
== link:#_thread_network_diagnostics_cluster_test_plan[]**Thread Network Diagnostics Cluster Test Plan**

[[_pics_definition_16]]
=== link:#_pics_definition_16[]49. PICS Definition

This section covers the Thread Diagnostics Cluster related PICS items
that are referenced in the following test cases.

[[_role_16]]
==== link:#_role_16[]49.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.S |Does the device implement the Thread Diagnostics cluster as
a server? |O |

|DGTHREAD.C |Does the device implement the Thread Diagnostics cluster as
a client? |O |
|===

[[_server_16]]
==== link:#_server_16[]49.2. Server

[[_features_12]]
===== link:#_features_12[]49.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.S.F00(PKTCNT) |Does the device implement "counts for the
number of received and transmitted packets" feature? |O |

|DGTHREAD.S.F01(ERRCNT) |Does the device implement "counts for the
number of errors that have occurred during the reception and
transmission" feature? |O |

|DGTHREAD.S.F02(MLECNT) |Does the device implement "counts for various
MLE layer happenings" feature? |O |

|DGTHREAD.S.F03(MACCNT) |Does the device implement "counts for various
MAC layer happenings" feature? |O |
|===

[[_attributes_19]]
===== link:#_attributes_19[]49.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Descrption* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.S.A0000(Channel) |Does the device implement the Channel
attribute? |M |

|DGTHREAD.S.A0001(RoutingRole) |Does the device implement the
RoutingRole attribute? |M |

|DGTHREAD.S.A0002(NetworkName) |Does the device implement the
NetworkName attribute? |M |

|DGTHREAD.S.A0003(PanId) |Does the device implement the PanId attribute?
|M |

|DGTHREAD.S.A0004(ExtendedPanId) |Does the device implement the
ExtendedPanId attribute? |M |

|DGTHREAD.S.A0005(MeshLocalPrefix) |Does the device implement the
MeshLocalPrefix attribute? |M |

|DGTHREAD.S.A0006(OverrunCount) |Does the device implement the
OverrunCount attribute? |ERRCNT |

|DGTHREAD.S.A0007(NeighborTable) |Does the device implement the
NeighborTable attribute? |M |

|DGTHREAD.S.A0008(RouteTable) |Does the device implement the RouteTable
attribute? |M |

|DGTHREAD.S.A0009(PartitionId) |Does the device implement the
PartitionId attribute? |M |

|DGTHREAD.S.A000a(Weighting) |Does the device implement the Weighting
attribute? |M |

|DGTHREAD.S.A000b(DataVersion) |Does the device implement the
DataVersion attribute? |M |

|DGTHREAD.S.A000c(StableDataVersion) |Does the device implement the
StableDataVersion attribute? |M |

|DGTHREAD.S.A000d(LeaderRouterId) |Does the device implement the
LeaderRouterId attribute? |M |

|DGTHREAD.S.A000e(DetachedRoleCount) |Does the device implement the
DetachedRoleCount attribute? |[MLECNT] |

|DGTHREAD.S.A000f(ChildRoleCount) |Does the device implement the
ChildRoleCount attribute? |[MLECNT] |

|DGTHREAD.S.A0010(RouterRoleCount) |Does the device implement the
RouterRoleCount attribute? |[MLECNT] |

|DGTHREAD.S.A0011(LeaderRoleCount) |Does the device implement the
LeaderRoleCount attribute? |[MLECNT] |

|DGTHREAD.S.A0012(AttachAttemptCount) |Does the device implement the
AttachAttemptCount attribute? |[MLECNT] |

|DGTHREAD.S.A0013(PartitionIdChangeCount) |Does the device implement the
PartitionIdChangeCount attribute? |[MLECNT] |

|DGTHREAD.S.A0014(BetterPartitionAttachAttemptCount) |Does the device
implement the BetterPartitionAttachAttemptCount attribute? |[MLECNT] |

|DGTHREAD.S.A0015(ParentChangeCount) |Does the device implement the
ParentChangeCount attribute? |[MLECNT] |

|DGTHREAD.S.A0016(TxTotalCount) |Does the device implement the
TxTotalCount attribute? |[MACCNT] |

|DGTHREAD.S.A0017(TxUnicastCount) |Does the device implement the
TxUnicastCount attribute? |[MACCNT] |

|DGTHREAD.S.A0018(TxBroadcastCount) |Does the device implement the
TxBroadcastCount attribute? |[MACCNT] |

|DGTHREAD.S.A0019(TxAckRequestedCount) |Does the device implement the
TxAckRequestedCount attribute? |[MACCNT] |

|DGTHREAD.S.A001a(TxAckedCount) |Does the device implement the
TxAckedCount attribute? |[MACCNT] |

|DGTHREAD.S.A001b(TxNoAckRequestedCount) |Does the device implement the
TxNoAckRequestedCount attribute? |[MACCNT] |

|DGTHREAD.S.A001c(TxDataCount) |Does the device implement the
TxDataCount attribute? |[MACCNT] |

|DGTHREAD.S.A001d(TxDataPollCount) |Does the device implement the
TxDataPollCount attribute? |[MACCNT] |

|DGTHREAD.S.A001e(TxBeaconCount) |Does the device implement the
TxBeaconCount attribute? |[MACCNT] |

|DGTHREAD.S.A001f(TxBeaconRequestCount) |Does the device implement the
TxBeaconRequestCount attribute? |[MACCNT] |

|DGTHREAD.S.A0020(TxOtherCount) |Does the device implement the
TxOtherCount attribute? |[MACCNT] |

|DGTHREAD.S.A0021(TxRetryCount) |Does the device implement the
TxRetryCount attribute? |[MACCNT] |

|DGTHREAD.S.A0022(TxDirectMaxRetryExpiryCount) |Does the device
implement the TxDirectMaxRetryExpiryCount attribute? |[MACCNT] |

|DGTHREAD.S.A0023(TxIndirectMaxRetryExpiryCount) |Does the device
implement the TxIndirectMaxRetryExpiryCount attribute? |[MACCNT] |

|DGTHREAD.S.A0024(TxErrCcaCount) |Does the device implement the
TxErrCcaCount attribute? |[MACCNT] |

|DGTHREAD.S.A0025(TxErrAbortCount) |Does the device implement the
TxErrAbortCount attribute? |[MACCNT] |

|DGTHREAD.S.A0026(TxErrBusyChannelCount) |Does the device implement the
TxErrBusyChannelCount attribute? |[MACCNT] |

|DGTHREAD.S.A0027(RxTotalCount) |Does the device implement the
RxTotalCount attribute? |[MACCNT] |

|DGTHREAD.S.A0028(RxUnicastCount) |Does the device implement the
RxUnicastCount attribute? |[MACCNT] |

|DGTHREAD.S.A0029(RxBroadcastCount) |Does the device implement the
RxBroadcastCount attribute? |[MACCNT] |

|DGTHREAD.S.A002a(RxDataCount) |Does the device implement the
RxDataCount attribute? |[MACCNT] |

|DGTHREAD.S.A002b(RxDataPollCount) |Does the device implement the
RxDataPollCount attribute? |[MACCNT] |

|DGTHREAD.S.A002c(RxBeaconCount) |Does the device implement the
RxBeaconCount attribute? |[MACCNT] |

|DGTHREAD.S.A002d(RxBeaconRequestCount) |Does the device implement the
RxBeaconRequestCount attribute? |[MACCNT] |

|DGTHREAD.S.A002e(RxOtherCount) |Does the device implement the
RxOtherCount attribute? |[MACCNT] |

|DGTHREAD.S.A002f(RxAddressFilteredCount) |Does the device implement the
RxAddressFilteredCount attribute? |[MACCNT] |

|DGTHREAD.S.A0030(RxDestAddrFilteredCount) |Does the device implement
the RxDestAddrFilteredCount attribute? |[MACCNT] |

|DGTHREAD.S.A0031(RxDuplicatedCount) |Does the device implement the
RxDuplicatedCount attribute? |[MACCNT] |

|DGTHREAD.S.A0032(RxErrNoFrameCount) |Does the device implement the
RxErrNoFrameCount attribute? |[MACCNT] |

|DGTHREAD.S.A0033(RxErrUnknownNeighborCount) |Does the device implement
the RxErrUnknownNeighborCount attribute? |[MACCNT] |

|DGTHREAD.S.A0034(RxErrInvalidSrcAddrCount) |Does the device implement
the RxErrInvalidSrcAddrCount attribute? |[MACCNT] |

|DGTHREAD.S.A0035(RxErrSecCount) |Does the device implement the
RxErrSecCount attribute? |[MACCNT] |

|DGTHREAD.S.A0036(RxErrFcsCount) |Does the device implement the
RxErrFcsCount attribute? |[MACCNT] |

|DGTHREAD.S.A0037(RxErrOtherCount) |Does the device implement the
RxErrOtherCount attribute? |[MACCNT] |

|DGTHREAD.S.A0038(ActiveTimestamp) |Does the device implement the
ActiveTimestamp attribute? |O |

|DGTHREAD.S.A0039(PendingTimestamp) |Does the device implement the
PendingTimestamp attribute? |O |

|DGTHREAD.S.A003a(Delay) |Does the device implement the Delay attribute?
|O |

|DGTHREAD.S.A003b(SecurityPolicy) |Does the device implement the
SecurityPolicy attribute? |M |

|DGTHREAD.S.A003c(ChannelPage0Mask) |Does the device implement the
ChannelPage0Mask attribute? |M |

|DGTHREAD.S.A003d(OperationalDatasetComponents) |Does the device
implement the OperationalDatasetComponents attribute? |M |

|DGTHREAD.S.A003e(ActiveNetworkFaults) |Does the device implement the
ActiveNetworkFaults attribute? |M |
|===

[[_events_3]]
===== link:#_events_3[]49.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.S.E00(ConnectionStatus) |Does the device implement the
ConnectionStatus event? |O |

|DGTHREAD.S.E01(NetworkFaultChange) |Does the device implement the
NetworkFaultChange event? |O |
|===

[[_commands_received_10]]
===== link:#_commands_received_10[]49.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.S.C00.Rsp(ResetCounts) |Does the device implement receiving of
ResetCounts command? |DGTHREAD.S.F01(ERRCNT) |
|===

[[_client_9]]
==== link:#_client_9[]49.3. Client

[[_attributes_20]]
===== link:#_attributes_20[]49.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.C.A0006(OverrunCount) |Does the DUT(client) have access
privileges for the OverrunCount attribute implemented on the server? |O
|
|===

[[_commands_generated_9]]
===== link:#_commands_generated_9[]49.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGTHREAD.C.C00.Tx(ResetCounts) |Does the Device(client)
invoking/generating the ResetCounts command? |O |
|===

[[_test_case_list_16]]
=== link:#_test_case_list_16[]50. Test Case List

[width="100%",cols="34%,66%",options="header",]
|===
|*TC UUID* |*Test Case Name*
|TC-DGTHREAD-1.1 |Global Attributes [DUT as Server]
|TC-DGTHREAD-2.1 |Attributes [DUT as Server]
|TC-DGTHREAD-2.2 |Attributes-Tx [DUT as Server]
|TC-DGTHREAD-2.3 |Attributes-Rx [DUT as Server]
|TC-DGTHREAD-2.4 |ResetCounts Command [DUT as Server]
|TC-DGTHREAD-2.5 |Events [DUT as Server] - REMOVED
|TC-DGTHREAD-3.4 |ResetCounts Command [DUT as Client]
|===

[[_test_cases_16]]
=== link:#_test_cases_16[]51. Test Cases

'''''

[[_generic_test_cases_13]]
==== link:#_generic_test_cases_13[]51.1. Generic Test Cases

'''''

[[_tc_dgthread_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_dgthread_1_1_global_attributes_with_dut_as_server[]51.1.1. [TC-DGTHREAD-1.1] Global Attributes with DUT as Server

[[_category_165]]
====== link:#_category_165[]Category

Functional conformance

[[_purpose_165]]
====== link:#_purpose_165[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_165]]
====== link:#_pics_165[]PICS

* DGTHREAD.S

[[_required_devices_165]]
====== link:#_required_devices_165[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_165]]
====== link:#_test_procedure_165[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if DGTHREAD.S.F00(PKTCNT)

- bit 1: SHALL be 1 if and only if DGTHREAD.S.F01(ERRCNT)

- bit 2: SHALL be 1 if and only if DGTHREAD.S.F02(MLECNT)

- bit 3: SHALL be 1 if and only if DGTHREAD.S.F03(MACCNT)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0008, 0x0009,
0x000a, 0x000b, 0x000c, 0x000d, 0x003b, 0x003c, 0x003d, 0x003e, 0xfff8,
0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0038: SHALL be included if and only if
DGTHREAD.S.A0038(ActiveTimestamp)

- 0x0039: SHALL be included if and only if
DGTHREAD.S.A0039(PendingTimestamp)

- 0x003a: SHALL be included if and only if DGTHREAD.S.A003a(Delay)

The list include entries based on feature support: +
- 0x0006: SHALL be included if and only if DGTHREAD.S.F01(ERRCNT) &
DGTHREAD.S.A0006(OverrunCount).

- 0x000e: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A000e(DetachedRoleCount).

- 0x000f: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A000f(ChildRoleCount).

- 0x0010: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0010(RouterRoleCount)

- 0x0011: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0011(LeaderRoleCount).

- 0x0012: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0012(AttachAttemptCount).

- 0x0013: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0013(PartitionIdChangeCount).

- 0x0014: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0014(BetterPartitionAttachAttemptCount).

- 0x0015: SHALL be included if and only if DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0015(ParentChangeCount).

- 0x0016: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0016(TxTotalCount).

- 0x0017: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0017(TxUnicastCount).

- 0x0018: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0018(TxBroadcastCount).

- 0x0019: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0019(TxAckRequestedCount).

- 0x001a: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A001a(TxAckedCount).

- 0x001b: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A001b(TxNoAckRequestedCount).

- 0x001c: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A001c(TxDataCount)

- 0x001d: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A001d(TxDataPollCount).

- 0x001e: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A001e(TxBeaconCount).

- 0x001f: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A001f(TxBeaconRequestCount).

- 0x0020: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0020(TxOtherCount).

- 0x0021: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0021(TxRetryCount).

- 0x0022: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0022(TxDirectMaxRetryExpiryCount).

- 0x0023: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0023(TxIndirectMaxRetryExpiryCount).

- 0x0024: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0024(TxErrCcaCount).

- 0x0025: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0025(TxErrAbortCount).

- 0x0026: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0026(TxErrBusyChannelCount).

- 0x0027: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0027(RxTotalCount).

- 0x0028: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0028(RxUnicastCount).

- 0x0029: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0029(RxBroadcastCount).

- 0x002a: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A002a(RxDataCount).

- 0x002b: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A002b(RxDataPollCount).

- 0x002c: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A002c(RxBeaconCount).

- 0x002d: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A002d(RxBeaconRequestCount).

- 0x002e: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A002e(RxOtherCount).

- 0x002f:'SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A002f(RxAddressFilteredCount).

- 0x0030: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0030(RxDestAddrFilteredCount).

- 0x0031: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0031(RxDuplicatedCount).

- 0x0032: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0032(RxErrNoFrameCount).

- 0x0033: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0033(RxErrUnknownNeighborCount).

- 0x0034: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0034(RxErrInvalidSrcAddrCount).

- 0x0035: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0035(RxErrSecCount).

- 0x0036: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0036(RxErrFcsCount).

- 0x0037: SHALL be included if and only if DGTHREAD.S.F03(MACCNT) &
DGTHREAD.S.A0037(RxErrOtherCount).

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list MAY include these optional entries: +
- 0x00: SHALL be included if and only if
DGTHREAD.S.E00(ConnectionStatus)

- 0x01: SHALL be included if and only if
DGTHREAD.S.E01(NetworkFaultChange)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list include entries based on feature support: +
- 0x00: SHALL be included if and only if DGTHREAD.S.F01(ERRCNT) &
DGTHREAD.S.C00.Rsp(ResetCounts).

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored.

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1)

|===

[[_notestesting_considerations_166]]
====== link:#_notestesting_considerations_166[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut_8]]
==== link:#_server_as_dut_8[]51.2. Server as DUT

[[_tc_dgthread_2_1_attributes_dut_server]]
===== link:#_tc_dgthread_2_1_attributes_dut_server[]51.2.1. [TC-DGTHREAD-2.1] Attributes [DUT- Server]

[[_category_166]]
====== link:#_category_166[]Category

Functional conformance

[[_purpose_166]]
====== link:#_purpose_166[]Purpose

This test case reads the attributes of the Thread Network Diagnostics
Cluster and checks for the type and length

[[_pics_166]]
====== link:#_pics_166[]PICS

* DGTHREAD.S

[[_pre_conditions]]
====== link:#_pre_conditions[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |
|===

[[_required_devices_166]]
====== link:#_required_devices_166[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_133]]
====== link:#_device_topology_133[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_145]]
====== link:#_test_setup_145[]Test Setup

[[_test_procedure_166]]
====== link:#_test_procedure_166[]Test Procedure

[width="100%",cols="5%,10%,15%,25%,45%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |11.13.7 |DGTHREAD.S.A0000(Channel) |TH reads Channel attribute value
from DUT a|
{empty}1. Verify that Channel is of the type uint16

2 Verify that the Channel attribute indicates the 802.15.4 channel
number configured on the Thread interface

|3 |11.13.7 |DGTHREAD.S.A0001(RoutingRole) |TH reads RoutingRole
attribute value from DUT a|
Verify that RoutingRole value is between 0 to 6

. Verify for the DUT type based on the values below:
+
[loweralpha]
.. 0 - Unspecified routing role
.. 1 - Unassigned - Thread Interface is not operational
.. 2 - SleepyEndDevice with RX-off-when-idle sleepy radio behavior
.. 3 - EndDevice without RX-off-when-idle sleepy radio behavior
.. 4 - RouterEligibleEndDevice
.. 5 - Router Device
.. 6 - Leader Device

|4 |11.13.7 |DGTHREAD.S.A0002(NetworkName) |TH reads Network Name
attribute value from DUT. a|
. Verify that Network name is of the type string
. Verify that maximum size of Network name is 16 bytes
. If value is NULL then verify that RoutingRole is set to 1

|5 |11.13.7 |DGTHREAD.S.A0003(PanId) |TH reads PanId attribute value
from DUT. a|
. Verify that PanId is of the type uint16
. If value is NULL then verify that RoutingRole is set to 1

|6 |11.13.7 |DGTHREAD.S.A0004(ExtendedPanId) |TH reads ExtendedPanId
attribute value from DUT. a|
. Verify that ExtendedPanId is of the type uint64
. If value is NULL then verify that RoutingRole is set to 1

|7 |11.13.7 |DGTHREAD.S.A0005(MeshLocalPrefix) |TH reads MeshLocalPrefix
attribute value from DUT. a|
. Verify that the MeshLocalPrefix follows the standard specified in
section 7.18.2.30 IPv6 Prefix
. If value is NULL then verify that RoutingRole is set to 1

|8 |11.13.7 a|
DGTHREAD.S.F01(ERRCNT) & DGTHREAD.S.A0006(OverrunCount)

|TH reads OverrunCount attribute value from DUT. a|
. Verify that OverrunCount is of the type uint64
. If the OverrunCount is greater than zero, Verify that Feature
ErrorCounts is greater than zero

|9 |11.13.7 |DGTHREAD.S.A0007(NeighborTable) |TH reads NeighborTable
attribute value from DUT. a|
. Verify that the NeighborTable List size is Zero or greater
. Verify that the list follows the behavior as per section 11.13.7.8
. Read the NeighborTable entries and for each entry (node) verify the
following attributes:
+
[loweralpha]
.. ExtAddress is of the type uint64
.. Age is of the type uint32.
+
[lowerroman]
... Verify that the Age field specify the duration of time in seconds
.. Rloc16 is of the type uint16
.. LinkFrameCounter is of the type uint32
.. MleFrameCounter is of the type uint32
.. LQI is of the type uint8 and value is between 0 to 255
.. AverageRssi is of the type int8 and value is between -128 to 0
+
[lowerroman]
... AverageRssi field has the units of dBm
.. LastRssi is of the type int8 and value is between -128 to 0
.. LastRssi field has the units of dBm
.. FrameErrorRate is of the type uint8 and value is between 0 to 100
.. MessageErrorRate is of the type uint8 and value is between 0 to 100
.. RxOnWhenIdle is of the type bool
.. FullThreadDevice is of the type bool
.. FullNetworkData is of the type bool
.. IsChild is of the type bool

|10 |11.13.7 |DGTHREAD.S.A0008(RouteTable) |TH reads RouteTable
attribute value from DUT. a|
1.Verify that the RouteTable List size is Zero or greater

{empty}2. Verify that the list follows the behavior as per section
11.13.7.9

3.Read the RouteTable entries and for each entry (node) verify the
following attributes:

[loweralpha]
. ExtAddress is of the type uint64
. Rloc16 is of the type uint16
. RouterId is of the type uint8
. NextHop is of the type uint8
. PathCost is of the type uint8
. LQIIn is of the type uint8 and value is between 0 to 255 M V
. LQIOut is of the type uint8 and value is between 0 to 255 M V
. Age is of the type uint8
. Allocated is of the type bool
. LinkEstablished is of the type bool

|11 |11.13.7 |DGTHREAD.S.A0009(PartitionId) |TH reads PartitionId
attribute value from DUT |1.Verify that PartitionId is of the type
uint32

|12 |11.13.7 |DGTHREAD.S.A000a(Weighting) |TH reads Weighting attribute
value from DUT |1.Verify that Weighting is of the type uint8

|13 |11.13.7 |DGTHREAD.S.A000b(DataVersion) |TH reads DataVersion
attribute value from DUT |1.Verify that DataVersion is of the type uint8

|14 |11.13.7 |DGTHREAD.S.A000c(StableDataVersion) |TH reads
StableDataVersion attribute value from DUT |1.Verify that
StableDataVersion is of the type uint8

|15 |11.13.7 |DGTHREAD.S.A000d(LeaderRouterId) |TH reads LeaderRouterId
attribute value from DUT |1.Verify that LeaderRouterId is of the type
uint8

|16 |11.13.7 |DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A000e(DetachedRoleCount) |TH reads DetachedRoleCount
attribute value from DUT a|
{empty}1. Verify that DetachedRoleCount is of the type uint16

|17 |11.13.7 |DGTHREAD.S.F02(MLECNT) & DGTHREAD.S.A000f(ChildRoleCount)
|TH reads ChildRoleCount attribute value from DUT a|
1.Verify that ChildRoleCount is of the type uint16

|18 |11.13.7 |DGTHREAD.S.F02(MLECNT) & DGTHREAD.S.A0010(RouterRoleCount)
|TH reads RouterRoleCount attribute value from DUT a|
1.Verify that RouterRoleCount is of the type uint16

|19 |11.13.7 |DGTHREAD.S.F02(MLECNT) & DGTHREAD.S.A0011(LeaderRoleCount)
|TH reads LeaderRoleCount attribute value from DUT a|
1.Verify that LeaderRoleCount is of the type uint16

|20 |11.13.7 |DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0012(AttachAttemptCount) |TH reads AttachAttemptCount
attribute value from DUT a|
1.Verify that AttachAttemptCount is of the type uint16

|21 |11.13.7 |DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0013(PartitionIdChangeCount) |TH reads
PartitionIdChangeCount attribute value from DUT a|
1.Verify that PartitionIdChangeCount is of the type uint16

|22 |11.13.7 |DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0014(BetterPartitionAttachAttemptCount) |TH reads
BetterPartitionAttachAttemptCount attribute value from DUT a|
1.Verify that BetterPartitionAttachAttemptCount is of the type uint16

|23 |11.13.7 |DGTHREAD.S.F02(MLECNT) &
DGTHREAD.S.A0015(ParentChangeCount) |TH reads ParentChangeCount
attribute value from DUT a|
1.Verify that ParentChangeCount is of the type uint16

|24 |11.13.7 |DGTHREAD.S.A0038(ActiveTimestamp) |TH reads
ActiveTimestamp attribute value from DUT a|
1.Verify that ActiveTimestamp is of the type uint64

|25 |11.13.7 |DGTHREAD.S.A0039(PendingTimestamp) |TH reads
PendingTimestamp attribute value from DUT a|
1.Verify that PendingTimestamp is of the type uint64

|26 |11.13.7 |DGTHREAD.S.A003a(Delay) |TH reads Delay attribute value
from DUT a|
1.Verify that Delay is of the type uint32

|27 |11.13.7 |DGTHREAD.S.A003b(SecurityPolicy) |TH reads SecurityPolicy
attribute value from DUT a|
Verify that the SecurityPolicy attribute has the following fields:

. RotationTime is of the type uint16
. Flags is of the type uint16

|28 |11.13.7 |DGTHREAD.S.A003c(ChannelPage0Mask) |TH reads
ChannelPage0Mask attribute value from DUT a|
Verify that ChannelPage0Mask is of the type octstr

|29 |11.13.7 |DGTHREAD.S.A003d(OperationalDatasetComponents) |TH reads
OperationalDatasetComponents attribute from DUT a|
Verify that the OperationalDatasetComponents attribute has the following
fields:

. ActiveTimestampPresent is of the type bool
. PendingTimestampPresent is of the type bool
. MasterKeyPresent is of the type bool
. NetworkNamePresent is of the type bool
. ExtendedPanIdPresent is of the type bool
. MeshLocalPrefixPresent is of the type bool
. DelayPresent is of the type bool
. PanIdPresent is of the type bool
. ChannelPresent is of the type bool
. PskcPresent is of the type bool
. SecurityPolicyPresent is of the type bool
. ChannelMaskPresent is of the type bool

|30 |11.13.7 |DGTHREAD.S.A003e(ActiveNetworkFaults) |TH reads
ActiveNetworkFaults attribute value from DUT a|
1.Verify for the following checks: ActiveNetworkFaults List size is Zero
or greater

{empty}2. The list can have maximum of four entries

3.The list entries are of type NetworkFault ENUM

0- Unspecified

1- LinkDown

2- HardwareFailure

3- NetworkJammed

4.The list entries have single instance occurrence

|===

[[_tc_dgthread_2_2_attributes_tx_dut_server]]
===== link:#_tc_dgthread_2_2_attributes_tx_dut_server[]51.2.2. [TC-DGTHREAD-2.2] Attributes-Tx [DUT- Server]

[[_category_167]]
====== link:#_category_167[]Category

Functional conformance

[[_purpose_167]]
====== link:#_purpose_167[]Purpose

This test case reads the attributes of the Thread Network Diagnostics
Cluster and checks for the type and length

[[_pics_167]]
====== link:#_pics_167[]PICS

* DGTHREAD.S
* DGTHREAD.S.F03(MACCNT)

[[_pre_conditions_2]]
====== link:#_pre_conditions_2[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |
|===

[[_required_devices_167]]
====== link:#_required_devices_167[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_134]]
====== link:#_device_topology_134[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_146]]
====== link:#_test_setup_146[]Test Setup

[[_test_procedure_167]]
====== link:#_test_procedure_167[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.13.7 |DGTHREAD.S.A0016(TxTotalCount) |TH reads TxTotalCount
attribute value from DUT a|
1.Verify that TxTotalCount is of the type uint32

|3 |11.13.7 |DGTHREAD.S.A0017(TxUnicastCount) |TH reads TxUnicastCount
attribute value from DUT a|
1.Verify that TxUnicastCount is of the type uint32

|4 |11.13.7 |DGTHREAD.S.A0018(TxBroadcastCount) |TH reads
TxBroadcastCount attribute value from DUT a|
1.Verify that TxBroadcastCount is of the type uint32

|5 |11.13.7 |DGTHREAD.S.A0019(TxAckRequestedCount) |TH reads
TxAckRequestedCount attribute value from DUT a|
1.Verify that TxAckRequestedCount is of the type uint32

|6 |11.13.7 |DGTHREAD.S.A001a(TxAckedCount) |TH reads TxAckedCount
attribute value from DUT a|
1.Verify that TxAckedCount is of the type uint32

|7 |11.13.7 |DGTHREAD.S.A001b(TxNoAckRequestedCount) |TH reads
TxNoAckRequestedCount attribute value from DUT a|
1.Verify that TxNoAckRequestedCount is of the type uint32

|8 |11.13.7 |DGTHREAD.S.A001c(TxDataCount) |TH reads TxDataCount
attribute value from DUT a|
1.Verify that TxDataCount is of the type uint32

|9 |11.13.7 |DGTHREAD.S.A001d(TxDataPollCount) |TH reads TxDataPollCount
attribute value from DUT a|
1.Verify that TxDataPollCount is of the type uint32

|10 |11.13.7 |DGTHREAD.S.A001e(TxBeaconCount) |TH reads TxBeaconCount
attribute value from DUT a|
1.Verify that TxBeaconCount is of the type uint32

|11 |11.13.7 |DGTHREAD.S.A001f(TxBeaconRequestCount) |TH reads
TxBeaconRequestCount attribute value from DUT a|
1.Verify that TxBeaconRequestCount is of the type uint32

|12 |11.13.7 |DGTHREAD.S.A0020(TxOtherCount) |TH reads TxOtherCount
attribute value from DUT a|
1.Verify that TxOtherCount is of the type uint32

|13 |11.13.7 |DGTHREAD.S.A0021(TxRetryCount) |TH reads TxRetryCount
attribute value from DUT a|
1.Verify that TxRetryCount is of the type uint32

|14 |11.13.7 |DGTHREAD.S.A0022(TxDirectMaxRetryExpiryCount) |TH reads
TxDirectMaxRetryExpiryCount attribute value from DUT a|
1.Verify that TxDirectMaxRetryExpiryCount is of the type uint32

|15 |11.13.7 |DGTHREAD.S.A0023(TxIndirectMaxRetryExpiryCount) |TH reads
TxIndirectMaxRetryExpiryCount attribute value from DUT a|
1.Verify that TxIndirectMaxRetryExpiryCount is of the type uint32

|16 |11.13.7 |DGTHREAD.S.A0024(TxErrCcaCount) |TH reads TxErrCcaCount
attribute value from DUT a|
1.Verify that TxErrCcaCount is of the type uint32

|17 |11.13.7 |DGTHREAD.S.A0025(TxErrAbortCount) |TH reads
TxErrAbortCount attribute value from DUT a|
1.Verify that TxErrAbortCount is of the type uint32

|18 |11.13.7 |DGTHREAD.S.A0026(TxErrBusyChannelCount) |TH reads
TxErrBusyChannelCount attribute value from DUT a|
1.Verify that TxErrBusyChannelCount is of the type uint32

|===

[[_tc_dgthread_2_3_attributes_rx_dut_server]]
===== link:#_tc_dgthread_2_3_attributes_rx_dut_server[]51.2.3. [TC-DGTHREAD-2.3] Attributes-Rx [DUT- Server]

[[_category_168]]
====== link:#_category_168[]Category

Functional conformance

[[_purpose_168]]
====== link:#_purpose_168[]Purpose

This test case reads the attributes of the Thread Network Diagnostics
Cluster and checks for the type and length

[[_pics_168]]
====== link:#_pics_168[]PICS

* DGTHREAD.S
* DGTHREAD.S.F03(MACCNT)

[[_pre_conditions_3]]
====== link:#_pre_conditions_3[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |
|===

[[_required_devices_168]]
====== link:#_required_devices_168[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_135]]
====== link:#_device_topology_135[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_147]]
====== link:#_test_setup_147[]Test Setup

[[_test_procedure_168]]
====== link:#_test_procedure_168[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.13.7 |DGTHREAD.S.A0027(RxTotalCount) |TH reads RxTotalCount
attribute value from DUT a|
1.Verify that RxTotalCount is of the type uint32

|3 |11.13.7 |DGTHREAD.S.A0028(RxUnicastCount) |TH reads RxUnicastCount
attribute value from DUT a|
1.Verify that RxUnicastCount is of the type uint32

|4 |11.13.7 |DGTHREAD.S.A0029(RxBroadcastCount) |TH reads
RxBroadcastCount attribute value from DUT a|
1.Verify that RxBroadcastCount is of the type uint32

|5 |11.13.7 |DGTHREAD.S.A002a(RxDataCount) |TH reads RxDataCount
attribute value from DUT a|
1.Verify that RxDataCount is of the type uint32

|6 |11.13.7 |DGTHREAD.S.A002b(RxDataPollCount) |TH reads RxDataPollCount
attribute value from DUT a|
1.Verify that RxDataPollCount is of the type uint32

|7 |11.13.7 |DGTHREAD.S.A002c(RxBeaconCount) |TH reads RxBeaconCount
attribute value from DUT a|
1.Verify that RxBeaconCount is of the type uint32

|8 |11.13.7 |DGTHREAD.S.A002d(RxBeaconRequestCount) |TH reads
RxBeaconRequestCount attribute value from DUT a|
1.Verify that RxBeaconRequestCount is of the type uint32

|9 |11.13.7 |DGTHREAD.S.A002e(RxOtherCount) |TH reads RxOtherCount
attribute value from DUT a|
1.Verify that RxOtherCount is of the type uint32

|10 |11.13.7 |DGTHREAD.S.A002f(RxAddressFilteredCount) |TH reads
RxAddressFilteredCount attribute value from DUT a|
1.Verify that RxAddressFilteredCount is of the type uint32

|11 |11.13.7 |DGTHREAD.S.A0030(RxDestAddrFilteredCount) |TH reads
RxDestAddrFilteredCount attribute value from DUT a|
1.Verify that RxDestAddrFilteredCount is of the type uint32

|12 |11.13.7 |DGTHREAD.S.A0031(RxDuplicatedCount) |TH reads
RxDuplicatedCount attribute value from DUT a|
1.Verify that RxDuplicatedCount is of the type uint32

|13 |11.13.7 |DGTHREAD.S.A0032(RxErrNoFrameCount) |TH reads
RxErrNoFrameCount attribute value from DUT a|
1.Verify that RxErrNoFrameCount is of the type uint32

|14 |11.13.7 |DGTHREAD.S.A0033(RxErrUnknownNeighborCount) |TH reads
RxErrUnknownNeighborCount attribute value from DUT a|
1.Verify that RxErrUnknownNeighborCount is of the type uint32

|15 |11.13.7 |DGTHREAD.S.A0034(RxErrInvalidSrcAddrCount) |TH reads
RxErrInvalidSrcAddrCount attribute value from DUT a|
1.Verify that RxErrInvalidSrcAddrCount is of the type uint32

|16 |11.13.7 |DGTHREAD.S.A0035(RxErrSecCount) |TH reads RxErrSecCount
attribute value from DUT a|
1.Verify that RxErrSecCount is of the type uint32

|17 |11.13.7 |DGTHREAD.S.A0036(RxErrFcsCount) |TH reads RxErrFcsCount
attribute value from DUT a|
1.Verify that RxErrFcsCount is of the type uint32

|18 |11.13.7 |DGTHREAD.S.A0037(RxErrOtherCount) |TH reads
RxErrOtherCount attribute value from DUT a|
1.Verify that RxErrOtherCount is of the type uint32

|===

[[_tc_dgthread_2_4_resetcounts_commanddut_server]]
===== link:#_tc_dgthread_2_4_resetcounts_commanddut_server[]51.2.4. [TC-DGTHREAD-2.4] ResetCounts Command[DUT- Server]

[[_category_169]]
====== link:#_category_169[]Category

Functional conformance

[[_purpose_169]]
====== link:#_purpose_169[]Purpose

DUT resets the overrun count to zero on receiving ResetCounts Command
from TH

[[_pics_169]]
====== link:#_pics_169[]PICS

* DGTHREAD.S
* DGTHREAD.S.F01(ERRCNT)

[[_pre_conditions_4]]
====== link:#_pre_conditions_4[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |
|===

[[_required_devices_169]]
====== link:#_required_devices_169[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_136]]
====== link:#_device_topology_136[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_148]]
====== link:#_test_setup_148[]Test Setup

[[_test_procedure_169]]
====== link:#_test_procedure_169[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.13.8.1 |DGTHREAD.S.C00.Rsp(ResetCounts) |TH sends ResetCounts
Command to DUT a|
{empty}1. DUT resets OverrunCount attribute to Zero

{empty}2. DUT sends a success response (0x00) to TH

|3 |11.13.7.7 |DGTHREAD.S.A0006(OverrunCount) |TH reads OverrunCount
attribute from DUT |1.Verify that the OverrunCount is set to Zero
|===

[[_tc_dgthread_2_5_thread_network_diagnostics_cluster_eventsdut_server_removed]]
===== link:#_tc_dgthread_2_5_thread_network_diagnostics_cluster_eventsdut_server_removed[]51.2.5. [TC-DGTHREAD-2.5] Thread Network Diagnostics Cluster Events[DUT-Server] - REMOVED

[[_category_170]]
====== link:#_category_170[]Category

Functional conformance

[[_purpose_170]]
====== link:#_purpose_170[]Purpose

To verify that all the events are implemented.

[[_pics_170]]
====== link:#_pics_170[]PICS

* DGTHREAD.S

[[_pre_conditions_5]]
====== link:#_pre_conditions_5[]Pre-Conditions

[width="99%",cols="10%,18%,36%,36%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT is Commissioned with TH |
|===

[[_required_devices_170]]
====== link:#_required_devices_170[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_137]]
====== link:#_device_topology_137[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_149]]
====== link:#_test_setup_149[]Test Setup

[[_test_procedure_170]]
====== link:#_test_procedure_170[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by an Unspecified failure a|
* TH receives NetworkFaultChange event with Current data specified by
anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|2 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by LinkDown failure a|
* TH receives NetworkFaultChange event with Current data specified by
anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|3 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by HardwareFailure a|
* TH receives NetworkFaultChange event with Current data specified by
anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|4 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by NetworkJammed Failure a|
* TH receives NetworkFaultChange event with Current data specified by
anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|5 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by an Unspecified failure a|
* TH receives NetworkFaultChange event before the occurrence of the
event by Previous data specified by anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|6 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by LinkDown failure a|
* TH receives NetworkFaultChange event before the occurrence of the
event by Previous data specified by anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|7 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by HardwareFailure a|
* TH receives NetworkFaultChange event before the occurrence of the
event by Previous data specified by anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|8 |11.13.8.1, 11.13.5.1 |DGTHREAD.S.E01(NetworkFaultChange) |Induce a
DUT by NetworkJammed Failure a|
* TH receives NetworkFaultChange event before the occurrence of the
event by Previous data specified by anyone of the following values:

0 - Unspecified

1 - LinkDown

2 - HardwareFailure

3 - NetworkJammed

* Verify that NetworkFaultChange event has priority set as INFO

|9 |11.13.8.2. |DGTHREAD.S.E00(ConnectionStatus) |Disconnect and
reconnect a node to a Thread network a|
* TH receives ConnectionStatus value specified below:

0 - Connected

1 - Not Connected

* Verify that ConnectionStatus event has priority set as INFO

|===

[[_client_as_dut_4]]
==== link:#_client_as_dut_4[]51.3. Client as DUT

[[_tc_dgthread_3_4_resetcounts_commanddut_client]]
===== link:#_tc_dgthread_3_4_resetcounts_commanddut_client[]51.3.1. [TC-DGTHREAD-3.4] ResetCounts Command[DUT-Client]

[[_category_171]]
====== link:#_category_171[]Category

Functional conformance

[[_purpose_171]]
====== link:#_purpose_171[]Purpose

TH resets the overrun count to zero on receiving ResetCounts Command
from DUT

[[_pics_171]]
====== link:#_pics_171[]PICS

* DGTHREAD.C

[[_pre_conditions_6]]
====== link:#_pre_conditions_6[]Pre-Conditions

[width="100%",cols="7%,31%,31%,31%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | | |
|===

[[_required_devices_171]]
====== link:#_required_devices_171[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |server
|2 |DUT |client
|===

[[_device_topology_138]]
====== link:#_device_topology_138[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_150]]
====== link:#_test_setup_150[]Test Setup

[[_test_procedure_171]]
====== link:#_test_procedure_171[]Test Procedure

[width="100%",cols="8%,11%,11%,35%,35%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission TH to DUT |

|2 |11.13.8.1 |DGTHREAD.C.C00.Tx(ResetCounts) |DUT sends ResetCounts
Command to TH |If DGTHREAD.C.C00.Tx(ResetCounts), Test Harness receives
the ResetCounts Command from the DUT

|3 |11.13.6.1 |DGTHREAD.C.A0006(OverrunCount) |DUT reads OverrunCount
attribute from TH |1.Verify that DUT reads OverrunCount from the TH
successfully
|===

[[_notestesting_considerations_167]]
====== link:#_notestesting_considerations_167[]Notes/Testing Considerations

[[_wi_fi_network_diagnostics_cluster_test_plan]]
== link:#_wi_fi_network_diagnostics_cluster_test_plan[]**Wi-Fi Network Diagnostics Cluster Test Plan**

[[_pics_definition_17]]
=== link:#_pics_definition_17[]52. PICS Definition

This section covers the Wi-Fi Diagnostics Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_17]]
==== link:#_role_17[]52.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGWIFI.S |Does the device implement the Wi-Fi Diagnostics cluster as a
server? |O |

|DGWIFI.C |Does the device implement the Wi-Fi Diagnostics cluster as a
client? |O |
|===

[[_server_17]]
==== link:#_server_17[]52.2. Server

[[_features_13]]
===== link:#_features_13[]52.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGWIFI.S.F00(PacketCounts) |Counts for the number of received and
transmitted packets on the ethernet interface. |O |

|DGWIFI.S.F01(ErrorCounts) |Counts for the number of errors during the
reception and transmission of packets on the ethernet interface. |O |
|===

[[_attributes_21]]
===== link:#_attributes_21[]52.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGWIFI.S.A0000(BSSID) |Indicates the BSSID for which the Wi-Fi network
the Node is currently connected. If the interface not configured, a NULL
value should be presented. |M |

|DGWIFI.S.A0001(SecurityType) |The current type of Wi-Fi security being
used. |M |The type definition is provided in 11.14.3.1 SecurityType
ENUM.

|DGWIFI.S.A0002(WiFiVersion) |Indicates the current 802.11 standard
version in use by the Node. |M |The version definition is provided in
11.14.3.2 WiFiVersion ENUM

|DGWIFI.S.A0003(ChannelNumber) |Indicate the channel that Wi-Fi
communication is currently operating on. If the interface not
configured, a NULL value should be presented. |M |

|DGWIFI.S.A0004(RSSI) |Indicates the current RSSI of the Node’s Wi-Fi
radio in dB. If the interface not configured or operational, a NULL
value should be presented. This value should not be subscribed. |M |

|DGWIFI.S.A0005(BeaconLostCount) |Indicates the count of the number of
missed beacons. This value should not be subscribed.
|DGWIFI.S.F01(ErrorCounts) |Mandatory if feature supported

|DGWIFI.S.A0006(BeaconRxCount) |Indicates the count of the number of
received beacons. This value should not be subscribed.
|DGWIFI.S.F00(PacketCounts) |

|DGWIFI.S.A0007(PacketMulticastRxCount) |Indicates the number of
multicast packets received by the Node. This value should not be
subscribed. |DGWIFI.S.F00(PacketCounts) |

|DGWIFI.S.A0008(PacketMulticastTxCount) |Indicates the number of
multicast packets transmitted by the Node. This value should not be
subscribed. |DGWIFI.S.F00(PacketCounts) |

|DGWIFI.S.A0009(PacketUnicastRxCount) |Indicates the number of unicast
packets received by the Node. This value should not be subscribed.
|DGWIFI.S.F00(PacketCounts) |

|DGWIFI.S.A000a(PacketUnicastTxCount) |Indicates the number of unicast
packets transmitted by the Node. This value should not be subscribed.
|DGWIFI.S.F00(PacketCounts) |

|DGWIFI.S.A000b(CurrentMaxRate) |Indicates the current maximum PHY rate
of transfer of data in bytes-per-second. |O |

|DGWIFI.S.A000c(OverrunCount) |Indicates the number of packets dropped
either at ingress or egress, due to lack of buffer memory to retain all
packets on the ethernet network interface. This attribute SHALL be reset
to 0 upon a reboot of the Node. This value should not be subscribed.
|DGWIFI.S.F01(ErrorCounts) |
|===

[[_events_4]]
===== link:#_events_4[]52.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGWIFI.S.E00(Disconnection) |Indicates Node’s Wi-Fi connection has been
disconnected as a result of de-authenticated or dis-association and
indicates the reason. |O |Reason code align with Table 9-49 of IEEE
802.11-2020

|DGWIFI.S.E01(AssociationFailure) |Indicates unsuccessful connection and
reconnection to Wi-Fi access point after exhaustive retries.
AssociationFailure fields are to indicate the cause and status. Each
field set values are described in 11.14.6.2 |O |Refer tables 11.14.6.2

|DGWIFI.S.E02(ConnectionStatus) |Indicates that a Node’s connection
status to a Wi-Fi network has changed. |O |Refer ConnectionStatus ENUM
table 11.14.6.3
|===

[[_commands_received_11]]
===== link:#_commands_received_11[]52.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGWIFI.S.C00.Rsp(ResetCount) |Reset the following attributes to 0;
BeaconLostCount, BeaconRxCount, PacketMulticastRxCount,
PacketMulticastTxCount, PacketUnicastRxCount, PacketUnicastTxCount
|DGWIFI.S.F01(ErrorCounts) |
|===

[[_client_10]]
==== link:#_client_10[]52.3. Client

[[_commands_generated_10]]
===== link:#_commands_generated_10[]52.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGWIFI.C.C00.Tx(ResetCount) |Reset the following attributes to 0;
BeaconLostCount, BeaconRxCount, PacketMulticastRxCount,
PacketMulticastTxCount, PacketUnicastRxCount, PacketUnicastTxCount |O |
|===

[[_test_case_list_17]]
=== link:#_test_case_list_17[]53. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-DGWIFI-1.1 |Global Attributes [DUT as Server]
|TC-DGWIFI-2.1 |Attributes [DUT as Server]
|TC-DGWIFI-2.2 |Event Functionality [DUT as Server]
|TC-DGWIFI-2.3 |Command Received [DUT as Server]
|TC-DGWIFI-3.2 |Commands Generated [DUT as Client]
|===

[[_test_cases_17]]
=== link:#_test_cases_17[]54. Test Cases

[[_generic_test_cases_14]]
==== link:#_generic_test_cases_14[]54.1. Generic Test Cases

[[_tc_dgwifi_1_1_global_attributes_dut_as_server]]
===== link:#_tc_dgwifi_1_1_global_attributes_dut_as_server[]54.1.1. [TC-DGWIFI-1.1] Global Attributes [DUT as Server]

[[_category_172]]
====== link:#_category_172[]Category

Functional conformance

[[_purpose_172]]
====== link:#_purpose_172[]Purpose

To verify the Global Attributes available in the Wi-Fi Diagnostics
Cluster

[[_pics_172]]
====== link:#_pics_172[]PICS

* DGWIFI.S

[[_pre_conditions_7]]
====== link:#_pre_conditions_7[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_172]]
====== link:#_required_devices_172[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissionee/Server as DUT.
|2 |TH |Commissioner
|===

[[_device_topology_139]]
====== link:#_device_topology_139[]Device Topology

[[_test_setup_151]]
====== link:#_test_setup_151[]Test Setup

[[_test_procedure_172]]
====== link:#_test_procedure_172[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |7.13.1 | |TH reads the ClusterRevision from DUT. |Verify that the
ClusterRevision attribute is of uint16 and reflects the highest revision
number.

|3 |7.13.2 | |TH reads the FeatureMap from DUT. |Check the number of
FeatureMap attribute being supported by DUT.

|4 |7.13.3 | |TH reads AttributeList from DUT. |Verify that the DUT
response provides a list of supported attributes. This list SHALL
include all supported attribute ID values mandatory attributes(value 0,
1, 2, 3, 4), optional attributes (value 5, 6, 7, 8, 9, 10, 11, 12),
conditional mandatory attributes (6, 7, 8, 9, 10 if PKTCNT feature
supported 5, 12 if ERRCNT feature supported) global attributes (65528,
65529, 65531, 65532, 65533).

|5 |7.13.3.1 | |TH reads AcceptedCommandList from DUT. |Verify that the
DUT response provides a list of Accepted Command that DUT implemented as
mandatory or optional/feature support. This list SHALL have one entry if
ERRCNT is supported by DUT otherwise, an empty list.

|6 |7.13.3.2 | |TH reads GeneratedCommandList from DUT. |Verify that the
DUT response provides a list of Generated Command that DUT implemented
as mandatory or optional/feature support. This list SHALL have zero
entry.

|7 |7.13.4 | |TH reads EventList from DUT. |Verify that the DUT response
provides a list of supported events. Currently this is out of scope for
Version 1.0.
|===

[[_notestesting_considerations_168]]
====== link:#_notestesting_considerations_168[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK.

'''''

[[_server_as_dut_9]]
==== link:#_server_as_dut_9[]54.2. Server as DUT

'''''

[[_tc_dgwifi_2_1_attributes_dut_as_server]]
===== link:#_tc_dgwifi_2_1_attributes_dut_as_server[]54.2.1. [TC-DGWIFI-2.1] Attributes [DUT as Server]

[[_category_173]]
====== link:#_category_173[]Category

Functional

[[_purpose_173]]
====== link:#_purpose_173[]Purpose

This test case verifies the behavior of the attributes of the Wi-Fi
diagnostics cluster server.

[[_pics_173]]
====== link:#_pics_173[]PICS

* DGWIFI.S

[[_required_devices_173]]
====== link:#_required_devices_173[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_140]]
====== link:#_device_topology_140[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_152]]
====== link:#_test_setup_152[]Test Setup

Commission DUT to TH

[[_test_procedure_173]]
====== link:#_test_procedure_173[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.14.4.1 |DGWIFI.S.A0000(BSSID) |TH reads BSSID attribute from DUT.
|The value read indicates the BSSID for which the Wi-Fi network the Node
is currently connected. If the interface not configured or operational,
a NULL value should be returned.

|3 |11.14.4.2 |DGWIFI.S.A0001(SecurityType) |TH reads a SecurityType
attribute value from DUT. |The data type must match the value listed in
the specification(s) SecurityType ENUM table. If not operational nor
configured, NULL value should be returned.

|4 |11.14.4.3 |DGWIFI.S.A0002(WiFiVersion) |TH reads a WiFiVersion
attribute value from DUT. |The data type must match the value listed in
the specification(s) WiFiVersion ENUM table.

|5 |11.14.4.4 |DGWIFI.S.A0003(ChannelNumber) |TH reads a ChannelNumber
attribute value from DUT. |The data type must match the value listed in
the specification(s). If not operational nor configured, NULL value
should be returned.

|6 |11.14.4.5 |DGWIFI.S.A0004(RSSI) |TH reads a RSSI attribute value
from DUT. |The attribute value is in dB. The data type must match the
value listed in the specification(s). If not operational nor configured,
NULL value should be returned. This attribute should not be subscribed.

|7 |11.14.4.6 |DGWIFI.S.A0005(BeaconLostCount) |TH reads a
BeaconLostCount attribute value from DUT. |The data type must match the
value listed in the specification(s). This attribute should not be
subscribed.

|8 |11.14.4.7 |DGWIFI.S.A0006(BeaconRxCount) |TH reads a BeaconRxCount
attribute value from DUT. |The data type must match the value listed in
the specification(s). This attribute should not be subscribed.

|9 |11.14.4.8 |DGWIFI.S.A0007(PacketMulticastRxCount) |TH reads a
PacketMultiRxCount attribute value from DUT. |The data type must match
the value listed in the specification(s). This attribute should not be
subscribed.

|10 |11.14.4.9 |DGWIFI.S.A0008(PacketMulticastTxCount) |TH reads a
PacketMultiTxCount attribute value from DUT. |The data type must match
the value listed in the specification(s). This attribute should not be
subscribed.

|11 |11.14.4.10 |DGWIFI.S.A0009(PacketUnicastRxCount) |TH reads a
PacketUniRxCount attribute value from DUT. |The data type must match the
value listed in the specification(s). This attribute should not be
subscribed.

|12 |11.14.4.11 |DGWIFI.S.A000a(PacketUnicastTxCount) |TH reads a
PacketUniTxCount attribute value from DUT. |The data type must match the
value listed in the specification(s). This attribute should not be
subscribed.

|13 |11.14.4.12 |DGWIFI.S.A000b(CurrentMaxRate) |TH reads a
CurrentMaxRate attribute value from DUT. |The data type must match the
value listed in the specification(s). This attribute value is
bytes-per-second.

|14 |11.14.4.13 |DGWIFI.S.A000c(OverrunCount) |TH reads a OverrunCount
attribute value from DUT. |The data type must match the value listed in
the specification(s). This attribute value resets to 0 after node
reboot. This attribute should not be subscribed.
|===

[[_notestesting_considerations_169]]
====== link:#_notestesting_considerations_169[]Notes/Testing Considerations

[[_tc_dgwifi_2_2_event_functionality_dut_as_server]]
===== link:#_tc_dgwifi_2_2_event_functionality_dut_as_server[]54.2.2. [TC-DGWIFI-2.2] Event Functionality [DUT as Server]

[[_category_174]]
====== link:#_category_174[]Category

Functional

[[_purpose_174]]
====== link:#_purpose_174[]Purpose

This test case verifies the event functionality of the Wi-Fi diagnostics
cluster server.

[[_pics_174]]
====== link:#_pics_174[]PICS

* DGWIFI.S

[[_required_devices_174]]
====== link:#_required_devices_174[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_141]]
====== link:#_device_topology_141[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_153]]
====== link:#_test_setup_153[]Test Setup

Commission DUT to TH

[[_test_procedure_174]]
====== link:#_test_procedure_174[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.14.6.1 |DGWIFI.S.E00(Disconnection) |Disconnect node Wi-Fi as a
result of de-authentication or dis-association. |TH receives
Disconnection event enum align with Table 9-49 of IEEE 802.11-2020.

|3 |11.14.6.2 |DGWIFI.S.E01(AssociationFailure) |Disconnect node Wi-Fi
as a result of de-authentication or dis-association. DUT exhausts all
internal retries. |TH receives AssociationFailure cause and status field
values whose values should be matched from 11.14.6.2
AssociationFailureCause ENUM table and Table 9-50 Status codes of IEEE
802.11-2020.

|4 |11.14.6.3 |DGWIFI.S.E02(ConnectionStatus) |Disconnect and reconnect
node Wi-Fi. |TH receives ConnectionStatus value specified at
ConnectionStatus ENUM table.
|===

[[_notestesting_considerations_170]]
====== link:#_notestesting_considerations_170[]Notes/Testing Considerations

[[_tc_dgwifi_2_3_command_received_dut_as_server]]
===== link:#_tc_dgwifi_2_3_command_received_dut_as_server[]54.2.3. [TC-DGWIFI-2.3] Command Received [DUT as Server]

[[_category_175]]
====== link:#_category_175[]Category

Functional

[[_purpose_175]]
====== link:#_purpose_175[]Purpose

This test case verifies the command functionality of the Wi-Fi
diagnostics cluster server.

[[_pics_175]]
====== link:#_pics_175[]PICS

* DGWIFI.S

[[_required_devices_175]]
====== link:#_required_devices_175[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_142]]
====== link:#_device_topology_142[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_154]]
====== link:#_test_setup_154[]Test Setup

Commission DUT to TH

[[_test_procedure_175]]
====== link:#_test_procedure_175[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.14.5.1 |DGWIFI.S.C00.Rsp(ResetCount) |TH sends ResetCounts
command to DUT |Upon DUT’s reception of this command, DUT will reset
BeaconLostCount, BeaconRxCount, PacketMulticastRxCount,
PacketMulticastTxCount, PacketUnicastRxCount, PacketUnicastTxCount.

|2a |11.14.4.6 |DGWIFI.S.A0005(BeaconLostCount) |TH reads a
BeaconLostCount attribute value from DUT. |The value read may not be
necessarily 0.

|2b |11.14.4.7 |DGWIFI.S.A0006(BeaconRxCount) |TH reads a BeaconRxCount
attribute value from DUT. |The value read may not be necessarily 0.

|2c |11.14.4.8 |DGWIFI.S.A0007(PacketMulticastRxCount) |TH reads a
PacketMultiRxCount attribute value from DUT. |The value read may not be
necessarily 0.

|2d |11.14.4.9 |DGWIFI.S.A0008(PacketMulticastTxCount) |TH reads a
PacketMultiTxCount attribute value from DUT. |The value read may not be
necessarily 0.

|2e |11.14.4.10 |DGWIFI.S.A0009(PacketUnicastRxCount) |TH reads a
PacketUniRxCount attribute value from DUT. |The value read may not be
necessarily 0.

|2f |11.14.4.11 |DGWIFI.S.A000a(PacketUnicastTxCount) |TH reads a
PacketUniTxCount attribute value from DUT. |The value read may not be
necessarily 0.
|===

[[_notestesting_considerations_171]]
====== link:#_notestesting_considerations_171[]Notes/Testing Considerations

'''''

[[_client_as_dut_5]]
==== link:#_client_as_dut_5[]54.3. Client as DUT

'''''

[[_tc_dgwifi_3_2_command_generated_dut_as_client]]
===== link:#_tc_dgwifi_3_2_command_generated_dut_as_client[]54.3.1. [TC-DGWIFI-3.2] Command Generated [DUT as Client]

[[_category_176]]
====== link:#_category_176[]Category

Functional

[[_purpose_176]]
====== link:#_purpose_176[]Purpose

This test case verifies a client can properly send Wi-Fi diagnostics
commands.

[[_pics_176]]
====== link:#_pics_176[]PICS

* DGWIFI.C

[[_required_devices_176]]
====== link:#_required_devices_176[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Server
|2 |DUT |DUT as Client
|===

[[_device_topology_143]]
====== link:#_device_topology_143[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_155]]
====== link:#_test_setup_155[]Test Setup

Commission TH to DUT

[[_test_procedure_176]]
====== link:#_test_procedure_176[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission TH to DUT |

|2 |11.14.5.1 |DGWIFI.C.C00.Tx(ResetCount) |DUT sends ResetCounts
command to TH. |Verify TH receives command and no errors are reported.
|===

[[_notestesting_considerations_172]]
====== link:#_notestesting_considerations_172[]Notes/Testing Considerations

'''''

[[_diagnostics_logs_cluster_test_plan]]
== link:#_diagnostics_logs_cluster_test_plan[]**Diagnostics Logs Cluster Test Plan**

[[_pics_definition_18]]
=== link:#_pics_definition_18[]55. PICS Definition

This section covers the Diagnostic Logs Cluster related PICS items that
are referenced in the following test case

[[_role_18]]
==== link:#_role_18[]55.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DLOG.S |Does the device implement the Diagnostic Logs cluster as a
server? |O |

|DLOG.C |Does the device implement the Diagnostic Logs cluster as a
client? |O |
|===

[[_server_18]]
==== link:#_server_18[]55.2. Server

[[_commands_received_12]]
===== link:#_commands_received_12[]55.2.1. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DLOG.S.C00.Rsp(RetrieveLogsRequest) |Does the Device(Server) implement
receiving the RetrieveLogsRequest command? |M |
|===

[[_commands_generated_11]]
===== link:#_commands_generated_11[]55.2.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DLOG.S.C01.Tx(RetrieveLogsResponse) |Does the Device(Server)
invoking/generating the RetrieveLogsResponse command? |M |
|===

[[_client_11]]
==== link:#_client_11[]55.3. Client

[[_commands_received_13]]
===== link:#_commands_received_13[]55.3.1. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DLOG.C.C01.Rsp(RetrieveLogsResponse) |Does the Device(client) implement
receiving the RetrieveLogsResponse command? |O |
|===

[[_commands_generated_12]]
===== link:#_commands_generated_12[]55.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DLOG.C.C00.Tx(RetrieveLogsRequest) |Does the Device(client)
invoking/generating the RetrieveLogsRequest command? |O |
|===

[[_test_case_list_18]]
=== link:#_test_case_list_18[]56. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*

|1 |DLOG-1.1 |Global Attributes with DUT as Server - REMOVED

|2 |DLOG-2.1 |Diagnostic Logs Cluster Commands Checks with BDX [DUT
Server] - REMOVED

|3 |DLOG-2.2 |Diagnostic Logs Cluster Commands Checks without BDX [DUT
Server] - REMOVED

|4 |DLOG-3.1 |Diagnostic Logs Cluster Commands Checks[DUT Client] -
REMOVED
|===

[[_test_cases_18]]
=== link:#_test_cases_18[]57. Test Cases

[[_generic_test_cases_15]]
==== link:#_generic_test_cases_15[]57.1. Generic test cases

[[_tc_dlog_1_1_global_attributes_with_dut_as_server_removed]]
===== link:#_tc_dlog_1_1_global_attributes_with_dut_as_server_removed[]57.1.1. [TC-DLOG-1.1] Global Attributes with DUT as Server - REMOVED

[[_category_177]]
====== link:#_category_177[]Category

Functional conformance.

[[_purpose_177]]
====== link:#_purpose_177[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_177]]
====== link:#_pics_177[]PICS

* DLOG.S

[[_required_devices_177]]
====== link:#_required_devices_177[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_177]]
====== link:#_test_procedure_177[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +
0x01.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_173]]
====== link:#_notestesting_considerations_173[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut_10]]
==== link:#_server_as_dut_10[]57.2. Server as DUT

[[_tc_dlog_2_1_diagnostic_logs_cluster_commands_checks_with_bdx_dut_server_removed]]
===== link:#_tc_dlog_2_1_diagnostic_logs_cluster_commands_checks_with_bdx_dut_server_removed[]57.2.1. [TC-DLOG-2.1] Diagnostic Logs Cluster Commands Checks with BDX [DUT-Server] - REMOVED

[[_category_178]]
====== link:#_category_178[]Category

Functional conformance

[[_purpose_178]]
====== link:#_purpose_178[]Purpose

To verify that upon receiving the RetrieveLogsRequest command from the
client, DUT responds with RetrieveLogsResponse command with correct
field values.

[[_pics_178]]
====== link:#_pics_178[]PICS

* DLOG.S

[[_pre_conditions_8]]
====== link:#_pre_conditions_8[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports BDX |
|===

[[_required_devices_178]]
====== link:#_required_devices_178[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_144]]
====== link:#_device_topology_144[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_156]]
====== link:#_test_setup_156[]Test Setup

[[_test_procedure_178]]
====== link:#_test_procedure_178[]Test Procedure

[width="100%",cols="5%,10%,15%,25%,45%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Reboot DUT |

|2 | | |Commission DUT to TH |

|3 |11.10.6.1 | |TH sends RetrieveLogsRequest Command (Intent =
EndUserSupport,TransferFileDesignator = 'test.txt',RequestedProtocol=
BDX) to DUT |

|4 |11.10.6.1 | | |Verify that the DUT initiates a BDX Transfer, sending
a BDX SendInit message with the File Designator field of the message set
to the value of the TransferFileDesignator field of the
RetrieveLogsRequest

|5 |11.21.5.1 | |TH Sends BDX SendAccept message |

|6 | a|
DLOG.S.C01.Tx(RetrieveLogsResponse)

| a|
* Verify that DUT sends RetrieveLogsResponse Command
* Verify that the Status field is set to Success

If LogContent size < 1024 octets

* Verify that the BDX transfer is not initiated from DUT
* Verify that DUT sends RetrieveLogsResponse command with a Status field
set to Exhausted
* Note: In this case steps 5 and 6 does not hold good.

else

* Verify that the BDX transfer is initiated from DUT
* Verify that the LogContent field of RetrieveLogsResponse is empty
* Verify that DUT sends RetrieveLogsResponse command with a Status field
set to Success
* Verify that UTCTimeStamp is included in the RetrieveLogsResponse
command
* Verify that TimeSinceBoot is included in the RetrieveLogsResponse
command
* Note: In this case steps 5 and 6 holds good.

|7 | | |TH sends RetrieveLogsRequest Command (Intent =
EndUserSupport,TransferFileDesignator = 'test.txt',RequestedProtocol=
BDX) to DUT |

|8 | | | |Verify that the DUT initiates a BDX Transfer, sending a BDX
SendInit message with the File Designator field of the message set to
the value of the TransferFileDesignator field of the RetrieveLogsRequest

|9 |11.21.5.2 | |TH Sends StatusReport(GeneralCode: FAILURE, ProtocolId:
BDX, ProtocolCode: TRANSFER_METHOD_NOT_SUPPORTED) |

|10 | | | |Verify that DUT sends RetrieveLogsResponse command with a
Status field set to Denied

|11 |11.10.6.1 | |TH sends RetrieveLogsRequest Command (Intent =
EndUserSupport,RequestedProtocol = ResponsePayload) to DUT |

|12 |11.10.6.2 | | a|
* Verify that the BDX transfer is not initiated from DUT
* Verify that the LogContent field of RetrieveLogsResponse has the size
< = 1024 octets

|13 |11.10.6.2 | | a|
* Verify that DUT sends RetrieveLogsResponse command with a Status field
set to Success
* Verify that UTCTimeStamp is included in the RetrieveLogsResponse
command
* Verify that TimeSinceBoot is included in the RetrieveLogsResponse
command

|===

[[_tc_dlog_2_2_diagnostic_logs_cluster_commands_checks_without_bdx_dut_server_removed]]
===== link:#_tc_dlog_2_2_diagnostic_logs_cluster_commands_checks_without_bdx_dut_server_removed[]57.2.2. [TC-DLOG-2.2] Diagnostic Logs Cluster Commands Checks without BDX [DUT-Server] - REMOVED

[[_category_179]]
====== link:#_category_179[]Category

Functional conformance

[[_purpose_179]]
====== link:#_purpose_179[]Purpose

[[_pics_179]]
====== link:#_pics_179[]PICS

* DLOG.S

[[_pre_conditions_9]]
====== link:#_pre_conditions_9[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT does not support BDX |
|===

[[_required_devices_179]]
====== link:#_required_devices_179[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |client
|2 |DUT |server
|===

[[_device_topology_145]]
====== link:#_device_topology_145[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_157]]
====== link:#_test_setup_157[]Test Setup

[[_test_procedure_179]]
====== link:#_test_procedure_179[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |11.10.6.1 | |TH sends RetrieveLogsRequest Command (Intent =
EndUserSupport,TransferFileDesignator = 'test.txt',RequestedProtocol=
BDX) to DUT |

|3 |11.10.6.2 | | a|
* Verify that the BDX transfer is not initiated from DUT
* Verify that DUT sends RetrieveLogsResponse command
* Verify that the LogContent field of RetrieveLogsResponse command has
the DUT log entries up to < = 1024 octets
* Verify that Status field is set to Exhausted

|===

[[_client_as_dut_6]]
==== link:#_client_as_dut_6[]57.3. Client as DUT

[[_tc_dlog_3_1_diagnostic_logs_cluster_commands_checksdut_client_removed]]
===== link:#_tc_dlog_3_1_diagnostic_logs_cluster_commands_checksdut_client_removed[]57.3.1. [TC-DLOG-3.1] Diagnostic Logs Cluster Commands Checks[DUT-Client] - REMOVED

[[_category_180]]
====== link:#_category_180[]Category

Functional conformance

[[_purpose_180]]
====== link:#_purpose_180[]Purpose

[[_pics_180]]
====== link:#_pics_180[]PICS

* DLOG.C

[[_pre_conditions_10]]
====== link:#_pre_conditions_10[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |DUT supports BDX |
|2 | |TH supports BDX |
|===

[[_required_devices_180]]
====== link:#_required_devices_180[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |server
|2 |DUT |client
|===

[[_device_topology_146]]
====== link:#_device_topology_146[]Device Topology

TH and DUT are on the same fabric

[[_test_setup_158]]
====== link:#_test_setup_158[]Test Setup

[[_test_procedure_180]]
====== link:#_test_procedure_180[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.10.6.1 |DLOG.C.C00.Tx(RetrieveLogsRequest) |DUT sends
RetrieveLogsRequest Command to TH a|
* Verify that the Intent field in RetrieveLogsRequest has one of the
following values:
* 0: EndUserSupport
* 1: NetworkDiag
* 2: CrashLogs

|3 |11.10.6.1 | |In case TH initiates a BDX Transfer a|
* Verify the following:
* RequestedProtocol = BDX in the RetrieveLogsRequest Command sent from
DUT
* TransferFileDesignator has a string value and the length is within 32
characters
* DUT sends BDX SendAccept message to TH

|4 |11.10.6.1 a| a|
In case TH does not initiate BDX Transfer

a|
* Verify the following:
* RequestedProtocol = ResponsePayload in the RetrieveLogsRequest Command
sent from DUT
* DUT does not send BDX SendAccept message to TH

|===

[[_identify_cluster_test_plan]]
== link:#_identify_cluster_test_plan[]**Identify Cluster Test Plan**

[[_pics_definition_19]]
=== link:#_pics_definition_19[]58. PICS Definition

This section covers the Identify Cluster Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_19]]
==== link:#_role_19[]58.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.S |Does the device implement the Identify cluster as a server? |O |

|I.C |Does the device implement the Identify cluster as a client? |O |
|===

[[_server_19]]
==== link:#_server_19[]58.2. Server

[[_features_14]]
===== link:#_features_14[]58.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.S.F00(QRY) |Supports multicast query for identification state |O |
|===

[[_attributes_22]]
===== link:#_attributes_22[]58.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.S.A0000(IdentifyTime) |Does the device implement the _IdentifyTime
attribute_? |M |

|I.S.A0001(IdentifyType) |Does the device implement the _IdentifyType
attribute_? |M |
|===

[[_commands_received_14]]
===== link:#_commands_received_14[]58.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.S.C00.Rsp(Identify) |Does the device implement receiving the
_Identify command_? |M |

|I.S.C01.Rsp(IdentifyQuery) |Does the device implement receiving the
_IdentifyQuery command_? |I.S.F00(QRY) |Not supported by Matter.

|I.S.C40.Rsp(TriggerEffect) |Does the device implement receiving the
_TriggerEffect command_? |O |
|===

[[_commands_generated_13]]
===== link:#_commands_generated_13[]58.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.S.C00.Tx(IdentifyQueryResponse) |Does the device implement sending
the _IdentifyQueryResponse command_? |I.S.F00(QRY) |Not supported by
Matter.
|===

[[_client_12]]
==== link:#_client_12[]58.3. Client

[[_commands_generated_14]]
===== link:#_commands_generated_14[]58.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.C.C00.Tx(Identify) |Does the device implement sending the _Identify
command_? |O |

|I.C.C01.Tx(IdentifyQuery) |Does the device implement sending the
_IdentifyQuery command_? |O |Not supported by Matter.

|I.C.C40.Tx(TriggerEffect) |Does the device implement sending the
_TriggerEffect command_? |O |
|===

[[_commands_received_15]]
===== link:#_commands_received_15[]58.3.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|I.C.C00.Rsp(IdentifyQueryResponse) |Does the device implement receiving
the _IdentifyQueryResponse command_? |O |Not supported by Matter.
|===

[[_test_case_list_19]]
=== link:#_test_case_list_19[]59. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-I-1.1 |Global Attributes with Server as DUT
|2 |TC-I-2.1 |Attributes with Server as DUT
|3 |TC-I-2.2 |Primary Functionality with Server as DUT
|4 |TC-I-2.3 |Secondary Functionality with Server as DUT
|5 |TC-I-3.2 |Functionality with Client as DUT
|===

[[_test_cases_19]]
=== link:#_test_cases_19[]60. Test Cases

'''''

[[_generic_test_cases_16]]
==== link:#_generic_test_cases_16[]60.1. Generic test cases

'''''

[[_tc_i_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_i_1_1_global_attributes_with_server_as_dut[]60.1.1. [TC-I-1.1] Global Attributes with Server as DUT

[[_category_181]]
====== link:#_category_181[]Category

Functional conformance

[[_purpose_181]]
====== link:#_purpose_181[]Purpose

This test case verifies that the DUT can provide the Identify Cluster
Global attributes.

[[_pics_181]]
====== link:#_pics_181[]PICS

* I.S

[[_required_devices_181]]
====== link:#_required_devices_181[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_147]]
====== link:#_device_topology_147[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_159]]
====== link:#_test_setup_159[]Test Setup

Commission DUT to TH

[[_test_procedure_181]]
====== link:#_test_procedure_181[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | | |TH reads the _ClusterRevision attribute_ from the DUT. |Verify
that the DUT response indicates that the _ClusterRevision attribute_ has
the value 4.

|3 | | |TH reads the _FeatureMap attribute_ from the DUT. |Verify that
the _FeatureMap attribute_ has the value: +
*0* - Mandatory +
*1* - PICS I.S.F00(QRY) _*Note*: Multicast query is not supported by
Matter 1.0_.

|4 | | |TH reads the _AttributeList attribute_ from the DUT. |Verify
that the DUT response provides a list of supported attributes. This list
should include the mandatory cluster and global attributes: +
*0, 1* - Mandatory cluster attributes +
*65533, 65532, 65531, 65529, 65528* - Mandatory global attributes
ClusterRevision, FeatureMap, AttributeList, AcceptedCommandList and
GeneratedCommandList

|5 | | |TH reads the _AcceptedCommandList attribute_ from the DUT. a|
Verify that the DUT response provides a list of supported commands. +

This list should include the mandatory commands and optional commands:
*0x00* - I.S.C00.Rsp(Identify)- Mandatory +
*0x01* - I.S.C01.Rsp(IdentifyQuery) - if I.S.F00(QRY) is True +
_*Note*: IdentifyQuery (0x01) is not supported by Matter 1.0_. +
*0x40* - I.S.C40.Rsp(TriggerEffect).

|6 | | |TH reads the _GeneratedCommandList attribute_ from the DUT. a|
Verify that the DUT response provides a list of supported commands. +

This list should include the optional response commands: +
*0x00* - I.S.C00.Tx(IdentifyQueryResponse) -if I.S.F00(QRY) is True +
_*Note*: IdentifyQueryResponse (0x00) is not supported by Matter 1.0_ so
the list will be empty.

|7 | | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. For this cluster the list
is usually empty but it can contain manufacturer specific event IDs.
|===

[[_notestesting_considerations_174]]
====== link:#_notestesting_considerations_174[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec GIT revision
62a474541785eb87d257c204f3ef6cda44f25780

'''''

[[_server_as_dut_11]]
==== link:#_server_as_dut_11[]60.2. Server as DUT

'''''

[[_tc_i_2_1_attributes_with_server_as_dut]]
===== link:#_tc_i_2_1_attributes_with_server_as_dut[]60.2.1. [TC-I-2.1] Attributes with Server as DUT

[[_category_182]]
====== link:#_category_182[]Category

Functional conformance

[[_purpose_182]]
====== link:#_purpose_182[]Purpose

This test case verifies that the DUT can respond to Identify Cluster
attribute read commands.

[[_pics_182]]
====== link:#_pics_182[]PICS

* I.S

[[_required_devices_182]]
====== link:#_required_devices_182[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_148]]
====== link:#_device_topology_148[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_160]]
====== link:#_test_setup_160[]Test Setup

Commission DUT to TH

[[_test_procedure_182]]
====== link:#_test_procedure_182[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | | |TH reads the _IdentifyTime attribute_ from the DUT. |Verify that
the DUT responds with a uint16 value.

|3 | | |TH reads the _IdentifyType attribute_ from the DUT. |Verify that
the DUT responds with an enum8 value. The value has to be in the range
of 0x00 to 0x05.
|===

[[_notestesting_considerations_175]]
====== link:#_notestesting_considerations_175[]Notes/Testing Considerations

Spec GIT revision 62a474541785eb87d257c204f3ef6cda44f25780

[[_tc_i_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_i_2_2_primary_functionality_with_server_as_dut[]60.2.2. [TC-I-2.2] Primary Functionality with Server as DUT

[[_category_183]]
====== link:#_category_183[]Category

Functional

[[_purpose_183]]
====== link:#_purpose_183[]Purpose

This test case verifies the primary functionality of the Identify
cluster server.

[[_pics_183]]
====== link:#_pics_183[]PICS

* I.S

[[_required_devices_183]]
====== link:#_required_devices_183[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_149]]
====== link:#_device_topology_149[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_161]]
====== link:#_test_setup_161[]Test Setup

Commission DUT to TH

[[_test_procedure_183]]
====== link:#_test_procedure_183[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2a | |I.S.C00.Rsp(Identify) |TH sends _Identify command_ to DUT, with
the identify time field set to 0x003c (60s). |

|2b | |I.S.A0000(IdentifyTime) |TH reads immediately _IdentifyTime
attribute_ from DUT. |_IdentifyTime attribute_ has a value approximately
equal to 0x003c.

|2c | |I.S.A0000(IdentifyTime) |After 10 seconds, the TH reads
_IdentifyTime attribute_ from DUT. |_IdentifyTime attribute_ has a value
approximately equal to 0x0032.

|3 | |I.S.C01.Rsp(IdentifyQuery), I.S.C00.Tx(IdentifyQueryResponse) |TH
sends _IdentifyQuery command_ to DUT. +
_*Note*: IdentifyQuery is not supported by Matter_. |DUT should send
_IdentifyQueryResponse command_ to TH, with the Timeout field set to a
value in the range 0x0000 – 0x0032.

|4a | |I.S.C00.Rsp(Identify) |TH sends _Identify command_ to DUT, with
the identify time field set to 0x0000 (stop identifying). |

|4b | |I.S.A0000(IdentifyTime) |TH reads immediately _IdentifyTime
attribute_ from DUT. |_IdentifyTime attribute_ has a value 0x0000.

|5 | |I.S.C01.Rsp(IdentifyQuery), I.S.C00.Tx(IdentifyQueryResponse) |TH
sends _IdentifyQuery command_ to DUT. +
_*Note*: IdentifyQuery is not supported by Matter_. |DUT should not send
a _IdentifyQueryResponse command_ to TH.

|6a | |I.S.A0000(IdentifyTime) |TH writes a value of 0x000f (15s) to
_IdentifyTime attribute_ of DUT. |

|6b | |I.S.A0000(IdentifyTime) |After 5 seconds, the TH reads
_IdentifyTime attribute_ from DUT. |_IdentifyTime attribute_ has a value
approximately equal to 0x000a.
|===

[[_notestesting_considerations_176]]
====== link:#_notestesting_considerations_176[]Notes/Testing Considerations

Spec GIT revision 62a474541785eb87d257c204f3ef6cda44f25780

[[_tc_i_2_3_secondary_functionality_with_server_as_dut]]
===== link:#_tc_i_2_3_secondary_functionality_with_server_as_dut[]60.2.3. [TC-I-2.3] Secondary Functionality with Server as DUT

[[_category_184]]
====== link:#_category_184[]Category

Functional

[[_purpose_184]]
====== link:#_purpose_184[]Purpose

This test case verifies the secondary functionality of the Identify
cluster server.

[[_pics_184]]
====== link:#_pics_184[]PICS

* I.S
* I.S.C40.Rsp(TriggerEffect)

[[_required_devices_184]]
====== link:#_required_devices_184[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_150]]
====== link:#_device_topology_150[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_162]]
====== link:#_test_setup_162[]Test Setup

Commission DUT to TH

[[_test_procedure_184]]
====== link:#_test_procedure_184[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2a | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x00 (blink) and the effect
variant field set to 0x00 (default). |DUT executes a blink effect.

|2b | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x01 (breathe) and the
effect variant field set to 0x00 (default). |DUT executes a breathe
effect.

|2c | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x02 (okay) and the effect
variant field set to 0x00 (default). |DUT executes an okay effect.

|2d | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x0b (channel change) and
the effect variant field set to 0x00 (default). |DUT executes a channel
change effect.

|2e | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x01 (breathe) and the
effect variant field set to 0x00 (default). |DUT executes a breathe
effect.

|2f | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0xfe (finish effect) and
the effect variant field set to 0x00 (default). |DUT stops the breathe
effect after the current effect sequence.

|2g | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x01 (breathe) and the
effect variant field set to 0x00 (default). |DUT executes a breathe
effect.

|2h | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0xff (stop effect) and the
effect variant field set to 0x00 (default). |DUT stops the breathe
effect as soon as possible.

|3a | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0x00 (blink) and the effect
variant field set to 0x42 (unknown). |DUT executes a blink effect.

|3b | |I.S.C40.Rsp(TriggerEffect) |TH sends _TriggerEffect command_ to
DUT, with the effect identifier field set to 0xff (stop effect) and the
effect variant field set to 0x00 (default). |DUT stops any effect that
may be still running as soon as possible.
|===

[[_notestesting_considerations_177]]
====== link:#_notestesting_considerations_177[]Notes/Testing Considerations

Spec GIT revision 62a474541785eb87d257c204f3ef6cda44f25780

'''''

[[_client_as_dut_7]]
==== link:#_client_as_dut_7[]60.3. Client as DUT

'''''

[[_tc_i_3_2_functionality_with_client_as_dut]]
===== link:#_tc_i_3_2_functionality_with_client_as_dut[]60.3.1. [TC-I-3.2] Functionality with Client as DUT

[[_category_185]]
====== link:#_category_185[]Category

Functional

[[_purpose_185]]
====== link:#_purpose_185[]Purpose

This test case verifies the functionality of the Identify cluster
client.

[[_pics_185]]
====== link:#_pics_185[]PICS

* I.C

[[_required_devices_185]]
====== link:#_required_devices_185[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_151]]
====== link:#_device_topology_151[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_163]]
====== link:#_test_setup_163[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_185]]
====== link:#_test_procedure_185[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |I.C.C00.Tx(Identify) |DUT issues an _Identify command_ to the Test
Harness, with the IdentifyTime argument set to 0x003C (60 seconds) or a
reasonable time that is supported by the DUT. |If I.C.C00.Tx(Identify),
Test Harness receives the _Identify command_ from the DUT. It has one
parameter (ID 0) of type uint16 with a value != 0.

|2 | |I.C.C01.Tx(IdentifyQuery) |DUT issues an _IdentifyQuery command_
to the Test Harness. +
_*Note*: IdentifyQuery is not supported by Matter_. |If
I.C.C01.Tx(IdentifyQuery), Test Harness receives the _IdentifyQuery
command_ from the DUT. The command has no parameters.

|3 | |I.C.C00.Tx(Identify) |DUT issues an _Identify command_ to the Test
Harness, with the IdentifyTime argument set to 0x0000 (Stop). |If
I.C.C00.Tx(Identify), Test Harness receives the _Identify command_ from
the DUT. It has one parameter (ID 0) of type uint16 with a value == 0.

|4 | |I.C.C40.Tx(TriggerEffect) |DUT sends a _TriggerEffect command_ to
the Test Harness, with any supported EffectIdentifier argument and
EffectVariant set to 0. |If I.C.C40.Tx(TriggerEffect), Test Harness
receives the _TriggerEffect command_ from the DUT. Verify the command
has two parameters: +
ID 0: the type is an enum8, the value has to be 0x00, 0x01, 0x02, 0x0b
0xfe or 0xff. +
ID 1: the type is an enum8, the value has to be 0x00.
|===

[[_notestesting_considerations_178]]
====== link:#_notestesting_considerations_178[]Notes/Testing Considerations

Spec GIT revision 62a474541785eb87d257c204f3ef6cda44f25780

[[_power_source_cluster_test_plan]]
== link:#_power_source_cluster_test_plan[]**Power Source Cluster Test Plan**

[[testplan_PowerSource]]
=== link:#testplan_PowerSource[]61. PICS Definition

This section covers the Power Source Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_20]]
==== link:#_role_20[]61.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PS.S |Does the device implement the Power Source cluster as a server?
|O |
|===

[[_server_20]]
==== link:#_server_20[]61.2. Server

[[_features_15]]
===== link:#_features_15[]61.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PS.S.F00(WIRED) |A wired power source |O |

|PS.S.F01(BAT) |A battery power source |O |

|PS.S.F02(RECHG) |A rechargeable battery power source (requires Battery
feature) |O |

|PS.S.F03(REPLC) |A replaceable battery power source (requires Battery
feature) |O |
|===

[[_attributes_23]]
===== link:#_attributes_23[]61.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PS.S.A0000(Status) |Does the device implement the Status attribute? |M
|

|PS.S.A0001(Order) |Does the device implement the Order attribute? |M |

|PS.S.A0002(Description) |Does the device implement the Description
attribute? |M |

|PS.S.A0003(WiredAssessedInputVoltage) |Does the device implement the
WiredAssessedInputVoltage attribute? |PS.S.F00(WIRED): O |

|PS.S.A0004(WiredAssessedInputFrequency) |Does the device implement the
WiredAssessedInputFrequency attribute? |PS.S.F00(WIRED): O |

|PS.S.A0005(WiredCurrentType) |Does the device implement the
WiredCurrentType attribute? |PS.S.F00(WIRED): M |

|PS.S.A0006(WiredAssessedCurrent) |Does the device implement the
WiredAssessedCurrent attribute? |PS.S.F00(WIRED): O |

|PS.S.A0007(WiredNominalVoltage) |Does the device implement the
WiredNominalVoltage attribute? |PS.S.F00(WIRED): O |

|PS.S.A0008(WiredMaximumCurrent) |Does the device implement the
WiredMaximumCurrent attribute? |PS.S.F00(WIRED): O |

|PS.S.A0009(WiredPresent) |Does the device implement the WiredPresent
attribute? |PS.S.F00(WIRED): O |

|PS.S.A000a(ActiveWiredFaults) |Does the device implement the
ActiveWiredFaults attribute? |PS.S.F00(WIRED): O |

|PS.S.A000b(BatVoltage) |Does the device implement the BatVoltage
attribute? |PS.S.F01(BAT): O |

|PS.S.A000c(BatPercentRemaining) |Does the device implement the
BatPercentRemaining attribute? |PS.S.F01(BAT): O |

|PS.S.A000d(BatTimeRemaining) |Does the device implement the
BatTimeRemaining attribute? |PS.S.F01(BAT): O |

|PS.S.A000e(BatChargeLevel) |Does the device implement the
BatChargeLevel attribute? |PS.S.F01(BAT): M |

|PS.S.A000f(BatReplacementNeeded) |Does the device implement the
BatReplacementNeeded attribute? |PS.S.F01(BAT): M |

|PS.S.A0010(BatReplaceability) |Does the device implement the
BatReplaceability attribute? |PS.S.F01(BAT): M |

|PS.S.A0011(BatPresent) |Does the device implement the BatPresent
attribute? |PS.S.F01(BAT): O |

|PS.S.A0012(ActiveBatFaults) |Does the device implement the
ActiveBatFaults attribute? |PS.S.F01(BAT): O |

|PS.S.A0013(BatReplacementDescription) |Does the device implement the
BatReplacementDescription attribute? |PS.S.F03(REPLC): M |

|PS.S.A0014(BatCommonDesignation) |Does the device implement the
BatCommonDesignation attribute? |PS.S.F03(REPLC): O |

|PS.S.A0015(BatANSIDesignation) |Does the device implement the
BatANSIDesignation attribute? |PS.S.F03(REPLC): O |

|PS.S.A0016(BatIECDesignation) |Does the device implement the
BatIECDesignation attribute? |PS.S.F03(REPLC): O |

|PS.S.A0017(BatApprovedChemistry) |Does the device implement the
BatApprovedChemistry attribute? |PS.S.F03(REPLC): O |

|PS.S.A0018(BatCapacity) |Does the device implement the BatCapacity
attribute? |PS.S.F03(REPLC): O |

|PS.S.A0019(BatQuantity) |Does the device implement the BatQuantity
attribute? |PS.S.F03(REPLC): M |

|PS.S.A001a(BatChargeState) |Does the device implement the
BatChargeState attribute? |PS.S.F02(RECHG): M |

|PS.S.A001b(BatTimeToFullCharge) |Does the device implement the
BatTimeToFullCharge attribute? |PS.S.F02(RECHG): O |

|PS.S.A001c(BatFunctionalWhileCharging) |Does the device implement the
BatFunctionalWhileCharging attribute? |PS.S.F02(RECHG): M |

|PS.S.A001d(BatChargingCurrent) |Does the device implement the
BatChargingCurrent attribute? |PS.S.F02(RECHG): O |

|PS.S.A001e(ActiveBatChargeFaults) |Does the device implement the
ActiveBatChargeFaults attribute? |PS.S.F02(RECHG): O |

|PS.S.A001f(EndpointList) |Does the device implement the EndpointList
attribute? |M |
|===

[[_manual_controllable_11]]
===== link:#_manual_controllable_11[]61.2.3. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PS.M.ManualWiredFault |Can the DUT be brought into a Wired Fault state?
|PS.S.F00(WIRED): O |

|PS.M.ManualBatFault |Can the DUT be brought into a Battery Fault state?
|PS.S.F01(BAT): O |

|PS.M.ManualBatChargeFault |Can the DUT be brought into a Battery Charge
Fault state? |PS.S.F02(RECHG): O |
|===

[[_events_5]]
===== link:#_events_5[]61.2.4. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PS.S.E00(WiredFaultChange) |Does the device implement the
WiredFaultChange event? |PS.S.F00(WIRED): O |

|PS.S.E01(BatFaultChange) |Does the device implement the BatFaultChange
event? |PS.S.F01(BAT): O |

|PS.S.E02(BatChargeFaultChange) |Does the device implement the
BatChargeFaultChange event? |PS.S.F02(RECHG): O |
|===

[[_test_case_list_20]]
=== link:#_test_case_list_20[]62. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-PS-1.1 |Global attributes with server as DUT
|TC-PS-2.1 |Attributes with server as DUT
|TC-PS-2.2 |Event reporting with server as DUT - REMOVED
|===

[[_test_cases_20]]
=== link:#_test_cases_20[]63. Test Cases

'''''

[[_generic_test_cases_17]]
==== link:#_generic_test_cases_17[]63.1. Generic test cases

'''''

[[_tc_ps_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_ps_1_1_global_attributes_with_server_as_dut[]63.1.1. [TC-PS-1.1] Global attributes with server as DUT

[[_category_186]]
====== link:#_category_186[]Category

Functional conformance

[[_purpose_186]]
====== link:#_purpose_186[]Purpose

This test case verifies that the DUT can provide the Power Source
Cluster Global attributes

[[_pics_186]]
====== link:#_pics_186[]PICS

* PS.S

[[_required_devices_186]]
====== link:#_required_devices_186[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_152]]
====== link:#_device_topology_152[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_164]]
====== link:#_test_setup_164[]Test Setup

Commission DUT to TH

[[_test_procedure_186]]
====== link:#_test_procedure_186[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | | |TH reads the _ClusterRevision attribute_ from the DUT |Verify
that the DUT response indicates that the ClusterRevision attribute has
the value 2

|3 | | |TH reads the _FeatureMap attribute_ from the DUT |Verify that
the DUT response indicates that the FeatureMap attribute has +
* bit 0 set to 1 if the DUT has a wired power source PS.S.F00(WIRED) is
true +
* bit 1 set to 1 if the DUT has a battery power source PS.S.F01(BAT) is
true +
* bit 1 and bit 2 set to 1 if the DUT has a rechargeable battery power
source PS.S.F02(RECHG) is true +
* bit 1 and bit 3 set to 1 if the DUT has a replaceable battery power
source PS.S.F03(REPLC) is true

|4 | | |TH reads the _AttributeList attribute_ from the DUT |Verify that
the DUT response provides a list of supported attributes. +
 +
This list SHALL include all the *mandatory* attribute (value 0x00, 0x01,
0x02 and 0x1f). +
If PS.S.F00(WIRED) this entry is mandatory: 5 +
If PS.S.F01(BAT) these entries are mandatory: 14, 15 and 16 +
If PS.S.F02(RECHG) these entries are mandatory: 26 and 28 +
If PS.S.F03(REPLC) these entries are mandatory: 19 and 25 +
It should also include the global attributes ClusterRevision,
FeatureMap, AttributeList, AcceptedCommandList and GeneratedCommandList
(value 65533, 65532, 65531, 65529 and 65528) +
 +
Following entries are *optional*: +
If PS.S.F00(WIRED) : 3, 4, 6, 7, 8, 9 and 10 +
If PS.S.F01(BAT) : 11, 12, 13, 17 and 18 +
If PS.S.F02(RECHG) : 27, 29 and 30 +
If PS.S.F03(REPLC) : 20, 21, 22, 23 and 24

|5 | | |TH reads the _AcceptedCommandList attribute_ from the DUT
|Verify that the DUT response provides a list of supported commands. For
this cluster the list is usually empty but it can contain manufacturer
specific command IDs.

|6 | | |TH reads the _GeneratedCommandList attribute_ from the DUT
|Verify that the DUT response provides a list of supported commands. For
this cluster the list is usually empty.

|7 | | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. +
This list can be empty or contain following optional event IDs: +
if PS.S.E00(WiredFaultChange) : 0 +
if PS.S.E01(BatFaultChange): 1 +
if PS.S.E02(BatChargeFaultChange): 2 +
Optionally the list can also contain manufacturer specific event IDs.
|===

[[_notestesting_considerations_179]]
====== link:#_notestesting_considerations_179[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec GIT revision
c4688d430620af534f51e6e002e2ac13deed2223

'''''

[[_server_as_dut_12]]
==== link:#_server_as_dut_12[]63.2. Server as DUT

'''''

[[_tc_ps_2_1_attributes_with_server_as_dut]]
===== link:#_tc_ps_2_1_attributes_with_server_as_dut[]63.2.1. [TC-PS-2.1] Attributes with server as DUT

[[_category_187]]
====== link:#_category_187[]Category

Functional conformance

[[_purpose_187]]
====== link:#_purpose_187[]Purpose

This test case verifies that the DUT can respond to Power Source Cluster
attribute read commands.

[[_pics_187]]
====== link:#_pics_187[]PICS

* PS.S

[[_required_devices_187]]
====== link:#_required_devices_187[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_153]]
====== link:#_device_topology_153[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_165]]
====== link:#_test_setup_165[]Test Setup

Commission DUT to TH

[[_test_procedure_187]]
====== link:#_test_procedure_187[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |PS.S.A0000(Status) |Test Harness Client reads _Status_ from Server
DUT |Verify that the DUT responds with an enum8 value present in the
PowerSourceStatusEnum list of values for the cluster version.

|3 | |PS.S.A0001(Order) |Test Harness Client reads _Order_ from Server
DUT |Verify that the DUT responds with a uint8 value.

|4 | |PS.S.A0002(Description) |Test Harness Client reads _Description_
from Server DUT |Verify that the DUT responds with a string value with a
length of 0 to 60 characters.

|5 | |PS.S.A0003(WiredAssessedInputVoltage) |Test Harness Client reads
_WiredAssessedInputVoltage_ from Server DUT |Verify that the DUT
responds with a uint32 value or null.

|6 | |PS.S.A0004(WiredAssessedInputFrequency) |Test Harness Client reads
_WiredAssessedInputFrequency_ from Server DUT |Verify that the DUT
responds with a uint16 value or null.

|7 | |PS.S.A0005(wiredCurrentType) |Test Harness Client reads
_WiredCurrentType_ from Server DUT |Verify that the DUT responds with an
enum8 value present in the WiredCurrentTypeEnum list of values for the
cluster version.

|8 | |PS.S.A0006(WiredAssessedCurrent) |Test Harness Client reads
_WiredAssessedCurrent_ from Server DUT |Verify that the DUT responds
with a uint32 value or null.

|9 | |PS.S.A0007(WiredNominalVoltage) |Test Harness Client reads
_WiredNominalVoltage_ from Server DUT |Verify that the DUT responds with
a uint32 value.

|10 | |PS.S.A0008(WiredMaximumCurrent) |Test Harness Client reads
_WiredMaximumCurrent_ from Server DUT |Verify that the DUT responds with
a uint32 value.

|11 | |PS.S.A0009(WiredPresent) |Test Harness Client reads
_WiredPresent_ from Server DUT |Verify that the DUT responds with a bool
value.

|12 | |PS.S.A000a(ActiveWiredFaults) |Test Harness Client reads
_ActiveWiredFaults_ from Server DUT |Verify that the DUT responds with a
list. The list has not more than 8 entries. Each entry is an enum8 value
from the WiredFaultEnum list of values for the cluster version.

|13 | |PS.S.A000b(BatVoltage) |Test Harness Client reads _BatVoltage_
from Server DUT |Verify that the DUT responds with a uint32 value or
null.

|14 | |PS.S.A000c(BatPercentRemaining) |Test Harness Client reads
_BatPercentRemaining_ from Server DUT |Verify that the DUT responds with
a uint8 value or null. If a non-null value is returned, it must be in
the range of 0 to 200.

|15 | |PS.S.A000d(BatTimeRemaining) |Test Harness Client reads
_BatTimeRemaining_ from Server DUT |Verify that the DUT responds with a
uint32 value or null.

|16 | |PS.S.A000e(BatChargeLevel) |Test Harness Client reads
_BatChargeLevel_ from Server DUT |Verify that the DUT responds with an
enum8 value in the BatChargeLevelEnum list of values for the cluster
version.

|17 | |PS.S.A000f(BatReplacementNeeded) |Test Harness Client reads
_BatReplacementNeeded_ from Server DUT |Verify that the DUT responds
with a bool value.

|18 | |PS.S.A0010(BatReplaceability) |Test Harness Client reads
_BatReplaceability_ from Server DUT |Verify that the DUT responds with
an enum8 value in the BatReplaceabilityEnum list of values for the
cluster version.

|19 | |PS.S.A0011(BatPresent) |Test Harness Client reads _BatPresent_
from Server DUT |Verify that the DUT responds with a bool value.

|20 | |PS.S.A0012(ActiveBatFaults) |Test Harness Client reads
_ActiveBatFaults_ from Server DUT |Verify that the DUT responds with a
list. The list has not more than 8 entries. Each entry is an enum8 from
the BatFaultEnum list of values for the cluster version.

|21 | |PS.S.A0013(BatReplacementDescription) |Test Harness Client reads
_BatReplacementDescription_ from Server DUT |Verify that the DUT
responds with a string value with a length of 0 to 60 characters.

|22 | |PS.S.A0014(BatCommonDesignation) |Test Harness Client reads
_BatCommonDesignation_ from Server DUT |Verify that the DUT responds
with an enum16 value present in the BatCommonDesignationEnum list of
values for the cluster version.

|23 | |PS.S.A0015(BatANSIDesignation) |Test Harness Client reads
_BatANSIDesignation_ from Server DUT |Verify that the DUT responds with
a string value with a length of 0 to 20 characters.

|24 | |PS.S.A0016(BatIECDesignation) |Test Harness Client reads
_BatIECDesignation_ from Server DUT |Verify that the DUT responds with a
string value with a length of 0 to 20 characters.

|25 | |PS.S.A0017(BatApprovedChemistry) |Test Harness Client reads
_BatApprovedChemistry_ from Server DUT |Verify that the DUT responds
with an enum16 value present in the BatApprovedChemistryEnum list of
values for the cluster version.

|26 | |PS.S.A0018(BatCapacity) |Test Harness Client reads _BatCapacity_
from Server DUT |Verify that the DUT responds with a uint32 value.

|27 | |PS.S.A0019(BatQuantity) |Test Harness Client reads _BatQuantity_
from Server DUT |Verify that the DUT responds with a uint8 value.

|28 | |PS.S.A001a(BatChargeState) |Test Harness Client reads
_BatChargeState_ from Server DUT |Verify that the DUT responds with an
enum8 value present in the BatChargeStateEnum list of values for the
cluster version.

|29 | |PS.S.A001b(BatTimeToFullCharge) |Test Harness Client reads
_BatTimeToFullCharge_ from Server DUT |Verify that the DUT responds with
a uint32 value or null.

|30 | |PS.S.A001c(BatFunctionalWhileCharging) |Test Harness Client reads
_BatFunctionalWhileCharging_ from Server DUT |Verify that the DUT
responds with a bool value.

|31 | |PS.S.A001d(BatChargingCurrent) |Test Harness Client reads
_BatChargingCurrent_ from Server DUT |Verify that the DUT responds with
a uint32 value or null.

|32 | |PS.S.A001e(ActiveBatChargeFaults) |Test Harness Client reads
_ActiveBatChargeFaults_ from Server DUT |Verify that the DUT responds
with a list. The list has not more than 16 entries. Each entry is an
enum8 value present in the BatChargeFaultEnum list of values for the
cluster version.

|33 | |PS.S.A001f(EndpointList) |Test Harness Client reads
_EndpointList_ from Server DUT |Verify that the DUT responds with a
list. Each entry is an endpoint-id.
|===

[[_notestesting_considerations_180]]
====== link:#_notestesting_considerations_180[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223 Test Steps
5-15 and 19-32 cannot be executed with V1.0 SDK The contents of the
EndpointList are checked fully in the endpoint composition test

[[_tc_ps_2_2_event_reporting_with_server_as_dut_removed]]
===== link:#_tc_ps_2_2_event_reporting_with_server_as_dut_removed[]63.2.2. [TC-PS-2.2] Event reporting with server as DUT - REMOVED

[[_category_188]]
====== link:#_category_188[]Category

Functional conformance

[[_purpose_188]]
====== link:#_purpose_188[]Purpose

Tests event reporting of the Power Source Cluster server. This includes
the following events:

* WiredFaultChange
* BatFaultChange
* BatChargeFaultChange

[[_pics_188]]
====== link:#_pics_188[]PICS

* PS.S

[[_required_devices_188]]
====== link:#_required_devices_188[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_154]]
====== link:#_device_topology_154[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_166]]
====== link:#_test_setup_166[]Test Setup

Commission DUT to TH

[[_test_procedure_188]]
====== link:#_test_procedure_188[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH

*Wired Faults*

2a

PS.S.A000a(ActiveWiredFaults)

Bring the DUT into a state without any wired faults.

2b

TH reads the _ActiveWiredFaults attribute_ from the DUT

Verify that the list is empty.

3a

PS.S.E00(WiredFaultChange), PS.M.ManualWiredFault

Set up subscription to WiredFaultChange event

3b

Bring the DUT into a wired fault state.

Receive a WiredFaultChange event with +
* a non-empty Current field +
* an empty Previous field.

4

PS.S.A000a(ActiveWiredFaults), PS.M.ManualWiredFault

TH reads the _ActiveWiredFaults attribute_ from the DUT

Verify that the list is not empty.

5

PS.S.E00(WiredFaultChange), +
PS.S.A000a(ActiveWiredFaults) PS.M.ManualWiredFault

The Current field of Step 3b has to be the same as the value of Step 4.

6

PS.S.E00(WiredFaultChange), PS.M.ManualWiredFault

Bring the DUT back into a clean state.

Receive a WiredFaultChange event with +
* an empty Current field +
* a non-empty Previous field. +
The Previous field has to have the same values as the Current field in
Step 3b.

*Battery Faults*

7a

PS.S.A0012(ActiveBatFaults)

Bring the DUT into a state without any battery faults.

7b

TH reads the _ActiveBatFaults attribute_ from the DUT

Verify that the list is empty.

8a

PS.S.E01(BatFaultChange), PS.M.ManualBatFault

Set up subscription to BatFaultChange event

8b

Bring the DUT into a battery fault state.

Receive a BatFaultChange event with +
* a non-empty Current field +
* an empty Previous field.

9

PS.S.A0012(ActiveBatFaults), PS.M.ManualBatFault

TH reads the _ActiveBatFaults attribute_ from the DUT

Verify that the list is not empty.

10

PS.S.E01(BatFaultChange), +
PS.S.A0012(ActiveBatFaults), PS.M.ManualBatFault

The Current field of Step 8b has to be the same as the value of Step 9.

11

PS.S.E01(BatFaultChange), PS.M.ManualBatFault

Bring the DUT back into a clean state.

Receive a BatFaultChange event with +
* an empty Current field +
* a non-empty Previous field. +
The Previous field has to have the same values as the Current field in
Step 8b.

*Charge Faults*

12a

PS.S.A001e(ActiveBatChargeFaults)

Bring the DUT into a state without any charge faults.

12b

TH reads the _ActiveBatChargeFaults attribute_ from the DUT

Verify that the list is empty.

13a

PS.S.E02(BatChargeFaultChange), PS.M.ManualBatChargeFault

Set up subscription to BatChargeFaultChange event

13b

Bring the DUT into a charge fault state.

Receive a BatChargeFaultChange event with +
* a non-empty Current field +
* an empty Previous field.

14

PS.S.A001e(ActiveBatChargeFaults), PS.M.ManualBatChargeFault

TH reads the _ActiveBatChargeFaults attribute_ from the DUT

Verify that the list is not empty.

15

PS.S.E02(BatChargeFaultChange), +
PS.S.A001e(ActiveBatChargeFaults), PS.M.ManualBatChargeFault

The Current field of Step 13b has to be the same as the value of Step
14.

16

PS.S.E02(BatChargeFaultChange), PS.M.ManualBatChargeFault

Bring the DUT back into a clean state.

Receive a BatChargeFaultChange event with +
* an empty Current field +
* a non-empty Previous field. +
The Previous field has to have the same values as the Current field in
Step 13b.

[[_notestesting_considerations_181]]
=== link:#_notestesting_considerations_181[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_ps_3_1_endpoint_composition_and_endpointlist]]
=== link:#_tc_ps_3_1_endpoint_composition_and_endpointlist[]63.2.3. [TC-PS-3.1] Endpoint composition and EndpointList

[[_category_189]]
==== link:#_category_189[]Category

Functional conformance

[[_purpose_189]]
==== link:#_purpose_189[]Purpose

Tests that the EndpointList attribute is properly implemented

[[_pics_189]]
==== link:#_pics_189[]PICS

* PS.S

[[_required_devices_189]]
==== link:#_required_devices_189[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_155]]
==== link:#_device_topology_155[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_167]]
==== link:#_test_setup_167[]Test Setup

Commission DUT to TH

[[_test_procedure_189]]
==== link:#_test_procedure_189[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |TH performs a wildcard read of all attributes and endpoints |

|2 | | | |For each power source cluster with a non-empty EndpointsList
attribute, verify that the endpoint exists on the device; also verify
that the EndpointsList attribute includes the endpoint on which the
cluster is located

|3 | | | |For each power source cluster on an endpoint with the Bridged
Node device type, ensure the EndpointList in the Power Source cluster
includes all the endpoints listed in the PartsList of the Descriptor
cluster as well as its own endpoint id.

|4 | | | |For each power source cluster on an endpoint that is a child
endpoint of an endpoint with a Bridged Node device type, ensure the
EndpointList in the Power Source cluster contains a list with one entry
that lists its own endpoint id
|===

[[_power_source_configuration_cluster_test_plan]]
== link:#_power_source_configuration_cluster_test_plan[]**Power Source Configuration Cluster Test Plan**

[[testplan_PowerSourceConfiguration]]
=== link:#testplan_PowerSourceConfiguration[]64. PICS Definition

This section covers the Power Source Configuration Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_21]]
==== link:#_role_21[]64.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PSCFG.S |Does the device implement the Power Source Configuration
cluster as a server? |O |

|PSCFG.C |Does the device implement the Power Source Configuration
cluster as a client? |O |
|===

[[_server_21]]
==== link:#_server_21[]64.2. Server

[[_attributes_24]]
===== link:#_attributes_24[]64.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PSCFG.S.A0000(Sources) |Does the device implement the Sources
attribute? |PSCFG.S: M |
|===

[[_test_case_list_21]]
=== link:#_test_case_list_21[]65. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-PSCFG-1.1 |Global attributes with server as DUT
|TC-PSCFG-2.1 |Attributes with server as DUT
|TC-PSCFG-2.2 |Primary functionality with server as DUT
|===

[[_test_cases_21]]
=== link:#_test_cases_21[]66. Test Cases

'''''

[[_generic_test_cases_18]]
==== link:#_generic_test_cases_18[]66.1. Generic test cases

'''''

[[_tc_pscfg_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_pscfg_1_1_global_attributes_with_server_as_dut[]66.1.1. [TC-PSCFG-1.1] Global attributes with server as DUT

[[_category_190]]
====== link:#_category_190[]Category

Functional

[[_purpose_190]]
====== link:#_purpose_190[]Purpose

This test case verifies the behavior of the global attributes of the
cluster client and server.

[[_pics_190]]
====== link:#_pics_190[]PICS

* PSCFG.S

[[_required_devices_190]]
====== link:#_required_devices_190[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_156]]
====== link:#_device_topology_156[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_168]]
====== link:#_test_setup_168[]Test Setup

Commission DUT to TH

[[_test_procedure_190]]
====== link:#_test_procedure_190[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | | |TH reads the _ClusterRevision attribute_ from the DUT |Verify
that the DUT response indicates that the ClusterRevision attribute has
the value 1

|3 | | |TH reads the _FeatureMap attribute_ from the DUT |Verify that
the FeatureMap attribute has the value 0.

|4 | | |TH reads the _AttributeList attribute_ from the DUT |Verify that
the DUT response provides a list of supported attributes. This list
should include the mandatory attribute (value 0) +
It should also include the global attributes ClusterRevision,
FeatureMap, AttributeList, AcceptedCommandList and GeneratedCommandList
(value 65533, 65532, 65531, 65529 and 65528)

|5 | | |TH reads the _AcceptedCommandList attribute_ from the DUT
|Verify that the DUT response provides a list of supported commands. For
this cluster the list is usually empty but it can contain manufacturer
specific command IDs.

|6 | | |TH reads the _GeneratedCommandList attribute_ from the DUT
|Verify that the DUT response provides a list of supported commands. For
this cluster the list is usually empty.

|7 | | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. For this cluster the list
is usually empty but it can contain manufacturer specific event IDs.
|===

[[_notestesting_considerations_182]]
====== link:#_notestesting_considerations_182[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec GIT revision
c4688d430620af534f51e6e002e2ac13deed2223

'''''

[[_server_as_dut_13]]
==== link:#_server_as_dut_13[]66.2. Server as DUT

'''''

[[_tc_pscfg_2_1_attributes_with_server_as_dut]]
===== link:#_tc_pscfg_2_1_attributes_with_server_as_dut[]66.2.1. [TC-PSCFG-2.1] Attributes with server as DUT

[[_category_191]]
====== link:#_category_191[]Category

Functional

[[_purpose_191]]
====== link:#_purpose_191[]Purpose

This test case verifies the behavior of the non-global attributes of the
Power Source Configuration cluster server.

[[_pics_191]]
====== link:#_pics_191[]PICS

* PSCFG.S

[[_required_devices_191]]
====== link:#_required_devices_191[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_157]]
====== link:#_device_topology_157[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_169]]
====== link:#_test_setup_169[]Test Setup

Commission DUT to TH

[[_test_procedure_191]]
====== link:#_test_procedure_191[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |PSCFG.S.A0000(Sources) |TH reads the _Sources attribute_ from the
DUT |Verify that the DUT response provides a list. Each entry in the
list has to be the endpoint number of an endpoint having a Power Source
cluster.
|===

[[_notestesting_considerations_183]]
====== link:#_notestesting_considerations_183[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_tc_pscfg_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_pscfg_2_2_primary_functionality_with_server_as_dut[]66.2.2. [TC-PSCFG-2.2] Primary functionality with server as DUT

[[_category_192]]
====== link:#_category_192[]Category

Functional conformance

[[_purpose_192]]
====== link:#_purpose_192[]Purpose

This test case verifies the primary functionality of the Power Source
Configuration Cluster server.

[[_pics_192]]
====== link:#_pics_192[]PICS

* PSCFG.S

[[_required_devices_192]]
====== link:#_required_devices_192[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_158]]
====== link:#_device_topology_158[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_170]]
====== link:#_test_setup_170[]Test Setup

Commission DUT to TH

[[_test_procedure_192]]
====== link:#_test_procedure_192[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH

2

PSCFG.S.A0000(Sources)

TH reads the _Sources attribute_ from the DUT

Verify that the DUT response provides a list. +
The list has not more than 6 entries. +
Each entry in this list is a valid endpoint number. +
Each list entry is unique, there are no duplicates.

3

For each endpoint number (eNr) in this list do

3a

TH reads the _Order attribute_ from Power Source Cluster at
Endpoint[eNr] of the DUT

Read succeeds with no error. +
The order value is the same or greater than the order value of the
previous iteration. (For the first iteration this check can obviously be
skipped).

[[_notestesting_considerations_184]]
=== link:#_notestesting_considerations_184[]Notes/Testing Considerations

Spec GIT revision c4688d430620af534f51e6e002e2ac13deed2223

[[_boolean_state_cluster_test_plan]]
== link:#_boolean_state_cluster_test_plan[]**Boolean State Cluster Test Plan**

[[_pics_definition_20]]
=== link:#_pics_definition_20[]67. PICS Definition

This section covers the Boolean State Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_22]]
==== link:#_role_22[]67.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BOOL.S |Does the device implement the Boolean State cluster as a
server? |O |
|===

[[_server_22]]
==== link:#_server_22[]67.2. Server

[[_attributes_25]]
===== link:#_attributes_25[]67.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BOOL.S.A0000(StateValue) |Does the device implement the _StateValue
attribute_? |M |
|===

[[_manual_controllable_12]]
===== link:#_manual_controllable_12[]67.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BOOL.M.ManuallyControlled |Can the _StateValue attribute_ be changed by
manual operation at the DUT? |O |
|===

[[_events_6]]
===== link:#_events_6[]67.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BOOL.S.E00(StateChange) |Does the device implement the _StateChange
event_? |O |
|===

[[_test_case_list_22]]
=== link:#_test_case_list_22[]68. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-BOOL-1.1 |Global Attributes with Server as DUT
|2 |TC-BOOL-2.1 |Attributes with Server as DUT
|3 |TC-BOOL-2.2 |Primary Functionality with Server as DUT
|===

[[_test_cases_22]]
=== link:#_test_cases_22[]69. Test Cases

'''''

[[_generic_test_cases_19]]
==== link:#_generic_test_cases_19[]69.1. Generic test cases

'''''

[[_tc_bool_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_bool_1_1_global_attributes_with_server_as_dut[]69.1.1. [TC-BOOL-1.1] Global Attributes with Server as DUT

[[_category_193]]
====== link:#_category_193[]Category

Functional conformance

[[_purpose_193]]
====== link:#_purpose_193[]Purpose

This test case verifies that the DUT can provide the Level Control
Cluster Global attributes.

[[_pics_193]]
====== link:#_pics_193[]PICS

* BOOL.S

[[_required_devices_193]]
====== link:#_required_devices_193[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_159]]
====== link:#_device_topology_159[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_171]]
====== link:#_test_setup_171[]Test Setup

Commission DUT to TH

[[_test_procedure_193]]
====== link:#_test_procedure_193[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | | |TH reads the _ClusterRevision attribute_ from the DUT. |Verify
that the DUT response indicates that the _ClusterRevision attribute_ has
the value 1.

|3 | | |TH reads the _FeatureMap attribute_ from the DUT. |Verify that
the _FeatureMap attribute_ has the value 0.

|4 | | |TH reads the _AttributeList attribute_ from the DUT. |Verify
that the DUT response provides a list of supported attributes. This list
should include the mandatory attribute (value 0). +
It should also include the global attributes ClusterRevision,
FeatureMap, AttributeList, AcceptedCommandList and GeneratedCommandList
(value 65533, 65532, 65531, 65529 and 65528).

|5 | | |TH reads the _AcceptedCommandList attribute_ from the DUT.
|Verify that the DUT response provides a list of supported commands.For
this cluster the list is usually empty but it can contain manufacturer
specific command IDs.

|6 | | |TH reads the _GeneratedCommandList attribute_ from the DUT.
|Verify that the DUT response provides a list of supported commands.For
this cluster the list is usually empty.

|7 | | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. +
If BOOL.S.E00(StateChange) == false, the list is usually empty. +
If BOOL.S.E00(StateChange) == true, the list has to contain 0
(_StateChange event_). +
Optionally the list can also contain manufacturer specific event IDs.
|===

[[_notestesting_considerations_185]]
====== link:#_notestesting_considerations_185[]Notes/Testing Considerations

Test Step #7 cannot be executed with V1.0 SDK. Spec GIT revision
1a767fee749efe03b2c8fea4bb22b7681d2ee6b4

'''''

[[_server_as_dut_14]]
==== link:#_server_as_dut_14[]69.2. Server as DUT

'''''

[[_tc_bool_2_1_attributes_with_server_as_dut]]
===== link:#_tc_bool_2_1_attributes_with_server_as_dut[]69.2.1. [TC-BOOL-2.1] Attributes with Server as DUT

[[_category_194]]
====== link:#_category_194[]Category

Functional conformance

[[_purpose_194]]
====== link:#_purpose_194[]Purpose

This test case verifies that the DUT can respond to Boolean State
Cluster attribute read commands.

[[_pics_194]]
====== link:#_pics_194[]PICS

* BOOL.S

[[_required_devices_194]]
====== link:#_required_devices_194[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_160]]
====== link:#_device_topology_160[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_172]]
====== link:#_test_setup_172[]Test Setup

Commission DUT to TH

[[_test_procedure_194]]
====== link:#_test_procedure_194[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | |BOOL.S.A0000(StateValue) |TH reads the _StateValue attribute_ from
the DUT. |Verify that the DUT responds with a boolean value.
|===

[[_notestesting_considerations_186]]
====== link:#_notestesting_considerations_186[]Notes/Testing Considerations

Spec GIT revision 1a767fee749efe03b2c8fea4bb22b7681d2ee6b4

[[_tc_bool_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_bool_2_2_primary_functionality_with_server_as_dut[]69.2.2. [TC-BOOL-2.2] Primary Functionality with Server as DUT

[[_category_195]]
====== link:#_category_195[]Category

Functional conformance

[[_purpose_195]]
====== link:#_purpose_195[]Purpose

This test case verifies the primary functionality of the Boolean State
Cluster server.

[[_pics_195]]
====== link:#_pics_195[]PICS

* BOOL.S

[[_required_devices_195]]
====== link:#_required_devices_195[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_161]]
====== link:#_device_topology_161[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_173]]
====== link:#_test_setup_173[]Test Setup

Commission DUT to TH

[[_test_procedure_195]]
====== link:#_test_procedure_195[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH (can be skipped if done in a preceding test).

2a

BOOL.M.ManuallyControlled BOOL.S.A0000(StateValue)

Bring the DUT into a state so StateValue is FALSE.

2b

TH reads the _StateValue attribute_ from the DUT.

Verify that value in the response is FALSE.

3a

BOOL.M.ManuallyControlled BOOL.S.A0000(StateValue)

Bring the DUT into a state so StateValue is TRUE.

3b

TH reads the _StateValue attribute_ from the DUT.

Verify that value in the response is TRUE.

4a

BOOL.M.ManuallyControlled BOOL.S.E00(StateChange)
BOOL.S.A0000(StateValue)

Set up subscription to _StateChange event_.

4b

Bring the DUT into a state so StateValue is FALSE.

Receive _StateChange event_ with StateValue set to FALSE.

4c

TH reads the _StateValue attribute_ from the DUT.

Verify that value in the response is FALSE.

4d

Bring the DUT into a state so StateValue is TRUE.

Receive _StateChange event_ with StateValue set to TRUE.

4e

TH reads the _StateValue attribute_ from the DUT.

Verify that value in the response is TRUE.

[[_notestesting_considerations_187]]
=== link:#_notestesting_considerations_187[]Notes/Testing Considerations

Spec GIT revision 1a767fee749efe03b2c8fea4bb22b7681d2ee6b4 Steps #4a and
#4b cannot be executed with V1.0 SDK

[[_illuminance_measurement_cluster_test_plan]]
== link:#_illuminance_measurement_cluster_test_plan[]**Illuminance Measurement Cluster Test Plan**

[[_pics_definition_21]]
=== link:#_pics_definition_21[]70. PICS Definition

This section covers the Illuminance Measurement Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_23]]
==== link:#_role_23[]70.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ILL.S |Does the device implement the Illuminance Measurement cluster as
a server? |O |
|===

[[_server_23]]
==== link:#_server_23[]70.2. Server

[[_attributes_26]]
===== link:#_attributes_26[]70.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ILL.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue attribute_? |M |

|ILL.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue attribute_? |M |

|ILL.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue attribute_? |M |

|ILL.S.A0003(Tolerance) |Does the device implement the _Tolerance
attribute_? |O |

|ILL.S.A0004(LightSensorType) |Does the device implement the
_LightSensorType attribute_? |O |
|===

[[_test_case_list_23]]
=== link:#_test_case_list_23[]71. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-ILL-1.1 |Global Attributes with Server as DUT
|TC-ILL-2.1 |Attributes with Server as DUT
|TC-ILL-2.2 |Primary Functionality with Server as DUT
|===

[[_test_cases_23]]
=== link:#_test_cases_23[]72. Test Cases

'''''

[[_generic_test_cases_20]]
==== link:#_generic_test_cases_20[]72.1. Generic test cases

'''''

[[_tc_ill_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_ill_1_1_global_attributes_with_server_as_dut[]72.1.1. [TC-ILL-1.1] Global Attributes with Server as DUT

[[_category_196]]
====== link:#_category_196[]Category

Functional conformance

[[_purpose_196]]
====== link:#_purpose_196[]Purpose

This test case verifies that the DUT can provide the Illuminance
Measurement Cluster Global attributes.

[[_pics_196]]
====== link:#_pics_196[]PICS

* ILL.S

[[_required_devices_196]]
====== link:#_required_devices_196[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_162]]
====== link:#_device_topology_162[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_174]]
====== link:#_test_setup_174[]Test Setup

Commission DUT to TH

[[_test_procedure_196]]
====== link:#_test_procedure_196[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | | |TH reads the _ClusterRevision attribute_ from the DUT. |Verify
that the DUT response indicates that the _ClusterRevision attribute_ has
the value 3.

|3 | | |TH reads the _FeatureMap attribute_ from the DUT. |Verify that
the _FeatureMap attribute_ has the value 0.

|4 | | |TH reads the _AttributeList attribute_ from the DUT. |Verify
that the DUT response provides a list of supported attributes. This list
should include the mandatory attribute (values 0, 1 and 2). +
It should also include the global attributes ClusterRevision,
FeatureMap, AttributeList, AcceptedCommandList and GeneratedCommandList
(value 65533, 65532, 65531, 65529 and 65528) +
Option attributes: +
if ILL.S.A0003(Tolerance): 3 +
if ILL.S.A0004(LightSensorType): 4.

|5 | | |TH reads the _EventList attribute_ from the DUT. +
_*Note*: EventList is not supported by Matter 1.0_. |Verify that the DUT
response provides a list of supported events. For this cluster the list
is usually empty but it can contain manufacturer specific event IDs.

|6 | | |TH reads the _AcceptedCommandList attribute_ from the DUT.
|Verify that the DUT response provides a list of supported commands. For
this cluster the list is usually empty but it can contain manufacturer
specific command IDs.

|7 | | |TH reads the _GeneratedCommandList attribute_ from the DUT.
|Verify that the DUT response provides a list of supported commands. For
this cluster the list is usually empty.
|===

[[_notestesting_considerations_188]]
====== link:#_notestesting_considerations_188[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK. Spec GIT revision
6e56f582bc3f82335c1a0af39b77ddc44b13b849

'''''

[[_server_as_dut_15]]
==== link:#_server_as_dut_15[]72.2. Server as DUT

'''''

[[_tc_ill_2_1_attributes_with_server_as_dut]]
===== link:#_tc_ill_2_1_attributes_with_server_as_dut[]72.2.1. [TC-ILL-2.1] Attributes with Server as DUT

[[_purpose_197]]
====== link:#_purpose_197[]Purpose

This test case verifies the behavior of the non-global attributes of the
Illuminance Measurement cluster server.

[[_pics_197]]
====== link:#_pics_197[]PICS

* ILL.S

[[_required_devices_197]]
====== link:#_required_devices_197[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_163]]
====== link:#_device_topology_163[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_175]]
====== link:#_test_setup_175[]Test Setup

Commission DUT to TH

[[_test_procedure_197]]
====== link:#_test_procedure_197[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | |ILL.S.A0001(MinMeasuredValue) |Test Harness Client reads
_MinMeasuredValue attribute_ from DUT. a|
Verify that the DUT response contains either +
null +
or +
an integer where +
1 ≤ _MinMeasuredValue_ ≤ 0xfffd. +

Note the value for usage in later steps as I~min~. +
If _MinMeasuredValue_ is Null note 1.

|3 | |ILL.S.A0002(MaxMeasuredValue) |Test Harness Client reads
_MaxMeasuredValue attribute_ from DUT. a|
Verify that the DUT response contains either +
null +
or +
an integer where +
I~min~ < _MaxMeasuredValue_ ≤ 0xfffe. +

Note the value for usage in later steps as I~max~. +
If _MaxMeasuredValue_ is Null note 0xfffe.

|4 | |ILL.S.A0000(MeasuredValue) |Test Harness Client reads
_MeasuredValue attribute_ from DUT. |Verify that the DUT response
contains either +
null +
or +
0 +
or +
an integer where +
I~min~ ≤ _MeasuredValue_ ≤ I~max~.

|5 | |ILL.S.A0003(Tolerance) |TH reads the _Tolerance attribute_ from
the DUT. |Verify that the DUT responds with a uint16 value. Its value
should be in the range of 0 and 0x0800.

|6 | |ILL.S.A0004(LightSensorType) |TH reads the _LightSensorType
attribute_ from the DUT |Verify that the DUT responds with null or an
enum8 value from 0 to 0xfe.
|===

[[_notestesting_considerations_189]]
====== link:#_notestesting_considerations_189[]Notes/Testing Considerations

Spec GIT revision 6e56f582bc3f82335c1a0af39b77ddc44b13b849

[[_tc_ill_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_ill_2_2_primary_functionality_with_server_as_dut[]72.2.2. [TC-ILL-2.2] Primary Functionality with Server as DUT

[[_category_197]]
====== link:#_category_197[]Category

Functional conformance

[[_purpose_198]]
====== link:#_purpose_198[]Purpose

This test case verifies the primary functionality of the Illuminance
Measurement cluster server.

[[_pics_198]]
====== link:#_pics_198[]PICS

* ILL.S

[[_required_devices_198]]
====== link:#_required_devices_198[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_164]]
====== link:#_device_topology_164[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_176]]
====== link:#_test_setup_176[]Test Setup

Commission DUT to TH

[[_test_procedure_198]]
====== link:#_test_procedure_198[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 | |ILL.S.A0001(MinMeasuredValue), ILL.S.A0002(MaxMeasuredValue) |Test
Harness Client reads _MinMeasuredValue attribute_ and _MaxMeasuredValue
attribute_ from DUT. |Note MinMeasuredValue and MaxMeasuredValue.

|3 | | |Cover the sensor or darken the room |

|4 | |ILL.S.A0000(MeasuredValue) |After a few seconds, TH reads
_MeasuredValue attribute_ from DUT. |Value should be 0 or close to
MinMeasuredValue.

|5 | | |Expose the sensor again to light |

|6 | |ILL.S.A0000(MeasuredValue) |After a few seconds, TH reads
_MeasuredValue attribute_ from DUT. |Value has to increase significantly
compared to step 4. The value should be smaller or equal to
MaxMeasuredValue.
|===

Spec GIT revision 6e56f582bc3f82335c1a0af39b77ddc44b13b849

[[_switch_cluster_test_plan]]
== link:#_switch_cluster_test_plan[]**Switch Cluster Test Plan**

[[_pics_definition_22]]
=== link:#_pics_definition_22[]73. PICS Definition

This section covers the Switch Cluster Test Plan related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_24]]
==== link:#_role_24[]73.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SWTCH.S |Does the device implement the Switch cluster as a server?
|Optional |

|SWTCH.C |Does the device implement the Switch cluster as a client?
|Optional |
|===

[[_server_24]]
==== link:#_server_24[]73.2. Server

[[_features_16]]
===== link:#_features_16[]73.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SWTCH.S.F00(LS) |Does the device represent a Latching Switch? |SWTCH.S:
O.a a|
* SHALL claim exactly one of SWTCH.S.F00(LS) and SWTCH.S.F01(MS)

|SWTCH.S.F01(MS) |Does the device represent a Momentary Switch?
|SWTCH.S: O.a a|
* SHALL claim exactly one of SWTCH.S.F00(LS) and SWTCH.S.F01(MS)

|SWTCH.S.F02(MSR) |Does the MS device support Momentary Switch Release?
|[SWTCH.S.F01(MS)] |

|SWTCH.S.F03(MSL) |Does the MS device support Momentary Switch
LongPress? |[SWTCH.S.F01(MS) & SWTCH.S.F02(MSR)] |

|SWTCH.S.F04(MSM) |Does the MS device support Momentary Switch
MultiPress? |[SWTCH.S.F01(MS) & SWTCH.S.F02(MSR)] |
|===

[width="100%",cols="50%,50%",]
|===
a|
Note

|consistency of the PICS-flags is checked in TC-SWTCH-1.1
|===

[[_client_13]]
==== link:#_client_13[]73.3. Client

[[_features_17]]
===== link:#_features_17[]73.3.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SWTCH.C.F00(LS) |Does the DUT support a Latching Switch? |O |

|SWTCH.C.F01(MS) |Does the DUT support a Momentary Switch? |O |

|SWTCH.C.F02(MSR) |Does the DUT support Momentary Switch Release? |O |

|SWTCH.C.F03(MSL) |Does the DUT support Momentary Switch LongPress? |O |

|SWTCH.C.F04(MSM) |Does the DUT support Momentary Switch MultiPress? |O
|
|===

[width="100%",cols="50%,50%",]
|===
a|
Note

|consistency of these PICS-flags is checked in TC-SWTCH-3.2
|===

[[_manual_controllable_13]]
===== link:#_manual_controllable_13[]73.3.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SWTCH.C.M.RA |Does the DUT support reading attribute to get switch
state (polling)? |O |

|SWTCH.C.M.EV |Does the DUT support eventing to get switch state
changes? |O |

|MCORE.IDM.C.SubscribeEvent |Does the DUT support subscribing to an
individual Event? |O |
|===

[[_test_case_list_24]]
=== link:#_test_case_list_24[]74. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-SWTCH-1.1 |Global attributes with server as DUT
|2 |TC-SWTCH-2.1 |Attributes with server as DUT
|3 |TC-SWTCH-2.2 |Primary functionality with server as DUT
|4 |TC-SWTCH-3.2 |Primary functionality with client as DUT
|===

[[_test_cases_24]]
=== link:#_test_cases_24[]75. Test Cases

'''''

[[_generic_test_cases_21]]
==== link:#_generic_test_cases_21[]75.1. Generic test cases

'''''

[[_tc_swtch_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_swtch_1_1_global_attributes_with_server_as_dut[]75.1.1. [TC-SWTCH-1.1] Global attributes with server as DUT

[[_purpose_199]]
====== link:#_purpose_199[]Purpose

This test case verifies the Switch Global Attributes.

[[_pics_199]]
====== link:#_pics_199[]PICS

* SWTCH.S

[[_required_devices_199]]
====== link:#_required_devices_199[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_165]]
====== link:#_device_topology_165[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_177]]
====== link:#_test_setup_177[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).
Verify that Feature Flags are set correctly, e.g. check that either LS
or MS is present but not both. Also verify the other global attributes.

[[_test_procedure_199]]
====== link:#_test_procedure_199[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |DUT and TH are on same fabric

| | | | |

|2a | | |Read FeatureMap (global attribute 65532) |value is used in next
steps

|2b | |SWTCH.S.F00(LS) |Check values of flags in this FeatureMap |LS is
set to 1; MS, MSR, MSL, MSM are all set to 0

|2c | |SWTCH.S.F01(MS) |Check values of flags in this FeatureMap |LS is
set to 0; MS is set to 1

|2d | |SWTCH.S.F02(MSR) |Check values of flags in this FeatureMap |LS is
set to 0; MS, MSR are set to 1

|2e | |SWTCH.S.F03(MSL) |Check values of flags in this FeatureMap |LS is
set to 0; MS, MSR, MSL are all set to 1

|2f | |SWTCH.S.F04(MSM) |Check values of flags in this FeatureMap |LS is
set to 0; MS, MSR, MSM are all set to 1

| | | | |

|3 | | |Read ClusterRevision (global attribute 65533) |value SHALL be 1

|4 | | |Read AttributeList (global attribute 65531) |if SWTCH.S.F04(MSM)
then list SHALL be [0,1,2] else list SHALL be [0,1]

|5 | | |Read EventList (global attribute 65530) a|
* if SWTCH.S.F00(LS) then list SHALL be [0]
* if SWTCH.S.F01(MS) & !SWTCH.S.F02(MSR) then list SHALL be [1]
* if SWTCH.S.F01(MS) & SWTCH.S.F02(MSR) & !SWTCH.S.F03(MSL) &
!SWTCH.S.F04(MSM) then list SHALL be [1,3]
* if SWTCH.S.F01(MS) & SWTCH.S.F02(MSR) & SWTCH.S.F03(MSL) &
!SWTCH.S.F04(MSM) then list SHALL be [1,2,3,4]
* if SWTCH.S.F01(MS) & SWTCH.S.F02(MSR) & !SWTCH.S.F03(MSL) &
SWTCH.S.F04(MSM) then list SHALL be [1,3,5,6]
* if SWTCH.S.F01(MS) & SWTCH.S.F02(MSR) & SWTCH.S.F03(MSL) &
SWTCH.S.F04(MSM) then list SHALL be [1,2,3,4,5,6]

|6 | | |Read AcceptedCommandList (global attribute 65529) |list SHALL be
empty

|7 | | |Read GeneratedCommandList (global attribute 65528) |list SHALL
be empty
|===

[[_notestesting_considerations_190]]
====== link:#_notestesting_considerations_190[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_server_as_dut_16]]
==== link:#_server_as_dut_16[]75.2. Server as DUT

'''''

[[_tc_swtch_2_1_attributes_with_server_as_dut]]
===== link:#_tc_swtch_2_1_attributes_with_server_as_dut[]75.2.1. [TC-SWTCH-2.1] Attributes with server as DUT

[[_purpose_200]]
====== link:#_purpose_200[]Purpose

This test case verifies the Switch Attributes.

[[_pics_200]]
====== link:#_pics_200[]PICS

* SWTCH.S

[[_required_devices_200]]
====== link:#_required_devices_200[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_166]]
====== link:#_device_topology_166[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_178]]
====== link:#_test_setup_178[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test). Read
CurrentPosition to verify it changes according to switch capabilities.

[[_test_procedure_200]]
====== link:#_test_procedure_200[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |DUT and TH are on same fabric

| | | | |

|2a | | |Read NumberOfPositions attribute |value is at least 2

|2b | | |Read CurrentPosition attribute |value is in range
0..NumberOfPositions-1

|2c | |SWTCH.S.F04(MSM) |Read MultiPressMax attribute |value is at least
2
|===

[[_notestesting_considerations_191]]
====== link:#_notestesting_considerations_191[]Notes/Testing Considerations

[[_tc_swtch_2_2_primary_functionality_with_server_as_dut]]
===== link:#_tc_swtch_2_2_primary_functionality_with_server_as_dut[]75.2.2. [TC-SWTCH-2.2] Primary functionality with server as DUT

[[_category_198]]
====== link:#_category_198[]Category

Functional

[[_purpose_201]]
====== link:#_purpose_201[]Purpose

This test case verifies the primary functionality of the Switch cluster
server.

[[_pics_201]]
====== link:#_pics_201[]PICS

* SWTCH.S

[[_required_devices_201]]
====== link:#_required_devices_201[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_167]]
====== link:#_device_topology_167[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_179]]
====== link:#_test_setup_179[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test). Read
CurrentPosition to verify it changes according to switch capabilities.

[[_test_procedure_201]]
====== link:#_test_procedure_201[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH (can be skipped if done in a preceding test)

DUT and TH are on same fabric

2: tests for Latching Switch

2a

SWTCH.S.F00(LS)

Set up subscription to SwitchLatched event

2b

Operator sets switch to first position

2c

Read CurrentPosition attribute

value is 0

2d

Operator sets switch to second position

receive SwitchLatched event with NewPosition set to 1

2e

Read CurrentPosition attribute

value is 1

2f

If NumberOfPositions>2 (see 2a of TC-SWTCH-2.1) : +
- Operator sets switch to next position +
- Read CurrentPosition attribute

* receive SwitchLatched event with NewPosition set to 1 higher than in
previous event
* value of CurrentPosition attribute is 1 higher than previous attribute
value, and matches the NewPosition field from the SwitchLatched event

2g

If NumberOfPositions>3 : +
- Repeat step 2f for NumberOfPositions-3 times +
- After each time Operator has set switch to next position, +
- Read CurrentPosition attribute

see 2f

2h

Operator returns switch to first position

receive SwitchLatched event with NewPosition set to 0

2i

Read CurrentPosition attribute

value is 0

3: tests for Momentary Switch

3a

SWTCH.S.F01(MS)

Set up subscription to InitialPress event

3b

Operator does not operate switch

3c

Read CurrentPosition attribute

value is 0

3d

Operator operates switch (keep it pressed)

receive InitialPress event with NewPosition set to 1

3e

Read CurrentPosition attribute

value is 1

3f

Operator releases switch

3g

Read CurrentPosition attribute

value is 0

4: tests for Momentary Switch with release capability but not long press
capabilities

4a

SWTCH.S.F01(MS) & SWTCH.S.F02(MSR) & !SWTCH.S.F03(MSL)

Set up subscription to InitialPress and ShortRelease events

4b

Operator does not operate switch

4c

Operator operates switch (press briefly)

receive InitialPress event with NewPosition set to 1

4d

Operator releases switch

receive ShortRelease event with PreviousPosition set to 1

4e

Operator operates switch (keep pressed for long time, e.g. 5 seconds)

receive InitialPress event with NewPosition set to 1

4f

Operator releases switch

receive ShortRelease event with PreviousPosition set to 1

5: tests for Momentary Switch with release and long press capabilities

5a

SWTCH.S.F01(MS) & SWTCH.S.F03(MSL)

Set up subscription to InitialPress, LongPress, ShortRelease,
LongRelease events

5b

Operator does not operate switch

5c

Operator operates switch (press briefly)

receive InitialPress event with NewPosition set to 1

5d

Operator releases switch

receive ShortRelease event with PreviousPosition set to 1

5e

Operator operates switch (keep pressed for long time, e.g. 5 seconds)

* receive InitialPress event with NewPosition set to 1
* afterwards receive (one, not more than one) LongPress event with
NewPosition set to 1

5f

Operator releases switch

receive LongRelease event with PreviousPosition set to 1

6: tests for Momentary Switch with multi-press capabilities

6a

SWTCH.S.F01(MS) & SWTCH.S.F04(MSM)

Set up subscription to InitialPress, ShortRelease, MultiPressOngoing,
MultiPressComplete events

6b

Operator does not operate switch

6c

Operator operates switch (press briefly)

receive InitialPress event with NewPosition set to 1

6d

Operator releases switch

* receive ShortRelease event with PreviousPosition set to 1
* afterwards, receive MultiPressComplete event with PreviousPosition set
to 1 and TotalNumberOfPressesCounted set to 1

6e

Operator operates switch (press briefly)

receive InitialPress event with NewPosition set to 1

6f

Operator releases switch

receive ShortRelease event with PreviousPosition set to 1

6g

Briefly after 6f, operator operates switch again (press briefly)

* receive InitialPress event with NewPosition set to 1
* receive MultiPressOngoing event with NewPosition set to 1 and
CurrentNumberOfPressesCounted set to 2 +
(MultiPressOngoing event SHALL NOT arrive before InitialPress event)

6h

Operator releases switch

* receive ShortRelease event with PreviousPosition set to 1
* afterwards, receive MultiPressComplete event with PreviousPosition set
to 1 and TotalNumberOfPressesCounted set to 2

6i

If MultiPressMax == 2 (see 2c of TC-SWTCH-2.1), skip steps 6j .. 6o

6j

Operator operates switch (press briefly)

receive InitialPress event with NewPosition set to 1

6k

Operator releases switch

receive ShortRelease event with PreviousPosition set to 1

6l

Briefly after 6k, operator operates switch again (press briefly)

* receive InitialPress event with NewPosition set to 1
* receive MultiPressOngoing event with NewPosition set to 1 and
CurrentNumberOfPressesCounted set to 2
* (MultiPressOngoing event SHALL NOT arrive before InitialPress event)

6m

Operator releases switch

receive ShortRelease event with PreviousPosition set to 1

6n

Briefly after 6m, operator operates switch again (press briefly)

* receive InitialPress event with NewPosition set to 1
* receive MultiPressOngoing event with NewPosition set to 1 and
CurrentNumberOfPressesCounted set to 3
* (MultiPressOngoing event SHALL NOT arrive before InitialPress event)

6o

Operator releases switch

* receive ShortRelease event with PreviousPosition set to 1
* afterwards, receive MultiPressComplete event with PreviousPosition set
to 1 and TotalNumberOfPressesCounted set to 3

[width="100%",cols="50%,50%",]
|===
a|
Note

|no testing (yet) for Momentary Switch with NumberOfPositions>2
|===

[[_notestesting_considerations_192]]
=== link:#_notestesting_considerations_192[]Notes/Testing Considerations

[[_client_14]]
=== link:#_client_14[]75.3. Client

[[_tc_swtch_3_2_primary_functionality_with_client_as_dut]]
==== link:#_tc_swtch_3_2_primary_functionality_with_client_as_dut[]75.3.1. [TC-SWTCH-3.2] Primary functionality with client as DUT

[[_category_199]]
===== link:#_category_199[]Category

Functional

[[_purpose_202]]
===== link:#_purpose_202[]Purpose

This test case verifies the primary functionality of the Switch cluster
client.

[[_pics_202]]
===== link:#_pics_202[]PICS

* SWTCH.C
* MCORE.IDM.C.SubscribeEvent

[[_required_devices_202]]
===== link:#_required_devices_202[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_168]]
===== link:#_device_topology_168[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_180]]
===== link:#_test_setup_180[]Test Setup

TH models a (simulated) switch device, which is being operated by a
simulated user, toggling between states (LS) or pressing in certain
patterns (MS). The DUT client is expected to receive and process these
togglings through attributes and/or events.

Commission DUT to TH, and verify that DUT reacts to simulated operation
of the switch by TH.

[[_test_procedure_202]]
===== link:#_test_procedure_202[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

Consistency check of PICS flags

0a

!SWTCH.C.F00(LS) & !SWTCH.C.F01(MS)

FAIL the test - at least one of SWTCH.C.F00(LS) and SWTCH.C.F01(MS) has
to be supported

0b

SWTCH.C.F02(MSR) & !SWTCH.C.F01(MS)

FAIL the test - when supporting SWTCH.C.F02(MSR) also SWTCH.C.F01(MS)
must be supported

0c

SWTCH.C.F03(MSL) & !SWTCH.C.F01(MS)

FAIL the test - when supporting SWTCH.C.F03(MSL) also SWTCH.C.F01(MS)
must be supported

0d

SWTCH.C.F03(MSL) & !SWTCH.C.F02(MSR)

FAIL the test - when supporting SWTCH.C.F03(MSL) also SWTCH.C.F02(MSR)
must be supported

0e

SWTCH.C.F04(MSM) & !SWTCH.C.F01(MS)

FAIL the test - when supporting SWTCH.C.F04(MSM) also SWTCH.C.F01(MS)
must be supported

0f

SWTCH.C.F04(MSM) & !SWTCH.C.F02(MSR)

FAIL the test - when supporting SWTCH.C.F04(MSM) also SWTCH.C.F02(MSR)
must be supported

0g

!SWTCH.C.M.RA & !SWTCH.C.M.EV

FAIL the test - at least one of SWTCH.C.M.RA and SWTCH.C.M.EV must be
supported

Commission and configure latching switch

1a

SWTCH.C.F00(LS)

Commission DUT to TH. +
Use client mechanism to set it up so switch state can be observed (e.g.
UI shows state of switch) and/or other device is controlled (e.g. light
on same fabric gets controlled by the switch ⇒ TH has to simulate that
light). +
While commissioning and configuring, TH records and reacts to the
messages relating to the switch functionality detailed in the steps
below. The order of the messages received may be different from the
order of the sub-steps 1b..1d below.

1b

SWTCH.C.F00(LS)

DUT reads global attribute FeatureMap.

TH provides value 1 (LS).

1c

SWTCH.C.F00(LS)

DUT reads attribute NumberOfPositions.

TH provides value 2.

1d

SWTCH.C.F00(LS) & SWTCH.C.M.EV

DUT sets up eventing (SwitchLatched) so it will receive events when the
switch is operated.

TH responds accordingly.

Simulate operation of latching switch

2a

SWTCH.C.F00(LS) & SWTCH.C.M.RA

TH simulates operation of the switch by changing state (attribute
CurrentPosition) from 0 to 1 and back every 10 seconds (over a 1 minute
period) +
DUT reads attribute CurrentPosition regularly

When DUT reads attribute CurrentPosition, TH provides response with
current value. +
DUT presents state of simulated switch and/or controls another device
based on the state of the switch.

2b

SWTCH.C.F00(LS) & SWTCH.C.M.EV

TH simulates operation of the switch by changing state (attribute
CurrentPosition) from 0 to 1 and back every 10 seconds (over a 1 minute
period), and sending the event SwitchLatched (with field NewPosition
reflecting the new state) on every change

DUT receives these events +
DUT presents state of simulated switch and/or controls another device
based on the state of the switch.

Commission and configure momentary switch

3a

SWTCH.C.F01(MS)

Commission DUT to TH. +
Use client mechanism to set it up so switch state can be observed (e.g.
UI shows state of switch) and/or other device is controlled (e.g. light
on same fabric gets controlled by the switch ⇒ TH has to simulate that
light). +
While commissioning and configuring, TH records and reacts to the
messages relating to the switch functionality detailed in the steps
below. The order of the messages received may be different from the
order of the sub-steps 3b..3d below.

3b

SWTCH.C.F01(MS)

DUT reads global attribute FeatureMap

TH provides value 0x1E (MS, MSR, MSL, MSM).

3c

SWTCH.C.F01(MS)

DUT reads attribute NumberOfPositions

TH provides value 2.

3d

SWTCH.C.F01(MS) & SWTCH.C.M.EV

DUT sets up eventing (InitialPress and ShortRelease; if SWTCH.C.F03(MSL)
also LongPress and LongRelease) so it will receive events when the
switch is operated

TH responds accordingly.

Simulate operation of momentary switch

4a

SWTCH.C.F01(MS) & SWTCH.C.M.RA

TH simulates operation of the switch by repeating these steps (over a 1
minute period)

* change state (attribute CurrentPosition) from 0 to 1
* wait 0.2 seconds
* change state (attribute CurrentPosition) from 1 to 0
* wait 10 seconds

DUT reads attribute CurrentPosition regularly

TH provides response with current value. +
DUT presents state of simulated switch and/or controls another device
based on the state of the switch.

4b

SWTCH.C.F01(MS) & SWTCH.C.M.EV

TH simulates operation of the switch by repeating these steps (over a 1
minute period)

* change state (attribute CurrentPosition) from 0 to 1, and send the
event InitialPress (with field NewPosition=1)
* wait 0.2 seconds
* change state (attribute CurrentPosition) from 1 to 0, and send the
event ShortRelease (with field PreviousPosition=1)
* wait 10 seconds

TH sends events corresponding to simulated switch operation, DUT
receives these events +
DUT presents state of simulated switch and/or controls another device
based on the state of the switch.

4c

SWTCH.C.F01(MS) & SWTCH.C.F03(MSL) & SWTCH.C.M.EV

TH simulates operation of the switch by repeating these steps (over a 1
minute period)

* change state (field CurrentPosition) from 0 to 1, and send the event
InitialPress (with field NewPosition=1)
* wait 0.75 seconds
* send the event LongPress (field NewPosition=1)
* wait 2 seconds
* change state (field CurrentPosition) from 1 to 0, and send the event
LongRelease (with field PreviousPosition=1)
* wait 8 seconds

TH sends events corresponding to simulated switch operation, DUT
receives these events +
DUT presents state of simulated switch and/or controls another device
based on the state of the switch (long-press behavior if supported).

[[_notestesting_considerations_193]]
=== link:#_notestesting_considerations_193[]Notes/Testing Considerations

[[_actions_cluster_test_plan]]
== link:#_actions_cluster_test_plan[]**Actions Cluster Test Plan**

[[_pics_definition_23]]
=== link:#_pics_definition_23[]76. PICS Definition

This section covers the Actions Cluster Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_25]]
==== link:#_role_25[]76.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACT.S |Does the device implement the Actions cluster as a server?
|Optional |

|ACT.C |Does the device implement the Actions cluster as a client?
|Optional |
|===

[[_server_25]]
==== link:#_server_25[]76.2. Server

[[_attributes_27]]
===== link:#_attributes_27[]76.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACT.S.A0000(ActionList) |Does the device implement the ActionList
attribute? |ACT.S: Mandatory |

|ACT.S.A0001(EndpointLists) |Does the device implement the EndpointLists
attribute? |ACT.S: Mandatory |

|ACT.S.A0002(SetupURL) |Does the device implement the SetupURL
attribute? |ACT.S: Optional |
|===

[[_manual_controllable_14]]
===== link:#_manual_controllable_14[]76.2.2. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACT.S.M.FillActionList |Can the ActionList attribute be filled or
changed by some means? (see Note) |ACT.S: Optional |Supporting the
ActionList attribute is Mandatory. Providing a way to manually fill or
update it is optional.

|ACT.S.M.FillEndpointLists |Can the EndpointLists attribute be changed
by some means? (see Note) |ACT.S: Optional |Supporting the EndpointLists
attribute is Mandatory. Providing a way to manually update it is
optional.

|ACT.S.M.OverlappingEndpointLists |Does the DUT support exposing an
Endpoint in multiple EndpointListStructs |ACT.S: Optional |Supporting
the EndpointLists attribute is Mandatory. Providing a mechanism to
expose a particular Endpoint in multiple entries is optional.

|ACT.S.M.SetupURLWithSuffix |Can a suffix be used on SetupURL
|ACT.S.A0002(SetupURL): Optional |
|===

[width="100%",cols="50%,50%",]
|===
a|
Note

|These 'manual' changes could be done be by manual control at the device
or other manufacturer provided means, e.g. an app which has some
proprietary interface into the server allowing to change the set of
exposed groups and/or actions.
|===

[[_commands_received_16]]
===== link:#_commands_received_16[]76.2.3. Commands received

INFO: The commands supported by the server are listed in the
SupportedCommands field for each action.

[[_client_15]]
==== link:#_client_15[]76.3. Client

[[_commands_generated_15]]
===== link:#_commands_generated_15[]76.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACT.C.C00.Tx(InstantAction) |Does the DUT support sending the
InstantAction command? |ACT.C: Optional |

|ACT.C.C01.Tx(InstantActionWithTransition) |Does the DUT support sending
the InstantActionWithTransition command? |ACT.C: Optional |

|ACT.C.C02.Tx(StartAction) |Does the DUT support sending the StartAction
command? |ACT.C: Optional |

|ACT.C.C03.Tx(StartActionWithDuration) |Does the DUT support sending the
StartActionWithDuration command? |ACT.C: Optional |

|ACT.C.C04.Tx(StopAction) |Does the DUT support sending the StopAction
command? |ACT.C: Optional |

|ACT.C.C05.Tx(PauseAction) |Does the DUT support sending the PauseAction
command? |ACT.C: Optional |

|ACT.C.C06.Tx(PauseActionWithDuration) |Does the DUT support sending the
PauseActionWithDuration command? |ACT.C: Optional |

|ACT.C.C07.Tx(ResumeAction) |Does the DUT support sending the
ResumeAction command? |ACT.C: Optional |

|ACT.C.C08.Tx(EnableAction) |Does the DUT support sending the
EnableAction command? |ACT.C: Optional |

|ACT.C.C09.Tx(EnableActionWithDuration) |Does the DUT support sending
the EnableActionWithDuration command? |ACT.C: Optional |

|ACT.C.C0a.Tx(DisableAction) |Does the DUT support sending the
DisableAction command? |ACT.C: Optional |

|ACT.C.C0b.Tx(DisableActionWithDuration) |Does the DUT support sending
the DisableActionWithDuration command? |ACT.C: Optional |
|===

[[_test_case_list_25]]
=== link:#_test_case_list_25[]77. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-ACT-1.1 |Global attributes with server as DUT
|2 |TC-ACT-2.1 |Attributes with server as DUT
|3 |TC-ACT-2.2 |Primary functionality with server as DUT
|4 |TC-ACT-3.2 |Functionality with client as DUT
|===

[[_test_cases_25]]
=== link:#_test_cases_25[]78. Test Cases

'''''

[[_generic_test_cases_22]]
==== link:#_generic_test_cases_22[]78.1. Generic test cases

'''''

[[_tc_act_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_act_1_1_global_attributes_with_server_as_dut[]78.1.1. [TC-ACT-1.1] Global attributes with server as DUT

[[_purpose_203]]
====== link:#_purpose_203[]Purpose

[[_pics_203]]
====== link:#_pics_203[]PICS

* ACT.S

[[_required_devices_203]]
====== link:#_required_devices_203[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_169]]
====== link:#_device_topology_169[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_181]]
====== link:#_test_setup_181[]Test Setup

Verify that the global attributes are set correctly.

[[_test_procedure_203]]
====== link:#_test_procedure_203[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |DUT and TH are on same fabric

|2 | | |Read ClusterRevision (global attribute 65533) |value SHALL be 1

|3 | | |Read FeatureMap (global attribute 65532) |value SHALL be 0

|4 | | |Read AttributeList (global attribute 65531) a|
* if ACT.S.A0002(SetupURL) then list SHALL be [0,1,2] else list SHALL be
[0,1]
* It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 | | |Read EventList (global attribute 65530) |list SHALL be [0,1]

|6 | | |Read AcceptedCommandList (global attribute 65529) ; retain this
list for reference in test [TC-ACT-2.2] step 4d |list SHALL contain zero
or more elements from 0..11 (and no other elements)

|7 | | |Read GeneratedCommandList (global attribute 65528) |list SHALL
be empty
|===

[[_notestesting_considerations_194]]
====== link:#_notestesting_considerations_194[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_server_as_dut_17]]
==== link:#_server_as_dut_17[]78.2. Server as DUT

'''''

[[_tc_act_2_1_attributes_with_server_as_dut]]
===== link:#_tc_act_2_1_attributes_with_server_as_dut[]78.2.1. [TC-ACT-2.1] Attributes with server as DUT

[[_purpose_204]]
====== link:#_purpose_204[]Purpose

This test case verifies the attributes provided by the Actions cluster
server.

[[_pics_204]]
====== link:#_pics_204[]PICS

* ACT.S

[[_required_devices_204]]
====== link:#_required_devices_204[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_170]]
====== link:#_device_topology_170[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_182]]
====== link:#_test_setup_182[]Test Setup

Use manufacturer provided means (e.g. app) to define groups of endpoints
and available actions that can be exposed using the Actions server
cluster. Validate that the exposed attributes are set accordingly.

[[_test_procedure_204]]
====== link:#_test_procedure_204[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH (can be skipped if done in a preceding test)

DUT and TH are on same fabric

2: preparation in manufacturer app

2a

ACT.S.M.FillEndpointLists

Use manufacturer provided means (e.g. app) to define groups of endpoints
that can be exposed using the Actions server cluster +
(NOTE if this is not provided, it is assumed the DUT automagically
creates these)

Actions server can expose those groups - used in later steps

2b

ACT.S.M.FillActionList

Use manufacturer provided means (e.g. app) to define available actions
that can be exposed using the Actions server cluster

Actions server can expose those actions - used in later steps

3: get list of all endpoints

3

Read PartsList attribute of Descriptor cluster on endpoint 0 of the DUT

this list will be used in later steps

4: validate EndpointLists attribute

4a

ACT.S.A0001(EndpointLists)

Read EndpointLists attribute of Actions server

validate the EndpointListStructs using the following steps

4b

For each EndpointListStruct, verify that the endpoints in the Endpoints
field are in the list of endpoints of the DUT

all referenced endpoints present in list from step 3

4c

For each EndpointListStruct, verify that the Name is present

Name is present

4d

For each EndpointListStruct, verify that the Type is present and valid

Type is present and valid (enum value 0-2)

4e

Verify that the EndPointListIDs of all EndpointListStruct are unique (no
duplicates)

no duplicates found

4f

ACT.S.A0001(EndpointLists) & ACT.S.M.FillEndpointLists

For each EndpointListStruct, verify Name and Type against the name/type
of each group of endpoints provided by the manufacturer’s means

information matches

5: validate ActionList attribute

5a

ACT.S.A0000(ActionList)

Read ActionList attribute of Actions server

validate the ActionStructs using the following steps

5b

For each ActionStruct, verify the Name is present

Name is present

5c

For each ActionStruct, verify the Type is present and valid

Type is present and valid (enum value 0-6)

5d

For each ActionStruct, verify the EndpointListID is present in one of
the EndpointListStructs (see step 4a)

EndpointListID found in EndpointLists

5e

For each ActionStruct, verify the SupportedCommands field is present and
valid (at least one bit is set)

SupportedCommands field is present and valid (range 0x0001-0x0fff)

5f

For each ActionStruct, verify the State field is present and valid

State field is valid and present (enum value 0-3)

5g

Verify that the ActionIDs of all ActionStructs are unique (no
duplicates)

no duplicates found

5h

ACT.S.A0000(ActionList) & ACT.S.M.FillActionList

For each ActionStruct, verify Name, Type and State against the
name/type/state info for the action provided by the manufacturer’s means

information matches

6: validate SetupURL attribute

6a

ACT.S.A0002(SetupURL)

Read SetupURL attribute

6b

Verify that its syntax

syntax as specified in RFC 3986, max. 512 ASCII characters

6c

Verify SetupURL points to a site providing information about the actions

SetupURL points to a relevant location (consistent with information the
manufacturer has provided out of band)

6d

ACT.S.A0002(SetupURL) & ACT.S.M.SetupURLWithSuffix

Verify SetupURL appended by "?/a=" and the decimal numeric value of one
of the exposed ActionIDs (see step 5a) points to a site providing
information about the action

SetupURL points to a relevant location

[[_notestesting_considerations_195]]
=== link:#_notestesting_considerations_195[]Notes/Testing Considerations

[[_tc_act_2_2_primary_functionality_with_server_as_dut]]
=== link:#_tc_act_2_2_primary_functionality_with_server_as_dut[]78.2.2. [TC-ACT-2.2] Primary functionality with server as DUT

[[_category_200]]
==== link:#_category_200[]Category

Functional

[[_purpose_205]]
==== link:#_purpose_205[]Purpose

This test case verifies the primary functionality of the Actions cluster
server.

[[_pics_205]]
==== link:#_pics_205[]PICS

* ACT.S

[[_required_devices_205]]
==== link:#_required_devices_205[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_device_topology_171]]
==== link:#_device_topology_171[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_183]]
==== link:#_test_setup_183[]Test Setup

Use manufacturer provided means (e.g. app) to define and update groups
of endpoints and/or available actions that can be exposed using the
Actions server cluster. Validate that the exposed attributes are updated
accordingly, and that the exposed actions are accepted.

[[_test_procedure_205]]
==== link:#_test_procedure_205[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

Commission DUT to TH (can be skipped if done in a preceding test)

DUT and TH are on same fabric

2: manual update of grouping and naming

2a

9.13.7

ACT.S.A0001(EndpointLists) & ACT.S.M.FillEndpointLists

Using the manufacturer provided means, create multiple groups with each
multiple bridged devices (endpoints)

2b

Read EndpointLists attribute

2c

Using the manufacturer provided means, update the name of one of the
groups

2d

Read EndpointLists attribute again

2e

compare result of step 2d to what was read in step 2b

* Name field in relevant EndpointListStruct has been updated
* no other changes in EndpointLists attribute

2f

Using the manufacturer provided means, move one of the bridged devices
(one endpoint) from one group to another group

2g

Read EndpointLists attribute again

2h

compare result of step 2g to what was read in step 2d

* in one of the EndpointListStructs the endpoint for the moved device
has been removed
* in another EndpointListStruct the endpoint for the moved device has
been added
* no other changes in EndpointLists attribute

2i

Using the manufacturer provided means, remove one of the groups

2j

Read EndpointLists attribute again

2k

compare result of step 2j to what was read in step 2g

* the EndpointListStructs for the removed group has been removed from
EndpointLists attribute
* no other changes in EndpointLists attribute

2l

ACT.S.A0001(EndpointLists) & ACT.S.M.OverlappingEndpointLists

Using the manufacturer provided means, create a new group, which
includes one of the bridged devices also present in another group

2m

Read EndpointLists attribute again

2n

compare result of step 2m to what was read in step 2j

* a new EndpointListStruct has been added to the EndpointLists
attribute, with Name, Type and Endpoints[] matching the group which was
created in 2l
* no other changes in EndpointLists attribute
* the endpoint of the bridged device which is present in multiple groups
appears in the Endpoints[] of multiple EndpointListStruct

3: manual update of action list

3a

ACT.S.A0000(ActionList) & ACT.S.M.FillActionList

Using the manufacturer provided means, create multiple actions

3b

Read ActionList attribute

3c

Using the manufacturer provided means, update the name of one of the
actions

3d

Read ActionList attribute again

3e

compare result of step 3d to what was read in step 3b

* Name field in relevant ActionStruct has been updated
* no other changes in ActionList attribute

3f

Using the manufacturer provided means, remove one of the exposed actions

3g

Read ActionList attribute again

3h

compare result of step 3g to what was read in step 3d

* the relevant ActionStruct has been removed from ActionList attribute
* no other changes in ActionList attribute

3i

Using the manufacturer provided means, add a new exposed action

3j

Read ActionList attribute again

3k

compare result of step 3j to what was read in step 3g

* a new ActionStruct has been added into ActionList attribute (matching
what was added in 3i)
* no other changes in ActionList attribute

4: execute actions

4a

ACT.S.A0000(ActionList) & ACT.S.M.FillActionList

Using the manufacturer provided means, create multiple actions

4b

ACT.S.A0000(ActionList)

Read ActionList attribute

* list will be used in 4d,4e
* if list is empty, skip remainder of test

4c

subscribe to StateChanged and ActionFailed events

(events will be used in 4d,4e)

4d

For each of the ActionStructs provided by DUT (see list read in step
4b), perform one of the actions supported (see SupportedCommands in this
ActionStruct) by sending the command with this particular ActionID and a
random value for InvokeID

* id of the command is included in the AcceptedCommandList global
attribute
* command is accepted (no INVALID_COMMAND reply)
* DUT generates an StateChanged or ActionFailed event with these
ActionID and InvokeID values and a NewState consistent with the command
and previous state
* DUT performs the requested action on the associated endpoints

4e

repeat 4d for the other SupportedCommands of each ActionStruct

see 4d

[[_notestesting_considerations_196]]
=== link:#_notestesting_considerations_196[]Notes/Testing Considerations

[[_tc_act_3_2_functionality_with_client_as_dut]]
=== link:#_tc_act_3_2_functionality_with_client_as_dut[]78.2.3. [TC-ACT-3.2] Functionality with client as DUT

[[_category_201]]
==== link:#_category_201[]Category

Functional

[[_purpose_206]]
==== link:#_purpose_206[]Purpose

This test case verifies the functionality of the Actions cluster client.

[[_pics_206]]
==== link:#_pics_206[]PICS

* ACT.C

[[_required_devices_206]]
==== link:#_required_devices_206[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_172]]
==== link:#_device_topology_172[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_184]]
==== link:#_test_setup_184[]Test Setup

TH as server exposes an Actions server cluster on EP 1, with one action
(supporting all possible commands) and corresponding ActionLists and
EndpointLists attributes:

....
ActionList: contains one list element (ActionListStruct):
    ActionID = 0xA001
    Name = "some test"
    Type = other
    EndpointListID = 0xE001
    SupportedCommands = 0x0fff // supports all commands
    State = Inactive

EndpointLists: contains one list element (EndpointListStruct):
    EndpointListID = 0xE001
    Name = "test room"
    Type = room
    Endpoints = [3]
....

Commission DUT to TH, if not done so already.

[[_test_procedure_206]]
==== link:#_test_procedure_206[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

1

ACT.C.C00.Tx(InstantAction)

DUT issues an InstantAction command to TH

TH verifies the parameters of this command are correct:

* ActionID contains a uint16 with valid 0xA001
* if InvokeID is provided, it is a uint32

2

ACT.C.C02.Tx(StartAction)

DUT issues an StartAction command to TH

3

ACT.C.C04.Tx(StopAction)

DUT issues an StopAction command to TH

4

ACT.C.C05.Tx(PauseAction)

DUT issues an PauseAction command to TH

5

ACT.C.C07.Tx(ResumeAction)

DUT issues an ResumeAction command to TH

6

ACT.C.C08.Tx(EnableAction)

DUT issues an EnableAction command to TH

7

ACT.C.C0a.Tx(DisableAction)

DUT issues an DisableAction command to TH

8

ACT.C.C03.Tx(StartActionWithDuration)

DUT issues an StartActionWithDuration command to TH

TH verifies the parameters of this command are correct:

* ActionID contains a uint16 with valid 0xA001
* if InvokeID is provided, it is a uint32
* Duration contains a valid uint16

9

ACT.C.C06.Tx(PauseActionWithDuration)

DUT issues an PauseActionWithDuration command to TH

10

ACT.C.C09.Tx(EnableActionWithDuration)

DUT issues an EnableActionWithDuration command to TH

11

ACT.C.C0b.Tx(DisableActionWithDuration)

DUT issues an DisableActionWithDuration command to TH

12

ACT.C.C01.Tx(InstantActionWithTransition)

DUT issues an InstantActionWithTransition command to TH

TH verifies the parameters of this command are correct

* ActionID contains a uint16 with valid 0xA001
* if InvokeID is provided, it is a uint32
* TransitionTime contains a valid uint16

[[_notestesting_considerations_197]]
=== link:#_notestesting_considerations_197[]Notes/Testing Considerations

Test Steps #2 to #12 cannot be executed with V1.0 SDK

[[_mode_select_cluster_test_plan]]
== link:#_mode_select_cluster_test_plan[]**Mode Select Cluster Test Plan**

[[_pics_definition_24]]
=== link:#_pics_definition_24[]79. PICS Definition

This section covers the Mode Select Cluster related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_26]]
==== link:#_role_26[]79.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MOD.S |Does the device implement the Mode Select Cluster as a server?
|O |

|MOD.C |Does the device implement the Mode Select Cluster as a client?
|O |
|===

[[_server_26]]
==== link:#_server_26[]79.2. Server

[[_features_18]]
===== link:#_features_18[]79.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MOD.S.F00(DEPONOFF) |Does the device support depending on an On/Off
cluster implemented on the same DUT? |O |
|===

[[_attributes_28]]
===== link:#_attributes_28[]79.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MOD.S.A0000(Description) |Does the device implement the _Description_
attribute? |M |

|MOD.S.A0001(StandardNamespace) |Does the device implement the
_StandardNamespace_ attribute? |M |

|MOD.S.A0002(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |M |

|MOD.S.A0003(CurrentMode) |Does the device implement the _CurrentMode_
attribute? |M |

|MOD.S.A0004(StartUpMode) |Does the device implement the _StartUpMode_
attribute? |O |

|MOD.S.A0005(OnMode) |Does the device implement the _OnMode_ attribute?
|DEPONOFF |
|===

[[_commands_received_17]]
===== link:#_commands_received_17[]79.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MOD.S.C00.Rsp(ChangeToMode) |Does the device implement receiving the
_ChangeToMode_ command? |O |
|===

[[_client_16]]
==== link:#_client_16[]79.3. Client

[[_attributes_29]]
===== link:#_attributes_29[]79.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MOD.C.A0002(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |O |
|===

[[_commands_generated_16]]
===== link:#_commands_generated_16[]79.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|MOD.C.C00.Tx(ChangeToMode) |Does the device implement sending the
_ChangeToMode_ command? |M |
|===

[[_test_case_list_26]]
=== link:#_test_case_list_26[]80. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-MOD-1.1 |Global attributes with server as DUT
|TC-MOD-1.2 |Cluster attributes with server as DUT
|TC-MOD-1.3 |Cluster attributes with client as DUT
|TC-MOD-2.1 |ChangeToMode Verification (DUT as Server)
|TC-MOD-2.2 |ChangeToMode Verification (DUT as Client)
|TC-MOD-3.1 |OnMode Verification
|TC-MOD-3.2 |StartUpMode Verification
|TC-MOD-3.3 |OTA Mode Verification
|TC-MOD-3.4 |OnMode Overwriting StartUpMode (DUT as Server)
|===

[[_test_cases_26]]
=== link:#_test_cases_26[]81. Test Cases

'''''

[[_attribute_test_cases]]
==== link:#_attribute_test_cases[]81.1. Attribute test cases

'''''

[[_tc_mod_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_mod_1_1_global_attributes_with_server_as_dut[]81.1.1. [TC-MOD-1.1] Global attributes with server as DUT

[[_category_202]]
====== link:#_category_202[]Category

Functional conformance

[[_purpose_207]]
====== link:#_purpose_207[]Purpose

This test case verifies the ModeSelect Global attributes

[[_pics_207]]
====== link:#_pics_207[]PICS

* MOD.S

[[_required_devices_207]]
====== link:#_required_devices_207[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_207]]
====== link:#_test_procedure_207[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 1 if the DUT has a dependency on the On/Off cluster (ie:
MOD.S.F00 is true), otherwise 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0003, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
0x0004: SHALL be included if and only if MOD.S.A0004

The list include entries based on feature support: +
0x0005 SHALL be included if and only if MOD.S.A0005

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00,

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_198]]
====== link:#_notestesting_considerations_198[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_tc_mod_1_2_cluster_attributes_with_server_as_dut]]
===== link:#_tc_mod_1_2_cluster_attributes_with_server_as_dut[]81.1.2. [TC-MOD-1.2] Cluster attributes with server as DUT

[[_category_203]]
====== link:#_category_203[]Category

Functional conformance

[[_purpose_208]]
====== link:#_purpose_208[]Purpose

This test case verifies the ModeSelect Cluster attributes

[[_pics_208]]
====== link:#_pics_208[]PICS

* MOD.S

[[_required_devices_208]]
====== link:#_required_devices_208[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_208]]
====== link:#_test_procedure_208[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.8.5, 1.8.9 |MOD.S.A0002 |TH reads the _SupportedModes attribute_
from DUT a|
Verify that the DUT response provides a list of supported modes. Each
mode should be a struct containing a label (user understandable string
describing the mode), mode number (integer that identifies the mode and
is unique within this SupportedMode list), and a list of semantic tags.
Record the mode numbers for use in steps 2, 3, and 4.

Verify that each entry in the semantics tag list, if any are present,
are structs containing a value field and manufacturer code. All of these
values should be no larger than 16 bits.

|2 |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that the DUT response is an integer that is in the list of
modes returned in step 1.

|3 |1.8.5 |MOD.S.A0005 |TH reads the _OnMode attribute_ from the DUT
|Verify that the DUT response is an integer that is in the list of modes
returned in step 1.

|4 |1.8.5 |MOD.S.A0004 |TH reads the _StartUpMode attribute_ from the
DUT |Verify that the DUT response is an integer that is in the list of
modes returned in step 1.

|5 |1.8.5 |MOD.S.A0000 |TH reads the _Description attribute_ from the
DUT |Verify that the DUT response provides human readable text string
that describes the purpose of the mode select server.

|6 |1.8.5 |MOD.S.A0001 |TH reads the _StandardNamespace attribute_ from
the DUT |Verify that the DUT response provides a 16 bit enum (null is
also acceptable).
|===

[[_notestesting_considerations_199]]
====== link:#_notestesting_considerations_199[]Notes/Testing Considerations

. Step 1 - Semantic tags may be part of a standard namespace or
manufacturer specific. Refer to manufacturer documentation for details
on the expected semantic tag information on their device.

[[_tc_mod_1_3_attributes_with_client_as_dut]]
===== link:#_tc_mod_1_3_attributes_with_client_as_dut[]81.1.3. [TC-MOD-1.3] Attributes with client as DUT

[[_category_204]]
====== link:#_category_204[]Category

Functional.

[[_purpose_209]]
====== link:#_purpose_209[]Purpose

This test case verifies the support of non-global attributes of the Mode
Select Cluster cluster client.

This test case evaluates only attributes which are: +
1. Defined in the Matter spec for Mode Select Cluster cluster client. +
2. Required or just usable for the functionality of the DUT (Mode Select
Cluster cluster client). +
A mandatory attribute on server side does not mean that the support of
this attribute is required on client side. +
The requirement of supporting an attribute on client side is either
driven by the device type or is a decision by the DUT manufacturer.

In this test, the PICS notation MOD.C.AM-READ represents the list of
non-global attributes that are specified as being mandatory on client
side and relevant for the DUT. +
Similarly, the PICS notation MOD.C.AO-READ represents the list of
non-global attributes that are specified as being optional on client
side. +
MOD.C.AM-WRITE and MOD.C.AO-WRITE are similar to MOD.C.AM-READ and
MOD.C.AO-READ, but additional they are marked as writeable in the
cluster spec and the the DUTs supports writing to these attributes.

[[_pics_209]]
====== link:#_pics_209[]PICS

* MOD.C
* MOD.C.AM-READ
* MOD.C.AO-READ
* MOD.C.AM-WRITE
* MOD.C.AO-WRITE

[[_required_devices_209]]
====== link:#_required_devices_209[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Server.
|2 |DUT |DUT as Client.
|===

[[_device_topology_173]]
====== link:#_device_topology_173[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_185]]
====== link:#_test_setup_185[]Test Setup

Configure TH such that it implements mandatory and all optional
attributes of the server-side of the cluster, and that it also reflects
this in global attributes such as FeatureMap and AttributeList.
Commission DUT to TH.

[[_test_procedure_209]]
====== link:#_test_procedure_209[]Test Procedure

*#*

*Ref*

*PICS*

*Test Step*

*Expected Outcome*

Read mandatory attributes.

1

MOD.C.AM-READ

DUT reads all supported mandatory attributes from TH one at a time in a
manufacturer specific order.

- TH receives the read command and knows this attribute for this cluster
and provides a plausible value. +
- DUT processes the values and operates normally (does not crash,
continues with next steps).

Read optional attributes (TH simulates a server cluster which supports
all optional attributes).

2

MOD.C.AO-READ

DUT reads all supported optional attributes from TH one at a time in a
manufacturer specific order.

- TH receives the read command and provides a plausible value. +
- DUT processes the values and operates normally (does not crash,
continues with next steps).

Write mandatory attributes.

3

MOD.C.AM-WRITE

DUT writes a suitable value to all supported mandatory attributes on the
TH one at a time in a manufacturer specific order.

TH receives the write command, checks whether the value is valid. If
value invalid, provide appropriate feedback to DUT and flag test as
FAIL. +
- DUT operates normally (does not crash, continues with next steps).

Write optional attributes (TH simulates a server cluster which supports
all optional attributes).

4

MOD.C.AO-WRITE

DUT writes a suitable value to all supported optional attributes on the
TH one at a time in a manufacturer specific order.

- TH receives the write command, checks whether the value is valid. If
value invalid, provide appropriate feedback to DUT and flag test as
FAIL. +
- DUT operates normally (does not crash, continues with next steps).

Change configuration - TH does not support optional attributes.

5

Configure TH such that it implements mandatory and none of the optional
attributes of the server-side of the cluster, and that it also reflects
this in global attributes such as FeatureMap and AttributeList. +
Commission DUT to TH again.

DUT is aware of the new configuration.

Read optional attributes (TH simulates a server cluster which does not
support any optional attributes).

6

MOD.C.AO-READ

DUT reads all supported optional attributes from TH one at a time in a
manufacturer specific order.

- TH receives the read command, and responds that this attribute is not
available. +
- DUT processes the error response and operates normally (does not
crash, continues with next steps). +
_Alternative allowed DUT behavior_: +
- DUT is aware (from the global attributes it may have read in step 5)
that the optional attributes are not available, and does not issue read
requests for the attributes which it _did_ read in step 2.

Write optional attributes (TH simulates a server cluster which does not
support any optional attributes).

7

MOD.C.AO-WRITE

DUT writes a suitable value to all supported optional attributes on the
TH one at a time in a manufacturer specific order.

- TH receives the write command and responds that this attribute is not
available. +
- DUT processes the error response and operates normally (does not
crash, continues with next steps if any). +
_Alternative allowed DUT behavior_: +
- DUT is aware (from the global attributes it may have read in step 5)
that the optional attributes are not available, and does not issue write
requests for the attributes which it _did_ write in step 4.

[[_notestesting_considerations_200]]
=== link:#_notestesting_considerations_200[]Notes/Testing Considerations

Spec git revision e3d2baad5e165a2cb18ddbb23605c338994f76c9

[[_changetomode_test_cases]]
=== link:#_changetomode_test_cases[]81.2. ChangeToMode Test Cases

'''''

[[_tc_mod_2_1_changetomode_verification_dut_as_server]]
==== link:#_tc_mod_2_1_changetomode_verification_dut_as_server[]81.2.1. [TC-MOD-2.1] ChangeToMode Verification (DUT as Server)

[[_category_205]]
===== link:#_category_205[]Category

Functional conformance

[[_purpose_210]]
===== link:#_purpose_210[]Purpose

This test case verifies the ChangeToMode command functionality.

[[_pics_210]]
===== link:#_pics_210[]PICS

* MOD.S.C00.Rsp

[[_required_devices_210]]
===== link:#_required_devices_210[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_210]]
===== link:#_test_procedure_210[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.8.5, 1.8.9 |MOD.S.A0002 |TH reads the _SupportedModes attribute_
from the DUT |Verify that the DUT response provides a list of supported
modes. Record the mode numbers for usage in steps 3 and 4.

|2 |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Record the mode numbers for usage in steps 3.

|3a |1.8.6 |MOD.S.C00.Rsp |TH sends a _ChangeToMode_ command to the DUT
with a integer from the list in step 1, but different from the integer
from step 2 |Verify DUT responds with a successful (value 0x00) status
response.

|3b |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that the DUT responds with the integer provided in step 3a,
not the integer from step 2.

|4 |1.8.6 |MOD.S.C00.Rsp |TH sends a _ChangeToMode_ command to the DUT
with a integer that is not in the list in step 1. |Verify DUT responds
with a _INVALID_COMMAND_ (hex value 0x85/decimal 133) status response.
|===

[[_notestesting_considerations_201]]
===== link:#_notestesting_considerations_201[]Notes/Testing Considerations

[[_tc_mod_2_2_changetomode_verification_dut_as_client]]
==== link:#_tc_mod_2_2_changetomode_verification_dut_as_client[]81.2.2. [TC-MOD-2.2] ChangeToMode Verification (DUT as Client)

[[_category_206]]
===== link:#_category_206[]Category

Functional conformance

[[_purpose_211]]
===== link:#_purpose_211[]Purpose

This test case verifies that the DUT can send a ChangeToMode command.

[[_pics_211]]
===== link:#_pics_211[]PICS

* MOD.C.C00.Tx

[[_required_devices_211]]
===== link:#_required_devices_211[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as server
|2 |DUT |DUT as client
|===

[[_device_topology_174]]
===== link:#_device_topology_174[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_186]]
===== link:#_test_setup_186[]Test Setup

Commission DUT to TH, if not done so already.

[[_test_procedure_211]]
===== link:#_test_procedure_211[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |1.8.5, 1.8.9 |MOD.C.A0002 |DUT reads the _SupportedModes attribute_
from the TH |Verify that the TH response provides a list of supported
modes. Record the mode numbers for usage in steps 2.

|2 |1.8.6 |MOD.C00.Tx |DUT sends a _ChangeToMode_ command to the TH with
an integer from the list in step 1. |Verify TH responds with a
successful (value 0x00) status response.
|===

[[_notestesting_considerations_202]]
===== link:#_notestesting_considerations_202[]Notes/Testing Considerations

[[_onoff_and_startup_mode_test_cases]]
=== link:#_onoff_and_startup_mode_test_cases[]81.3. On/Off and StartUp Mode Test Cases

'''''

[[_tc_mod_3_1_onmode_verification_dut_as_server]]
==== link:#_tc_mod_3_1_onmode_verification_dut_as_server[]81.3.1. [TC-MOD-3.1] OnMode Verification (DUT as Server)

[[_category_207]]
===== link:#_category_207[]Category

Functional conformance

[[_purpose_212]]
===== link:#_purpose_212[]Purpose

This test case verifies that the DUT switches to the proper OnMode when
the On/Off attribute of the On/Off cluster changes.

[[_pics_212]]
===== link:#_pics_212[]PICS

* MOD.S.A0005

[[_preconditions_73]]
===== link:#_preconditions_73[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |ModeSelect and OnOff clusters are available on the same endpoint |
|===

[[_required_devices_212]]
===== link:#_required_devices_212[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_212]]
===== link:#_test_procedure_212[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.8.5 |MOD.S.A0005 & MOD.S.F00 |TH reads from the DUT the _OnMode_
attribute. |Verify that the DUT response contains an integer or is null.
Record this value for use in step 2b.

|2a |1.8.5 |MOD.S.A0003 & MOD.S.F00 |TH reads from the DUT the
_CurrentMode_ attribute. |Verify that the DUT response contains an
integer. Record this value for use in step 2b.

|2b | |MOD.S.A0003 & MOD.S.A0005 & MOD.S.F00 |If the _OnMode_ and
_CurrentMode_ attributes have the same value or _OnMode_ is null,
proceed to step 2c, otherwise proceed to step 3a. |

|2c |1.8.5, 1.8.9 |MOD.S.A0002 & MOD.S.F00 |TH reads from the DUT the
_SupportedModes_ attribute. |Verify that the DUT response contains a
list of supported modes. Record the mode numbers for use in step 2d.

|2d |1.8.6 |MOD.S.A0002 & MOD.S.C00.Rsp & MOD.S.F00 |Select a value from
the list in step 2c with a different value than the _OnMode_ value read
in step 1. +
TH sends command _ChangeToMode_ with the selected value. |Verify that
the DUT response contains a successful (value 0x00) status response.

|3a |1.5.7 |OO.S.C00.Rsp & MOD.S.F00 |TH sends command _Off_ |Verify
that the DUT response contains a successful (value 0x00) status
response.

|3b |1.5.7 |OO.S.C01.Rsp & MOD.S.F00 |TH sends command _On_ |Verify that
the DUT response contains a successful (value 0x00) status response.

|3c |1.8.5 |MOD.S.A0003 & MOD.S.F00 |TH reads from the DUT the
_CurrentMode_ attribute. |Verify that the DUT response contains the
integer recorded in step 1 if _OnMode_ was not null or that the DUT
response is the integer written in step 2d.
|===

[[_notestesting_considerations_203]]
===== link:#_notestesting_considerations_203[]Notes/Testing Considerations

[[_tc_mod_3_2_startupmode_verification_dut_as_server]]
==== link:#_tc_mod_3_2_startupmode_verification_dut_as_server[]81.3.2. [TC-MOD-3.2] StartUpMode Verification (DUT as Server)

[[_category_208]]
===== link:#_category_208[]Category

Functional conformance

[[_purpose_213]]
===== link:#_purpose_213[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled.

[[_pics_213]]
===== link:#_pics_213[]PICS

* MOD.S.A0004

[[_required_devices_213]]
===== link:#_required_devices_213[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_213]]
===== link:#_test_procedure_213[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.8.5 |MOD.S.A0004 |TH reads the _StartUpMode attribute_ from the
DUT |Verify that the DUT response is an integer. Record this value for
usage in step 2.

|2a |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that the DUT response is an integer. Record this value for
usage in steps 2b.

|2b | |MOD.S.A0003, MOD.S.A0004 |If the _StartUpMode_ and _CurrentMode_
attributes have the same value, proceed to step 2c, Otherwise proceed to
step 3a. |

|2c |1.8.5, 1.8.9 |MOD.S.A0002 |TH reads the _SupportedModes attribute_
from the DUT |Verify that the DUT response provides a list of supported
modes. Record the mode numbers for usage in step 2d.

|2d |1.8.6 |MOD.S.A0002, MOD.S.C00.Rsp |Select a value from the list in
step 2c with a different value than the _StartUpMode_ value read in step
1. TH sends a _ChangeToMode_ command to the DUT with the selected value.
|Verify DUT responds with a successful (value 0x00) status response.

|3a | | |Physically power cycle the device. |

|3b |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that the DUT response is the integer recorded in step 1.
|===

[[_notestesting_considerations_204]]
===== link:#_notestesting_considerations_204[]Notes/Testing Considerations

[[_tc_mod_3_3_ota_mode_verification_dut_as_server]]
==== link:#_tc_mod_3_3_ota_mode_verification_dut_as_server[]81.3.3. [TC-MOD-3.3] OTA Mode Verification (DUT as Server)

[[_category_209]]
===== link:#_category_209[]Category

Functional conformance

[[_purpose_214]]
===== link:#_purpose_214[]Purpose

This test case verifies that the DUT switches to the proper mode
following an OTA update.

[[_pics_214]]
===== link:#_pics_214[]PICS

* MOD.S.A0004

[[_required_devices_214]]
===== link:#_required_devices_214[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_214]]
===== link:#_test_procedure_214[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.8.5 |MOD.S.A0004 |TH reads the _StartUpMode attribute_ from the
DUT |Verify that the DUT response is an integer. Record this value for
usage in step 2.

|2a |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that the DUT response is an integer. Record this value for
usage in steps 2b and 3.

|2b | |MOD.S.A0003, MOD.S.A0004 |If the _StartUpMode_ and _CurrentMode_
attributes have the same value, proceed to step 2c, Otherwise proceed to
step 3a. |

|2c |1.8.5, 1.8.9 |MOD.S.A0002 |TH reads the _SupportedModes attribute_
from the DUT |Verify that the DUT response provides a list of supported
modes. Record the mode numbers for usage in step 2d.

|2d |1.8.6 |MOD.S.A0002, MOD.S.C00.Rsp |Select a value from the list in
step 2c with a different value than the _StartUpMode_ value read in step
1. TH sends a _ChangeToMode_ command to the DUT with the selected value.
|Verify DUT responds with a successful (value 0x00) status response.
Record the value provided for usage in step 3.

|3a | | |Perform an OTA update on the device that requires a reboot.
Allow for the DUT to update and fully reboot. |

|3b |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that the DUT response is the integer recorded in step 2a or,
if the mode was changed, 2d.
|===

[[_notestesting_considerations_205]]
===== link:#_notestesting_considerations_205[]Notes/Testing Considerations

[[_tc_mod_3_4_onmode_overwriting_startupmode_dut_as_server]]
==== link:#_tc_mod_3_4_onmode_overwriting_startupmode_dut_as_server[]81.3.4. [TC-MOD-3.4] OnMode Overwriting StartUpMode (DUT as Server)

[[_category_210]]
===== link:#_category_210[]Category

Functional conformance

[[_purpose_215]]
===== link:#_purpose_215[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled, if the device supports OnMode, and StartUpOnOff.

[[_pics_215]]
===== link:#_pics_215[]PICS

* MOD.S.A0004
* MOD.S.A0005
* OO.S.A4003

[[_required_devices_215]]
===== link:#_required_devices_215[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT |DUT as server
|===

[[_test_procedure_215]]
===== link:#_test_procedure_215[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |1.8.5 |MOD.S.A0004 |TH reads the _StartUpMode attribute_ from the
DUT |Verify that the DUT response is an integer. Record this value for
usage in step 2.

|2a |1.8.5 |MOD.S.A0005 |TH reads the _OnMode attribute_ from the DUT
|Verify that the DUT response is an integer different from StartUpMode.
Record this value for usage in step 2b.

|2b | |MOD.S.A0004 MOD.S.A0005 |If the _StartUpMode_ and _OnMode_
attributes have the same value, proceed to step 2c, Otherwise proceed to
step 3. |

|2c |1.8.5, 1.8.9 |MOD.S.A0002 |TH reads the _SupportedModes attribute_
from the DUT |Verify that the response provides a list of supported
modes. Record the mode numbers for usage in step 2d.

|2d |1.8.6 |MOD.S.A0002 MOD.S.C00.Rsp |Select a value from the list in
step 2c with a different value than the _StartUpMode_ value read in step
1. TH sends a write command for _OnMode_ to the DUT with the selected
value. |Verify DUT responds with a successful (value 0x00) status
response.

|3 |1.8.5 |MOD.S.F00, MOD.S.A0005 |TH reads the _OnMode attribute_ from
the DUT |Record this number.

|4 |1.8.5 |OO.S.A4003 |TH writes 1 to _StartUpOnOff attribute_ of the
OnOff Cluster of the DUT |Verify that the response status was success.

|5 | | |Physically power cycle the device. |

|6 |1.8.5 |MOD.S.A0003 |TH reads the _CurrentMode attribute_ from the
DUT |Verify that this number is the same with the number recorded in
step 3.
|===

[[_notestesting_considerations_206]]
===== link:#_notestesting_considerations_206[]Notes/Testing Considerations

[[_rvc_run_cluster_test_plan]]
=== link:#_rvc_run_cluster_test_plan[]82. link:./cluster/mode_rvc_run.adoc[RVC Run Cluster Test Plan]

[[_rvc_run_mode_cluster_test_plan]]
== link:#_rvc_run_mode_cluster_test_plan[]**RVC Run Mode Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|0.1 |18-Apr-2023 |`Petru Lauric` |Initial Document upload to github
|0.2 |14-Jul-2023 |`Rob Bultman` |Fix test names
|===

[[_rvc_run_mode_cluster_testing_overview]]
=== link:#_rvc_run_mode_cluster_testing_overview[]83. RVC Run Mode Cluster Testing Overview

The RVC Run Mode cluster is a derived version of the Mode Base cluster.
This document describes the tests specific to this derived cluster.

[[_pics_definition_25]]
=== link:#_pics_definition_25[]84. PICS Definition

This section covers the RVC Run Mode Cluster related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_27]]
==== link:#_role_27[]84.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCRUNM.S |Does the device implement the RVCRUNM cluster as a server?
|O |
|===

[[_server_27]]
==== link:#_server_27[]84.2. Server

[[_features_19]]
===== link:#_features_19[]84.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCRUNM.S.F00(DEPONOFF) |Does the device support depending on an On/Off
cluster implemented on the same endpoint? |O |
|===

[[_attributes_30]]
===== link:#_attributes_30[]84.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCRUNM.S.A0000(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |M |

|RVCRUNM.S.A0001(CurrentMode) |Does the device implement the
_CurrentMode_ attribute? |M |

|RVCRUNM.S.A0002(StartUpMode) |Does the device implement the
_StartUpMode_ attribute? |O |

|RVCRUNM.S.A0003(OnMode) |Does the device implement the _OnMode_
attribute? |DEPONOFF |
|===

[[_commands_received_18]]
===== link:#_commands_received_18[]84.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCRUNM.S.C00.Rsp(ChangeToMode) |Does the device implement receiving
the _ChangeToMode_ command? |M |
|===

[[_commands_generated_17]]
===== link:#_commands_generated_17[]84.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCRUNM.S.C01.Tx(ChangeToModeResponse) |Does the device implement
sending the _ChangeToModeResponse_ command? |M |
|===

[[_manual_controllable_15]]
===== link:#_manual_controllable_15[]84.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCRUNM.S.M.CAN_TEST_MODE_FAILURE |Does the DUT support testing the
failed _ChangeToMode_ command? |O |Declared by manufacturer
|===

[[_pixit_definition_4]]
=== link:#_pixit_definition_4[]85. PIXIT Definition

This section covers the RVC Run Mode Test Plan related PIXIT items that
might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.RVCRUNM.MODE_CHANGE_FAIL |Id of mode the device will fail to
transition to, given its current state |O |

|PIXIT.RVCRUNM.MODE_CHANGE_OK |Id of mode the device will successfully
transition to, given its current state |O |
|===

[[_test_case_list_27]]
=== link:#_test_case_list_27[]86. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|[TC-RVCRUNM-1.1] |Global attributes with DUT as Server

|[TC-RVCRUNM-1.2] |Cluster attributes with DUT as Server

|[TC-RVCRUNM-2.1] |Change to Mode functionality with DUT as Server

|[TC-RVCRUNM-3.1] |On Mode functionality with DUT as Server

|[TC-RVCRUNM-3.2] |Startup Mode functionality with DUT as Server

|[TC-RVCRUNM-3.3] |On Mode and Startup Mode functionality with DUT as
Server
|===

[[_test_cases_27]]
=== link:#_test_cases_27[]87. Test Cases

'''''

[[_generic_test_cases_23]]
==== link:#_generic_test_cases_23[]87.1. Generic Test Cases

'''''

[[_tc_rvcrunm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_rvcrunm_1_1_global_attributes_with_dut_as_server[]87.1.1. [TC-RVCRUNM-1.1] Global attributes with DUT as Server

[[_category_211]]
====== link:#_category_211[]Category

Functional conformance

[[_purpose_216]]
====== link:#_purpose_216[]Purpose

This test case verifies the cluster server global attributes.

[[_pics_216]]
====== link:#_pics_216[]PICS

* RVCRUNM.S

[[_required_devices_216]]
====== link:#_required_devices_216[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_175]]
====== link:#_device_topology_175[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_187]]
====== link:#_test_setup_187[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_216]]
====== link:#_test_procedure_216[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

* bit 0: SHALL be 1 if and only if RVCRUNM.S.F00(DEPONOFF)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if RVCRUNM.S.A0002(StartUpMode)

The list include entries based on feature support: +

* 0x0003 SHALL be included if and only if RVCRUNM.S.F00(DEPONOFF)

and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute with a
list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +

0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +

0x01

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_207]]
====== link:#_notestesting_considerations_207[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_18]]
==== link:#_server_as_dut_18[]87.2. Server as DUT

'''''

[[_tc_rvcrunm_1_2_cluster_attributes_with_dut_as_server]]
===== link:#_tc_rvcrunm_1_2_cluster_attributes_with_dut_as_server[]87.2.1. [TC-RVCRUNM-1.2] Cluster attributes with DUT as Server

[[_category_212]]
====== link:#_category_212[]Category

Functional.

[[_purpose_217]]
====== link:#_purpose_217[]Purpose

This test case verifies the non-global attributes of the RVC Run Mode
cluster server.

[[_pics_217]]
====== link:#_pics_217[]PICS

* RVCRUNM.S

[[_required_devices_217]]
====== link:#_required_devices_217[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_176]]
====== link:#_device_topology_176[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_188]]
====== link:#_test_setup_188[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_217]]
====== link:#_test_procedure_217[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8, AC.7.2.5 |RVCRUNM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has at least 2 and at most 255 entries
* Verify that each ModeOptionsStruct entry has a unique Mode field value
* Verify that each ModeOptionsStruct entry has a unique Label field
value
* Verify that each ModeOptionsStruct entry’s ModeTags field, if not
empty, has:
+
** the values of the Value fields that are not larger than 16 bits
** each Value field Is the mode tag value a defined common tag value
(Auto(0x0000), Quick(0x0001), Quiet(0x0002), LowNoise(0x0003),
LowEnergy(0x0004), Vacation(0x0005), Min(0x0006), Max(0x0007),
Night(0x0008), Day(0x0009)) or a defined cluster derived tag value
(Idle(0x4000), Cleaning(0x4001)) or in the MfgTags (0x8000 to 0xBFFF)
range
** if the Value field is in the MfgTags (0x8000 to 0xBFFF) range, the
TagName field is a string with a length between 1 and 64
* Verify that at least one ModeOptionsStruct entry includes the
_Idle(0x4000)_ mode tag in the ModeTags field
* Verify that at least one ModeOptionsStruct entry includes the
_Cleaning(0x4001)_ mode tag in the ModeTags field
* Verify that none of the ModeOptionsStruct entries include both the
_Idle(0x4000)_ mode tag and the _Cleaning(0x4001)_ mode tag in the
ModeTags field
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut`

|4 |AC.1.9.6.4 |RVCRUNM.S.A0003(OnMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|5 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|===

[[_notestesting_considerations_208]]
====== link:#_notestesting_considerations_208[]Notes/Testing Considerations

. Step 2 - The mode tag values may be standard (if from the CommonTags
range) or derived cluster (if from the ClusterDerivedTags range) or
manufacturer specific (if from the MfgTags range). Refer to the
manufacturer documentation for details regarding the MfgTags values.

[[_changetomode_test_cases_2]]
==== link:#_changetomode_test_cases_2[]87.3. ChangeToMode Test Cases

'''''

[[_tc_rvcrunm_2_1_change_to_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvcrunm_2_1_change_to_mode_functionality_with_dut_as_server[]87.3.1. [TC-RVCRUNM-2.1] Change to Mode functionality with DUT as Server

[[_category_213]]
====== link:#_category_213[]Category

Functional conformance

[[_purpose_218]]
====== link:#_purpose_218[]Purpose

This test case verifies the functionality associated with the
ChangeToMode command.

[[_pics_218]]
====== link:#_pics_218[]PICS

* RVCRUNM.S

[[_required_devices_218]]
====== link:#_required_devices_218[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_177]]
====== link:#_device_topology_177[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_189]]
====== link:#_test_setup_189[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_218]]
====== link:#_test_procedure_218[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8 |RVCRUNM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* Select a value which is NOT in `supported_modes_dut` and save it as
`invalid_mode_th`

|4 |AC.1.9.7.1, AC.1.9.7.2 |RVCRUNM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`old_current_mode_dut`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|5 | |RVCRUNM.S.M.CAN_TEST_MODE_FAILURE a|
Manually put the device in a state from which it will FAIL to transition
to PIXIT.RVCRUNM.MODE_CHANGE_FAIL

a|

|6 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|7 |AC.1.9.7.1, AC.1.9.7.2 |RVCRUNM.S.M.CAN_TEST_MODE_FAILURE &
RVCRUNM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.RVCRUNM.MODE_CHANGE_FAIL

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to GenericFailure(0x02) or one of
Stuck(0x41), DustBinMissing(0x42), DustBinFull(0x43),
WaterTankEmpty(0x44), WaterTankMissing(0x45), WaterTankLidOpen(0x46),
MopCleaningPadMissing(0x47), BatteryLow(0x48) or in the MfgCodes (0x80
to 0xBF) range
* Verify that the StatusText field has a length between 1 and 64

|8 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
`old_current_mode_dut`

|9 | | a|
Manually put the device in a state from which it will SUCCESSFULLY
transition to PIXIT.RVCRUNM.MODE_CHANGE_OK

a|

|10 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|11 |AC.1.9.7.1, AC.1.9.7.2 |RVCRUNM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.RVCRUNM.MODE_CHANGE_OK

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to Success(0x00)

|12 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.RVCRUNM.MODE_CHANGE_OK

|13 |AC.1.9.7.1, AC.1.9.7.2 |RVCRUNM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`invalid_mode_th`

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to UnsupportedMode(0x01).

|14 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.RVCRUNM.MODE_CHANGE_OK

|===

[[_notestesting_considerations_209]]
====== link:#_notestesting_considerations_209[]Notes/Testing Considerations

[[_onoff_and_startup_mode_test_cases_2]]
==== link:#_onoff_and_startup_mode_test_cases_2[]87.4. On/Off and StartUp Mode Test Cases

'''''

[[_tc_rvcrunm_3_1_on_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvcrunm_3_1_on_mode_functionality_with_dut_as_server[]87.4.1. [TC-RVCRUNM-3.1] On Mode functionality with DUT as Server

[[_category_214]]
====== link:#_category_214[]Category

Functional conformance

[[_purpose_219]]
====== link:#_purpose_219[]Purpose

This test case verifies that the DUT switches to the proper OnMode when
the On/Off attribute of the On/Off cluster changes.

[[_pics_219]]
====== link:#_pics_219[]PICS

* RVCRUNM.S

[[_preconditions_74]]
====== link:#_preconditions_74[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |RVC Run Mode and OnOff clusters are available on the same endpoint
|

|2 | |The _OnMode_ attribute is set to a non-NULL value from the mode
values indicated by the _SupportedModes_ attribute. |
|===

[[_required_devices_219]]
====== link:#_required_devices_219[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_178]]
====== link:#_device_topology_178[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_190]]
====== link:#_test_setup_190[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_219]]
====== link:#_test_procedure_219[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.4 |RVCRUNM.S.A0003(OnMode), RVCRUNM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `on_mode_dut`

|3 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode), RVCRUNM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `on_mode_dut` is equal to `old_current_mode_dut` proceed to step 4.
Else proceed to step 6.

|4 |AC.1.9.6.1 |RVCRUNM.S.A0000(SupportedModes), RVCRUNM.S.F00(DEPONOFF)
a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`on_mode_dut`. Save the value as `new_mode_th`.

|5 |AC.1.9.7.1, AC.1.9.7.2 |RVCRUNM.S.C00.Rsp(ChangeToMode),
RVCRUNM.S.F00(DEPONOFF) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|6 |AC.1.5.7.1 |OO.S.C00.Rsp RVCRUNM.S.F00(DEPONOFF) a|
TH sends a _Off_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|7 |AC.1.5.7.2 |OO.S.C01.Rsp, RVCRUNM.S.F00(DEPONOFF) a|
TH sends a _On_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode), RVCRUNM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `on_mode_dut`

|===

[[_notestesting_considerations_210]]
====== link:#_notestesting_considerations_210[]Notes/Testing Considerations

[[_tc_rvcrunm_3_2_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvcrunm_3_2_startup_mode_functionality_with_dut_as_server[]87.4.2. [TC-RVCRUNM-3.2] Startup Mode functionality with DUT as Server

[[_category_215]]
====== link:#_category_215[]Category

Functional conformance

[[_purpose_220]]
====== link:#_purpose_220[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled.

[[_pics_220]]
====== link:#_pics_220[]PICS

* RVCRUNM.S

[[_preconditions_75]]
====== link:#_preconditions_75[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |!RVCRUNM.S.F00(DEPONOFF) | OnOff cluster’s _StartUpOnOff_
attribute is NULL | _StartUpOnOff_ is 0 | _OnMode_ is NULL |
|===

[[_required_devices_220]]
====== link:#_required_devices_220[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_179]]
====== link:#_device_topology_179[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_191]]
====== link:#_test_setup_191[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_220]]
====== link:#_test_procedure_220[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |RVCRUNM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `startup_mode_dut` is equal to `old_current_mode_dut` proceed to
step 6. Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |RVCRUNM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.7.1, AC.1.9.7.2 |RVCRUNM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|8 | | a|
Physically power cycle the device

a|

|9 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_start_up_mode_dut`
* The value is equal to `new_start_up_mode_th`

|10 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_dut`

|===

[[_notestesting_considerations_211]]
====== link:#_notestesting_considerations_211[]Notes/Testing Considerations

[[_tc_rvcrunm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvcrunm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[]87.4.3. [TC-RVCRUNM-3.3] On Mode and Startup Mode functionality with DUT as Server

[[_category_216]]
====== link:#_category_216[]Category

Functional conformance

[[_purpose_221]]
====== link:#_purpose_221[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled, if the device supports OnMode, and StartUpOnOff (from the
OnOff cluster).

[[_pics_221]]
====== link:#_pics_221[]PICS

* RVCRUNM.S

[[_required_devices_221]]
====== link:#_required_devices_221[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_180]]
====== link:#_device_topology_180[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_192]]
====== link:#_test_setup_192[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_221]]
====== link:#_test_procedure_221[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |RVCRUNM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.4 |RVCRUNM.S.A0003(OnMode), RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_on_mode_dut`
* If `startup_mode_dut` is equal to `old_on_mode_dut` proceed to step 6.
Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |RVCRUNM.S.A0000(SupportedModes),
RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.6.4 |RVCRUNM.S.A0003(OnMode) a|
TH writes to the DUT the _OnMode_ attribute with the `new_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.4 |RVCRUNM.S.A0003(OnMode), RVCRUNM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_on_mode_dut`
* The value is equal to `new_mode_th`

|9 |AC.1.5.6.5 |OO.S.A4003 a|
TH writes to the DUT the _StartUpOnOff_ attribute with the value 1.

a|
Verify DUT responds w/ status SUCCESS(0x00)

|10 | | a|
Physically power cycle the device

a|

|11 |AC.1.9.6.3 |RVCRUNM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_th`

|12 |AC.1.9.6.2 |RVCRUNM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_on_mode_dut`

|===

[[_notestesting_considerations_212]]
====== link:#_notestesting_considerations_212[]Notes/Testing Considerations

[[_rvc_clean_mode_cluster_test_plan]]
== link:#_rvc_clean_mode_cluster_test_plan[]**RVC Clean Mode Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|0.1 |18-Apr-2023 |`Petru Lauric` |Initial Document upload to github
|0.2 |14-Jul-2023 |`Rob Bultman` |Fix test names
|===

[[_rvc_clean_mode_cluster_testing_overview]]
=== link:#_rvc_clean_mode_cluster_testing_overview[]88. RVC Clean Mode Cluster Testing Overview

The RVC Clean Mode cluster is a derived version of the Mode Base
cluster. This document describes the tests specific to this derived
cluster.

[[_pics_definition_26]]
=== link:#_pics_definition_26[]89. PICS Definition

This section covers the RVC Clean Mode Cluster related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_28]]
==== link:#_role_28[]89.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCCLEANM.S |Does the device implement the RVCCLEANM cluster as a
server? |O |
|===

[[_server_28]]
==== link:#_server_28[]89.2. Server

[[_features_20]]
===== link:#_features_20[]89.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCCLEANM.S.F00(DEPONOFF) |Does the device support depending on an
On/Off cluster implemented on the same endpoint? |O |
|===

[[_attributes_31]]
===== link:#_attributes_31[]89.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCCLEANM.S.A0000(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |M |

|RVCCLEANM.S.A0001(CurrentMode) |Does the device implement the
_CurrentMode_ attribute? |M |

|RVCCLEANM.S.A0002(StartUpMode) |Does the device implement the
_StartUpMode_ attribute? |O |

|RVCCLEANM.S.A0003(OnMode) |Does the device implement the _OnMode_
attribute? |DEPONOFF |
|===

[[_commands_received_19]]
===== link:#_commands_received_19[]89.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCCLEANM.S.C00.Rsp(ChangeToMode) |Does the device implement receiving
the _ChangeToMode_ command? |M |
|===

[[_commands_generated_18]]
===== link:#_commands_generated_18[]89.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCCLEANM.S.C01.Tx(ChangeToModeResponse) |Does the device implement
sending the _ChangeToModeResponse_ command? |M |
|===

[[_manual_controllable_16]]
===== link:#_manual_controllable_16[]89.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCCLEANM.S.M.CAN_TEST_MODE_FAILURE |Does the DUT support testing the
failed _ChangeToMode_ command? |O |Declared by manufacturer
|===

[[_pixit_definition_5]]
=== link:#_pixit_definition_5[]90. PIXIT Definition

This section covers the RVC Clean Mode Test Plan related PIXIT items
that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.RVCCLEANM.MODE_CHANGE_FAIL |Id of mode the device will fail to
transition to, given its current state |O |

|PIXIT.RVCCLEANM.MODE_CHANGE_OK |Id of mode the device will successfully
transition to, given its current state |O |
|===

[[_test_case_list_28]]
=== link:#_test_case_list_28[]91. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|[TC-RVCCLEANM-1.1] |Global attributes with DUT as Server

|[TC-RVCCLEANM-1.2] |Cluster attributes with DUT as Server

|[TC-RVCCLEANM-2.1] |Change to Mode functionality with DUT as Server

|[TC-RVCCLEANM-3.1] |On Mode functionality with DUT as Server

|[TC-RVCCLEANM-3.2] |Startup Mode functionality with DUT as Server

|[TC-RVCCLEANM-3.3] |On Mode and Startup Mode functionality with DUT as
Server
|===

[[_test_cases_28]]
=== link:#_test_cases_28[]92. Test Cases

'''''

[[_generic_test_cases_24]]
==== link:#_generic_test_cases_24[]92.1. Generic Test Cases

'''''

[[_tc_rvccleanm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_rvccleanm_1_1_global_attributes_with_dut_as_server[]92.1.1. [TC-RVCCLEANM-1.1] Global attributes with DUT as Server

[[_category_217]]
====== link:#_category_217[]Category

Functional conformance

[[_purpose_222]]
====== link:#_purpose_222[]Purpose

This test case verifies the cluster server global attributes.

[[_pics_222]]
====== link:#_pics_222[]PICS

* RVCCLEANM.S

[[_required_devices_222]]
====== link:#_required_devices_222[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_181]]
====== link:#_device_topology_181[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_193]]
====== link:#_test_setup_193[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_222]]
====== link:#_test_procedure_222[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

* bit 0: SHALL be 1 if and only if RVCCLEANM.S.F00(DEPONOFF)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if
RVCCLEANM.S.A0002(StartUpMode)

The list include entries based on feature support: +

* 0x0003 SHALL be included if and only if RVCCLEANM.S.F00(DEPONOFF)

and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute with a
list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +

0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +

0x01

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_213]]
====== link:#_notestesting_considerations_213[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_19]]
==== link:#_server_as_dut_19[]92.2. Server as DUT

'''''

[[_tc_rvccleanm_1_2_cluster_attributes_with_dut_as_server]]
===== link:#_tc_rvccleanm_1_2_cluster_attributes_with_dut_as_server[]92.2.1. [TC-RVCCLEANM-1.2] Cluster attributes with DUT as Server

[[_category_218]]
====== link:#_category_218[]Category

Functional.

[[_purpose_223]]
====== link:#_purpose_223[]Purpose

This test case verifies the non-global attributes of the RVC Clean Mode
cluster server.

[[_pics_223]]
====== link:#_pics_223[]PICS

* RVCCLEANM.S

[[_required_devices_223]]
====== link:#_required_devices_223[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_182]]
====== link:#_device_topology_182[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_194]]
====== link:#_test_setup_194[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_223]]
====== link:#_test_procedure_223[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8, AC.7.3.5 |RVCCLEANM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has at least 2 and at most 255 entries
* Verify that each ModeOptionsStruct entry has a unique Mode field value
* Verify that each ModeOptionsStruct entry has a unique Label field
value
* Verify that each ModeOptionsStruct entry’s ModeTags field, if not
empty, has:
+
** the values of the Value fields that are not larger than 16 bits
** for each Value field: Is the mode tag value a defined common tag
value (Auto(0x0000), Quick(0x0001), Quiet(0x0002), LowNoise(0x0003),
LowEnergy(0x0004), Vacation(0x0005), Min(0x0006), Max(0x0007),
Night(0x0008), Day(0x0009)) or a defined derived cluster tag value
(DeepClean(0x4000), Vacuum(0x4001), Mop(0x4002)) or in the MfgTags
(0x8000 to 0xBFFF) range
** if the Value field is in the MfgTags (0x8000 to 0xBFFF) range, the
TagName field is a string with a length between 1 and 64
* Verify that at least one ModeOptionsStruct entry includes either the
Vacuum(0x4001) mode tag or the Mop(0x4002)mode tag in the ModeTags field
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut`

|4 |AC.1.9.6.4 |RVCCLEANM.S.A0003(OnMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|5 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|===

[[_notestesting_considerations_214]]
====== link:#_notestesting_considerations_214[]Notes/Testing Considerations

. Step 2 - The mode tag values may be standard (if from the CommonTags
range) or manufacturer specific (if from the MfgTags range). Refer to
the manufacturer documentation for details regarding the MfgTags values.

[[_changetomode_test_cases_3]]
==== link:#_changetomode_test_cases_3[]92.3. ChangeToMode Test Cases

'''''

[[_tc_rvccleanm_2_1_change_to_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvccleanm_2_1_change_to_mode_functionality_with_dut_as_server[]92.3.1. [TC-RVCCLEANM-2.1] Change to Mode functionality with DUT as Server

[[_category_219]]
====== link:#_category_219[]Category

Functional conformance

[[_purpose_224]]
====== link:#_purpose_224[]Purpose

This test case verifies the functionality associated with the
ChangeToMode command.

[[_pics_224]]
====== link:#_pics_224[]PICS

* RVCCLEANM.S

[[_required_devices_224]]
====== link:#_required_devices_224[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_183]]
====== link:#_device_topology_183[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_195]]
====== link:#_test_setup_195[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_224]]
====== link:#_test_procedure_224[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8 |RVCCLEANM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* Select a value which is NOT in `supported_modes_dut` and save it as
`invalid_mode_th`

|4 |AC.1.9.7.1, AC.1.9.7.2 |RVCCLEANM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`old_current_mode_dut`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|5 | |RVCCLEANM.S.M.CAN_TEST_MODE_FAILURE a|
Manually put the device in a state from which it will FAIL to transition
to PIXIT.RVCCLEANM.MODE_CHANGE_FAIL

a|

|6 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|7 |AC.1.9.7.1, AC.1.9.7.2 |RVCCLEANM.S.M.CAN_TEST_MODE_FAILURE &
RVCCLEANM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.RVCCLEANM.MODE_CHANGE_FAIL

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to GenericFailure(0x02) or one of
CleaningInProgress(0X40) or in the MfgCodes (0x80 to 0xBF) range
* Verify that the StatusText field has a length between 1 and 64

|8 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
`old_current_mode_dut`

|9 | | a|
Manually put the device in a state from which it will SUCCESSFULLY
transition to PIXIT.RVCCLEANM.MODE_CHANGE_OK

a|

|10 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|11 |AC.1.9.7.1, AC.1.9.7.2 |RVCCLEANM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.RVCCLEANM.MODE_CHANGE_OK

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to Success(0x00)

|12 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.RVCCLEANM.MODE_CHANGE_OK

|13 |AC.1.9.7.1, AC.1.9.7.2 |RVCCLEANM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`invalid_mode_th`

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to UnsupportedMode(0x01).

|14 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.RVCCLEANM.MODE_CHANGE_OK

|===

[[_notestesting_considerations_215]]
====== link:#_notestesting_considerations_215[]Notes/Testing Considerations

[[_onoff_and_startup_mode_test_cases_3]]
==== link:#_onoff_and_startup_mode_test_cases_3[]92.4. On/Off and StartUp Mode Test Cases

'''''

[[_tc_rvccleanm_3_1_on_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvccleanm_3_1_on_mode_functionality_with_dut_as_server[]92.4.1. [TC-RVCCLEANM-3.1] On Mode functionality with DUT as Server

[[_category_220]]
====== link:#_category_220[]Category

Functional conformance

[[_purpose_225]]
====== link:#_purpose_225[]Purpose

This test case verifies that the DUT switches to the proper OnMode when
the On/Off attribute of the On/Off cluster changes.

[[_pics_225]]
====== link:#_pics_225[]PICS

* RVCCLEANM.S

[[_preconditions_76]]
====== link:#_preconditions_76[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |RVC Clean Mode and OnOff clusters are available on the same
endpoint |

|2 | |The _OnMode_ attribute is set to a non-NULL value from the mode
values indicated by the _SupportedModes_ attribute. |
|===

[[_required_devices_225]]
====== link:#_required_devices_225[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_184]]
====== link:#_device_topology_184[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_196]]
====== link:#_test_setup_196[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_225]]
====== link:#_test_procedure_225[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.4 |RVCCLEANM.S.A0003(OnMode), RVCCLEANM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `on_mode_dut`

|3 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode),
RVCCLEANM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `on_mode_dut` is equal to `old_current_mode_dut` proceed to step 4.
Else proceed to step 6.

|4 |AC.1.9.6.1 |RVCCLEANM.S.A0000(SupportedModes),
RVCCLEANM.S.F00(DEPONOFF) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`on_mode_dut`. Save the value as `new_mode_th`.

|5 |AC.1.9.7.1, AC.1.9.7.2 |RVCCLEANM.S.C00.Rsp(ChangeToMode),
RVCCLEANM.S.F00(DEPONOFF) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|6 |AC.1.5.7.1 |OO.S.C00.Rsp RVCCLEANM.S.F00(DEPONOFF) a|
TH sends a _Off_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|7 |AC.1.5.7.2 |OO.S.C01.Rsp, RVCCLEANM.S.F00(DEPONOFF) a|
TH sends a _On_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode),
RVCCLEANM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `on_mode_dut`

|===

[[_notestesting_considerations_216]]
====== link:#_notestesting_considerations_216[]Notes/Testing Considerations

[[_tc_rvccleanm_3_2_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvccleanm_3_2_startup_mode_functionality_with_dut_as_server[]92.4.2. [TC-RVCCLEANM-3.2] Startup Mode functionality with DUT as Server

[[_category_221]]
====== link:#_category_221[]Category

Functional conformance

[[_purpose_226]]
====== link:#_purpose_226[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled.

[[_pics_226]]
====== link:#_pics_226[]PICS

* RVCCLEANM.S

[[_preconditions_77]]
====== link:#_preconditions_77[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |!RVCCLEANM.S.F00(DEPONOFF) | OnOff cluster’s _StartUpOnOff_
attribute is NULL | _StartUpOnOff_ is 0 | _OnMode_ is NULL |
|===

[[_required_devices_226]]
====== link:#_required_devices_226[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_185]]
====== link:#_device_topology_185[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_197]]
====== link:#_test_setup_197[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_226]]
====== link:#_test_procedure_226[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |RVCCLEANM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `startup_mode_dut` is equal to `old_current_mode_dut` proceed to
step 6. Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |RVCCLEANM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.7.1, AC.1.9.7.2 |RVCCLEANM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|8 | | a|
Physically power cycle the device

a|

|9 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_start_up_mode_dut`
* The value is equal to `new_start_up_mode_th`

|10 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_dut`

|===

[[_notestesting_considerations_217]]
====== link:#_notestesting_considerations_217[]Notes/Testing Considerations

[[_tc_rvccleanm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_rvccleanm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[]92.4.3. [TC-RVCCLEANM-3.3] On Mode and Startup Mode functionality with DUT as Server

[[_category_222]]
====== link:#_category_222[]Category

Functional conformance

[[_purpose_227]]
====== link:#_purpose_227[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled, if the device supports OnMode, and StartUpOnOff (from the
OnOff cluster).

[[_pics_227]]
====== link:#_pics_227[]PICS

* RVCCLEANM.S

[[_required_devices_227]]
====== link:#_required_devices_227[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_186]]
====== link:#_device_topology_186[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_198]]
====== link:#_test_setup_198[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_227]]
====== link:#_test_procedure_227[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |RVCCLEANM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.4 |RVCCLEANM.S.A0003(OnMode),
RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_on_mode_dut`
* If `startup_mode_dut` is equal to `old_on_mode_dut` proceed to step 6.
Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |RVCCLEANM.S.A0000(SupportedModes),
RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.6.4 |RVCCLEANM.S.A0003(OnMode) a|
TH writes to the DUT the _OnMode_ attribute with the `new_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.4 |RVCCLEANM.S.A0003(OnMode), RVCCLEANM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_on_mode_dut`
* The value is equal to `new_mode_th`

|9 |AC.1.5.6.5 |OO.S.A4003 a|
TH writes to the DUT the _StartUpOnOff_ attribute with the value 1.

a|
Verify DUT responds w/ status SUCCESS(0x00)

|10 | | a|
Physically power cycle the device

a|

|11 |AC.1.9.6.3 |RVCCLEANM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_th`

|12 |AC.1.9.6.2 |RVCCLEANM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_on_mode_dut`

|===

[[_notestesting_considerations_218]]
====== link:#_notestesting_considerations_218[]Notes/Testing Considerations

[[_descriptor_cluster_testplan]]
== link:#_descriptor_cluster_testplan[]**Descriptor Cluster TestPlan**

[[_pics_definition_27]]
=== link:#_pics_definition_27[]93. PICS Definition

This section covers the Descriptor Cluster related PICS items that are
referenced in the following test case

[[_role_29]]
==== link:#_role_29[]93.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DESC.S |Does the device implement the Descriptor cluster as a server?
|O |
|===

[[_server_29]]
==== link:#_server_29[]93.2. Server

[[_features_21]]
===== link:#_features_21[]93.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DESC.S.F00(TagList) |Does the device support the _TagList_ command |O |
|===

[[_attributes_32]]
===== link:#_attributes_32[]93.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DESC.S.A0000(DEVICETYPELIST) |Does the DUT(server) support the
DEVICETYPELIST attribute? |M |

|DESC.S.A0001(SERVERLIST) |Does the DUT(server) support the SERVERLIST
attribute? |M |

|DESC.S.A0002(CLIENTLIST) |Does the DUT(server) support the CLIENTLIST
attribute? |M |

|DESC.S.A0003(PARTSLIST) |Does the DUT(server) support the PARTSLIST
attribute? |M |

|DESC.S.A0004(TAGLIST) |Does the DUT(server) support the TAGLIST
attribute? |_TagList_ |
|===

[[_pixit_definition_6]]
=== link:#_pixit_definition_6[]94. PIXIT Definition

This section covers the Descriptor’s Test Plan related PIXIT items that
might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.DESC.DeviceTypeConformanceList |Predefined list generated from
the spec which contains all the mandatory clusters and elements that
must be implemented for a given DeviceType |M |
|===

[[_test_case_list_29]]
=== link:#_test_case_list_29[]95. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-DESC-1.1 |Global Attributes with DUT as Server
|2 |TC-DESC-2.1 |Descriptor Cluster Attributes [DUT- Server]
|===

[[_test_cases_29]]
=== link:#_test_cases_29[]96. Test Cases

[[_generic_test_cases_25]]
==== link:#_generic_test_cases_25[]96.1. Generic test cases

[[_tc_desc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_desc_1_1_global_attributes_with_dut_as_server[]96.1.1. [TC-DESC-1.1] Global Attributes with DUT as Server

[[_category_223]]
====== link:#_category_223[]Category

Functional conformance.

[[_purpose_228]]
====== link:#_purpose_228[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_228]]
====== link:#_pics_228[]PICS

* DESC.S

[[_required_devices_228]]
====== link:#_required_devices_228[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_228]]
====== link:#_test_procedure_228[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the map of supported features:

The list include entries based on feature support: +
0x0001: SHALL be included if and only if DESC.S.F00(TagList) and SHALL
NOT be included otherwise.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0003 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list include entries based on feature support: +
0x0004: SHALL be included if and only if DESC.S.F00(TagList).

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_219]]
====== link:#_notestesting_considerations_219[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_cluster_attribute_test_cases_2]]
==== link:#_cluster_attribute_test_cases_2[]96.2. Cluster Attribute test cases

[[_tc_desc_2_1_descriptor_cluster_attributes_dut_server]]
===== link:#_tc_desc_2_1_descriptor_cluster_attributes_dut_server[]96.2.1. [TC-DESC-2.1] Descriptor Cluster Attributes [DUT-Server]

[[_category_224]]
====== link:#_category_224[]Category

Functional

[[_purpose_229]]
====== link:#_purpose_229[]Purpose

This test case verifies the properties of Descriptor Cluster Attributes.

[[_pics_229]]
====== link:#_pics_229[]PICS

* DESC.S

[[_required_devices_229]]
====== link:#_required_devices_229[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Client
|2 |DUT |Server
|===

[[_device_topology_187]]
====== link:#_device_topology_187[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_199]]
====== link:#_test_setup_199[]Test Setup

Commission DUT to TH.

[width="100%",cols="50%,50%",]
|===
a|
Note

|Manufacturer-specific Device Types and Clusters shall be ignored
(skipped) while performing the validation steps.
|===

[[_test_procedure_229]]
====== link:#_test_procedure_229[]Test Procedure

[width="100%",cols="5%,10%,15%,30%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |9.6.4.1 a|
DESC.S.A0000(DEVICETYPELIST) & DESC.S.A0003(PARTSLIST)

a|
TH reads DeviceTypeList and PartsList attributes from DUT for Endpoint 0

a|
* Verify that PartsList attribute is not empty and contains a list of
all endpoints. (use this list of endpoints in step 1b)
* Verify that the DeviceTypeList count is at least one.
* Verify that the DeviceTypeList contains one Root Node Device Type and
may only contain other Node Device Types (device types with scope=node,
it can be any of the following Power Source, OTA Requestor, OTA
Provider) next to the Root Node Device Type.
* Read each element from the DeviceTypeList and check for the following:
+
. DeviceType should be one of the DeviceTypes listed in the
PIXIT.DESC.DeviceTypeConformanceList.
. Revision should match the revision of that Device Type in the
PIXIT.DESC.DeviceTypeConformanceList.
. Revision value is not less than 1.

|1b |9.6.4.1 a|
DESC.S.A0000(DEVICETYPELIST) & DESC.S.A0003(PARTSLIST)

a|
TH reads DeviceTypeList and PartsList attributes from DUT for each
Endpoint supported by DUT (except Endpoint 0).

a|
if PartsLists count is 0, // leaf endpoint

* Verify that the DeviceTypeList count is at least one.
* Verify that the DeviceTypeList contains exactly one Application Device
Type, or a set of Application Device Types which are a subset of each
other.
* It may also contain one or more Utility Device Types - but not Root
Node.

endif

if PartsLists count is not 0, // composed device type at this endpoint

* Verify that the DeviceTypeList contains at most one Application Device
Type, or a set of Application Device Types which are a subset of each
other.
* It may also contain one or more Utility Device Types - but not Root
Node.

endif

For any value of PartsList count, read each element from the
DeviceTypeList and check for the following:

. DeviceType should match to the DeviceType listed in the
PIXIT.DESC.DeviceTypeConformanceList.
. Revision should match the revision of that Device Type in the
PIXIT.DESC.DeviceTypeConformanceList.
. Revision value is not less than 1.

endif

|2 |9.6.4.2 |DESC.S.A0001(SERVERLIST) a|
TH reads "ServerList" attribute.

a|
If ServerList count is greater than 0 read each element from the list
and check for the following:

* Each cluster marked as server and mandatory in
PIXIT.DESC.DeviceTypeConformanceList, SHALL be in the ServerList.

|3 |9.6.4.3 |DESC.S.A0002(CLIENTLIST) a|
TH reads "ClientList" attribute

a|
If ClientList count is greater than 0 read each element from the list
and check for the following:

* Each cluster marked as client and mandatory in
PIXIT.DESC.DeviceTypeConformanceList, SHALL be in the ClientList.

|4 |9.6.4.4 |DESC.S.A0003(PARTSLIST) |TH reads "PartsList" attribute. a|
If PartsList count is greater than 0, read each Endpoint from the list
and check for the following:

. Endpoint is in the range of 1 to 65534 and not equal to the Endpoint
of the Endpoint where this PartsList was read (i..e no self-reference)
. Repeat Steps 1b to 4 in a recursive manner for the Endpoints read in
this step (i.e. recursively walk all the Endpoints encountered in all
PartsLists)

|5 |9.6.4.4 |DESC.S.F00(TagList)& DESC.S.A0004(TAGLIST) |TH reads from
the DUT the "TagList" attribute. a|
Verify that the DUT response contains a TagList which contains at least
one element.

Read each TagStruct from the list and check for the following:

. Number of entries in TagList is in the range of 1 to 6 and each entry
contains at least a NamespaceID and a Tag property. Confirm that each
entry is unique (i.e. no duplicate tags).
. Confirm that each non-manufacturer specific tag is from a namespace
defined in the spec (either from an common namespace or from a namespace
for the particular device type).
. If the MfgCode field is not null, confirm that it is the
link:#ref_VendorID[Vendor ID] of the manufacturer who has defined a
certain namespace and that the NamespaceID field indicates which
namespace from the manufacturer is associated with the Tag field.
. If a manufacturer specific Tag field is indicated, at least one
standardized tag which is not from any manufacturer’s namespace shall be
included in the TagList.
. Tag field is the ID of a semantic tag within the namespace indicated
by the NamespaceID property.
. If the Label field is not null, it contains human-readable text
suitable for display on a client. The Label field SHALL be present when
the MfgCode is not null.

|6 | | |The cluster tests applicable to each Device Type should be
executed to make sure all mandatory (and applicable optional)
attributes/commands are implemented. |
|===

[[_general_diagnostics_cluster_test_plan]]
== link:#_general_diagnostics_cluster_test_plan[]**General Diagnostics Cluster Test Plan**

[[_pics_definition_28]]
=== link:#_pics_definition_28[]97. PICS Definition

This section covers the General Diagnostics Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_30]]
==== link:#_role_30[]97.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGGEN.S |Does the device implement the General Diagnostics cluster as a
server? |O |

|DGGEN.C |Does the device implement the General Diagnostics cluster as a
client? |O |
|===

[[_server_30]]
==== link:#_server_30[]97.2. Server

[[_attributes_33]]
===== link:#_attributes_33[]97.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGGEN.S.A0000(NetworkInterfaces) |Provides a node network interface
information via NetworkInterface structure. |M |Structure data includes
Name, IsOperational, OffPremiseServicesReachableIPv4,
OffPremiseServicesReachableIPv6, HardwareAddress, IPv4Address,
IPv6Address, Type.

|DGGEN.S.A0001(RebootCount) |The number of times that the node has
rebooted. Node low power or sleep state shall not be counted and the
count shall be reset by the factory reset. |M |

|DGGEN.S.A0002(Uptime) |The best effort assessment of the length of the
time, in seconds, since node’s last reboot. The UpTime should be
incremented during low-power or sleep state of the node. The UpTime
shall be reset only by a device reboot. The Uptime should not be
subscribed. |O |

|DGGEN.S.A0003(TotalOperationalHours) |The best effort attempt to track
the operational hours of node since the node is operational. The
operational hour should be incremented during low-power or sleep state
of the node. The TotalOperationalHours shall be reset by the node
factory reset. |O |

|DGGEN.S.A0004(BootReason) |Indicates the reason for the most recent
node reboot. |O |Table 104 BootReason

|DGGEN.S.A0005(ActiveHardwareFaults) |Indicates a set of hardware fault
detected by the node. |O |Follow 11.11.6.1 HardwareFault Data Type.

|DGGEN.S.A0006(ActiveRadioFaults) |Indicates a set of radio fault
detected by the node. |O |Follow 11.11.6.2 RadioFault Data Type.

|DGGEN.S.A0007(ActiveNetworkFaults) |Indicates a set of network fault
detected by the node. |O |Follow 11.11.6.3 NetworkFault Data Type.

|DGGEN.S.A0008(TestEventTriggersEnabled) |Indicates that node is
configured for test event triggers. |M |
|===

[[_commands_received_20]]
===== link:#_commands_received_20[]97.2.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGGEN.S.C00.Rsp(TestEventTrigger) |Indicates that node is configured
for test event triggers. |M |
|===

[[_events_7]]
===== link:#_events_7[]97.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGGEN.S.E00(HardwareFaultChange) |Indicates a change in the set of
hardware faults currently detected by the Node. |O |Section 11.11.6.1,
“HardwareFault enum”

|DGGEN.S.E01(RadioFaultChange) |Indicates a change in the set of radio
faults currently detected by the Node. |O |Section 11.11.6.2,
“RadioFault enum”

|DGGEN.S.E02(NetworkFaultChange) |Indicates a change in the set of
network faults currently detected by the Node. |O |Section 11.11.6.3,
“NetworkFault enum”.

|DGGEN.S.E03(BootReason) |Indicates the reason that caused the device to
reboot start-up. |M |Table 104. BootReason ENUM
|===

[[_client_17]]
==== link:#_client_17[]97.3. Client

[[_commands_generated_19]]
===== link:#_commands_generated_19[]97.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DGGEN.C.C00.Tx(TestEventTrigger) |Indicates that node is configured for
test event triggers. |O |
|===

[[_pixit_definition_7]]
=== link:#_pixit_definition_7[]98. PIXIT Definition

This section covers the General Diagnostics Cluster Test Plan related
PIXIT items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.DGGEN.ENABLEKEY |EnableKey for TestEventTrigger Command is
provided by the manufacturer |O |
|===

[[_test_case_list_30]]
=== link:#_test_case_list_30[]99. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-DGGEN-1.1 |Global Attributes with DUT as Server
|2 |TC-DGGEN-2.1 |Attributes [DUT as Server]
|3 |TC-DGGEN-2.2 |Event Functionality [DUT as Server]
|4 |TC-DGGEN-2.3 |Command Received [DUT as Server]
|===

[[_test_cases_30]]
=== link:#_test_cases_30[]100. Test Cases

[[_generic_test_cases_26]]
==== link:#_generic_test_cases_26[]100.1. Generic Test Cases

[[_tc_dggen_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_dggen_1_1_global_attributes_with_dut_as_server[]100.1.1. [TC-DGGEN-1.1] Global Attributes with DUT as Server

[[_category_225]]
====== link:#_category_225[]Category

Functional conformance.

[[_purpose_230]]
====== link:#_purpose_230[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_230]]
====== link:#_pics_230[]PICS

* DGGEN.S

[[_required_devices_230]]
====== link:#_required_devices_230[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_230]]
====== link:#_test_procedure_230[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0008, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if DGGEN.S.A0002(Uptime)

- 0x0003: SHALL be included if and only if
DGGEN.S.A0003(TotalOperationalHours)

- 0x0004: SHALL be included if and only if DGGEN.S.A0004(BootReason)

- 0x0005: SHALL be included if and only if
DGGEN.S.A0005(ActiveHardwareFaults)

- 0x0006: SHALL be included if and only if
DGGEN.S.A0006(ActiveRadioFaults)

- 0x0007: SHALL be included if and only if
DGGEN.S.A0007(ActiveNetworkFaults)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list SHALL include all the mandatory entries: +
0x03.

The list MAY include these optional entries: +
- 0x00: SHALL be included if and only if
DGGEN.S.E00(HardwareFaultChange)

- 0x01: SHALL be included if and only if DGGEN.S.E01(RadioFaultChange)

- 0x02: SHALL be included if and only if DGGEN.S.E02(NetworkFaultChange)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_220]]
====== link:#_notestesting_considerations_220[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_20]]
==== link:#_server_as_dut_20[]100.2. Server as DUT

'''''

[[_tc_dggen_2_1_attributes_dut_as_server]]
===== link:#_tc_dggen_2_1_attributes_dut_as_server[]100.2.1. [TC-DGGEN-2.1] Attributes [DUT as Server]

[[_category_226]]
====== link:#_category_226[]Category

Functional

[[_purpose_231]]
====== link:#_purpose_231[]Purpose

This test case verifies the behavior of the attributes of the general
diagnostics cluster server.

[[_pics_231]]
====== link:#_pics_231[]PICS

* DGGEN.S

[[_required_devices_231]]
====== link:#_required_devices_231[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_188]]
====== link:#_device_topology_188[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_200]]
====== link:#_test_setup_200[]Test Setup

Commission DUT to TH

[[_test_procedure_231]]
====== link:#_test_procedure_231[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.11.7.1 |DGGEN.S.A0000(NetworkInterfaces) |TH reads
NetworkInterfaces structure attribute from DUT. |The read data type must
match the value listed in the specification(s) 11.11.6.5
NetworkInterfaces structure. Each logical NW interface shall be
represented by a single entry here. Structure data includes Name
(interface name), IsOperational (indicates the node is operational in
the fabric), OffPremiseServicesReachableIPv4 (Ability to reach
off-premise services it uses by utilizing IPv4, if not NULL),
OffPremiseServicesReachableIPv6 (Ability to reach off-premise services
it uses by utilizing IPv6, if not NULL), HardwareAddress (MAC-layer
address for a 802.3 or IEEE 802.11-2020 network interface, or 802.15.4),
IPv4Address, IPv6Address (a list of the unicast IPv6 addresses that are
GUA and ULA), Type (Interface types).

|3 |11.11.7.2 |DGGEN.S.A0001(RebootCount) |TH reads a RebootCount
attribute value from DUT. Then a DUT (node) gets rebooted more than 2
times. |The data type must be UINT16 and the count should match with the
number of rebooted times. A low power or sleep shall not count as a
reboot. Upon the factory reset, the count shall be set to 0.

|4 |11.11.7.3 |DGGEN.S.A0002(Uptime) |DUT reboots and TH reads a UpTime
attribute value of DUT since some arbitrary start time of DUT rebooting.
|The data type must be UINT64 and the time duration should be
represented in seconds since DUT (node) has been rebooted. Low power and
sleep period should be included as well. The time should be reset to 0
upon the reboot, and this attribute should not be subscribed.

|5 |11.11.7.4 |DGGEN.S.A0003(TotalOperationalHours) |TH reads a
TotalOperationalHours attribute value from DUT. |The data type must be
UINT32 and the value indicates the number of hours the node has been
operational since DUT (node) has been rebooted. Low power and sleep
period should be included as well. The time should be reset to 0 upon
the reboot, and this attribute should not be subscribed.

|6 |11.11.7.5 |DGGEN.S.A0004(BootReason) |DUT undergoes a reboot
process. TH reads a attribute value from DUT. |The data type must match
the value listed in Table 105 BootReason ENUM table. For example, with
the normal reboot power cycle, PowerOnReboot indicates the value of 1.

|7 |11.11.7.6 |DGGEN.S.A0005(ActiveHardwareFaults) |TH reads
ActiveHardwareFaults attribute value from DUT. Subscription may be
possible for this attribute. |When operational, the attribute response
should be empty. But when a hardware fault occurs, the return attribute
value must match the value listed in the HardwareFault ENUM table
11.11.6.1. After the elimination of fault cause(s), the attribute value
should be empty. This value may be subscribed.

|8 |11.11.7.7 |DGGEN.S.A0006(ActiveRadioFaults) |TH reads
ActiveRadioFaults attribute value from DUT. Subscription is possible for
this attribute. |When operational, the attribute response should be
empty. But when a radio fault occurs, the return attribute value must
match the value listed in the RadioFault ENUM table. 11.11.6.2. After
the elimination of fault cause(s), the attribute value should be empty.
This value may be subscribed.

|9 |11.11.7.8 |DGGEN.S.A0007(ActiveNetworkFaults) |TH reads
ActiveNetworkFaults attribute value from DUT. Subscription is possible
for this attribute. |When operational, the attribute response should be
empty. But when a network fault occurs, the return attribute value must
match the value listed in the NetworkFault ENUM table 11.11.6.3. After
the elimination of fault cause(s), the attribute value should be empty.
This value may be subscribed.

|10 |11.11.7.9 |DGGEN.S.A0008(TestEventTriggersEnabled) |TH reads
TestEventTriggersEnabled attribute value. If this value is set True,
then a certain test mode will be performed (or triggered) according to
pre-provisioned client and server test mode. |Indicates that node is
configured for test event triggers. When configured TRUE, Node has been
configured with one or more test event triggers by virtue of the
internally programmed non zero EnableKey value.
|===

[[_notestesting_considerations_221]]
====== link:#_notestesting_considerations_221[]Notes/Testing Considerations

[[_tc_dggen_2_2_event_functionality_dut_as_server]]
===== link:#_tc_dggen_2_2_event_functionality_dut_as_server[]100.2.2. [TC-DGGEN-2.2] Event Functionality [DUT as Server]

[[_category_227]]
====== link:#_category_227[]Category

Functional

[[_pics_232]]
====== link:#_pics_232[]PICS

* DGGEN.S

[[_purpose_232]]
====== link:#_purpose_232[]Purpose

This test case verifies the event functionality of the general
diagnostics cluster server.

[[_required_devices_232]]
====== link:#_required_devices_232[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_189]]
====== link:#_device_topology_189[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_201]]
====== link:#_test_setup_201[]Test Setup

Commission DUT to TH

[[_test_procedure_232]]
====== link:#_test_procedure_232[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |11.11.9.1 |DGGEN.S.E00(HardwareFaultChange) |Induce a DUT hardware
failure two times as addressed in HardwareFault ENUM table 11.11.6.1.
(Ex. Pull the DUT power plug off causing power source failure, and
rejoin DUT back to previous TH fabric. Next, repeat power plug off and
rejoining DUT back to previous TH fabric one more time.) |TH receives
HardwareFaultChange event with current and previous data specified by
HardwareFault ENUM table 11.11.6.1. For the first failure, observe
HardwareFaultChange ID 0 value is appropriately changed. For the second
failure, observe HardwareFaultChange ID 0 and 1 values are changed
appropriately.

|3 |11.11.9.2 |DGGEN.S.E01(RadioFaultChange) |Induce a DUT radio failure
two times as addressed in RadioFault ENUM table 11.11.6.2. (Ex. Put the
DUT under metallic cover causing WiFi failure. Uncover DUT and make DUT
rejoining DUT back to previous TH fabric. Repeat the radio failure one
more time and rejoin DUT back to previous TH fabric. |TH receives
RadioFaultChange event with current and previous data specified by
RadioFault ENUM table 11.11.6.2 according to two repeated failures.

|4 |11.11.9.3 |DGGEN.S.E02(NetworkFaultChange) |Induce a DUT radio
failure two times as addressed in NetworkFault ENUM table 11.11.6.3.
(Ex. Put the DUT under metallic cover causing network failure. Uncover
DUT and rejoin DUT back to previous TH fabric. Pull the DUT power plug
off causing power source failure. rejoining DUT back to previous TH
fabric.) |TH receives NetworkFaultChange event with current and previous
data specified by NetworkFault ENUM table 11.11.2.3 according to two
failure causes.

|5 |11.11.9.4 |DGGEN.S.E03(BootReason) |Reboot DUT with a normal reboot
process. Rejoin DUT back to previous TH fabric. |TH read the event data
of BootReason specified by Table 103 BootReason ENUM table.
|===

[[_notestesting_considerations_222]]
====== link:#_notestesting_considerations_222[]Notes/Testing Considerations

[[_tc_dggen_2_3_command_received_dut_as_server]]
===== link:#_tc_dggen_2_3_command_received_dut_as_server[]100.2.3. [TC-DGGEN-2.3] Command Received [DUT as Server]

[[_category_228]]
====== link:#_category_228[]Category

Functional

[[_pics_233]]
====== link:#_pics_233[]PICS

* DGGEN.S

[[_purpose_233]]
====== link:#_purpose_233[]Purpose

This test case verifies the event functionality of the general
diagnostics cluster server.

[[_required_devices_233]]
====== link:#_required_devices_233[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as Client
|2 |DUT |DUT as Server
|===

[[_device_topology_190]]
====== link:#_device_topology_190[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_202]]
====== link:#_test_setup_202[]Test Setup

Commission DUT to TH

[[_test_procedure_233]]
====== link:#_test_procedure_233[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | | |TH reads TestEventTriggersEnabled attribute value a|
Verify that the value is of bool type

* If this value is set to True, then proceed with step 3, otherwise skip
step 3.

|3 |11.11.8.1 |DGGEN.S.C00.Rsp(TestEventTrigger) |Invoke the
TestEventTrigger command with EnableKey field set to
PIXIT.DGGEN.ENABLEKEY and EventTrigger field set to 0. a|
* Verify that DUT responds with INVALID_COMMAND.

|4 |11.11.8.1 |DGGEN.S.C00.Rsp(TestEventTrigger) |Invoke the
TestEventTrigger command with EnableKey field set to 16 bytes of all
zeroes and EventTrigger field set to 0. a|
* Verify that DUT responds with CONSTRAINT_ERROR.

|===

[[_notestesting_considerations_223]]
====== link:#_notestesting_considerations_223[]Notes/Testing Considerations

[[_general_commissioning_cluster_test_plan]]
== link:#_general_commissioning_cluster_test_plan[]**General Commissioning Cluster Test Plan**

[[_pics_definition_29]]
=== link:#_pics_definition_29[]101. PICS Definition

This section covers the General Commissioning Cluster Cluster related
PICS items that are referenced in the following test cases.

[[_role_31]]
==== link:#_role_31[]101.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CGEN.S |Does the device implement the General Commissioning Cluster
cluster as a server? |O |
|===

[[_server_31]]
==== link:#_server_31[]101.2. Server

[[_attributes_34]]
===== link:#_attributes_34[]101.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CGEN.S.A0000(Breadcrumb) |Does the device(Server) support Breadcrumb
attribute? |M |

|CGEN.S.A0001(BasicCommissioningInfo) |Does the device(Server) support
BasicCommissioningInfo attribute? |M |

|CGEN.S.A0002(RegulatoryConfig) |Does the device(Server) support
RegulatoryConfig attribute? |M |

|CGEN.S.A0003(LocationCapability) |Does the device(Server) support
LocationCapability attribute? |M |

|CGEN.S.A0004(SupportsConcurrentConnection) |Does the device(Server)
support SupportsConcurrentConnection attribute? |M |
|===

[[_commands_received_21]]
===== link:#_commands_received_21[]101.2.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CGEN.S.C00.Rsp(ArmFailSafe) |Does the Device(Server) implement
receiving the ArmFailSafe command? |M |

|CGEN.S.C02.Rsp(SetRegulatoryConfig) |Does the Device(Server) implement
receiving the SetRegulatoryConfig command? |M |

|CGEN.S.C04.Rsp(CommissioningComplete) |Does the Device(Server)
implement receiving the CommissioningComplete command? |M |
|===

[[_commands_generated_20]]
===== link:#_commands_generated_20[]101.2.3. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CGEN.S.C01.Tx(ArmFailSafeResponse) |Does the Device(Server)
invoking/generating the ArmFailSafeResponse command? |M |

|CGEN.S.C03.Tx(SetRegulatoryConfigResponse) |Does the Device(Server)
invoking/generating the SetRegulatoryConfigResponse command? |M |

|CGEN.S.C05.Tx(CommissioningCompleteResponse) |Does the Device(Server)
invoking/generating the CommissioningCompleteResponse command? |M |
|===

[[_pixit_definition_8]]
=== link:#_pixit_definition_8[]102. PIXIT Definition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.CGEN.FailsafeExpiryLengthSeconds |Timeout to use when sending
ArmFailSafe command |M |Timeout used on test steps that test the
failsafe timeout. Because this is used to test timeouts, it should be
tuned to avoid unnecessarily long delays. This needs to be sufficiently
long to perform 3 cluster interactions, but must be less than the DUT
MaxCumulativeFailsafeSeconds field in the BasicCommissioningInfo
attribute.
|===

[[_test_case_list_31]]
=== link:#_test_case_list_31[]103. Test Case List

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-CGEN-1.1 |Global Attributes [DUT-Server]

|2 |TC-CGEN-2.1 |Breadcrumb, BasicCommissioningInfo, RegulatoryConfig,
LocationCapability and SupportsConcurrentConnection attributes [DUT -
Server]

|3 |TC-CGEN-2.2 |ArmFailSafe command verification [DUT - Server]

|4 |TC-CGEN-2.4 |Verification For CommissioningError on response message
[DUT - Server]
|===

[[_test_cases_31]]
=== link:#_test_cases_31[]104. Test Cases

[[_generic_test_cases_27]]
==== link:#_generic_test_cases_27[]104.1. Generic test cases

[[_tc_cgen_1_1_global_attributes_dut_server]]
===== link:#_tc_cgen_1_1_global_attributes_dut_server[]104.1.1. [TC-CGEN-1.1] Global Attributes [DUT-Server]

[[_category_229]]
====== link:#_category_229[]Category

Functional conformance

[[_purpose_234]]
====== link:#_purpose_234[]Purpose

To verify the Global Attributes available in the General Commissioning
Cluster

[[_pics_234]]
====== link:#_pics_234[]PICS

* CGEN.S

[[_pre_conditions_11]]
====== link:#_pre_conditions_11[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_234]]
====== link:#_required_devices_234[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH1 |Client
|===

[[_device_topology_191]]
====== link:#_device_topology_191[]Device Topology

[[_test_setup_203]]
====== link:#_test_setup_203[]Test Setup

[[_test_procedure_234]]
====== link:#_test_procedure_234[]Test Procedure

[width="100%",cols="5%,5%,9%,41%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |7.13.1 | |TH reads the ClusterRevision from DUT a |* verify that the
ClusterRevision attribute is of uint16. * Verify that the DUT response
indicates that the ClusterRevision attribute has the value 1

|3 |7.13.2 | |TH reads the FeatureMap from DUT |Verify that the
FeatureMap attribute has the value 0.

|4 |7.13.3 | |TH reads AttributeList from DUT a |* Verify that the DUT
response provides a list of supported attributes * This list SHALL
include all mandatory attributes(values CGEN.S.A0000, CGEN.S.A0001,
CGEN.S.A0002 , CGEN.S.A0003, CGEN.S.A0004) * It SHALL include global
attributes (0xFFFD)ClusterRevision, (0xFFFC)FeatureMap,
(0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 |7.13.4 | |TH reads EventList from DUT |Verify that the DUT response
provides a list of supported events. For this cluster the list is empty
with 0 entries

|6 |7.13.3.1 | |TH reads AcceptedCommandList from DUT |Verify that the
DUT response provides a list of Accepted Command. This list SHALL
include all mandatory Commands(values CGEN.S.C00.Rsp, CGEN.S.C02.Rsp
CGEN.S.C04.Rsp)

|7 |7.13.3.2 | |TH reads GeneratedCommandList from DUT |Verify that the
DUT response provides a list of Generated Command. This list SHALL
include all mandatory attributes(values CGEN.S.C01.Tx, CGEN.S.C03.Tx,
CGEN.S.C05.Tx)
|===

[[_notestesting_considerations_224]]
====== link:#_notestesting_considerations_224[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

[[_dut_as_server_4]]
==== link:#_dut_as_server_4[]104.2. DUT as Server

[[_tc_cgen_2_1_breadcrumb_basiccommissioninginfo_regulatoryconfig_locationcapability_and_supportsconcurrentconnection_attributes_dut_server]]
===== link:#_tc_cgen_2_1_breadcrumb_basiccommissioninginfo_regulatoryconfig_locationcapability_and_supportsconcurrentconnection_attributes_dut_server[]104.2.1. [TC-CGEN-2.1] Breadcrumb, BasicCommissioningInfo, RegulatoryConfig, LocationCapability and SupportsConcurrentConnection attributes [DUT - Server]

[[_category_230]]
====== link:#_category_230[]Category

Functional conformance

[[_purpose_235]]
====== link:#_purpose_235[]Purpose

* Verify for the following checks:
+
. DUT’s Breadcrumb default value is 0
. TH1 writes Breadcrumb value as 1 and read from DUT to have Breadcrumb
value as 1
. RegulatoryConfig and LocationCapability value is in the inclusive
range of 0 ..2
. BasicCommissioningInfo attribute value type
. SupportsConcurrentConnection Attribute value checks for connection
flow

[[_pics_235]]
====== link:#_pics_235[]PICS

* CGEN.S

[[_pre_conditions_12]]
====== link:#_pre_conditions_12[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |TH1 is commissioned with DUT |
|===

[[_required_devices_235]]
====== link:#_required_devices_235[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH1 |Client
|===

[[_device_topology_192]]
====== link:#_device_topology_192[]Device Topology

[[_test_setup_204]]
====== link:#_test_setup_204[]Test Setup

. TH1 and DUT are on the same fabric

[[_test_procedure_235]]
====== link:#_test_procedure_235[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.9.6.1 |CGEN.S.A0000(Breadcrumb) |TH1 reads the BreadCrumb
Attribute from the DUT |Verify the BreadCrumb value is of type uint64

|2 |11.9.6.1 |CGEN.S.A0000(Breadcrumb) |TH1 writes the BreadCrumb
attribute as '1' to the DUT |

|3 |11.9.6.1 |CGEN.S.A0000(Breadcrumb) |TH1 reads the BreadCrumb
attribute from the DUT |Verify the BreadCrumb value is '1' in the DUT

|4 |11.9.6.3 |CGEN.S.A0002(RegulatoryConfig) |TH1 reads the
RegulatoryConfig attribute from the DUT |Verify that the
RegulatoryConfig attribute value is any one of the values: 0,1 or 2.
0:Indoor only 1:Outdoor only 2:IndoorOutdoor

|5 |11.9.6.4 |CGEN.S.A0003(LocationCapability) |TH1 reads the
LocationCapability attribute from the DUT a|
* Verify that the LocationCapability attribute is any one of the values:
0,1 or 2.
+
. 0:Indoor only
. 1:Outdoor only
. 2:IndoorOutdoor

|6 |11.9.6.2 |CGEN.S.A0001(BasicCommissioningInfo) |TH1 reads
BasicCommissioningInfo attribute from DUT a|
* Verify that the BasicCommissioningInfo attribute has the following
field:
+
. FailSafeExpiryLengthSeconds field value is within a duration range of
0 to 65535

|7 |11.9.6.5 |CGEN.S.A0004(SupportsConcurrentConnection) |TH1 reads
SupportsConcurrentConnection attribute from the DUT |Verify that
SupportsConcurrentConnection value is 'Bool' in the DUT
|===

[[_tc_cgen_2_2_armfailsafe_command_verification_dut_server]]
===== link:#_tc_cgen_2_2_armfailsafe_command_verification_dut_server[]104.2.2. [TC-CGEN-2.2] ArmFailSafe command verification [DUT - Server]

[[_category_231]]
====== link:#_category_231[]Category

Functional conformance

[[_purpose_236]]
====== link:#_purpose_236[]Purpose

. Verify that the failsafe expires without external intervention at
PIXIT.CGEN.FailsafeExpiryLengthSeconds
. Verify that sending an ArmFailSafe command with the
ExpiryLengthSeconds field set to 0 causes an immediate expiry of the
failsafe
. Verify that disarming the failsafe resets the breadcrumb
. Verify that the failsafe cannot be armed over a CASE session while the
commissioning window is open
. Verify that successfully establishing a PASE session causes the
failsafe to arm
. Verify that a successful CommissioningComplete command call persists
the failsafe context
. Verify that a successful CommissioningComplete command disarms the
failsafe
. Verify that a second admin cannot arm a failsafe while it is already
held
. Verify that sending a second ArmFailSafe command resets the timer

[[_pics_236]]
====== link:#_pics_236[]PICS

* CGEN.S

[[_pre_conditions_13]]
====== link:#_pre_conditions_13[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Commission TH and DUT |
|===

[[_required_devices_236]]
====== link:#_required_devices_236[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH1 |Client
|3 |TH2 |Client
|===

[[_device_topology_193]]
====== link:#_device_topology_193[]Device Topology

[[_test_setup_205]]
====== link:#_test_setup_205[]Test Setup

. TH1 and DUT are on the same fabric

[[_test_procedure_236]]
====== link:#_test_procedure_236[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster and saves the number of list
items as `numTrustedRootsOriginal` |

|2 |11.9.5.2 |CGEN.S.A0001(BasicCommissioningInfo) |TH1 reads the
BasicCommissioningInfo attribute and saves the
MaxCumulativeFailsafeSeconds as `maxFailsafe` |

|[#arm-failsafe-disarm-part1-start]####3 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to PIXIT.CGEN.FailsafeExpiryLengthSeconds and the Breadcrumb value
as 1 |Verify that the DUT responds with ArmFailSafeResponse with
ErrorCode as 'OK'(0) and DebugText argument is of type string with max
length 512 or empty

|4 |11.9.6.1 a|
CGEN.S.A0000(Breadcrumb)

|TH1 reads the Breadcrumb attribute |Verify that the breadcrumb
attribute is 1

|[#arm-failsafe-disarm-part1-end]####5 |11.17.7.13 | |TH1 obtains or
generates a new TrustedRootCertificate that is different from the
previously commissioned TrustedRootCertificate for TH1. TH1 sends an
AddTrustedRootCertificate command to the Node Operational Credentials
cluster to install this new certificate |Verify that the DUT responds
with SUCCESS

|6 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the number of
items in the returned list is `numTrustedRootsOriginal` + 1

|7 |11.9.7.2 | |TH1 waits for PIXIT.CGEN.FailsafeExpiryLengthSeconds to
ensure the failsafe timer has expired |

|[#arm-failsafe-disarm-part2-start]####8 |11.17.6.5 | |TH1 reads the
TrustedRootCertificates attribute from the Node Operational Credentials
cluster |Verify that the number of items in the returned list is
`numTrustedRootsOriginal`

|[#arm-failsafe-disarm-part2-end]####9 a|
* 11.9.7.2
* 11.9.6.1

a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.A0000(Breadcrumb)

|TH1 reads the Breadcrumb attribute |Verify that the breadcrumb
attribute is 0

|10 | | |TH1 repeats steps link:#arm-failsafe-disarm-part1-start[3]
through link:#arm-failsafe-disarm-part1-end[5] |

|11 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to 0 |Verify that the DUT responds with ArmFailSafeResponse with
ErrorCode as 'OK'(0) and DebugText argument is of type string with max
length 512 or empty

|12 | | |Repeat steps link:#arm-failsafe-disarm-part2-start[8] through
link:#arm-failsafe-disarm-part2-end[9] |

|13 |11.18.8.1 | |TH1 sends the OpenCommissioningWindow command to the
Administrator Commissioning cluster |Verify that the DUT returns a
status code of SUCCESS

|14 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to PIXIT.CGEN.FailsafeExpiryLengthSeconds |Verify that the DUT
responds with ArmFailSafeResponse with ErrorCode as BusyWithOtherAdmin

|15 | | |TH2 opens a PASE session with the DUT |Verify that TH2
successfully opens a PASE session

|16 |11.17.7.13 | |TH2 obtains or generates a TrustedRootCertificate
that is different from the previously commissioned
TrustedRootCertificate for TH1. TH2 sends an AddTrustedRootCertificate
command to the Node Operational Credentials cluster to install this new
certificate |Verify that the DUT responds with SUCCESS

|17 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH2 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to 0 |Verify that the DUT responds with ArmFailSafeResponse with
ErrorCode as 'OK'(0) and DebugText argument is of type string with max
length 512 or empty

|18 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a non-fabric-filtered read and saves the
returned list as `nocs` |

|19 |11.17.6.2 | |TH1 reads the Fabrics attribute from the Node
Operational Credentials cluster using a non-fabric-filtered read and
saves the returned list as `fabrics` |

|20 |11.17.6.2 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster and saves the returned list as
`trustedroots` |

|21 |5.5 | |TH2 starts commissioning the DUT. It performs all steps up
to establishing a CASE connection, but DOES NOT send the
CommissioningComplete command |

|22 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH2 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to 0 |Verify that the DUT responds with ArmFailSafeResponse with
ErrorCode as 'OK'(0) and DebugText argument is of type string with max
length 512 or empty

|23 |11.17.6.1 | |TH1 reads the NOCs attribute from the Node Operational
Credentials cluster using a non-fabric-filtered read |Verify that the
returned list matches `nocs`

|24 |11.17.6.2 | |TH1 reads the Fabrics attribute from the Node
Operational Credentials cluster using a non-fabric-filtered read |Verify
that the returned list matches `fabrics`

|25 |11.17.6.2 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the returned list
matches `trustedroots`

|26 |5.5 | |TH2 fully commissions the DUT |Verify that the commissioning
completes successfully

|27 |11.17.7.13 | |TH2 obtains or generates a new TrustedRootCertificate
that is different from the previously commissioned
TrustedRootCertificate for TH2. TH2 sends an AddTrustedRootCertificate
command to the Node Operational Credentials cluster to install this new
certificate |Verify that the DUT responds with FAILSAFE_REQUIRED

|28 |11.17.6.2 | |TH1 reads the Fabrics attribute from the Node
Operational Credentials cluster using a non-fabric-filtered read |Verify
that the returned list includes an additional entry for TH2 when
compared to `fabrics`

|29 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to PIXIT.CGEN.FailsafeExpiryLengthSeconds and the Breadcrumb value
as 1 |Verify that the DUT responds with ArmFailSafeResponse with
ErrorCode as 'OK'(0) and DebugText argument is of type string with max
length 512 or empty

|30 |11.17.7.13 | |TH1 obtains or generates a new TrustedRootCertificate
that is different from the previously commissioned
TrustedRootCertificate for TH1. TH1 sends an AddTrustedRootCertificate
command to the Node Operational Credentials cluster to install this new
certificate |Verify that the DUT responds with SUCCESS

|31 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the number of
items in the returned list is `numTrustedRootsOriginal` + 1

|32 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH1 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to `maxFailsafe` |Verify that the DUT responds with
ArmFailSafeResponse with ErrorCode as 'OK'(0) and DebugText argument is
of type string with max length 512 or empty

|33 |11.9.7.2 | |TH1 waits for PIXIT.CGEN.FailsafeExpiryLengthSeconds |

|34 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the number of
items in the returned list is still `numTrustedRootsOriginal` + 1

|35 |11.9.7.2 a|
* CGEN.S.C00.Rsp(ArmFailSafe)
* CGEN.S.C01.Tx(ArmFailSafeResponse)

|TH2 sends ArmFailSafe command to the DUT with ExpiryLengthSeconds field
set to PIXIT.CGEN.FailsafeExpiryLengthSeconds and the Breadcrumb value
as 1 |Verify that the DUT responds with ArmFailSafeResponse with
ErrorCode as BusyWithOtherAdmin

|36 |11.9.7.2 |CGEN.S.C00.Rsp(ArmFailSafe) |TH1 sends ArmFailSafe
command to the DUT with ExpiryLengthSeconds field set to 0 |

|37 |11.9.7.2 |CGEN.S.C00.Rsp(ArmFailSafe) |TH1 sends ArmFailSafe
command to the DUT with ExpiryLengthSeconds field set to `maxFailsafe`
|Verify that the DUT responds with ArmFailSafeResponse with ErrorCode as
'OK'(0) and DebugText argument is of type string with max length 512 or
empty

|38 | | |TH1 saves the current wall time clock in seconds as `Tstart` |

|39 |11.17.7.13 | |TH1 obtains or generates a new TrustedRootCertificate
that is different from the previously commissioned
TrustedRootCertificate for TH1. TH1 sends an AddTrustedRootCertificate
command to the Node Operational Credentials cluster to install this new
certificate |Verify that the DUT responds with SUCCESS

|40 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the number of
items in the returned list is `numTrustedRootsOriginal` + 1

|41 | | |TH1 waits until the current wall time clock is `Tstart` +
`maxFailsafe`/2 |

|[#re-arm]####42 |11.9.7.2 |CGEN.S.C00.Rsp(ArmFailSafe) |TH1 sends
ArmFailSafe command to the DUT with ExpiryLengthSeconds field set to
`maxFailsafe` |Verify that the DUT responds with ArmFailSafeResponse
with ErrorCode as 'OK'(0) and DebugText argument is of type string with
max length 512 or empty

|43 | | |TH1 waits until the current wall time clock is `Tstart` +
`maxFailsafe`. `maxFailsafe` is the maximum amount of time a failsafe
can be armed for, so the failsafe is required to time out at this point,
despite having been re-armed in step link:#re-arm[42]. |

|44 |11.17.6.5 | |TH1 reads the TrustedRootCertificates attribute from
the Node Operational Credentials cluster |Verify that the number of
items in the returned list is `numTrustedRootsOriginal`
|===

[[_tc_cgen_2_4_verification_for_commissioningerror_on_response_message_dut_server]]
===== link:#_tc_cgen_2_4_verification_for_commissioningerror_on_response_message_dut_server[]104.2.3. [TC-CGEN-2.4] Verification For CommissioningError on response message [DUT - Server]

[[_category_232]]
====== link:#_category_232[]Category

Functional conformance

[[_purpose_237]]
====== link:#_purpose_237[]Purpose

Verify that ErrorCode field values are executed by DUT in response
commands when TH1 sends commands with different error scenario

[[_pics_237]]
====== link:#_pics_237[]PICS

* CGEN.S

[[_pre_conditions_14]]
====== link:#_pre_conditions_14[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_237]]
====== link:#_required_devices_237[]Required Devices

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH1 |Client
|3 |TH2 |Client
|===

[[_device_topology_194]]
====== link:#_device_topology_194[]Device Topology

[[_test_setup_206]]
====== link:#_test_setup_206[]Test Setup

. DUT is commissioned onto TH1 fabric

[[_test_procedure_237]]
====== link:#_test_procedure_237[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|[#cgen_2.6_open]####1 |11.18.8.1 | |TH1 opens a commissioning window on
the DUT by sending an OpenCommissioningWindow command to the
Administrator Commissioning Cluster on EP0 over CASE. TH1 saves the
generated QR or manual setup code for commissioning as
`WindowSetupPayload` |Verify that the DUT responds with SUCCESS

|[#cgen_2.6_commission]## 2 |5.5 | |TH2 begins commissioning the DUT
using `WindowSetupPayload`, but stops after sending the first arm
failsafe command |

|[#cgen_2.6_complete]####3 |11.9.7.6
|CGEN.S.C04.Rsp(CommissioningComplete) |TH2 sends a
CommissioningComplete command to the GeneralCommissioning cluster on EP0
of the DUT over the PASE connection opened in step
link:#cgen_2.6_commission[2] |Verify that the DUT responds with
UNSUPPORTED_ACCESS

|[#cgen_2.6_revoke]####4 |11.18.8.3 | |TH1 revokes the commissioning
window by sending a RevokeCommissioning command to the Administrator
Commissioning Cluster on EP0 over CASE |Verify that the DUT responds
with SUCCESS

|5 | | |Repeat steps link:#cgen_2.6_open[1] through
link:#cgen_2.6_revoke[4], stopping after configuring the regulatory
config in step link:#cgen_2.6_commission[2] |

|6 | | |Repeat steps link:#cgen_2.6_open[1] through
link:#cgen_2.6_revoke[4], stopping after sending the PAI certificate
request in step link:#cgen_2.6_commission[2] |

|7 | | |Repeat steps link:#cgen_2.6_open[1] through
link:#cgen_2.6_revoke[4], stopping after sending the DAC certificate
request in step link:#cgen_2.6_commission[2] |

|8 | | |Repeat steps link:#cgen_2.6_open[1] through
link:#cgen_2.6_revoke[4], stopping after sending the attestation request
in step link:#cgen_2.6_commission[2] |

|9 | | |Repeat steps link:#cgen_2.6_open[1] through
link:#cgen_2.6_revoke[4], stopping after sending the operational
certificate signing request in step link:#cgen_2.6_commission[2] |

|10 | | |Repeat steps link:#cgen_2.6_open[1] through
link:#cgen_2.6_revoke[4], stopping after sending the trusted root
certificate in step link:#cgen_2.6_commission[2] |

|11 |11.18.8.1 | |TH1 opens a commissioning window on the DUT by sending
an OpenCommissioningWindow command to the Administrator Commissioning
Cluster on EP0 over CASE. TH1 saves the generated QR or manual setup
code for commissioning as `WindowSetupPayload` |Verify that the DUT
responds with SUCCESS

|[#cgen_2.6_commission2]####12 |5.5 | |TH2 begins commissioning the DUT
using `WindowSetupPayload`, but stops after sending the AddNOC command |

|13 |11.9.7.6 |CGEN.S.C04.Rsp(CommissioningComplete) |TH2 sends a
CommissioningComplete command to the GeneralCommissioning cluster on EP0
of the DUT over the PASE connection opened in step
link:#cgen_2.6_commission2[12] |Verify that the DUT responds the cluster
specific error InvalidAuthentication (2)

|14 |11.18.8.3 | |TH1 revokes the commissioning window by sending a
RevokeCommissioning command to the Administrator Commissioning Cluster
on EP0 over CASE |Verify that the DUT responds with SUCCESS

|15 |11.18.8.1 | |TH1 opens a commissioning window on the DUT by sending
an OpenCommissioningWindow command to the Administrator Commissioning
Cluster on EP0 over CASE. TH1 saves the setup information as
`WindowSetupPayload` |Verify that the DUT responds with SUCCESS

|16 |5.5 | |TH2 fully commissions the DUT using `WindowSetupPayload`
|Verify SUCCESS

|17 |11.9.7.2 | |TH1 sends an ArmFailSafe command to the General
Commissioning cluster over CASE with the ExpiryLengthSeconds field set
to 900 |Verify that the DUT returns SUCCESS

|18 |11.9.6.4 | |TH1 reads the LocationCapability Attribute from the
General Commissioning cluster over CASE and saves it as `locationCap`
|Verify the read is successful

|19 |11.9.7.5 a|
* CGEN.S.C02.Rsp(SetRegulatoryConfig)
* CGEN.S.C03.Tx(SetRegulatoryConfigResponse)

a|
....
TH1 sends SetRegulatoryConfig command to the DUT over CASE with the fields set as follows:
....

* CountryCode: "XX"
* Breadcrumb: 0
* NewRegulatoryConfig: if `locationCap` is Indoor, set to Outdoor if
`locationCap` is Outdoor, set to Indoor if `locationCap` is
IndoorOutdoor, set to 3 (invalid enum)

|Verify that the DUT sends SetRegulatoryConfigResponse command to TH1
with field ErrorCode as 'ValueOutsideRange'(1) and DebugText argument is
of type string with max length 512 or an empty or absent string value

|20 |11.9.7.5 |CGEN.S.C04.Rsp(CommissioningComplete) |TH2 Sends the
CommissioningComplete command to the DUT over a CASE connection |Verify
that the DUT responds with the cluster-specific error
InvalidAuthentication (2)

|21 |11.9.7.2 | |TH1 sends an ArmFailSafe command to the General
Commissioning cluster over CASE with the ExpiryLengthSeconds field set
to 0 |Verify that the DUT returns SUCCESS

|22 |11.9.7.5 |CGEN.S.C04.Rsp(CommissioningComplete) |TH1 Sends the
CommissioningComplete command to the DUT over CASE |Verify that DUT
sends CommissioningCompleteResponse Command to TH1 With ErrorCode as
'NoFailSafe'(3) and DebugText as a 'string' value

|23 |11.17.6.6. | |TH2 reads its fabric index from the Operational
Credentials cluster CurrentFabricIndex attribute over CASE |Read
successful, save as `th2FabricIndex`

|24 |11.17.7.12 | |TH1 sends a RemoveFabric command to the Node
Operational Credentials cluster over CASE with FabricIndex set to
`th2FabricIndex` |Verify SUCCESS
|===

[[_notestesting_considerations_225]]
====== link:#_notestesting_considerations_225[]Notes/Testing Considerations

[[_user_label_cluster_test_plan]]
== link:#_user_label_cluster_test_plan[]**User Label Cluster Test Plan**

[[_pics_definition_30]]
=== link:#_pics_definition_30[]105. PICS Definition

This section covers the User Label Cluster related PICS items that are
referenced in the following test cases.

[[_role_32]]
==== link:#_role_32[]105.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ULABEL.S |Does the device implement the User Label cluster as a server?
|O |
|===

[[_server_32]]
==== link:#_server_32[]105.2. Server

[[_attributes_35]]
===== link:#_attributes_35[]105.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ULABEL.S.A0000(LabelList) |Does the DUT(Server) support LabelList
attribute? |M |
|===

[[_test_case_list_32]]
=== link:#_test_case_list_32[]106. Test Case List

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-ULABEL-1.1 |Global Attributes with DUT as Server

|2 |TC-ULABEL-2.1 |User label cluster read verification [DUT-server]

|3 |TC-ULABEL-2.2 |User Label cluster write verification [DUT-server]

|4 |TC-ULABEL-2.3 |User Label cluster constraint_error verification
[DUT-server]

|5 |TC-ULABEL-2.4 |User Label cluster empty entry verification
[DUT-server]
|===

[[_test_cases_32]]
=== link:#_test_cases_32[]107. Test Cases

[[_generic_test_cases_28]]
==== link:#_generic_test_cases_28[]107.1. Generic test cases

[[_tc_ulabel_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_ulabel_1_1_global_attributes_with_dut_as_server[]107.1.1. [TC-ULABEL-1.1] Global Attributes with DUT as Server

[[_category_233]]
====== link:#_category_233[]Category

Functional conformance.

[[_purpose_238]]
====== link:#_purpose_238[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_238]]
====== link:#_pics_238[]PICS

* ULABEL.S

[[_required_devices_238]]
====== link:#_required_devices_238[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_238]]
====== link:#_test_procedure_238[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_226]]
====== link:#_notestesting_considerations_226[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_dut_as_server_5]]
==== link:#_dut_as_server_5[]107.2. DUT as Server

[[_tc_ulabel_2_1_user_label_cluster_read_verification_dut_server]]
===== link:#_tc_ulabel_2_1_user_label_cluster_read_verification_dut_server[]107.2.1. [TC-ULABEL-2.1] User label cluster read verification [DUT-server]

[[_category_234]]
====== link:#_category_234[]Category

Functional conformance

[[_purpose_239]]
====== link:#_purpose_239[]Purpose

Verify that userlabel cluster with LabelList attribute has at least 4
entries per node.

[[_pics_239]]
====== link:#_pics_239[]PICS

* ULABEL.S

[[_pre_conditions_15]]
====== link:#_pre_conditions_15[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |TH is commissioned with DUT |
|===

[[_required_devices_239]]
====== link:#_required_devices_239[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_195]]
====== link:#_device_topology_195[]Device Topology

[[_test_setup_207]]
====== link:#_test_setup_207[]Test Setup

. TH and DUT are on the same Fabric

[[_test_procedure_239]]
====== link:#_test_procedure_239[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |9.9.4 |ULABEL.S.A0000(LabelList) |TH reads LabelList from the DUT a|
* Verify that the LabelList is empty or has one or more entries
* Each tuple has following fields:
+
. Label field is of type string and have a length up to 16 bytes
. Value field is of type string and have a length up to 16 bytes

|===

[[_tc_ulabel_2_2_user_label_cluster_write_verification_dut_server]]
===== link:#_tc_ulabel_2_2_user_label_cluster_write_verification_dut_server[]107.2.2. [TC-ULABEL-2.2] User Label cluster write verification [DUT-server]

[[_category_235]]
====== link:#_category_235[]Category

Functional conformance

[[_purpose_240]]
====== link:#_purpose_240[]Purpose

Verify that TH can write the userlabel cluster with LabelList attribute.

[[_pics_240]]
====== link:#_pics_240[]PICS

* ULABEL.S

[[_pre_conditions_16]]
====== link:#_pre_conditions_16[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |TH is commissioned with DUT |
|===

[[_required_devices_240]]
====== link:#_required_devices_240[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_196]]
====== link:#_device_topology_196[]Device Topology

[[_test_setup_208]]
====== link:#_test_setup_208[]Test Setup

. TH and DUT are on the same Fabric

[[_test_procedure_240]]
====== link:#_test_procedure_240[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |9.7.4 |ULABEL.S.A0000(LabelList) |TH writes LabelList attribute on
the DUT with following entry: "roomName":"master bedroom
1","orientation":"east", "floor":"2", "roomType":"bedroom" a|
* Verify that DUT responds with status code as 'success'

|2 |9.9.4 |ULABEL.S.A0000(LabelList) |TH reads LabelList attribute of
the DUT |Verify the DUT responds with following same 4 entries as
written in previous steps
|===

[[_tc_ulabel_2_3_user_label_cluster_constraint_error_verification_dut_server]]
===== link:#_tc_ulabel_2_3_user_label_cluster_constraint_error_verification_dut_server[]107.2.3. [TC-ULABEL-2.3] User Label cluster constraint_error verification [DUT-server]

[[_category_236]]
====== link:#_category_236[]Category

Functional conformance

[[_purpose_241]]
====== link:#_purpose_241[]Purpose

Verify that TH can’t write the userlabel cluster with LabelList
attribute of constraint more the 16 bytes and receive a status code from
the DUT.

[[_pics_241]]
====== link:#_pics_241[]PICS

* ULABEL.S

[[_pre_conditions_17]]
====== link:#_pre_conditions_17[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |TH is commissioned with DUT |
|===

[[_required_devices_241]]
====== link:#_required_devices_241[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_197]]
====== link:#_device_topology_197[]Device Topology

[[_test_setup_209]]
====== link:#_test_setup_209[]Test Setup

. TH and DUT are on the same Fabric

[[_test_procedure_241]]
====== link:#_test_procedure_241[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |9.7.4 |ULABEL.S.A0000(LabelList) |TH writes LabelList attribute of
the DUT by setting "room":"17_bytesIsTooLong" |DUT sends status code as
CONSTRAINT_ERROR

|2 |9.7.4 |ULABEL.S.A0000(LabelList) |TH writes LabelList attribute of
the DUT by setting "17_bytesIsTooLong":"foobar" |DUT sends status code
as CONSTRAINT_ERROR
|===

[[_tc_ulabel_2_4_user_label_cluster_empty_entry_verification_dut_server]]
===== link:#_tc_ulabel_2_4_user_label_cluster_empty_entry_verification_dut_server[]107.2.4. [TC-ULABEL-2.4] User Label cluster empty entry verification [DUT-server]

[[_category_237]]
====== link:#_category_237[]Category

Functional conformance

[[_purpose_242]]
====== link:#_purpose_242[]Purpose

Verify that TH can write the userlabel cluster with LabelList attribute
of constraint with empty entry.

[[_pics_242]]
====== link:#_pics_242[]PICS

* ULABEL.S

[[_pre_conditions_18]]
====== link:#_pre_conditions_18[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |TH is commissioned with DUT |
|===

[[_required_devices_242]]
====== link:#_required_devices_242[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_198]]
====== link:#_device_topology_198[]Device Topology

[[_test_setup_210]]
====== link:#_test_setup_210[]Test Setup

. TH and DUT are on the same Fabric

[[_test_procedure_242]]
====== link:#_test_procedure_242[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |9.7.4 |ULABEL.S.A0000(LabelList) |TH writes LabelList attribute of
the DUT with entry as following: "room":"bedroom 1","orientation":"east"
" a|
* Verify that DUT responds with status code as 'success'

|2 |9.9.4 |ULABEL.S.A0000(LabelList) |TH reads LabelList attribute of
the DUT |Verify the DUT responds with same tuples as provided

|3 |9.7.4 |ULABEL.S.A0000(LabelList) |TH writes LabelList attribute of
the DUT with an entry as empty values in the list a|
* Verify that DUT responds with status code as 'success'

|4 |9.9.4 |ULABEL.S.A0000(LabelList) |TH reads LabelList attribute of
the DUT |Verify the DUT responds with an entry as empty values in the
list
|===

[[_fixed_label_cluster_test_plan]]
== link:#_fixed_label_cluster_test_plan[]**Fixed Label Cluster Test Plan**

[[_pics_definition_31]]
=== link:#_pics_definition_31[]108. PICS Definition

This section covers the Fixed Label Cluster related PICS items that are
referenced in the following test cases.

[[_role_33]]
==== link:#_role_33[]108.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLABEL.S |Does the device implement the Fixed Label cluster as a
server? |O |
|===

[[_server_33]]
==== link:#_server_33[]108.2. Server

[[_attributes_36]]
===== link:#_attributes_36[]108.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLABEL.S.A0000(LabelList) |Does the DUT(Server) support LabelList
attribute? |M |
|===

[[_test_case_list_33]]
=== link:#_test_case_list_33[]109. Test Case List

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-FLABEL-1.1 |Global Attributes with DUT as Server
|2 |TC-FLABEL-2.1 |Fixed Label cluster [DUT-server]
|===

[[_test_cases_33]]
=== link:#_test_cases_33[]110. Test Cases

[[_generic_test_cases_29]]
==== link:#_generic_test_cases_29[]110.1. Generic test cases

[[_tc_flabel_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_flabel_1_1_global_attributes_with_dut_as_server[]110.1.1. [TC-FLABEL-1.1] Global Attributes with DUT as Server

[[_category_238]]
====== link:#_category_238[]Category

Functional conformance.

[[_purpose_243]]
====== link:#_purpose_243[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_243]]
====== link:#_pics_243[]PICS

* FLABEL.S

[[_required_devices_243]]
====== link:#_required_devices_243[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_243]]
====== link:#_test_procedure_243[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_227]]
====== link:#_notestesting_considerations_227[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_dut_server]]
==== link:#_dut_server[]110.2. DUT-server

[[_tc_flabel_2_1_fixed_label_cluster_dut_server]]
===== link:#_tc_flabel_2_1_fixed_label_cluster_dut_server[]110.2.1. [TC-FLABEL-2.1] Fixed Label cluster [DUT-server]

[[_category_239]]
====== link:#_category_239[]Category

Functional conformance

[[_purpose_244]]
====== link:#_purpose_244[]Purpose

verify that TH can read-only the Fixed Label cluster with LabelList
attribute.

[[_pics_244]]
====== link:#_pics_244[]PICS

* FLABEL.S

[[_pre_conditions_19]]
====== link:#_pre_conditions_19[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |5.5 |TH is commissioned with DUT |
|===

[[_required_devices_244]]
====== link:#_required_devices_244[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_199]]
====== link:#_device_topology_199[]Device Topology

[[_test_setup_211]]
====== link:#_test_setup_211[]Test Setup

. TH and DUT are on the same Fabric

[[_test_procedure_244]]
====== link:#_test_procedure_244[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |9.8.4 |FLABEL.S.A0000(LabelList) |TH reads LabelList from the DUT a|
* Verify that DUT responds with the LabelList as empty or each tuple has
following fields:
+
. Label field is of type string and have a length up to 16 bytes
. Value field is of type string and have a length up to 16 bytes

|2 |9.7.4 |FLABEL.S.A0000(LabelList) |TH tries to write LabelList
attribute of the DUT by setting Label = "Test_Label", Value=
"Test_Value" |Verify DUT is sending status code UNSUPPORTED_WRITE

|3 |9.8.4 |FLABEL.S.A0000(LabelList) |TH reads LabelList from the DUT a|
Verify that the LabelList value is same as value from step 1

|===

[[_localization_configuration_cluster_test_plan]]
== link:#_localization_configuration_cluster_test_plan[]**Localization Configuration Cluster Test Plan**

[[_pics_definition_32]]
=== link:#_pics_definition_32[]111. PICS Definition

This section covers the Localization Configuration Cluster related PICS
items that are referenced in the following test cases.

[[_role_34]]
==== link:#_role_34[]111.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LCFG.S |Does the device implement the Localization Configuration
cluster as a server? |O |
|===

[[_server_34]]
==== link:#_server_34[]111.2. Server

[[_attributes_37]]
===== link:#_attributes_37[]111.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LCFG.S.A0000(ActiveLocale) |Does the DUT(server) support the
ActiveLocale attribute? |M |

|LCFG.S.A0001(SupportedLocales) |Does the DUT(server) support the
SupportedLocales attribute? |M |
|===

[[_test_case_list_34]]
=== link:#_test_case_list_34[]112. Test Case List

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-LCFG-1.1 |Global Attributes [DUT-Server]

|2 |TC-LCFG-2.1 |Localization Configuration Cluster
Attributes[DUT-Server]
|===

[[_test_cases_34]]
=== link:#_test_cases_34[]113. Test Cases

'''''

[[_generic_test_case]]
==== link:#_generic_test_case[]113.1. Generic test case

'''''

[[_tc_lcfg_1_1_global_attributes_dut_server]]
===== link:#_tc_lcfg_1_1_global_attributes_dut_server[]113.1.1. [TC-LCFG-1.1] Global Attributes [DUT-Server]

[[_category_240]]
====== link:#_category_240[]Category

Functional conformance

[[_purpose_245]]
====== link:#_purpose_245[]Purpose

To verify the Global Attributes available in Localization Configuration
Cluster

[[_pics_245]]
====== link:#_pics_245[]PICS

* LCFG.S

[[_pre_conditions_20]]
====== link:#_pre_conditions_20[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_245]]
====== link:#_required_devices_245[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_200]]
====== link:#_device_topology_200[]Device Topology

[[_test_setup_212]]
====== link:#_test_setup_212[]Test Setup

[[_test_procedure_245]]
====== link:#_test_procedure_245[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission TH to DUT |

|2 | | |TH reads from the DUT the (0xFFFD) _ClusterRevision attribute_
|Verify that the DUT response contains a minimal revision of 1.

|3 | | |TH reads from the DUT the (0xFFFC) _FeatureMap attribute_ a|
Verify that the DUT response contains the following bitmap32 w/:

- all bits should be cleared.

|4 | | |TH reads from the DUT the (0xFFFB) _AttributeList attribute_ a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support:

- (0x0000) ActiveLocale (mandatory)

- (0x0001) SupportedLocales (mandatory)

- It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 | | |TH reads from the DUT the (0xFFFA) _EventList attribute_ |Verify
that the DUT response contains a list of supported events empty for this
cluster.

|6 | | |TH reads from the DUT the (0xFFF9) _AcceptedCommandList
attribute_ |Verify that the DUT response contains a list of Accepted
commands (C2S) empty for this cluster.

|7 | | |TH reads from the DUT the (0xFFF8) _GeneratedCommandList
attribute_ |Verify that the DUT response contains a list of Generated
commands (S2C) empty for this cluster.
|===

[[_notestesting_considerations_228]]
====== link:#_notestesting_considerations_228[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_server_as_dut_21]]
==== link:#_server_as_dut_21[]113.2. Server as DUT

'''''

[[_tc_lcfg_2_1_localization_configuration_cluster_attributesdut_server]]
===== link:#_tc_lcfg_2_1_localization_configuration_cluster_attributesdut_server[]113.2.1. [TC-LCFG-2.1] Localization Configuration Cluster Attributes[DUT-Server]

[[_category_241]]
====== link:#_category_241[]Category

Functional conformance

[[_purpose_246]]
====== link:#_purpose_246[]Purpose

This test case verifies the attribute provided by the Localization
Configuration Cluster.

[[_pics_246]]
====== link:#_pics_246[]PICS

* LCFG.S

[[_pre_conditions_21]]
====== link:#_pre_conditions_21[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with DUT |
|===

[[_required_devices_246]]
====== link:#_required_devices_246[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_201]]
====== link:#_device_topology_201[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_213]]
====== link:#_test_setup_213[]Test Setup

Commission DUT to TH.

[[_test_procedure_246]]
====== link:#_test_procedure_246[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.3.4.1 |LCFG.S.A0001(SupportedLocales) |TH reads SupportedLocales
attribute from DUT a|
* Verify that the values in the SupportedLocales attribute are not
repeated
* Verify that the maximum number of elements in the SupportedLocales
list is 32
* Verify that the values of the SupportedLocales attribute has a maximum
length of 35 bytes

|2 | | |TH writes "xx-XX" to SupportedLocales attribute a|
Verify DUT responds with UNSUPPORTED_WRITE

|3 | | |TH reads SupportedLocales attribute |Verify that the value is
unchanged

|4 |11.3.4.1 |LCFG.S.A0000(ActiveLocale) a|
TH reads ActiveLocale Attribute from the DUT

a|
* Verify that the ActiveLocale attribute is Language Tag as defined by
BCP47
* Verify that the value of ActiveLocale attribute has a maximum length
of 35 bytes
* Verify that the ActiveLocale Attribute value is present in the
SupportedLocales attribute list
* Verify that the default value is assigned by the Vendor

|5 | | |TH writes new string not present in SupportedLocales attribute
to ActiveLocale Attribute. a|
DUT responds with CONSTRAINT_ERROR

|6 | | |TH writes new string present in SupportedLocales attribute to
ActiveLocale Attribute a|
Verify that the DUT send the Success response

|7 | | |TH Reads ActiveLocale a|
Verify that the value of the ActiveLocale attribute is changed to
SupportedLocales

|===

[[_unit_localization_cluster_test_plan]]
== link:#_unit_localization_cluster_test_plan[]**Unit Localization Cluster Test Plan**

[[_pics_definition_33]]
=== link:#_pics_definition_33[]114. PICS Definition

This section covers the Unit Localization’s Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_35]]
==== link:#_role_35[]114.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LUNIT.S |Does the device implement the Unit Localization as a server?
|O |
|===

[[_server_35]]
==== link:#_server_35[]114.2. Server

[[_features_22]]
===== link:#_features_22[]114.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LUNIT.S.F00(TEMP) |Does the device implement different units of
temperature ? |O |
|===

[[_attributes_38]]
===== link:#_attributes_38[]114.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LUNIT.S.A0000(TemperatureUnit) |Does the device support the
TemperatureUnit attribute ? |LUNIT.S.F00(TEMP) |

|LUNIT.S.Afff8(GeneratedCommandList) |Does the device implement the
(0xFFF8) GeneratedCommandList attribute ? |M |

|LUNIT.S.Afff9(AcceptedCommandList) |Does the device implement the
(0xFFF9) AcceptedCommandList attribute ? |M |

|LUNIT.S.Afffa(EventList) |Does the device implement the (0xFFFA)
EventList attribute ? |M Provisional |

|LUNIT.S.Afffb(AttributeList) |Does the device implement the (0xFFFB)
AttributeList attribute ? |M |

|LUNIT.S.Afffc(FeatureMap) |Does the device implement the (0xFFFC)
FeatureMap attribute ? |M |

|LUNIT.S.Afffd(ClusterRevision) |Does the device implement the (0xFFFD)
ClusterRevision attribute ? |M |
|===

[[_enums_values]]
===== link:#_enums_values[]114.2.3. Enums & Values

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LUNIT.TempUnit.Fahrenheit |Does the device support the TemperatureUnit
Fahrenheit ? |M |

|LUNIT.TempUnit.Celsius |Does the device support the TemperatureUnit
Celsius ? |M |

|LUNIT.TempUnit.Kelvin |Does the device support the TemperatureUnit
Kelvin ? |M |
|===

[[_test_case_list_35]]
=== link:#_test_case_list_35[]115. Test Case List

[width="100%",cols="50%,50%",options="header",]
|===
|*TC UUID* |*Test Case Name*
|TC-LUNIT-1.2 |Global Attributes [DUT as Server]

|TC-LUNIT-3.1 |Read and Write to Unit Localization Cluster Attributes
[DUT as Server]
|===

[[_test_cases_35]]
=== link:#_test_cases_35[]116. Test Cases

[[_generic_test_cases_30]]
==== link:#_generic_test_cases_30[]116.1. Generic test cases

[[_tc_lunit_1_2_global_attributes_dut_as_server]]
===== link:#_tc_lunit_1_2_global_attributes_dut_as_server[]116.1.1. [TC-LUNIT-1.2] Global Attributes [DUT as Server]

[[_category_242]]
====== link:#_category_242[]Category

Functional conformance

[[_purpose_247]]
====== link:#_purpose_247[]Purpose

To verify the Global Attributes available in Unit Localization Cluster.

[[_pics_247]]
====== link:#_pics_247[]PICS

* LUNIT.S

[[_pre_conditions_22]]
====== link:#_pre_conditions_22[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_247]]
====== link:#_required_devices_247[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_202]]
====== link:#_device_topology_202[]Device Topology

[[_test_setup_214]]
====== link:#_test_setup_214[]Test Setup

[[_test_procedure_247]]
====== link:#_test_procedure_247[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission TH to DUT |

|2 | |LUNIT.S.Afffd(ClusterRevision) |TH reads from the DUT the (0xFFFD)
_ClusterRevision attribute_ |Verify that the DUT response contains a
minimal revision of 1.

|3 | |LUNIT.S.Afffc(FeatureMap) |TH reads from the DUT the (0xFFFC)
_FeatureMap attribute_ a|
Verify that the DUT response contains the following bitmap32 w/:

- bit 0 is set to 1 if LUNIT.S.F00(TEMP) is true.

|4 | |LUNIT.S.Afffb(AttributeList) |TH reads from the DUT the (0xFFFB)
_AttributeList attribute_ a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support:

- (0) TemperatureUnit (LUNIT.S.F00(TEMP))

- It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 | |LUNIT.S.Afffa(EventList) |TH reads from the DUT the (0xFFFA)
_EventList attribute_ |Verify that the DUT response contains a list of
supported events empty for this cluster.

|6 | |LUNIT.S.Afff9(AcceptedCommandList) |TH reads from the DUT the
(0xFFF9) _AcceptedCommandList attribute_ |Verify that the DUT response
contains a list of Accepted commands (C2S) empty for this cluster.

|7 | |LUNIT.S.Afff8(GeneratedCommandList) |TH reads from the DUT the
(0xFFF8) _GeneratedCommandList attribute_ |Verify that the DUT response
contains a list of Generated commands (S2C) empty for this cluster.
|===

[[_notestesting_considerations_229]]
====== link:#_notestesting_considerations_229[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

[[_dut_as_server_6]]
==== link:#_dut_as_server_6[]116.2. DUT as Server

[[_tc_lunit_3_1_read_and_write_unit_localization_cluster_attributes_dut_as_server]]
===== link:#_tc_lunit_3_1_read_and_write_unit_localization_cluster_attributes_dut_as_server[]116.2.1. [TC-LUNIT-3.1] Read and Write Unit Localization Cluster Attributes [DUT as Server]

[[_category_243]]
====== link:#_category_243[]Category

Functional conformance

[[_purpose_248]]
====== link:#_purpose_248[]Purpose

This test case verifies the read and write functionality of attributes
provided by the Unit Localization Cluster.

[[_pics_248]]
====== link:#_pics_248[]PICS

* LUNIT.S

[[_pre_conditions_23]]
====== link:#_pre_conditions_23[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with DUT |
|===

[[_required_devices_248]]
====== link:#_required_devices_248[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_203]]
====== link:#_device_topology_203[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_215]]
====== link:#_test_setup_215[]Test Setup

Commission TH to DUT.

[[_test_procedure_248]]
====== link:#_test_procedure_248[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) |TH reads from the DUT the
TemperatureUnit attribute a|
* Verify that the read request was successful with status code 0x00
* Verify that the value is of Enum8 datatype

|2 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) & LUNIT.TempUnit.Fahrenheit
|TH writes 0 to TemperatureUnit attribute |Verify the write request is
successful with status code 0x00

|3 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) & LUNIT.TempUnit.Fahrenheit
|TH reads from the DUT the TemperatureUnit attribute |Verify that the
value is 0

|4 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) & LUNIT.TempUnit.Celsius
|TH writes 1 to TemperatureUnit attribute |Verify the write request is
successful with status code 0x00

|5 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) & LUNIT.TempUnit.Celsius
|TH reads from the DUT the TemperatureUnit attribute |Verify that the
value is 1

|6 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) & LUNIT.TempUnit.Kelvin |TH
writes 2 to TemperatureUnit attribute |Verify the write request is
successful with status code 0x00

|7 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) & LUNIT.TempUnit.Kelvin |TH
reads from the DUT the TemperatureUnit attribute |Verify that the value
is 2

|8 |11.3.4.1 |LUNIT.S.A0000(TemperatureUnit) |TH writes 5 to
TemperatureUnit attribute |Verify that the write request fails with 0x87
(Constraint Error)
|===

[[_time_format_localization_cluster_test_plan]]
== link:#_time_format_localization_cluster_test_plan[]**Time Format Localization Cluster Test Plan**

[[_pics_definition_34]]
=== link:#_pics_definition_34[]117. PICS Definition

This section covers the Time Format Localization Test Plan related PICS
items that are referenced in the following test cases.

[[_role_36]]
==== link:#_role_36[]117.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LTIME.S |Does the device implement the Time Format Localization cluster
as a server? |O |

|LTIME.C |Does the device implement the Time Format Localization cluster
as a client? |O |
|===

[[_server_36]]
==== link:#_server_36[]117.2. Server

[[_attributes_39]]
===== link:#_attributes_39[]117.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LTIME.S.A0000(HourFormat) |Does the device implement the HourFormat
attribute ? |M |

|LTIME.S.A0001(ActiveCalendarType) |Does the device implement the
ActiveCalendarType attribute ? |M |

|LTIME.S.A0002(SupportedCalendarTypes) |Does the device implement the
SupportedCalendarTypes attribute ? |M |

|LTIME.S.Afff8(GeneratedCommandList) |Does the device implement the
(0xFFF8) GeneratedCommandList attribute ? |M |

|LTIME.S.Afff9(AcceptedCommandList) |Does the device implement the
(0xFFF9) AcceptedCommandList attribute ? |M |

|LTIME.S.Afffa(EventList) |Does the device implement the (0xFFFA)
EventList attribute ? |M Provisional |

|LTIME.S.Afffb(AttributeList) |Does the device implement the (0xFFFB)
AttributeList attribute ? |M |

|LTIME.S.Afffc(FeatureMap) |Does the device implement the (0xFFFC)
FeatureMap attribute ? |M |

|LTIME.S.Afffd(ClusterRevision) |Does the device implement the (0xFFFD)
ClusterRevision attribute ? |M |
|===

[[_specific_attribute_features]]
===== link:#_specific_attribute_features[]117.2.2. Specific Attribute Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LTIME.S.A0000.12HR |Does the DUT (Server) support 12 Hr Hour Format ?
|M |

|LTIME.S.A0000.24HR |Does the DUT (Server) support 24 Hr Hour Format ?
|M |
|===

[[_pixit_definition_9]]
=== link:#_pixit_definition_9[]118. PIXIT Definition

This section covers the Time Format Localization Test Plan related PIXIT
items that are referenced in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.LTIME.SCT |PIXIT of the list of SupportedCalendarTypes |M |
|===

[[_test_case_list_36]]
=== link:#_test_case_list_36[]119. Test Case List

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-LTIME-1.2 |Global Attributes [DUT as Server]

|2 |TC-LTIME-3.1 |Read and Write to Time Format Localization Cluster
Attributes [DUT as Server]
|===

[[_test_cases_36]]
=== link:#_test_cases_36[]120. Test Cases

[[_generic_test_cases_31]]
==== link:#_generic_test_cases_31[]120.1. Generic test cases

[[_tc_ltime_1_2_global_attributes_dut_as_server]]
===== link:#_tc_ltime_1_2_global_attributes_dut_as_server[]120.1.1. [TC-LTIME-1.2] Global Attributes [DUT as Server]

[[_category_244]]
====== link:#_category_244[]Category

Functional conformance

[[_purpose_249]]
====== link:#_purpose_249[]Purpose

To verify the Global Attributes available in Time Format Localization
Cluster

[[_pics_249]]
====== link:#_pics_249[]PICS

* LTIME.S

[[_pre_conditions_24]]
====== link:#_pre_conditions_24[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_249]]
====== link:#_required_devices_249[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as Server
|2 |TH |Test Harness as Client
|===

[[_device_topology_204]]
====== link:#_device_topology_204[]Device Topology

[[_test_setup_216]]
====== link:#_test_setup_216[]Test Setup

[[_test_procedure_249]]
====== link:#_test_procedure_249[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission TH to DUT |

|2 | |LTIME.S.Afffd(ClusterRevision) |TH reads from the DUT the (0xFFFD)
_ClusterRevision attribute_ |Verify that the DUT response contains a
minimal revision of 1.

|3 | |LTIME.S.Afffc(FeatureMap) |TH reads from the DUT the (0xFFFC)
_FeatureMap attribute_ a|
Verify that the DUT response contains the following bitmap32 w/:

- bit 0 is set to 1 If CALFMT is true.

|4 | |LTIME.S.Afffb(AttributeList) |TH reads from the DUT the (0xFFFB)
_AttributeList attribute_ a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support:

- (0) HourFormat (mandatory)

- (1) ActiveCalendarType (CALFMT)

- (2) SupportedCalendarTypes (CALFMT)

- It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 | |LTIME.S.Afffa(EventList) |TH reads from the DUT the (0xFFFA)
_EventList attribute_ |Verify that the DUT response contains a list of
supported events empty for this cluster.

|6 | |LTIME.S.Afff9(AcceptedCommandList) |TH reads from the DUT the
(0xFFF9) _AcceptedCommandList attribute_ |Verify that the DUT response
contains a list of Accepted commands (C2S) empty for this cluster.

|7 | |LTIME.S.Afff8(GeneratedCommandList) |TH reads from the DUT the
(0xFFF8) _GeneratedCommandList attribute_ |Verify that the DUT response
contains a list of Generated commands (S2C) empty for this cluster.
|===

[[_notestesting_considerations_230]]
====== link:#_notestesting_considerations_230[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

[[_dut_as_server_7]]
==== link:#_dut_as_server_7[]120.2. DUT as Server

[[_tc_ltime_3_1_read_and_write_time_format_localization_cluster_attributes_dut_as_server]]
===== link:#_tc_ltime_3_1_read_and_write_time_format_localization_cluster_attributes_dut_as_server[]120.2.1. [TC-LTIME-3.1] Read and Write Time Format Localization Cluster Attributes [DUT as Server]

[[_category_245]]
====== link:#_category_245[]Category

Functional conformance

[[_purpose_250]]
====== link:#_purpose_250[]Purpose

This test case verifies the read and write functionality of attributes
provided by the Time Format Localization Cluster.

[[_pics_250]]
====== link:#_pics_250[]PICS

* LTIME.S

[[_pre_conditions_25]]
====== link:#_pre_conditions_25[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with DUT |
|===

[[_required_devices_250]]
====== link:#_required_devices_250[]Required Devices

[width="100%",cols="6%,47%,47%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as Server
|2 |TH |Test Harness as Client
|===

[[_device_topology_205]]
====== link:#_device_topology_205[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_217]]
====== link:#_test_setup_217[]Test Setup

Commission TH to DUT.

[[_test_procedure_250]]
====== link:#_test_procedure_250[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.3.4.1 |LTIME.S.A0000 |TH reads HourFormat attribute from DUT a|
* Verify that the read request was successful
* Verify that the value is of Enum8 datatype

|2 |11.3.4.1 |LTIME.S.A0000.12HR |If (LTIME.S.A0000.12HR) TH writes 0 to
HourFormat attribute a|
Verify the write request is successful

|3 |11.3.4.1 |LTIME.S.A0000 |TH reads HourFormat attribute |Verify that
read request is successful

|4 |11.3.4.1 |LTIME.S.A0000.24HR |If (LTIME.S.A0000.24HR) TH writes 1 to
HourFormat attribute a|
Verify the write request is successful

|5 |11.3.4.1 |LTIME.S.A0000 |TH reads HourFormat attribute |Verify that
read request is successful

|6 |11.3.4.1 |LTIME.S.A0001 |TH reads ActiveCalendarType attribute from
DUT a|
* Verify that the read request is successful
* Verify that the value is in between 0 to 11

|7 |11.3.4.1 |LTIME.S.A0002 |TH reads SupportedCalendarTypes attribute
from DUT a|
* Verify that the read request is successful
* Verify that the values in the List is in between 0 and 11

|8 |11.3.4.1 |LTIME.S.A0001 |TH writes value in PIXIT.LTIME.SCT to
ActiveCalendarType attribute, followed by reading the ActiveCalendarType
attribute value a|
Verify write request is successful. Verify that the read
ActiveCalendarType attribute value shows the same as the value that was
set before.

|9 |11.3.4.1 |LTIME.S.A0001 |Repeat step 8 for all the values in
PIXIT.LTIME.SCT a|
Verify write request is successful. Verify that the read
ActiveCalendarType attribute value shows the same as the value that was
set before.

|10 |11.3.4.1 |LTIME.S.A0001 |TH writes 50 to ActiveCalendarType
attribute a|
Verify the write request shows 0x87 (Constraint Error)

|11 |11.3.4.1 |LTIME.S.A0000 |TH writes 5 to HourFormat attribute a|
Verify the write request shows 0x87 (Constraint Error)

|===

[[_door_lock_test_plan]]
== link:#_door_lock_test_plan[]**Door lock Test Plan**

[[_pics_definition_35]]
=== link:#_pics_definition_35[]121. PICS Definition

This section covers the Door Lock Cluster related PICS items that are
referenced in the following test cases.

[[_role_37]]
==== link:#_role_37[]121.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S |Does the device implement the DoorLock cluster as a server? |O
|

|DRLK.C |Does the device implement the DoorLock cluster as a client? |O
|
|===

[[_server_37]]
==== link:#_server_37[]121.2. Server

[[_manual_controllable_17]]
===== link:#_manual_controllable_17[]121.2.1. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.M.Simulate.NotFullyLocked |Does the DUT(server) support
simulating a Not Fully Locked State? |O |

|DRLK.S.M.DetectLockJammed |Does the DUT(server) detect a LockJammed
State? |O |
|===

[[_attributes_40]]
===== link:#_attributes_40[]121.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.A0000(LockState) |Does the DUT(server) support the LockState
attribute? |M |

|DRLK.S.A0001(LockType) |Does the DUT(server) support the LockType
attribute? |M |

|DRLK.S.A0002(ActuatorEnabled) |Does the DUT(server) support the
ActuatorEnabled attribute? |M |

|DRLK.S.A0003(DoorState) |Does the DUT(server) support the DoorState
attribute? |DRLK.S.F05(DPS) |

|DRLK.S.A0004(DoorOpenEvents) |Does the DUT(server) support the DoorOpen
Events attribute? |[DRLK.S.F05(DPS)] |

|DRLK.S.A0005(DoorClosedEvents) |Does the DUT(server) support the
DoorClosedEvents attribute? |[DRLK.S.F05(DPS)] |

|DRLK.S.A0006(OpenPeriod) |Does the DUT(server) support the OpenPeriod
attribute? |[DRLK.S.F05(DPS)] |

|DRLK.S.A0011(NumberOfTotalUsersSupported) |Does the DUT(server) support
the NumberOf TotalUsersSupported attribute? |DRLK.S.F08(USR) |

|DRLK.S.A0012(NumberOfPINUsersSupported) |Does the DUT(server) support
the NumberOfPINUsersSupported attribute? |DRLK.S.F00(PIN) |

|DRLK.S.A0013(NumberOfRFIDUsersSupported) |Does the DUT(server) support
the NumberOfRFIDUsersSupported attribute? |DRLK.S.F01(RID) |

|DRLK.S.A0014(NumberOfWeekDaysSchedulesSupported) |Does the DUT(server)
support the NumberOfWeekDaysSchedulesSupported attribute?
|DRLK.S.F04(WDSCH) |

|DRLK.S.A0015(NumberOfYearDaysSchedulesSupported) |Does the DUT(server)
support the NumberOfYearDaysSchedulesSupported attribute?
|DRLK.S.F0a(YDSCH) |

|DRLK.S.A0016(NumberOfHolidaySchedulesSupported) |Does the DUT(server)
support the NumberOfHolidaySchedulesSupported attribute?
|DRLK.S.F0b(HDSCH) |

|DRLK.S.A0017(MaxPINCodeLength) |Does the DUT(server) support the
MaxPINCodedLength attribute? |DRLK.S.F00(PIN) |

|DRLK.S.A0018(MinPINCodeLength) |Does the DUT(server) support the
MinPINCodedLength attribute? |DRLK.S.F00(PIN) |

|DRLK.S.A0019(MaxRFIDCodeLength) |Does the DUT(server) support the
MaxRFIDCodedLength attribute? |DRLK.S.F01(RID) |

|DRLK.S.A001a(MinRFIDCodeLength) |Does the DUT(server) support the
MinRFIDCodedLength attribute? |DRLK.S.F01(RID) |

|DRLK.S.A001b(CredentialRulesSupport) |Does the DUT(server) support the
CredentialRulesSupport attribute? |DRLK.S.F08(USR) |

|DRLK.S.A001c(NumberOfCredentialsSupportedPerUser) |Does the DUT(server)
support the NumberOfCredentialsSupportedPerUser attribute?
|DRLK.S.F08(USR) |

|DRLK.S.A0021(Language) |Does the DUT(server) support the Language
attribute? |O |

|DRLK.S.A0022(LEDSettings) |Does the DUT(server) support the LEDSettings
attribute? |O |

|DRLK.S.A0023(AutoRelockTime) |Does the DUT(server) support the
AutoRelockTime attribute? |O |

|DRLK.S.A0024(SoundVolume) |Does the DUT(server) support the SoundVolume
attribute? |O |

|DRLK.S.A0025(OperatingMode) |Does the DUT(server) support the
OperatingMode attribute? |M |

|DRLK.S.A0026(SupportedOperatingModes) |Does the DUT(server) support the
SupportedOperatingModes attribute? |M |

|DRLK.S.A0027(DefaultConfigurationRegister) |Does the DUT(server)
support the DefaultConfigurationRegister attribute? |O |

|DRLK.S.A0028(EnableLocalProgramming) |Does the DUT(server) support the
EnableLocalProgramming attribute? |O |

|DRLK.S.A0028(EnableLocalProgramming).ReadOnly |Does the DUT(server)
support the EnableLocalProgramming attribute and is ReadOnly |O |

|DRLK.S.A0029(EnableOneTouchLocking) |Does the DUT(server) support the
EnableOneTouchLocking attribute? |O |

|DRLK.S.A002a(EnableInsideStatusLED) |Does the DUT(server) support the
EnableInsideStatusLED attribute? |O |

|DRLK.S.A002b(EnablePrivacyModeButton) |Does the DUT(server) support the
EnablePrivacyModeButton attribute? |O |

|DRLK.S.A002c(LocalProgrammingFeatures) |Does the DUT(server) support
the LocalProgrammingFeatures attribute? |O |

|DRLK.S.A002c(LocalProgrammingFeatures).ReadOnly |Does the DUT(server)
support the LocalProgrammingFeatures attribute and is ReadOnly |O |

|DRLK.S.A0030(WrongCodeEntryLimit) |Does the DUT(server) support the
WrongCodeEntryLimit attribute? |DRLK.S.F00(PIN) | DRLK.S.F01(RID) |

|DRLK.S.A0031(UserCodedTemporaryDisableTime) |Does the DUT(server)
support the UserCodedTemporaryDisableTime attribute? |DRLK.S.F00(PIN) |
DRLK.S.F01(RID) |

|DRLK.S.A0032(SendPINOverTheAir) |Does the DUT(server) support the
SendPINOverTheAir attribute? |[DRLK.S.F00(PIN)] |

|DRLK.S.A0033(RequirePINForRemoteOperation) |Does the DUT(server)
support the RequirePINForRemoteOperation attribute? |DRLK.S.F07(COTA) &
DRLK.S.F00(PIN) |

|DRLK.S.A0035(ExpiringUserTimeOut) |Does the DUT(server) support the
ExpiringUserTimeOut attribute? |[DRLK.S.F08(USR)] |
|===

[[_write_attributes]]
===== link:#_write_attributes[]121.2.3. Write Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.A0021(Language).Write |Does the DUT(server) support the Language
attribute? |O |

|DRLK.S.A0022(LEDSettings).Write |Does the DUT(server) support the
LEDSettings attribute? |O |

|DRLK.S.A0023(AutoRelockTime).Write |Does the DUT(server) support the
AutoRelockTime attribute? |O |

|DRLK.S.A0024(SoundVolume).Write |Does the DUT(server) support the
SoundVolume attribute? |O |

|DRLK.S.A0025(OperatingMode).Write |Does the DUT(server) support the
OperatingMode attribute? |O |

|DRLK.S.A0028(EnableLocalProgramming).Write |Does the DUT(server)
support the EnableLocalProgramming attribute? |O |

|DRLK.S.A002c(LocalProgrammingFeatures).Write |Does the DUT(server)
support the LocalProgrammingFeatures attribute? |O |

|DRLK.S.A0030(WrongCodeEntryLimit).Write |Does the DUT(server) support
the WrongCodeEntryLimit attribute? |[DRLK.S.F00(PIN) | DRLK.S.F01(RID)]
|

|DRLK.S.A0031(UserCodedTemporaryDisableTime).Write |Does the DUT(server)
support the UserCodedTemporaryDisableTime attribute? |[DRLK.S.F00(PIN) |
DRLK.S.F01(RID)] |

|DRLK.S.A0032(SendPINOverTheAir).Write |Does the DUT(server) support the
SendPINOverTheAir attribute? |[DRLK.S.F00(PIN)] |

|DRLK.S.A0033(RequirePINForRemoteOperation).Write |Does the DUT(server)
support the RequirePINForRemoteOperation attribute? |[DRLK.S.F07(COTA) &
DRLK.S.F00(PIN)] |

|DRLK.S.A0035(ExpiringUserTimeOut).Write |Does the DUT(server) support
the ExpiringUserTimeOut attribute? |[DRLK.S.F08(USR)] |
|===

[[_events_8]]
===== link:#_events_8[]121.2.4. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.E00(DoorLockAlarm) |Does the DUT(server) support the
DoorLockAlarm event? |M |

|DRLK.S.E01(DoorStateChange) |Does the DUT(server) support the
DoorStateChange event? |DRLK.S.F05(DPS) |

|DRLK.S.E02(LockOperation) |Does the DUT(server) support the
LockOperation event? |M |

|DRLK.S.E03(LockOperationError) |Does the DUT(server) support the
LockOperationError event? |M |

|DRLK.S.E04(LockUserChange) |Does the DUT(server) support the
LockUserChange event? |DRLK.S.F08(USR) |
|===

[[_features_23]]
===== link:#_features_23[]121.2.5. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.F00(PIN) |Does the DUT(server) support the "Lock supports PIN
credentials (via keypad, or over the-air)" feature? |O |

|DRLK.S.F01(RID) |Does the DUT(server) support the "Lock supports RFID
credentials" feature? |O |

|DRLK.S.F02(FGP) |Does the DUT(server) support the "Lock supports finger
related credentials(fingerprint, fingervein)" feature? |O |

|DRLK.S.F04(WDSCH) |Does the DUT(server) support the "Lock supports
weekday access schedules" feature? |O |

|DRLK.S.F05(DPS) |Does the DUT(server) support the "Lock supports a door
position sensor that indicates door’s state" feature? |O |

|DRLK.S.F06(FACE) |Does the DUT(server) support the "Lock supports face
related credentials (face, iris, retina)" feature? |O |

|DRLK.S.F07(COTA) |Does the DUT(server) support the "PIN codes over
the-air supported for lock/unlock operations" feature? |O |

|DRLK.S.F08(USR) |Does the DUT(server) support the "Lock supports the
user commands and database" feature? |O |

|DRLK.S.F0a(YDSCH) |Does the DUT(server) support the "Lock supports
yearday access schedules" feature? |O |

|DRLK.S.F0b(HDSCH) |Does the DUT(server) support the "Lock supports
holiday access schedules" feature? |O |

|DRLK.S.F0c(UBOLT) |Does the DUT(server) support the "Lock supports
unbolting" feature? |O |
|===

[[_commands_received_22]]
===== link:#_commands_received_22[]121.2.6. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.C00.Rsp(Lock Door) |Does the DUT(server) support the Lock Door
command? |M |

|DRLK.S.C01.Rsp(Unlock Door) |Does the DUT(server) support the Unlock
Door command? |M |

|DRLK.S.C03.Rsp(Unlock with Timeout) |Does the DUT(server) support the
Unlock with Timeout command? |O |

|DRLK.S.C0b.Rsp(Set Week Day Schedule) |Does the DUT(server) support the
Set Week Day Schedule command? |DRLK.S.F04(WDSCH) |

|DRLK.S.C0c.Rsp(Get Week Day Schedule) |Does the DUT(server) support the
Get Week Day Schedule command? |DRLK.S.F04(WDSCH) |

|DRLK.S.C0d.Rsp(Clear Week Day Schedule) |Does the DUT(server) support
the Clear Week Day Schedule command? |DRLK.S.F04(WDSCH) |

|DRLK.S.C0e.Rsp(Set Year Day Schedule) |Does the DUT(server) support the
Set Year Day Schedule command? |DRLK.S.F0a(YDSCH) |

|DRLK.S.C0f.Rsp(Get Year Day Schedule) |Does the DUT(server) support the
Get Year Day Schedule command? |DRLK.S.F0a(YDSCH) |

|DRLK.S.C10.Rsp(Clear Year Day Schedule) |Does the DUT(server) support
the Clear Year Day Schedule command? |DRLK.S.F0a(YDSCH) |

|DRLK.S.C11.Rsp(Set Holiday Schedule) |Does the DUT(server) support the
Set Holiday Schedule command? |DRLK.S.F0b(HDSCH) |

|DRLK.S.C12.Rsp(Get Holiday Schedule) |Does the DUT(server) support the
Get Holiday Schedule command? |DRLK.S.F0b(HDSCH) |

|DRLK.S.C13.Rsp(Clear Holiday Schedule) |Does the DUT(server) support
the Clear Holiday Schedule command? |DRLK.S.F0b(HDSCH) |

|DRLK.S.C1a.Rsp(Set User) |Does the DUT(server) support the Set User
command? |DRLK.S.F08(USR) |

|DRLK.S.C1b.Rsp(Get User) |Does the DUT(server) support the Get User
command? |DRLK.S.F08(USR) |

|DRLK.S.C1d.Rsp(Clear User) |Does the DUT(server) support the Clear User
command? |DRLK.S.F08(USR) |

|DRLK.S.C22.Rsp(Set Credential) |Does the DUT(server) support the Set
Credential command? |DRLK.S.F08(USR) |

|DRLK.S.C24.Rsp(Get Credential) |Does the DUT(server) support the Get
Credential command? |DRLK.S.F08(USR) |

|DRLK.S.C26.Rsp(Clear Credential) |Does the DUT(server) support the
Clear Credential command? |DRLK.S.F08(USR) |

|DRLK.S.C27.Rsp(Unbolt Door) |Does the DUT(server) support the Unbolt
Door command? |DRLK.S.F0c(UBOLT) |
|===

[[_commands_generated_21]]
===== link:#_commands_generated_21[]121.2.7. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.S.C0c.Tx(Get Week Day Schedule Response) |Does the DUT(server)
support the Get Week Day Schedule Response command? |DRLK.S.F04(WDSCH) |

|DRLK.S.C0f.Tx(Get Year Day Response Schedule) |Does the DUT(server)
support the Get Year Day Response Schedule command? |DRLK.S.F0a(YDSCH) |

|DRLK.S.C12.Tx(Get Holiday Schedule Response) |Does the DUT(server)
support the Get Holiday Schedule Response command? |DRLK.S.F0b(HDSCH) |

|DRLK.S.C1c.Tx(Get User Response) |Does the DUT(server) support the Get
User Response command? |DRLK.S.F08(USR) |

|DRLK.S.C23.Tx(Set Credential Response) |Does the DUT(server) support
the Set Credential Response command? |DRLK.S.F08(USR) |

|DRLK.S.C25.Tx(Get Credential Response) |Does the DUT(server) support
the Get Credential Response command? |DRLK.S.F08(USR) |
|===

[[_client_18]]
==== link:#_client_18[]121.3. Client

[[_features_24]]
===== link:#_features_24[]121.3.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.C.F04(WDSCH) |Does the DUT(client) support the "Lock supports
weekday access schedules" feature? |DRLK.C.F08(USR) |Does the
DUT(client) support the "Lock supports the user commands and database"
feature?
|===

[[_commands_generated_22]]
===== link:#_commands_generated_22[]121.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.C.C00.Tx(Lock Door) |Does the DUT(Client) support the Lock Door
command? |O |

|DRLK.C.C01.Tx(Unlock Door) |Does the DUT(Client) support the Unlock
Door command? |O |

|DRLK.C.C03.Tx(Unlock with Timeout) |Does the DUT(Client) support the
Unlock with Timeout command? |O |

|DRLK.C.C0b.Tx(Set Week Day Schedule) |Does the DUT(Client) support the
Set Week Day Schedule command? |O |

|DRLK.C.C0c.Tx(Get Week Day Schedule) |Does the DUT(Client) support the
Get Week Day Schedule command? |O |

|DRLK.C.C0d.Tx(Clear Week Day Schedule) |Does the DUT(Client) support
the Clear Week Day Schedule command? |O |

|DRLK.C.C0e.Tx(Set Year Day Schedule) |Does the DUT(Client) support the
Set Year Day Schedule command? |O |

|DRLK.C.C0f.Tx(Get Year Day Schedule) |Does the DUT(Client) support the
Get Year Day Schedule command? |O |

|DRLK.C.C10.Tx(Clear Year Day Schedule) |Does the DUT(Client) support
the Clear Year Day Schedule command? |O |

|DRLK.C.C11.Tx(Set Holiday Schedule) |Does the DUT(Client) support the
Set Holiday Schedule command? |O |

|DRLK.C.C12.Tx(Get Holiday Schedule) |Does the DUT(Client) support the
Get Holiday Schedule command? |O |

|DRLK.C.C13.Tx(Clear Holiday Schedule) |Does the DUT(Client) support the
Clear Holiday Schedule command? |O |

|DRLK.C.C1a.Tx(Set User) |Does the DUT(Client) support the Set User
command? |O |

|DRLK.C.C1b.Tx(Get User) |Does the DUT(Client) support the Get User? |O
|

|DRLK.C.C1d.Tx(Clear User) |Does the DUT(Client) support the Clear User
command? |O |

|DRLK.C.C22.Tx(Set Credential) |Does the DUT(Client) support the Set
Credential command? |O |

|DRLK.C.C24.Tx(Get Credential) |Does the DUT(Client) support the Get
Credential command? |O |

|DRLK.C.C26.Tx(Clear Credential) |Does the DUT(Client) support the Clear
Credential command? |O |

|DRLK.C.C27.Tx(Unbolt Door) |Does the DUT(Client) support the Unbolt
Door command? |O |
|===

[[_commands_received_23]]
===== link:#_commands_received_23[]121.3.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DRLK.C.C0c.Rsp(Get Week Day Schedule Response) |Does the DUT(Client)
support the Get Week Day Schedule Response command? |O |

|DRLK.C.C0f.Rsp(Get Year Day Schedule Response) |Does the DUT(Client)
support the Get Year Day Schedule Response command? |O |

|DRLK.C.C12.Rsp(Get Holiday Schedule Response) |Does the DUT(Client)
support the Get Holiday Schedule Response command? |O |

|DRLK.C.C1c.Rsp(Get User Response) |Does the DUT(Client) support the Get
User Response? |O |

|DRLK.C.C23.Rsp(Set Credential Response) |Does the DUT(Client) support
the Set Credential Response command? |O |

|DRLK.C.C25.Rsp(Get Credential Response) |Does the DUT(Client) support
the Get Credential Response command? |O |
|===

[[_pixit_definition_10]]
=== link:#_pixit_definition_10[]122. PIXIT Definition

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.DRLK.WrongCodeEntryLimit |The number of incorrect Pin codes or
RFID presentment attempts a user is allowed to enter before the lock
will enter a lockout state. |DRLK.S.F00(PIN) | DRLK.S.F01(RID) |

|PIXIT.DRLK.UserCodeTemporaryDisableTime |The number of seconds that the
lock shuts down following wrong code entry. |DRLK.S.F00(PIN) |
DRLK.S.F01(RID) |
|===

[[_test_case_list_37]]
=== link:#_test_case_list_37[]123. Test Case List

[width="100%",cols="9%,25%,66%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-DRLK-1.1 |Global Attributes [DUT-Server]

|2 |TC-DRLK-2.1 |Attributes check [DUT - Server]

|3 |TC-DRLK-2.2 |Verification for Door lock command[DUT-Server]

|4 |TC-DRLK-2.3 |Verification for Unlock Door command[DUT-Server]

|5 |TC-DRLK-2.4 |Verification for Unlock with Timeout
command[DUT-Server]

|6 |TC-DRLK-2.5 |Verification for the following Commands - Set Week Day
Schedule, Get Week Day Schedule , Get Week Day Schedule Response, Clear
Week Day Schedule [DUT-Server]

|7 |TC-DRLK-2.6 |Verification for the following Commands - Set Holiday
Schedule, Get Holiday Schedule, Get Holiday Schedule Response , Clear
Holiday Schedule [DUT-Server]

|8 |TC-DRLK-2.7 |Verification for the following Commands - Set Year
Schedule, Get Year Schedule, Get Year Day Schedule Response and Clear
Year Day Schedule[DUT-Server]

|9 |TC-DRLK-2.8 |Verification for the following Commands - Set User, Get
User, Get User Response, Clear User [DUT-Server]

|10 |TC-DRLK-2.9 |Verification for the following Commands - Set
Credential , Set Credential Response, Get Credential Status, Get
Credential Status Response, Clear Credential [DUT-Server]

|11 |TC-DRLK-2.10 |Verification for the Door Lock Events [DUT-Server]

|12 |TC-DRLK-2.11 |Verification for multiple credential types
[DUT-Server]

|13 |TC-DRLK-2.12 |Verification for Unbolt Door command[DUT-Server]

|14 |TC-DRLK-3.2 |Commands [DUT - Client]
|===

[[_test_cases_37]]
=== link:#_test_cases_37[]124. Test Cases

[[_generic_test_cases_32]]
==== link:#_generic_test_cases_32[]124.1. Generic test cases

[[_tc_drlk_1_1_global_attributes_dut_server]]
===== link:#_tc_drlk_1_1_global_attributes_dut_server[]124.1.1. [TC-DRLK-1.1] Global Attributes [DUT-Server]

[[_category_246]]
====== link:#_category_246[]Category

Functional conformance

[[_purpose_251]]
====== link:#_purpose_251[]Purpose

To verify the Global Attributes available in Door Lock Cluster

[[_pics_251]]
====== link:#_pics_251[]PICS

* DRLK.S

[[_pre_conditions_26]]
====== link:#_pre_conditions_26[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_251]]
====== link:#_required_devices_251[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Server
|2 |TH |Client
|===

[[_device_topology_206]]
====== link:#_device_topology_206[]Device Topology

[[_test_setup_218]]
====== link:#_test_setup_218[]Test Setup

[[_test_procedure_251]]
====== link:#_test_procedure_251[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |7.13 | |TH reads the ClusterRevision from DUT a|
* Verify that the ClusterRevision attribute is of uint16.
* Verify that the DUT response indicates that the ClusterRevision
attribute has the value 7.

|3 | | |TH reads the FeatureMap from DUT a|
Verify that the DUT response indicates that the FeatureMap attribute has
following values.

bit 0 is set to 1 If DRLK.S.F00(PIN) is true.

bit 1 is set to 1 If DRLK.S.F01(RID) is true.

bit 2 is set to 1 If DRLK.S.F02(FGP) is true.

bit 4 is set to 1 If DRLK.S.F04(WDSCH) is true.

bit 5 is set to 1 If DRLK.S.F05(DPS) is true.

bit 6 is set to 1 If DRLK.S.F06(FACE) is true.

bit 7 is set to 1 If DRLK.S.F07(COTA) is true.

bit 8 is set to 1 If DRLK.S.F08(USR) is true.

bit 10 is set to 1 If DRLK.S.F0a(YDSCH) is true.

bit 11 is set to 1 If DRLK.S.F0b(HDSCH) is true.

bit 12 is set to 1 If DRLK.S.F0c(UBOLT) is true.

|4 | | |TH reads AttributeList from DUT a|
Verify that the DUT response provides a list of supported attributes

It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

This list should include the mandatory attributes (Id 0x0000, 0x0001,
0x0002, 0x0025, 0x0026) and the following Id based on support for
optional attributes:

If DUT supports door position sensor [DRLK.S.F05(DPS) is true]: 0x0003

If DUT supports user commands and database [DRLK.S.F08(USR) is
true]:0x0011, 0x001b,0x001c

If DUT supports PIN credentials (via keypad, or over the-air)
[DRLK.S.F00(PIN] is true): 0x0012, 0x0017,0x0018

If DUT supports RFID credentials [DRLK.S.F01(RID) is true]: 0x0013,
0x0019, 0x001a

If DUT supports weekday schedules [DRLK.S.F04(WDSCH) is true]: 0x0014

If DUT supports yearday schedules [DRLK.S.F0a(YDSCH) is true]: 0x0015

If DUT supports holiday schedules [DRLK.S.F0b(HDSCH) is true]: 0x0016

If DUT supports PIN credentials or RFID credentials [DRLK.S.F00(PIN),
DRLK.S.F01(RID) is true]:0x0030, 0x0031

If DUT supports PIN codes over the-air supported for lock/unlock
operations and PIN credentials [DRLK.S.F07(COTA) , DRLK.S.F00(PIN) is
true]:0x0033

Language attribute [DRLK.S.A0021(Language)]: 0x0021

LEDSettings attribute [DRLK.S.A0022(LEDSettings)]: 0x0022

AutoRelockTime attribute [DRLK.S.A0023(AutoRelockTime)]:0X0023

SoundVolume attribute [DRLK.S.A0024(SoundVolume)]: 0x0024

DefaultConfigurationRegister attribute
[DRLK.S.A0027(DefaultConfigurationRegister)]: 0x0027

EnableLocalProgramming attribute [DRLK.S.A0028(EnableLocalProgramming)]:
0x0028

EnableOneTouchLocking attribute [DRLK.S.A0029(EnableOneTouchLocking)]:
0x0029

EnableInsideStatusLED attribute [DRLK.S.A002a(EnableInsideStatusLED)]:
0x002a

EnablePrivacyModeButton attribute
[DRLK.S.A002b(EnablePrivacyModeButton)]: 0x002b

LocalProgrammingFeatures attribute
[DRLK.S.A002c(LocalProgrammingFeatures)]: 0x002c

|5 | | |TH reads EventList from DUT a|
Verify that the DUT response provides a list of supported events.

This list should include the mandatory Events(values 0x00, 0x02,
0x03)and the following value based on support for optional Events:

If DUT supports door position sensor [DRLK.S.F05(DPS) is true]: 0x01

If DUT supports user commands and database [DRLK.S.F08(USR) is true]:
0x04

|6 | | |TH reads AcceptedCommandList from DUT a|
Verify that the DUT response provides a list of Accepted Command. This
list should include the mandatory Commands(values 0x00, 0x01) and the
following values based on support for optional Commands:

If DUT supports weekday schedules [DRLK.S.F04(WDSCH) is true]: 0x0b,
0x0c, 0x0d

If DUT supports yearday schedules [DRLK.S.F0a(YDSCH) is true]: 0x0e,
0x0f, 0x10

If DUT supports holiday schedules [DRLK.S.F0b(HDSCH) is true]: 0x11,
0x12, 0x13

If DUT supports user commands and database [DRLK.S.F08(USR) is
true]:0x1a, 0x1b, 0x1d, 0x22, 0x24, 0x26

Unlock with Timeout [DRLK.S.C03.Rsp(Unlock with Timeout)]: 0x03

IF DUT supports unbolting feature [DRLK.S.F0c(UBOLT) is true]: 0x27

|7 | | |TH reads GeneratedCommandList from DUT a|
Verify that the DUT response provides a list of Generated Command. This
list should include the following values based on support for optional
Commands:

If DUT supports weekday schedules [DRLK.S.F04(WDSCH) is true]: 0x0c

If DUT supports yearday schedules [DRLK.S.F0a(YDSCH) is true]: 0x0f

If DUT supports holiday schedules [DRLK.S.F0b(HDSCH) is true]: 0x12

If DUT supports the user commands and database [DRLK.S.F08(USR) is true]
: 0x1c, 0x23, 0x25

|===

[[_notestesting_considerations_231]]
====== link:#_notestesting_considerations_231[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

[[_server_as_dut_22]]
==== link:#_server_as_dut_22[]124.2. Server as DUT

[[_tc_drlk_2_1_attributes_check_dut_server]]
===== link:#_tc_drlk_2_1_attributes_check_dut_server[]124.2.1. [TC-DRLK-2.1] Attributes check [DUT - Server]

[[_category_247]]
====== link:#_category_247[]Category

Functional conformance

[[_purpose_252]]
====== link:#_purpose_252[]Purpose

To Check the attributes of Door Lock Cluster

[[_pics_252]]
====== link:#_pics_252[]PICS

* DRLK.S

[[_pre_conditions_27]]
====== link:#_pre_conditions_27[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | a|
Before sending the Lock/Unlock commands perform the following steps:

{empty}1. Send Set Credential Command to set up User and Credential.

After completing all steps in test procedure perform the following step:

{empty}1. Send Clear Credential command to clear credential and
associated user.

|
|===

[[_required_devices_252]]
====== link:#_required_devices_252[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_207]]
====== link:#_device_topology_207[]Device Topology

[[_test_setup_219]]
====== link:#_test_setup_219[]Test Setup

[[_test_procedure_252]]
====== link:#_test_procedure_252[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a |5.2.3.1 |DRLK.S.A0000 (LockState) |TH reads LockState attribute
from DUT a|
* Verify that LockState has one of the following values:
+
. 0 - Not Fully Locked
. 1 - Locked
. 2 - Unlocked
. 3 - Unlatched
* Verify that the value is NULL if the above values are not present

|1b |5.2.3.1 |DRLK.S.A0000 (LockState) |TH writes LockState attribute as
1 |Verify DUT responds with UNSUPPORTED_WRITE

|1c |5.2.3.1 |DRLK.S.A0000 (LockState) |TH reads LockState attribute
from DUT |Verify that the LockState value remains unchanged

|1d |5.2.3.1 |DRLK.S.A0000(LockState) |TH sends a Lock Door command to
the DUT. If DRLK.S.F00(PIN) & DRLK.S.F07(COTA), include a Valid PINCode
in the Lock Door command. |Verify that the DUT performs the door lock
action. +
Verify that the LockState attribute value is 1 after the lock action has
been completed (e.g. motor movement finished).

|1e |5.2.3.1 |DRLK.S.A0000(LockState) |TH sends a Unlock Door command to
the DUT. If DRLK.S.F00(PIN) & DRLK.S.F07(COTA), include a Valid PINCode
in the Unlock Door command. |Verify that the DUT performs the door
unlock action. +
Verify that the LockState attribute value is 2 after the lock action has
been completed (e.g. motor movement finished).

|1f |5.2.3.1 |DRLK.S.A0000(LockState), DRLK.S.M.Simulate.NotFullyLocked
|Simulate a not fully locked scenario on the DUT. |Verify that the
LockState attribute value is 0.

|2a |5.2.3.2 a|
DRLK.S.A0001

(LockType)

a|
TH reads LockType attribute from DUT

a|
Verify that LockType has one of the following values:

. 0-Dead bolt
. 1-Magnetic
. 2-Other
. 3-Mortise
. 4-Rim
. 5-Latch Bolt
. 6-Cylindrical Lock
. 7-Tubular Lock
. 8-Interconnected Lock
. 9-Dead Latch
. 10-Door Furniture
. 11-Eurocylinder

|2b | | |TH writes LockType attribute as 10 |Verify DUT responds with
UNSUPPORTED_WRITE

|2c | | |TH reads LockType attribute from DUT |Verify that the LockType
value remains unchanged

|3a |5.2.3.3 |DRLK.S.A0002 (ActuatorEnabled) |TH reads ActuatorEnabled
attribute from DUT a|
Verify that ActuatorEnabled has one of the following Values:

. Disabled
. enabled

|3b | | |TH writes ActuatorEnabled attribute as 0 |Verify DUT responds
with UNSUPPORTED_WRITE

|3c | | |TH reads ActuatorEnabled attribute from DUT a|
Verify that the ActuatorEnabled value remains unchanged

|4a |5.2.3.4 a|
DRLK.S.F05(DPS),

DRLK.S.A0003 (DoorState)

a|
TH reads DoorState attribute from DUT

a|
* Verify that DoorState has one of the following Values:
+
. 0-DoorOpen
. 1-DoorClosed
. 2-DoorJammed
. 3-DoorForcedOpen
. 4-DoorUnspecifiedError
. 5-DoorAjar
* Verify that the value is NULL if the above values are not present

|4b | | |TH writes DoorState attribute as 1 |Verify DUT responds with
UNSUPPORTED_WRITE

|4c | | |TH reads DoorState attribute from DUT a|
Verify that the DoorState value remains unchanged

|5a |5.2.3.5 a|
DRLK.S.F05(DPS),

DRLK.S.A0004 (DoorOpenEvents)

|TH reads DoorOpenEvents attribute from DUT a|
Verify that DoorOpen Events contains valid number in the inclusive range
of 0 to 4294967294

|5b | |DRLK.S.A0004(DoorOpenEvents) |TH writes DoorOpenEvents attribute
as 0 |Verify that the DUT sends SUCCESS response

|5c | | |TH reads DoorOpenEvents attribute from DUT a|
Verify that the DoorOpenEvents value is changed to 10

|6a |5.2.3.6 a|
DRLK.S.F05(DPS),

DRLK.S.A0005(DoorClosedEvents)

|TH reads DoorClosedEvents attribute from DUT a|
Verify that DoorClosed Events contains valid number in the inclusive
range of 0 to 4294967294

|6b | |DRLK.S.A0005(DoorClosedEvents) |TH writes DoorClosedEvents
attribute as 0 |Verify that the DUT sends SUCCESS response

|6c | | |TH reads DoorClosedEvents attribute from DUT a|
Verify that the DoorClosedEvents value is changed to 11

|7a |5.2.3.7 a|
DRLK.S.F05(DPS),

DRLK.S.A0006(OpenPeriod )

|TH reads OpenPeriod attribute from DUT a|
Verify that OpenPeriod contains valid number in the inclusive range of 0
to 65534 minutes

|7b | |DRLK.S.A0006(OpenPeriod) |TH writes OpenPeriod attribute as 2
minutes |Verify that the DUT sends SUCCESS response

|7c | | |TH reads OpenPeriod attribute from DUT a|
Verify that the OpenPeriod value is changed to 2 minutes

|8a |5.2.3.9 a|
DRLK.S.F08(USR),

DRLK.S.A0011 (NumberOfTotal UsersSupported)

|TH reads NumberOfTotal UsersSupported attribute from DUT a|
Verify that NumberOfTotal UsersSupported contains valid number in the
inclusive range of 0 to 65534

|8b | | |TH writes NumberOfTotal UsersSupported attribute as 20 |Verify
DUT responds with UNSUPPORTED_WRITE

|8c | | |TH reads NumberOfTotal UsersSupported attribute from DUT a|
Verify that the NumberOfTotal UsersSupported value remains unchanged.

|9a |5.2.3.10 a|
DRLK.S.F00(PIN),

DRLK.S.A0012 (NumberOfPIN UsersSupported)

|TH reads NumberOfPINUsersSupported attribute from DUT a|
Verify that NumberOfPINUsersSupported contains valid number in the
inclusive range of 0 to 65534

|9b | | |TH writes NumberOfPINUsersSupported attribute as 25 |Verify DUT
responds with UNSUPPORTED_WRITE

|9c | | |TH reads NumberOfPINUsersSupported attribute from DUT a|
Verify that the NumberOfPINUsersSupported value remains unchanged.

|10a |5.2.3.11 a|
DRLK.S.F01(RID),

DRLK.S.A0013 (NumberOfRFID UsersSupported)

|TH reads NumberOfRFID UsersSupported attribute from DUT a|
Verify that NumberOfRFID UsersSupported contains valid number in the
inclusive range of 0 to 65534

|10b | | |TH writes NumberOfRFID UsersSupported attribute as 30 |Verify
DUT responds with UNSUPPORTED_WRITE

|10c | | |TH reads NumberOfRFID UsersSupported attribute from DUT
|Verify that the NumberOfRFID UsersSupported value remains unchanged

|11a |5.2.3.12 a|
DRLK.S.F04(WDSCH),

DRLK.S.A0014 (NumberOf WeekDays Schedules Supported)

a|
TH reads NumberOfWeekDays

SchedulesSupporterUser attribute from DUT

a|
Verify that NumberOfWeekDays SchedulesSupporterUser contains valid
number in the inclusive range of 0 to 255

|11b | | a|
TH writes NumberOfWeekDaySchedules

SupportedPerUser attribute as 31

|Verify DUT responds with UNSUPPORTED_WRITE

|11c | | |TH reads NumberOfWeekDaySchedules SupportedPerUser attribute
from DUT |Verify that the NumberOfWeekDaySchedules SupportedPerUser
value remains unchanged.

|12a |5.2.3.13 a|
DRLK.S.F0a(YDSCH),

DRLK.S.A0015 (NumberOf YearDays Schedules Supported)

|TH reads NumberOfYearDay SchedulesSupportedPerUser attribute from DUT
a|
Verify that NumberOfYearDay SchedulesSupportedPerUser contains valid
number in the inclusive range of 0 to 255

|12b | | |TH writes NumberOfYearDay SchedulesSupportedPerUser attribute
as 35 |Verify DUT responds with UNSUPPORTED_WRITE

|12c | | |TH reads NumberOfYearDay SchedulesSupportedPerUser attribute
from DUT |Verify that the NumberOfYearDay SchedulesSupportedPerUser
value remains unchanged.

|13a |5.2.3.14 a|
DRLK.S.F0b(HDSCH),

DRLK.S.A0016 (NumberOfHoliday SchedulesSupported)

|TH reads NumberOfHoliday SchedulesSupported attribute from DUT a|
Verify that NumberOfHoliday SchedulesSupported contains valid number in
the inclusive range of 0 to 255

|13b | | |TH writes NumberOfHoliday SchedulesSupported attribute as 36
|Verify DUT responds with UNSUPPORTED_WRITE

|13c | | |TH reads NumberOfHoliday SchedulesSupported attribute from DUT
|Verify that the NumberOfHoliday SchedulesSupported value remains
unchanged.

|14a |5.2.3.15 a|
DRLK.S.F00(PIN),

DRLK.S.A0017 (MaxPINCodeLength )

|TH reads MaxPINCodeLength attribute from DUT a|
Verify that MaxPINCodeLength contains valid number in the inclusive
range of 0 to 255

|14b | | |TH writes MaxPINCodeLength attribute as 85 |Verify DUT
responds with UNSUPPORTED_WRITE

|14c | | |TH reads MaxPINCodeLength attribute from DUT a|
Verify that the MaxPINCodeLength value remains unchanged.

|15a |5.2.3.16 a|
DRLK.S.F00(PIN),

DRLK.S.A0018 (MinPINCodeLength)

|TH reads MinPINCodeLength attribute from DUT a|
Verify that MinPINCodeLength contains valid number in the inclusive
range of 0 to 255

|15b | | |TH writes MinPINCodeLength attribute as 63 |Verify DUT
responds with UNSUPPORTED_WRITE

|15c | | |TH reads MinPINCodeLength attribute from DUT a|
Verify that the MinPINCodeLength value remains unchanged.

|16a |5.2.3.17 a|
DRLK.S.F01(RID),

DRLK.S.A0019 (MaxRFIDCodeLength)

|TH reads MaxRFIDCodeLength attribute from DUT a|
Verify that MaxRFIDCodeLength contains valid number in the inclusive
range of 0 to 255

|16b | | |TH writes MaxRFIDCodeLength attribute as 46 |Verify DUT
responds with UNSUPPORTED_WRITE

|16c | | |TH reads MaxRFIDCodeLength attribute from DUT |Verify that the
MaxRFIDCodeLength value remains unchanged.

|17a |5.2.3.18 a|
DRLK.S.F01(RID),

DRLK.S.A001a (MinRFIDCodeLength)

|TH reads MinRFIDCodeLength attribute from DUT a|
Verify that MinRFIDCodeLength contains valid number in the inclusive
range of 0 to 255

|17b | | |TH writes MinRFIDCodeLength attribute as 17 |Verify DUT
responds with UNSUPPORTED_WRITE

|17c | | |TH reads MinRFIDCodeLength attribute from DUT |Verify that the
MinRFIDCodeLength value remains unchanged.

|18a |5.2.3.19 a|
DRLK.S.F08(USR),

DRLK.S.A001b (CredentialRulesSupport)

|TH reads Credential RulesSupport attribute from DUT a|
Verify that CredentialRules Support has at least one of the following
bit positions set . bit 0-Single . bit 1-Dual . bit 2-Tri

|18b | | |TH writes Credential RulesSupport attribute as bit 0 is set to
1 |Verify DUT responds with UNSUPPORTED_WRITE

|18c | | |TH reads Credential RulesSupport attribute from DUT |Verify
that the Credential RulesSupport value remains unchanged.

|19a |5.2.22 |DRLK.S.A0021 (Language) a|
* TH reads Language attribute from DUT
* TH saves the values as Current_Language Code

a|
* Verify that it has a string of length maximum to 3 bytes
* Verify the value is of the form ISO-639-1

|19b | | |TH writes Language attribute as fr a|
* If (DRLK.S.A0021 (Language).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|19c | | |TH reads Language attribute from DUT a|
* Verify that the Language value is changed to fr

else

* Verify that the Language value is same as Current_LanguageCode

|20a |5.2.25 |DRLK.S.A0022 (LEDSettings) a|
* TH reads LEDSettings attribute from DUT
* TH saves the values as Current_LEDSettings value

a|
* Verify that LEDSettings contains one of the following values
+
. 0- Never use LED for signalization
. 1- Use LED signalization except for access allowed events
. 2- Use LED signalization for all events

|20b | | |TH writes LEDSettings attribute as 2 a|
* If (DRLK.S.A0022 (LEDSettings).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|20c | | |TH reads LEDSettings attribute from DUT a|
* Verify that the LEDSettings value is changed to 2 else
* Verify that the LEDSettings value is same as Current_LEDSettings value

|21a |5.2.26 |DRLK.S.A0023 (AutoRelockTime) a|
* TH reads AutoRelockTime attribute from DUT
* TH saves the values as Current_AutoRelockTime

|Verify that AutoRelockTime contains valid numbers in the inclusive
range of 0 to 4294967294 seconds

|21b | | |TH writes AutoRelockTime attribute as 180 seconds a|
* If (DRLK.S.A0023 (AutoRelockTime).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|21c | | |TH reads AutoRelockTime attribute from DUT a|
* Verify that the AutoRelockTime is changed to 180 else
* Verify that the AutoRelockTime is same as Current_AutoRelockTime

|22a |5.2.27 |DRLK.S.A0024 (SoundVolume) a|
* TH reads SoundVolume attribute from DUT
* TH saves the values as Current_SoundVolume value

a|
* Verify that SoundVolume contains one of the following values.
+
. 0- Silent Mode
. 1- Low Volume
. 2- High Volume
. 3- Medium Volume

|22b | | |TH writes SoundVolume attribute as 3 a|
* If (DRLK.S.A0024 (SoundVolume).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|22c | | |TH reads SoundVolume attribute from DUT a|
* Verify that the SoundVolume value is changed to 3 else
* Verify that the SoundVolume value is same as Current_SoundVolume value

|23a |5.2.24 |DRLK.S.A0026 (SupportedOperatingModes) |TH reads Supported
OperatingModes attribute from DUT a|
* Verify that Supported OperatingModes has following bit positions set
to 0 for
+
. bit 0-Normal
. bit 3-NoRemoteLockUnlock bit positions set to 1 or set to 0 for
. bit 1-vacation
. bit 2-privacy
. bit 4-Passage
* TH saves the values as Current_Supported OperatingModes value
* Verify that the default value of Supported OperatingModes attribute is
set to 0xFFF6

|23b | | |TH writes Supported OperatingModes attribute as bit 0 is set
to 0 |Verify DUT responds with UNSUPPORTED_WRITE

|23c | | |TH reads Supported OperatingModes attribute from DUT a|
Verify that the Supported OperatingModes value remains unchanged.

|24a |5.2.23 |DRLK.S.A0025 (OperatingMode) a|
* TH reads OperatingMode attribute from DUT
* TH saves the values as Current_OperatingMode value

a|
* Verify that OperatingMode has one of the following Values
+
. 0-Normal,if bit 0 is set to 0 in Current_Supported OperatingModes
. 1-vacation,if bit 0 is set to 1 in Current_Supported OperatingModes
. 2-privacy,if bit 0 is set to 2 in Current_Supported OperatingModes
. 3-NoRemoteLockUnlock,if bit 0 is set to 3 in Current_Supported
OperatingModes
. 4-Passage,if bit 0 is set to 4 in Current_Supported OperatingModes

|24b | | a|
* TH writes OperatingMode attribute to a value as Normal and the new
value is present in SupportedOperatingModes

a|
* If (DRLK.S.A0025 (OperatingMode).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|24c | | a|
* TH writes OperatingMode attribute to a value as NoRemoteLockUnlock and
the new value is present in Supported OperatingModes

a|
* If (DRLK.S.A0025 (OperatingMode).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|24d | | |TH reads OperatingMode attribute from DUT a|
* Verify that the OperatingMode value is changed to Normal or
NoRemoteLockUnlock else
* Verify that the OperatingMode value is same as Current_OperatingMode
value

|25a |5.2.28 |DRLK.S.A0027 (Default ConfigurationRegister) |TH reads
Default ConfigurationRegister attribute from DUT a|
* Verify that the default values are set on the following attributes by
setting the bit to 0
+
. 0 - Enable Local Programming
. 1- Keypad Interface
. 2 - Remote Interface
. 5 - Sound Volume
. 6 - Auto Relock Time
. 7 - Led Settings

|25b | | |TH writes Default ConfigurationRegister attribute as bit 0 is
set to 1 |Verify DUT responds with UNSUPPORTED_WRITE

|25c | | |TH reads Default ConfigurationRegister attribute from DUT
|Verify that the Default ConfigurationRegister value remains unchanged.

|26a |5.2.29 |DRLK.S.A0028 (EnableLocal Programming) a|
* TH reads EnableLocalProgramming attribute from DUT
* TH saves the values as Current_EnableLocal Programming value

a|
Verify that the EnableLocalProgramming value is of bool type

|26b | | a|
TH writes

EnableLocalProgramming attribute as false

a|
* If (DRLK.S.A0028 (EnableLocal Programming).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|26c | | a|
TH reads

EnableLocalProgramming attribute from DUT

a|
* Verify that the EnableLocalProgramming value is changed to false

else

* Verify that the EnableLocalProgramming value is same as
Current_EnableLocal Programming value

|27a |5.2.30 |DRLK.S.A0029 (EnableOne TouchLocking) |TH reads
EnableOneTouchLocking attribute from DUT a|
Verify that the EnableOneTouchLocking value is of bool type

|27b | |DRLK.S.A0029 (EnableOne TouchLocking).Write |TH writes
EnableOneTouchLocking attribute as true |Verify that the DUT send the
success response

|27c | | |TH reads EnableOneTouchLocking attribute from DUT |Verify that
the EnableOneTouchLocking value is changed to true

|28a |5.2.31 |DRLK.S.A002a (EnableInsideStatusLED) |TH reads
EnableInside StatusLED attribute from DUT a|
Verify that the EnableInsideStatusLED value is of bool type

|28b | |DRLK.S.A002a (EnableInsideStatusLED).Write |TH writes
EnableInsideStatusLED attribute as true |Verify that the DUT send the
success response

|28c | | |TH reads EnableInsideStatusLED attribute from DUT |Verify that
the EnableInsideStatusLED value is changed to true

|29a |5.2.32 |DRLK.S.A002b (EnablePrivacy ModeButton) |TH reads
EnablePrivacyModeButton attribute from DUT a|
Verify that the EnablePrivacyModeButton value is of bool type

|29b | |DRLK.S.A002b (EnablePrivacy ModeButton).Write |TH writes
EnablePrivacy ModeButton attribute as true |Verify that the DUT send the
success response

|29c | | |TH reads EnablePrivacyModeButton attribute from DUT |Verify
that the EnablePrivacyModeButton value is changed to true

|30a |5.2.33 |DRLK.S.A002c (LocalProgramming Features) a|
* TH reads LocalProgrammingFeatures attribute from DUT
* TH saves the values as Current_LocalProgramming Features

value

a|
* Verify that LocalProgramming Features has the following bit positions
+
. bit 0 - The ability to add Users/Credentials/Schedules
. bit 1 - The ability to modify Users/Credentials/Schedules
. bit 2 - The ability to clear Users/Credentials/Schedules
. bit 3 - The ability to adjust lock settings locally is enabled

|30b | |DRLK.S.A002c(LocalProgrammingFeatures),
(DRLK.S.A0028(EnableLocalProgramming) |TH reads LocalProgrammingFeatures
attribute from DUT |Verify that the DUT sends SUCCESS response. +
Verify that all the 4 bits in the LocalProgrammingFeatures is set to 1
if EnableLocalProgramming is True. +
Verify that all the 4 bits in the LocalProgrammingFeatures is set to 0
if EnableLocalProgramming is False.

|30c | |(DRLK.S.A0028(EnableLocalProgramming),
(DRLK.S.A002c(LocalProgrammingFeatures).Write) |TH writes to
LocalProgrammingFeatures to disable all the features (Change all bits to
0) |Verify that the DUT sends SUCCESS response. +
Verify that all the 4 bits in the LocalProgrammingFeatures is set to 0.

|30d | |DRLK.S.A002c(LocalProgrammingFeatures) |TH sets the
EnableLocalProgramming attribute to False |Verify that the DUT sends
SUCCESS response. +
Verify that all the 4 bits in the LocalProgrammingFeatures is set to 0.

|30e | |(DRLK.S.A0028(EnableLocalProgramming).Write) |TH sets the
EnableLocalProgramming attribute to True |Verify that the DUT sends
SUCCESS response. +
Verify that all the 4 bits in the LocalProgrammingFeatures is set to 1.

|30f | |(DRLK.S.A002c(LocalProgrammingFeatures).Write) |TH sends a write
message to change any one of the bits of the LocalProgrammingFeatures.
a|
Verify that the DUT sends SUCCESS response. +
Verify that the correct bit has been changed by doing a Read on
LocalProgrammingFeatures attribute.

|30g | |(DRLK.S.A002c(LocalProgrammingFeatures).ReadOnly) |TH sends a
write message to change any one of the bits of the
LocalProgrammingFeatures. a|
Verify that the DUT sends an UNSUPPORTED_WRITE

|31a |5.2.34 a|
DRLK.S.F00(PIN)/

DRLK.S.F01(RID),

DRLK.S.A0030 (WrongCodeEntryLimit)

a|
* TH reads WrongCodeEntry Limit attribute from DUT
* TH saves the values as Current_WrongCode EntryLimit value

a|
Verify that the value is in the inclusive range of 1 to 255

|31b | a|
DRLK.S.F00(PIN)/

DRLK.S.F01(RID),

DRLK.S.A0030 (WrongCodeEntryLimit)

|TH writes WrongCodeEntryLimit attribute as 8 a|
* If (DRLK.S.A0030 (WrongCodeEntryLimit).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|31c | |DRLK.S.A0030 (WrongCodeEntryLimit) |TH reads WrongCode
EntryLimit attribute a|
if (DRLK.S.A0030 (WrongCodeEntryLimit) ) * Verify that the
WrongCodeEntryLimit value is changed to 8

else

* Verify that the WrongCodeEntryLimit value is same as
Current_WrongCodeEntryLimit value

|32a |5.2.35 a|
DRLK.S.F00(PIN)/

DRLK.S.F01(RID),

DRLK.S.A0031 (UserCodedTemporary DisableTime)

a|
* TH reads UserCodeTemporary DisableTime attribute from DUT
* TH saves the values as Current_UserCode TemporaryDisableTime

a|
Verify that the value is in the inclusive range of 1 to 255 seconds

|32b | a|
DRLK.S.F00(PIN)/

DRLK.S.F01(RID),

DRLK.S.A0031 (UserCodedTemporary DisableTime)

|TH writes UserCodeTemporaryDisableTime attribute as 120 a|
* If (DRLK.S.A0031 (UserCodedTemporary DisableTime).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|32c | |DRLK.S.A0031 (UserCodedTemporary DisableTime) |TH reads
UserCodeTemporary DisableTime attribute a|
If (DRLK.S.A0031 (UserCodedTemporary DisableTime).Write)

* Verify that the UserCodeTemporary DisableTime is changed to 120 else
* Verify that the UserCodeTemporary DisableTime is same as
Current_UserCode TemporaryDisableTime

|33a |5.2.37 a|
DRLK.S.F07(COTA)&

DRLK.S.F00(PIN),

DRLK.S.A0033 (RequirePINFor RemoteOperation)

a|
TH reads RequirePINfor RemoteOperation attribute from DUT

a|
Verify that the RequirePINforRemoteOperation value is of bool type

|33b | a|
DRLK.S.F00(PIN),

DRLK.S.A0033 (RequirePINFor RemoteOperation)

|TH writes RequirePINfor RemoteOperation attribute as true a|
* If(DRLK.S.A0033 (RequirePINFor RemoteOperation_Write)) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|33c | a|
DRLK.S.F00(PIN),

DRLK.S.A0033 (RequirePINFor RemoteOperation)

|TH reads RequirePINfor RemoteOperation attribute a|
If(DRLK.S.A0033 (RequirePINFor RemoteOperation_Write))

* Verify that the RequirePINFor RemoteOperation value is changed to true
else
* Verify that the RequirePINFor RemoteOperation value is same as
Current_RequirePINFor RemoteOperation value

|34a |5.2.38 a|
DRLK.S.F08(USR),

DRLK.S.A0035 (Expiring UserTimeOut)

a|
* TH reads ExpiringUserTimeOut attribute from DUT
* TH saves the values as Current_ExpiringUserTimeOut

a|
* Verify that the value is in the inclusive range of 1 to 2880 minutes
* If the Expiring Timeout exceeds the value then DUT is set to
OccupiedDisabled status.

|34b | a|
DRLK.S.F08(USR),

DRLK.S.A0035 (Expiring UserTimeOut)

|TH writes ExpiringUserTimeout attribute as 10 minutes a|
* If(DRLK.S.A0035 (ExpiringUser TimeOut).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|34c | a|
DRLK.S.F08(USR),

DRLK.S.A0035 (Expiring UserTimeOut)

|TH reads ExpiringUserTimeout attribute a|
If(DRLK.S.A0035 (ExpiringUser TimeOut).Write)

* Verify that the ExpiringUserTimeOut is changed to 10 else
* Verify that the ExpiringUserTimeOut is same as
Current_ExpiringUserTimeOut

|35a |5.2.20 a|
DRLK.S.F08(USR),

DRLK.S.A001c (NumberOfCredentials SupportedPerUser )

|TH reads NumberOfCredentials SupportedPerUser attribute from DUT a|
Verify that NumberOfCredentials SupportedPerUser contains valid number
in the inclusive range of 0 to 255

|35b | a|
DRLK.S.F08(USR),

DRLK.S.A001c (NumberOfCredentials SupportedPerUser )

|TH writes NumberOfCredentials SupportedPerUser attribute as 85 |Verify
DUT responds with UNSUPPORTED_WRITE

|35c | a|
DRLK.S.F08(USR),

DRLK.S.A001c (NumberOfCredentials SupportedPerUser )

|TH reads NumberOfCredentials SupportedPerUser attribute from DUT a|
Verify that the NumberOfCredentials SupportedPerUser value remains
unchanged.

|===

[[_tc_drlk_2_2_verification_for_door_lock_commanddut_server]]
===== link:#_tc_drlk_2_2_verification_for_door_lock_commanddut_server[]124.2.2. [TC-DRLK-2.2] Verification for Door lock command[DUT-Server]

[[_category_248]]
====== link:#_category_248[]Category

Functional conformance

[[_purpose_253]]
====== link:#_purpose_253[]Purpose

Verifies the DUT behaviour when it receives Door lock command from TH.

[[_pics_253]]
====== link:#_pics_253[]PICS

* DRLK.S

[[_pre_conditions_28]]
====== link:#_pre_conditions_28[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | |PINCode valid value is 123456 |

|4 | a|
Before sending the Lock Door command proceed following steps:

{empty}1. Send Set User Command and Get User for setting User.

{empty}2. Send Set Credential Command and Get Credential Status for
setting PIN code.

After sending Lock door Command with all condition proceed following
step

{empty}1. Send Clear Credential and Clear User Command.

|
|===

[[_required_devices_253]]
====== link:#_required_devices_253[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH |client
|===

[[_device_topology_208]]
====== link:#_device_topology_208[]Device Topology

[[_test_setup_220]]
====== link:#_test_setup_220[]Test Setup

[[_test_procedure_253]]
====== link:#_test_procedure_253[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) |TH writes the
RequirePINforRemoteOperation attribute value as false on the DUT a|
Verify that the DUT sends SUCCESS response If DRLK.S.A0033(RequirePINFor
RemoteOperation).Write is true, and otherwise responds with
UNSUPPORTED_WRITE

|2 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation) |TH reads the
RequirePINforRemoteOperation attribute from the DUT. Save the current
attribute value as Current_RequirePINValue a|
Verify that the read attribute operation completes successfully

|2a |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation).Write |TH evaluates the value
of saved value Current_RequirePINValue a|
Verify that value of Current_RequirePINValue is FALSE

|3 |5.2.4.1 |DRLK.S.C00.Rsp (Lock Door) |TH sends Lock Door Command to
the DUT without PINCode |Verify that DUT sends SUCCESS response to the
TH if value of Current_RequirePINValue == FALSE, and otherwise responds
with FAILURE if value of Current_RequirePINValue == TRUE

|4 |5.2.4.1 |DRLK.S.C00.Rsp (Lock Door) |TH sends Lock Door Command to
the DUT with valid PINCode |Verify that DUT sends success response to
the TH

|5 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) |TH writes the
RequirePINforRemoteOperation attribute value as true on the DUT a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0033(RequirePINForRemoteOperation).Write is True, and otherwise
responds with UNSUPPORTED_WRITE

|6 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) & DRLK.S.A0033
RequirePINForRemoteOperation) |TH reads the RequirePINforRemoteOperation
attribute from the DUT. Save the current attribute value as
Current_RequirePINValue a|
Verify that the read attribute operation completes successfully

|6a |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation).Write |TH evaluates the value
of saved value Current_RequirePINValue a|
Verify that value of Current_RequirePINValue is TRUE

|7 |5.2.4.1 |DRLK.S.C00.Rsp (Lock Door), DRLK.S.A0033 (RequirePINFor
RemoteOperation) |TH sends Lock Door Command to the DUT with invalid
PINCode a|
Verify that DUT sends failure response to the TH

|8 |5.2.4.1 |DRLK.S.C00.Rsp(Lock Door),
DRLK.S.A0033(RequirePINForRemoteOperation) |TH sends Lock Door Command
to the DUT without PINCode a|
Verify that DUT sends SUCCESS response to the TH if value of
Current_RequirePINValue == FALSE, and otherwise responds with FAILURE if
value of Current_RequirePINValue == TRUE

|9 |5.2.4.1 |DRLK.S.C00.Rsp (Lock Door), DRLK.S.A0033 (RequirePINFor
RemoteOperation) |TH sends Lock Door Command to the DUT with valid
PINCode |Verify that DUT sends success response to the TH

|10a |5.2.3.33 |DRLK.S.A0030(WrongCodeEntryLimit) |TH reads the value of
WrongCodeEntryLimit attribute. |Verify that the returned value is
between 1 and 255.

|10b |5.2.3.33 |DRLK.S.A0030(WrongCodeEntryLimit) |TH sends an Unlock
Door Command from a user say "User1" to the DUT with invalid PINCode. +
Repeat this step PIXIT.DRLK.WrongCodeEntryLimit times. |Verify that DUT
sends failure response to the TH for all the commands sent.

|10c |5.2.3.33 |DRLK.S.A0030(WrongCodeEntryLimit) |TH sends an Unlock
Door Command from User1 to the DUT with the valid PINCode. + |Verify
that DUT sends failure response or no response at all to the TH.

|10d |5.2.3.33 |DRLK.S.A0030(WrongCodeEntryLimit) |Wait for
PIXIT.DRLK.UserCodeTemporaryDisableTime. +
TH then sends an Unlock Door Command from User1 to the DUT with the
valid PINCode. + |Verify that DUT sends a success response.

|10e |5.2.3.33 |DRLK.S.F00(COTA) | DRLK.S.F01(RID) |TH writes
WrongCodeEntryLimit attribute to any number between 1 and 255. a|
Verify that the DUT sends Success response if
DRLK.S.A0030(WrongCodeEntryLimit).Write is True, and otherwise responds
with UNSUPPORTED_WRITE

|11a |5.2.3.33 |DRLK.S.A0031(UserCodedTemporaryDisableTime) |TH reads
the value of UserCodeTemporaryDisableTime attribute |Verify that the
returned value is between 1 and 255.

|12a |5.2.3.33 |DRLK.S.F00(COTA) | DRLK.S.F01(RID) |TH writes
UserCodeTemporaryDisableTime attribute to any number between 1 and 255
on the DUT a|
Verify that the DUT send the Success response if
DRLK.S.A0031(UserCodedTemporaryDisableTime) is True, and otherwise
responds with UNSUPPORTED_WRITE

|===

[[_tc_drlk_2_3_verification_for_unlock_door_command_dut_server]]
===== link:#_tc_drlk_2_3_verification_for_unlock_door_command_dut_server[]124.2.3. [TC-DRLK-2.3] Verification for Unlock Door command [DUT-Server]

[[_category_249]]
====== link:#_category_249[]Category

Functional conformance

[[_purpose_254]]
====== link:#_purpose_254[]Purpose

Verifies the DUT behaviour when it receives Unlock Door command from TH

[[_pics_254]]
====== link:#_pics_254[]PICS

* DRLK.S

[[_pre_conditions_29]]
====== link:#_pre_conditions_29[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | |PINCode valid value is 123456 |

|4 | |Door is in locked state |

|5 | a|
Before sending the Unlock Door command proceed following steps:

{empty}1. Send Set User Command and Get User for setting User.

{empty}2. Send Set Credential Command and Get Credential Status for
setting PIN code.

After sending Unlock Door Command with all condition proceed following
step

{empty}1. Send Clear Credential and Clear User Command.

|
|===

[[_required_devices_254]]
====== link:#_required_devices_254[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH |client
|===

[[_device_topology_209]]
====== link:#_device_topology_209[]Device Topology

[[_test_setup_221]]
====== link:#_test_setup_221[]Test Setup

[[_test_procedure_254]]
====== link:#_test_procedure_254[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) |TH writes the
RequirePINforRemoteOperation attribute value as False on the DUT a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0033(RequirePINForRemoteOperation).Write is True, and otherwise
responds with UNSUPPORTED_WRITE

|2 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation) |TH reads the
RequirePINforRemoteOperation attribute from the DUT. Save the current
attribute value as Current_RequirePINValue a|
Verify that the read attribute operation completes successfully

|2a |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation).Write |TH evaluates the value
of saved value Current_RequirePINValue a|
Verify that value of Current_RequirePINValue is FALSE

|3 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door) |TH sends Unlock Door Command
to the DUT without PINCode |Verify that DUT sends SUCCESS response to
the TH if value of Current_RequirePINValue == FALSE, and otherwise
responds with FAILURE if value of Current_RequirePINValue == TRUE

|4 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door) |TH sends Unlock Door Command
to the DUT with valid PINCode |Verify that DUT sends SUCCESS response to
the TH

|5 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) |TH writes the
RequirePINforRemoteOperation attribute value as true on the DUT a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0033(RequirePINForRemoteOperation).Write is True, and otherwise
responds with UNSUPPORTED_WRITE

|6 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation) |TH reads the
RequirePINforRemoteOperation attribute from the DUT. Save the current
attribute value as Current_RequirePINValue a|
Verify that the read attribute operation completes successfully

|6a |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation).Write |TH evaluates the value
of saved value Current_RequirePINValue a|
Verify that value of Current_RequirePINValue is TRUE

|7 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door), DRLK.S.A0033 (RequirePINFor
RemoteOperation) |TH sends Unlock Door Command to the DUT with Invalid
PINCode a|
Verify that DUT sends failure response to the TH

|8 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door), DRLK.S.A0033 (RequirePINFor
RemoteOperation) |TH sends Unlock Door Command to the DUT without
PINCode a|
Verify that DUT sends SUCCESS response to the TH if value of
Current_RequirePINValue == FALSE, and otherwise responds with FAILURE if
value of Current_RequirePINValue == TRUE

|9 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door), DRLK.S.A0033 (RequirePINFor
RemoteOperation) |TH sends Unlock Door Command to the DUT with valid
PINCode |Verify that DUT sends SUCCESS response to the TH

|10 |5.2.3.33 |DRLK.S.F00(PIN) | DRLK.S.F01(RID) |TH writes
WrongCodeEntryLimit attribute value as 3 on the DUT a|
Verify that the DUT sends Success response if DRLK.S.A0030
(WrongCodeEntryLimit).Write is True, and otherwise responds with
UNSUPPORTED_WRITE

|11 |5.2.3.33 |DRLK.S.F00(PIN) | DRLK.S.F01(RID) |TH writes
UserCodeTemporaryDisableTime attribute value as 15 seconds on the DUT a|
Verify that the DUT send the Success response if DRLK.S.A0031
(UserCodedTemporary DisableTime).Write is True, and otherwise responds
with UNSUPPORTED_WRITE

|12 |5.2.4.2,5.2.3.34 |DRLK.S.C01.Rsp(Unlock Door) |TH sends Unlock Door
Command to the DUT with invalid PINCode |Verify that DUT sends failure
response to the TH

|13 |5.4.2.1, 5.2.3.34 |(DRLK.S.F00(PIN) | DRLK.S.F01(RID)) &
DRLK.S.A0031 (UserCodedTemporary DisableTime) a|
Repeat the above step 3 times

* TH reads UserCodedTemporaryDisableTime attribute from DUT

a|
After sending 3 failure responses verify that
UserCodeTemporaryDisableTime attribute is triggered

|14 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door) |TH sends Unlock Door Command
to the DUT with valid PINCode before UserCodeTemporaryDisableTime
expires |Verify that DUT sends failure response to the TH

|15 |5.2.3.25 | |TH writes AutoRelockTime attribute value as 60 seconds
on the DUT After UserCodeTemporaryDisableTime expires a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0023(AutoRelockTime).Write is True, and otherwise responds with
UNSUPPORTED_WRITE

|16 |5.2.3.25 |DRLK.S.A0023(AutoRelockTime) |TH reads AutoRelockTime
attribute from the DUT a|
Verify that the AutoRelockTime is changed to 60

|17 |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door) |TH sends the Unlock Door
command to the DUT with valid PINCode |Verify that DUT sends SUCCESS
response to the TH

|18 |5.2.3.1 |DRLK.S.A0000(LockState ) |TH reads LockState attribute
after AutoRelockTime Expires and the lock action has been completed
(e.g. motor movement finished) |Verify that the DUT is locked.
|===

[[_tc_drlk_2_4_verification_for_unlock_with_timeout_command_dut_server]]
===== link:#_tc_drlk_2_4_verification_for_unlock_with_timeout_command_dut_server[]124.2.4. [TC-DRLK-2.4] Verification for Unlock with Timeout command [DUT-Server]

[[_category_250]]
====== link:#_category_250[]Category

Functional conformance

[[_purpose_255]]
====== link:#_purpose_255[]Purpose

Verifies the DUT behaviour when it receives Unlock with Timeout command
from TH

[[_pics_255]]
====== link:#_pics_255[]PICS

* DRLK.S

[[_pre_conditions_30]]
====== link:#_pre_conditions_30[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | |PINCode valid value is 123456 |

|4 | |Door is in locked state |

|5 | a|
Before sending the Unlock with Timeout command proceed following steps:

{empty}1. Send Set User Command and Get User for setting User

{empty}2. Send Set Credential Command and Get Credential Status for
setting PIN code

After sending Unlock with Timeout Command with all condition proceed
following step

{empty}1. Send Clear Credential and Clear User Command.

|
|===

[[_required_devices_255]]
====== link:#_required_devices_255[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_210]]
====== link:#_device_topology_210[]Device Topology

[[_test_setup_222]]
====== link:#_test_setup_222[]Test Setup

[[_test_procedure_255]]
====== link:#_test_procedure_255[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |5.2.3.25 |DRLK.S.A0023(AutoRelockTime) |TH writes AutoRelockTime
attribute value as 60 seconds on the DUT a|
* If(DRLK.S.A0023(AutoRelockTime).Write) supports
* Verify that the DUT sends SUCCESS response else
* Verify DUT responds with UNSUPPORTED_WRITE

|2 |5.2.4.3 |DRLK.S.C03.Rsp(Unlock with Timeout) |TH sends the Unlock
with Timeout command to the DUT with valid PINCode and the Timeout
argument value as 60 seconds a|
* Verify that DUT sends success response to the TH
* Verify that AutoRelockTime attribute is triggered
* Verify that DUT is relocked when Timeout value expires

|===

[[_tc_drlk_2_5_verification_for_the_following_commands_set_week_day_schedule_get_week_day_schedule_get_week_day_schedule_response_clear_week_day_schedule_dut_server]]
===== link:#_tc_drlk_2_5_verification_for_the_following_commands_set_week_day_schedule_get_week_day_schedule_get_week_day_schedule_response_clear_week_day_schedule_dut_server[]124.2.5. [TC-DRLK-2.5] Verification for the following Commands - Set Week Day Schedule, Get Week Day Schedule , Get Week Day Schedule Response, Clear Week Day Schedule [DUT-Server]

[[_category_251]]
====== link:#_category_251[]Category

Functional conformance

[[_purpose_256]]
====== link:#_purpose_256[]Purpose

Verifies the DUT behaviour when it receives Set Week Day Schedule, Get
Week Day Schedule, Clear Week Day Schedule Command from TH.

[[_pics_256]]
====== link:#_pics_256[]PICS

* DRLK.S

[[_pre_conditions_31]]
====== link:#_pre_conditions_31[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | a|
Before sending the Set Week Day Schedule command proceed following step:

{empty}1. Send Set User Command and Get User for setting User.

After sending Set Week Day Schedule,Get Week Day Schedule,Clear Week Day
Schedule Commands with all condition proceed following step

{empty}1. Send Clear User Command.

|
|===

[[_required_devices_256]]
====== link:#_required_devices_256[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_211]]
====== link:#_device_topology_211[]Device Topology

[[_test_setup_223]]
====== link:#_test_setup_223[]Test Setup

[[_test_procedure_256]]
====== link:#_test_procedure_256[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | a|
DRLK.S.F04(WDSCH),

DRLK.S.A0014 (NumberOfWeekDays SchedulesSupported)

|TH reads NumberOfWeekDay SchedulesSupportedPerUser attribute and saves
for future use. |Verify that NumberOfWeekDays SchedulesSupporterUser
contains valid number in the inclusive range of 0 to 255

|2 | a|
DRLK.S.F08(USR),

DRLK.S.A0011 (NumberOfTotalUsers Supported )

|TH reads NumberOfTotalUsers Supported attribute and saves for future
use. |Verify that NumberOfTotalUsers Supported contains valid number in
the inclusive range of 0 to 65534

|3 |5.2.4.14 a|
DRLK.S.F04(WDSCH),

DRLK.S.C0b.Rsp (SetWeekDaySchedule)

a|
TH send Set Week Day Schedule Command to DUT with the following values:

* WeekDayIndex as 1
* UserIndex as 1
* DaysMaskMap as 2
* StartHour as 15
* StartMinute as 45
* EndHour as 16
* EndMinute as 55

a|
* Verify that the DUT sends SUCCESS response

|4 |5.2.4.15 |DRLK.S.F04(WDSCH), DRLK.S.C0c.Rsp (GetWeekDaySchedule)
DRLK.S.C0c.Tx (GetWeekDaySchedule Response) a|
TH send Get Week Day Schedule Command to DUT with

* WeekDayIndex as 1
* UserIndex as 1

a|
* Verify that the DUT responds with Get Week Day Schedule Response
Command
* Verify that the DUT responds with WeekDayIndex as 1 .
* Verify that the DUT responds with UserIndex as 1 .
* Verify that the DUT responds with Status as SUCCESS .
* Verify that the DUT responds with DaysMaskMap as 2 .
* Verify that the DUT responds with StartHour as 15 .
* Verify that the DUT responds with StartMinute as 45 .
* Verify that the DUT responds with EndHour as 16 .
* Verify that the EndHour is greater than or equal to the StartHour
provided in the step 3.
* Verify that the DUT responds with EndMinute as 55 .
* Verify that the EndMinute is greater than the StartMinute provided in
the step 3.

|5 |5.2.4.14 a|
DRLK.S.F04(WDSCH),

DRLK.S.C0b.Rsp (SetWeekDaySchedule)

a|
TH send Set Week Day Schedule Command to DUT with the following values:

* WeekDayIndex as 0 (invalid value)
* UserIndex as 1
* DaysMaskMap as 7 (invalid value)
* StartHour as 15
* StartMinute as 45
* EndHour as 16
* EndMinute as 55

|Verify that the DUT sends the response as INVALID_COMMAND.

|6 |5.2.4.15 a|
DRLK.S.F04(WDSCH),

DRLK.S.C0c.Rsp (GetWeekDaySchedule)

DRLK.S.C0c.Tx (GetWeekDay ScheduleResponse)

a|
TH send Get Week Day Schedule Command to DUT

* WeekDayIndex as 0
* UserIndex as 1

a|
Verify that the DUT sends an INVALID_COMMAND .

|7 |5.2.4.17 a|
DRLK.S.F04(WDSCH),

DRLK.S.C0d.Rsp (ClearWeekDaySchedule)

a|
TH sends Clear Week Day Schedule Command to DUT with

* WeekDayIndex as 1
* UserIndex as 1

a|
* Verify that the DUT send SUCCESS response.

|8 |5.2.4.15 |DRLK.S.F04(WDSCH), DRLK.S.C0c.Rsp (Get Week Day Schedule)
DRLK.S.C0c.Tx (GetWeekDay ScheduleResponse) a|
* TH sends Get Week Day Schedule Command to DUT with following values:
* WeekDayIndex as 1
* UserIndex as 1

a|
Verify that the DUT sends a NOT_FOUND status .

|===

[[_tc_drlk_2_6_verification_for_the_following_commands_set_holiday_schedule_get_holiday_schedule_get_holiday_schedule_response_clear_holiday_schedule_dut_server]]
===== link:#_tc_drlk_2_6_verification_for_the_following_commands_set_holiday_schedule_get_holiday_schedule_get_holiday_schedule_response_clear_holiday_schedule_dut_server[]124.2.6. [TC-DRLK-2.6] Verification for the following Commands - Set Holiday Schedule, Get Holiday Schedule, Get Holiday Schedule Response , Clear Holiday Schedule [DUT-Server]

[[_category_252]]
====== link:#_category_252[]Category

Functional conformance

[[_purpose_257]]
====== link:#_purpose_257[]Purpose

Verifies the DUT behaviour when it receives Set Holiday Schedule,Get
Holiday Schedule,Clear Holiday Schedule Command from TH.

[[_pics_257]]
====== link:#_pics_257[]PICS

* DRLK.S

[[_pre_conditions_32]]
====== link:#_pre_conditions_32[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 |DUT |DUT as server |2
|===

[[_required_devices_257]]
====== link:#_required_devices_257[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_212]]
====== link:#_device_topology_212[]Device Topology

[[_test_setup_224]]
====== link:#_test_setup_224[]Test Setup

[[_test_procedure_257]]
====== link:#_test_procedure_257[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |DRLK.S.F0b(HDSCH) , DRLK.S.A0016 (NumberOfHoliday
SchedulesSupported) |TH reads NumberOfHoliday SchedulesSupported and
saves for future use. |Verify that NumberOfHoliday SchedulesSupported
contains valid number in the inclusive range of 0 to 255

|2 |5.2.4.22, 5.2.6.12 a|
DRLK.S.F0b(HDSCH) ,

DRLK.S.C11.Rsp (SetHolidaySchedule)

a|
TH sends Set Holiday Schedule Command to DUT with the following values:

* HolidayIndex as 1
* LocalStartTime as 20 Seconds
* LocalEndTime as 30 Seconds
* OperatingMode as 0

a|
* Verify that the DUT sends SUCCESS response

|3a |5.2.4.23 a|
DRLK.S.F0b(HDSCH) ,

DRLK.S.C12.Rsp (GetHolidaySchedule),

DRLK.S.C12.Tx (GetHoliday ScheduleResponse)

|TH sends Get Holiday Schedule Command to DUT with HolidayIndex as 1 a|
* Verify that the DUT responds with Get Holiday Schedule Response
command.
* Verify that the DUT responds with HolidayIndex as 1 .
* Verify that the DUT responds with LocalStartTime as 20 Seconds .
* Verify that the DUT responds with LocalEndTime as 30 Seconds.
* Verify that the LocalEndTime is greater than the LocalStartTime.
* Verify that the DUT responds with OperatingMode as 0 .

|4 | |DRLK.S.C11.Rsp (SetHolidaySchedule) a|
TH sends Set Holiday Schedule Command to DUT with the following values:

* HolidayIndex as 1
* LocalStartTime as 20
* LocalEndTime as 30
* OperatingMode as 5(Invalid value)

|Verify that the DUT sends INVALID_COMMAND response .

|5 |5.2.4.23 a|
DRLK.S.F0b(HDSCH) ,

DRLK.S.C12.Rsp (GetHolidaySchedule),

DRLK.S.C12.Tx (GetHoliday ScheduleResponse)

|TH sends Get Holiday Schedule Command to DUT with Invalid HolidayIndex
as 15. |Verify that the DUT sends a INVALID_COMMAND.

|6 |5.2.4.23 a|
DRLK.S.F0b(HDSCH) ,

DRLK.S.C12.Rsp (GetHolidaySchedule)

DRLK.S.C12.Tx (GetHoliday ScheduleResponse)

a|
* TH sends Get Holiday Schedule Command to DUT with the HolidayIndex as
10 (value is in the the range of step 1 but Holiday Schedule entry not
available)

a|
Verify that the DUT sends a NOT_FOUND status

|7 |5.2.4.25 a|
DRLK.S.F0b(HDSCH),

DRLK.S.C13.Rsp (ClearHolidaySchedule)

a|
TH send Clear Holiday Schedule Command to DUT with HolidayIndex as 1

a|
* Verify that the DUT sends SUCCESS response.

|8 |5.2.4.23 a|
DRLK.S.F0b(HDSCH) ,

DRLK.S.C12.Rsp (GetHolidaySchedule)

DRLK.S.C12.Tx (GetHolidayScheduleResponse)

a|
TH sends Get Holiday Schedule Command to DUT with HolidayIndex as 1.

a|
Verify that the DUT sends a NOT_FOUND status .

|===

[[_tc_drlk_2_7_verification_for_the_following_commands_set_year_schedule_get_year_schedule_get_year_day_schedule_response_and_clear_year_day_scheduledut_server]]
===== link:#_tc_drlk_2_7_verification_for_the_following_commands_set_year_schedule_get_year_schedule_get_year_day_schedule_response_and_clear_year_day_scheduledut_server[]124.2.7. [TC-DRLK-2.7] Verification for the following Commands - Set Year Schedule, Get Year Schedule, Get Year Day Schedule Response and Clear Year Day Schedule[DUT-Server]

[[_category_253]]
====== link:#_category_253[]Category

Functional conformance

[[_purpose_258]]
====== link:#_purpose_258[]Purpose

Verifies the DUT behaviour when it receives Set Year Schedule Command,
Get Year Schedule Command and Clear Year Day Schedule from TH.

[[_pics_258]]
====== link:#_pics_258[]PICS

* DRLK.S

[[_pre_conditions_33]]
====== link:#_pre_conditions_33[]Pre-Conditions

[width="100%",cols="11%,13%,40%,36%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | a|
Before sending the Set Year Day Schedule command proceed following step:

{empty}1. Send Set User Command and Get User for setting User.

After sending Set Year Day Schedule, Get Year Schedule, Clear Year Day
Schedule Commands with all condition proceed following step

{empty}1. Send Clear User Command.

|
|===

[[_required_devices_258]]
====== link:#_required_devices_258[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_213]]
====== link:#_device_topology_213[]Device Topology

[[_test_setup_225]]
====== link:#_test_setup_225[]Test Setup

[[_test_procedure_258]]
====== link:#_test_procedure_258[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | a|
DRLK.S.F0a(YDSCH),

DRLK.S.A0015 (NumberOfYearDays SchedulesSupported)

|TH reads NumberOfYearDay SchedulesSupportedPerUser attribute and saves
for future use. |Verify that NumberOfYearDay SchedulesSupportedPerUser
contains valid number in the inclusive range of 0 to 255

|2 | a|
DRLK.S.F08(USR),

DRLK.S.A0011 (NumberOfTotalUsers Supported )

|TH reads NumberOfTotalUsers Supported attribute and saves for future
use. |Verify that NumberOfTotalUsers Supported contains valid number in
the inclusive range of 0 to 65534

|3 |5.2.4.11. a|
DRLK.S.F0a(YDSCH),

DRLK.S.C0e.Rsp (SetYearDaySchedule)

a|
TH sends Set Year Day Schedule Command to DUT with the following values:

* YearDayIndex as 1
* UserIndex as 1
* LocalStartTime as 960 Seconds
* LocalEndTime as 1980 Seconds

a|
Verify that the DUT sends SUCCESS response

|4a |5.2.4.11 a|
DRLK.S.F0a(YDSCH),

DRLK.S.C0f.Rsp (GetYearDaySchedule)

DRLK.S.C0f.Tx (GetYearDay ResponseSchedule)

a|
TH sends Get Year Day Schedule Command to DUT with the following values:

* YearDayIndex as 1
* UserIndex as 1

a|
Verify that the DUT respond with the Get Year Day Schedule Response
Command

|4b | | | a|
* Verify that the DUT responds with YearDayIndex as 1 .
* Verify that the DUT responds with UserIndex as 1 .
* Verify that the DUT responds with LocalStartTime as 960 seconds .
* Verify that the DUT responds with LocalEndTime as 1980 seconds .
* Verify that the LocalEndTime is greater than LocalStartTime .
* Verify that the DUT responds with Status as SUCCESS .

|5 |5.2.4.11. |DRLK.S.C0e.Rsp(Set Year Day Schedule) a|
TH send Set Year Day Schedule Command to DUT with the following values:

* YearDayIndex as 0(Invalid value)
* UserIndex as 15(Invalid value)
* LocalStartTime as 1020
* LocalEndTime as 2040

a|
Verify that the DUT sends a INVALID_COMMAND .

|6 |5.2.4.11 a|
DRLK.S.F0a(YDSCH),

DRLK.S.C0f.Rsp (GetYearDaySchedule) DRLK.S.C0f.Tx (GetYearDay
ResponseSchedule)

a|
TH sends Get Year Day Schedule Command to DUT with

* YearDayIndex as 0
* UserIndex as 15

|Verify that the DUT sends the Status as INVALID_COMMAND.

|7 |5.2.4.11 a|
DRLK.S.F0a(YDSCH),

DRLK.S.C0f.Rsp (GetYearDaySchedule)

DRLK.S.C0f.Tx (GetYearDay ResponseSchedule)

a|
* Create a new user with UserIndex as 5 then TH sends Get Year Day
Schedule Command to DUT with
* YearDayIndex as 10 (value is in the the range of step 1 but YearDay
Schedule entry not available)
* UserIndex as 5

|Verify that the DUT sends the Status as NOT_FOUND .

|8 |5.2.4.11 |DRLK.S.C10.Rsp (ClearYearDaySchedule) a|
TH sends Clear Year Day Schedule to DUT with

* YearDayIndex as 1
* UserIndex as 1

a|
* Verify that the DUT sends Status as SUCCESS.

|9 |5.2.4.11 a|
DRLK.S.F0a(YDSCH),

DRLK.S.C0f.Rsp (GetYearDaySchedule)

DRLK.S.C0f.Tx (GetYearDayResponseSchedule)

a|
TH sends Get Year Day Schedule Command to DUT with

* YearDayIndex as 1 (value is in the the range of step 1 but YearDay
Schedule entry not available)
* UserDayIndex as 1

|Verify that the DUT sends the Status as NOT_FOUND .

|10 |5.2.4.11. |DRLK.S.C0e.Rsp(Set Year Day Schedule) a|
TH sends Set Year Day Schedule Command to DUT with the following values:

* YearDayIndex as 1
* UserIndex as 1
* LocalStartTime as 1080 Seconds
* LocalEndTime as 2100 Seconds

a|
Verify that the DUT sends SUCCESS response.

|11 |5.2.4.11 a|
DRLK.S.F0a(YDSCH),

DRLK.S.C0f.Rsp (GetYearDaySchedule)

DRLK.S.C0f.Tx (GetYearDayResponseSchedule)

a|
TH sends Get Year Day Schedule Command to DUT with

* YearDayIndex as 1
* UserDayIndex as 1

a|
* Verify that the DUT sends Get Year Day Schedule Response Command.
* Verify that the DUT responds with YearDayIndex as 1.
* Verify that the DUT responds with UserIndex as 1 .
* Verify that the DUT responds with status as SUCCESS .
* Verify that the DUT responds with LocalStartTime as 1080 Seconds.
* Verify that the DUT responds with LocalEndTime as 2100 Seconds.
* Verify that the LocalEndTime is greater than LocalStartTime.

|12 |5.2.4.11 a|
DRLK.S.F0a(YDSCH),

DRLK.S.C10.Rsp (ClearYearDaySchedule)

a|
TH sends Clear Year Day Schedule to DUT with

* YearDayIndex as 0(Invalid value)
* UserIndex as 0 (Invalid value)

|Verify that the DUT sends Status as INVALID_COMMAND.
|===

[[_tc_drlk_2_8_verification_for_the_following_commands_set_user_get_user_get_user_response_clear_user_dut_server]]
===== link:#_tc_drlk_2_8_verification_for_the_following_commands_set_user_get_user_get_user_response_clear_user_dut_server[]124.2.8. [TC-DRLK-2.8] Verification for the following Commands - Set User, Get User, Get User Response, Clear User [DUT-Server]

[[_category_254]]
====== link:#_category_254[]Category

Functional conformance

[[_purpose_259]]
====== link:#_purpose_259[]Purpose

Verifies the DUT behaviour when it receives Set User Command, Get User
Command and Clear User Command from TH.

[[_pics_259]]
====== link:#_pics_259[]PICS

* DRLK.S

[[_pre_conditions_34]]
====== link:#_pre_conditions_34[]Pre-Conditions

[width="100%",cols="11%,13%,40%,36%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |
|2 | |Lock device is the DUT |
|===

[[_required_devices_259]]
====== link:#_required_devices_259[]Required Devices

[width="100%",cols="11%,47%,42%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_214]]
====== link:#_device_topology_214[]Device Topology

[[_test_setup_226]]
====== link:#_test_setup_226[]Test Setup

[[_test_procedure_259]]
====== link:#_test_procedure_259[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | a|
DRLK.S.F08(USR),

DRLK.S.A0011 (NumberOfTotal UsersSupported )

|TH reads NumberOfTotalUsers Supported attribute and saves for future
use. |Verify that NumberOfTotal UsersSupported contains valid number in
the inclusive range of 0 to 65534

|2 |5.2.4.34 a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

* OperationType as 0
* UserIndex as 1
* UserName as xxx
* UserUniqueID as 6452
* UserStatus as 1
* UserType as 0
* CredentialRule as 0

a|
Verify that the DUT sends SUCCESS response

|3 |5.2.4.35 a|
DRLK.S.F08(USR),

DRLK.S.C1b.Rsp (Get User)

DRLK.S.C1c.Tx (Get User Response)

a|
TH sends Get User Command to DUT with UserIndex as 1

a|
* Verify that the DUT responds with Get User Response Command
* Verify that the DUT responds with UserIndex as 1 .
* Verify that the DUT responds with UserName as xxx .
* Verify that the DUT responds with UserUniqueID as 6452 .
* Verify that the DUT responds with UserStatus as 1 .
* Verify that the DUT responds with UserType as 0 .
* Verify that the DUT responds with CredentialRule as 0 .
* Verify that the DUT responds with Credentials as null .
* Verify that the DUT responds with NextUserIndex as NOT null if there
is at least one occupied entry after the requested UserIndex .
* Verify that the DUT responds with NextUserIndex as null If the
occupied entries are not available

|4 |5.2.4.34 a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

* OperationType as 0
* UserIndex as 2
* UserName as xxx
* UserUniqueID as 6452
* UserStatus as 1
* UserType as 10 (Invalid value)
* CredentialRule as 3

|Verify that the DUT sends INVALID_COMMAND .

|5 |5.2.4.34 a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

* OperationType as 0
* UserIndex as 1 (Same as step 2)
* UserName as xxx
* UserUniqueID as 8965
* UserStatus as 1
* UserType as 0
* CredentialRule as 0

|Verify that the DUT sends OCCUPIED .

|6a | a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

* OperationType as 0
* UserIndex as 2
* UserName as NULL
* UserUniqueID as NULL
* UserStatus as NULL
* UserType as NULL
* CredentialRule as NULL

|Verify that the DUT sends SUCCESS response

|6b | | |TH sends Get User Command to DUT with UserIndex as 2 a|
* Verify that the DUT responds with Get User Response Command .
* Verify that the DUT responds with UserName as empty .
* Verify that the DUT responds with UserUniqueID as NULL .
* Verify that the DUT responds with UserStatus as default value If the
OperationType is Add .
* Verify that the DUT responds with UserType as default value If the
OperationType is Add .
* Verify that the DUT responds with CredentialRule as default value If
the OperationType is Add .
* Verify that the DUT responds with Credentials as null .
* Verify that the DUT responds with NextUserIndex as NOT null if there
is at least one occupied entry after the requested UserIndex .
* Verify that the DUT responds with NextUserIndex as null If the
occupied entries are not available .

|7 | a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

* OperationType as 2
* UserIndex as 2
* UserName as NULL
* UserUniqueID as NULL
* UserStatus as NULL
* UserType as NULL
* CredentialRule as NULL

a|
Verify that the DUT sends SUCCESS response

|8 |5.2.4.35 a|
DRLK.S.F08(USR),

DRLK.S.C1b.Rsp (Get User)

DRLK.S.C1c.Tx (Get User Response)

a|
TH sends Get User Command to DUT with the UserIndex as 2

a|
* Verify that the DUT sends Get User Response Command
* Verify that the DUT responds with UserIndex as 2 .
* Verify that the DUT responds with UserName as empty .
* Verify that the DUT responds with UserUniqueID as null .
* Verify that the DUT responds with UserStatus as default value If the
OperationType is Add .
* Verify that the DUT responds with UserType as default value If the
OperationType is Add .
* Verify that the DUT responds with CredentialRule as default value If
the OperationType is Add .
* Verify that the DUT responds with Credentials as null .
* Verify that the DUT responds with NextUserIndex as NOT null if there
is at least one occupied entry after the requested UserIndex .
* Verify that the DUT responds with NextUserIndex as null If the
occupied entries are not available .

|9 | a|
DRLK.S.F08(USR),

DRLK.S.C1d.Rsp (Clear User)

|TH sends Clear User Command to DUT with the UserIndex as 1 a|
Verify that the DUT sends SUCCESS response

|10 |5.2.4.35 a|
DRLK.S.F08(USR),

DRLK.S.C1b.Rsp (Get User)

DRLK.S.C1c.Tx (Get User Response)

a|
TH sends Get User Command to DUT with the UserIndex as 1

a|
* Verify that the DUT sends Get User Response Command
* Verify that the DUT sends the response as NULL

|===

[[_tc_drlk_2_9_verification_for_the_following_commands_set_credential_set_credential_response_get_credential_status_get_credential_status_response_clear_credential_dut_server]]
===== link:#_tc_drlk_2_9_verification_for_the_following_commands_set_credential_set_credential_response_get_credential_status_get_credential_status_response_clear_credential_dut_server[]124.2.9. [TC-DRLK-2.9] Verification for the following Commands - Set Credential , Set Credential Response, Get Credential Status, Get Credential Status Response, Clear Credential [DUT-Server]

[[_category_255]]
====== link:#_category_255[]Category

Functional conformance

[[_purpose_260]]
====== link:#_purpose_260[]Purpose

Verifies the DUT behaviour when it receives Set Credential, Get
Credential Status and Clear Credential from TH.

[[_pics_260]]
====== link:#_pics_260[]PICS

* DRLK.S

[[_pre_conditions_35]]
====== link:#_pre_conditions_35[]Pre-Conditions

[width="100%",cols="11%,13%,40%,36%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | a|
Before sending the Set Credential command proceed following step:

{empty}1. Send Set User Command and Get User for setting User.

After sending Set Credential, Get Credential Status and Clear Credential
Commands with all condition proceed following step

{empty}1. Send Clear User Command

|
|===

[[_required_devices_260]]
====== link:#_required_devices_260[]Required Devices

[width="100%",cols="11%,47%,42%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_215]]
====== link:#_device_topology_215[]Device Topology

[[_test_setup_227]]
====== link:#_test_setup_227[]Test Setup

[[_test_procedure_260]]
====== link:#_test_procedure_260[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | a|
DRLK.S.F08(USR),

DRLK.S.A0011 (NumberOfTotalUsers Supported )

|TH reads NumberOfTotalUsers Supported attribute and saves for future
use. |Verify that NumberOfTotalUsers Supported contains valid number in
the inclusive range of 0 to 65534

|2 | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 0
* Credential as 1 1
* CredentialData as 123456
* UserIndex as 1
* UserStatus as null
* UserType as null

a|
* Verify that the DUT responds with Set Credential Response command.
* Verify that the DUT responds with Status as SUCCESS.
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not NULL if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is NULL if the entries are not
available

|3 | a|
DRLK.S.F08(USR),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 1
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is of bool type .
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not NULL if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is NULL if the entries are not
available

|4 | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 0
* Credential as 1 2
* CredentialData as 4321
* UserIndex as null
* UserStatus as 5(Invalid value)
* UserType as 10(Invalid value)

|Verify that the DUT sends Set Credential Response with status as
INVALID_COMMAND .

|5 | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 0
* Credential as 1 2
* CredentialData as 123456 (same as step 2)
* UserIndex as null
* UserStatus as null
* UserType as null

|Verify that the DUT sends Set Credential Response command with status
as DUPLICATE .

|6a | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 0
* Credential as 1 1 (same as step 2)
* CredentialData as 123456
* UserIndex as 1
* UserStatus as null
* UserType as null

|Verify that the DUT sends Set Credential Response command with status
as DUPLICATE or OCCUPIED .

|6b | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 0
* Credential as 1 1 (same as step 2)
* CredentialData as 123457
* UserIndex as 1
* UserStatus as null
* UserType as null

|Verify that the DUT sends Set Credential Response command with status
as DUPLICATE or OCCUPIED .

|7 | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 2
* Credential as 1 3
* CredentialData as 1234567
* UserIndex as 1
* UserStatus as null
* UserType as null

|Verify that the DUT sends Set Credential Response command with status
INVALID_COMMAND(0x85) if the CredentialIndex is not associated with the
UserIndex.

|8 | a|
DRLK.S.F08(USR),

DRLK.S.C26.Rsp (Clear Credential)

a|
TH sends Clear Credential Command to DUT with the following fields:

* CredentialType as 1
* CredentialIndex as 1

a|
* Verify that the DUT sends SUCCESS response

|9 | a|
DRLK.S.F08(USR),

DRLK.S.C24.Rsp (Get Credential)

a|
TH sends Get Credential command to DUT with the following fields:

* CredentialType as 1
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command
* Verify that the CredentialType for the provided value is cleared.
* Verify that the CredentialIndex for the provided value is cleared.

|10 |5.2.4.34 a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

* OperationType as 0
* UserIndex as 2
* UserName as xxx
* UserUniqueID as 6452
* UserStatus as 1
* UserType as 0
* CredentialRule as 0

a|
Verify that the DUT sends SUCCESS response

|11 | a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp (Set Credential)

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType as 0
* Credential as 1 1
* CredentialData as 123456
* UserIndex as 1
* UserStatus as null
* UserType as null

|Verify that the DUT sends Set Credential response command as SUCCESS.

|12a | a|
DRLK.S.F08(USR),

DRLK.S.C26.Rsp (Clear Credential)

a|
TH sends Clear Credential Command to DUT with the following fields:

* CredentialType as 1
* CredentialIndex as 0xFFFE

|Verify that the DUT sends SUCCESS response

|12b | a|
DRLK.S.F08(USR),

DRLK.S.C24.Rsp (Get Credential)

a|
TH sends Get Credential command to DUT with the following fields:

* CredentialType as 1
* CredentialIndex as 0xFFFE

a|
* Verify that the CredentialType for the provided value is cleared.
* Verify that the CredentialIndex is cleared.

|13 | a|
DRLK.S.F08(USR),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 1
* CredentialIndex as 1

|Verify that the DUT responds with Get Credential Status Response
Command with credentialExists==FALSE and userIndex==null

|14 | a|
DRLK.S.F08(USR),

DRLK.S.C26.Rsp (Clear Credential)

a|
TH sends Clear Credential Command to DUT with the following fields:

* CredentialType as 8(Invalid value)
* CredentialIndex as 2

|Verify that the DUT sends a INVALID_COMMAND if any of the values are
invalid.
|===

[[_notestesting_considerations_232]]
====== link:#_notestesting_considerations_232[]Notes/Testing Considerations

Test Step 7 cannot be executed with V1.0 SDK

[[_tc_drlk_2_10_verification_for_the_door_lock_events_dut_server]]
===== link:#_tc_drlk_2_10_verification_for_the_door_lock_events_dut_server[]124.2.10. [TC-DRLK-2.10] Verification for the Door Lock Events [DUT-Server]

[[_category_256]]
====== link:#_category_256[]Category

Functional conformance

[[_purpose_261]]
====== link:#_purpose_261[]Purpose

To verify that all the events are implemented.

[[_pics_261]]
====== link:#_pics_261[]PICS

* DRLK.S

[[_pre_conditions_36]]
====== link:#_pre_conditions_36[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | a|
Before sending the Events proceed following steps:

{empty}1. Send Set User Command and Get User for setting User.

{empty}2. Send Set Credential Command and Get Credential Status for
setting PIN code.

After sending Events with all condition proceed following step

{empty}1. Send Clear Credential and Clear User Command.

|
|===

[[_required_devices_261]]
====== link:#_required_devices_261[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_216]]
====== link:#_device_topology_216[]Device Topology

[[_test_setup_228]]
====== link:#_test_setup_228[]Test Setup

[[_test_procedure_261]]
====== link:#_test_procedure_261[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |5.2.5.1 |DRLK.S.E00(DoorLockAlarm), DRLK.S.M.DetectLockJammed
|Trigger the DUT to generate DoorLockAlarm Event (by LockJammed
scenario) a|
* Verify that TH receives the DoorLockAlarm event from DUT +

|1b |5.2.5.1 |DRLK.S.E00(DoorLockAlarm) |TH reads the DoorLockAlarm
event from DUT a|
* Verify that the AlarmCode is set to LockJammed
* Verify that the Event priority is set to CRITICAL

|2a |5.2.5.2 |DRLK.S.F05(DPS),DRLK.S.E01(DoorStateChange) a|
Trigger the DUT to generate DoorStateChange Event

a|
Verify that TH receives the DoorStateChange event from DUT

|2b |5.2.5.2 |DRLK.S.F05(DPS),DRLK.S.E01(DoorStateChange) a|
TH reads the DoorStateChange event from DUT

a|
. Verify that the DoorState set to DoorClosed
. Verify that Priority is set to CRITICAL or INFO

|3a |5.2.4.1 |DRLK.S.C00.Rsp(Lock Door) |TH sends the Lock Door command
(using Remote) to the DUT with valid PINCode a|
Verify that DUT sends success response to the TH

|3b |5.2.5.3 |DRLK.S.E02(LockOperation) a|
TH reads the LockOperation event from DUT

a|
. Verify that LockOperationType is set to Lock
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to CRITICAL or INFO

|3c |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door) |TH sends the Unlock Door
command(using Remote) to the DUT with valid PINCode a|
Verify that DUT sends success response to the TH

|3d |5.2.5.3 |DRLK.S.E02(LockOperation),DRLK.S.F0c(UBOLT) a|
TH reads the LockOperation event from DUT

a|
. Verify that LockOperationType is set to Unlatch
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to CRITICAL

|3e |5.2.5.3 |DRLK.S.E02(LockOperation) a|
TH reads the LockOperation event from DUT

a|
. Verify that LockOperationType is set to Unlock
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to CRITICAL

|4a |5.2.4.1 |DRLK.S.C00.Rsp(Lock Door) |TH sends the Lock Door command(
using Remote) to the DUT with invalid PINCode a|
Verify that DUT sends failure response to the TH

|4b |5.2.5.4 |DRLK.S.E03(LockOperationError) a|
TH reads the LockOperationError event from DUT

a|
. Verify that LockOperationType is set to Lock
. Verify that OperationError is set to InvalidCredential
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to CRITICAL

|4c |5.2.4.2 |DRLK.S.C01.Rsp(Unlock Door) |TH sends Unlock Door Command
to the DUT with InvalidPINCode. a|
Verify that DUT sends a Failure response to the TH

|4d |5.2.5.4 |DRLK.S.E03(LockOperationError) a|
TH reads the LockOperationError event from DUT

a|
. Verify that LockOperationType is set to Unlock
. Verify that OperationSource is set to Remote
. Verify that OperationError is set to InvalidCredential
. Verify that the Priority is set to CRITICAL

|5a |5.2.4.34 a|
DRLK.S.F08(USR),

DRLK.S.C1a.Rsp (Set User)

a|
TH sends Set User Command to DUT with the following values:

. OperationType as 0-Add
. UserIndex as 2( Different from an existing UserIndex)
. UserName as xxx
. UserUniqueID as 6452
. UserStatus as 1-OccupiedEnabled
. UserType as 0-UnrestrictedUser
. CredentialRule as 0-Single

a|
Verify that the DUT sends SUCCESS response

|5b |5.2.5.5 |DRLK.S.E04(LockUserChange) a|
TH reads the LockUserChange event from DUT

a|
. Verify that LockDataType is set to UserIndex
. Verify that DataOperationType is set to Add
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to INFO

|5c |5.2.4.14 a|
DRLK.S.F04(WDSCH),

DRLK.S.C0b.Rsp (SetWeekDaySchedule)

a|
TH send Set Week Day Schedule Command to DUT with the following values:

. WeekDayIndex as 1
. UserIndex as 1
. DaysMaskMap as 2
. StartHour as 15
. StartMinute as 45
. EndHour as 16
. EndMinute as 55

a|
* Verify that the DUT sends SUCCESS response

|5d |5.2.5.5 |DRLK.S.E04(LockUserChange) a|
TH reads the LockUserChange event from DUT

a|
. Verify that LockDataType is set to WeekDaySchedule
. Verify that DataOperationType is set to Add
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to INFO

|5e |5.2.4.40 a|
DRLK.S.F08(USR),

DRLK.S.C22.Rsp(Set Credential)

DRLK.S.C23.Tx(Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

. OperationType as 0-Add
. Credential as 1 1- PIN, Index
. CredentialData as 123456
. UserIndex as 1
. UserStatus as 0
. UserType as 0

a|
* Verify that the DUT sends Set Credential Response command.
* Verify that the Status is SUCCESS.

|5f |5.2.4.2 |DRLK.S.E04(LockUserChange) a|
TH reads the LockUserChange event from DUT

a|
. Verify that LockDataType is set to PIN
. Verify that DataOperationType is set to Add
. Verify that OperationSource is set to Remote
. Verify that the Priority is set to INFO

|5g |5.2.4.37 a|
DRLK.S.C1d.Rsp

(Clear User)

a|
TH sends Clear User Command to DUT for user created in Step 5a

a|
* Verify that the DUT sends Success response to TH

|6a |5.2.4.44 |DRLK.S.C26.Rsp(Clear Credential) a|
TH sends Clear Credential Command to DUT for Credential created in
Preconditions

a|
* Verify that the DUT sends Success response to TH

|6b |5.2.4.37 a|
DRLK.S.C1d.Rsp

(Clear User)

a|
TH sends Clear User Command to DUT for user created in Preconditions

a|
* Verify that the DUT sends Success response to TH

|===

[[_tc_drlk_2_11_verification_for_multiple_credential_types_dut_server]]
===== link:#_tc_drlk_2_11_verification_for_multiple_credential_types_dut_server[]124.2.11. [TC-DRLK-2.11] Verification for multiple credential types [DUT-Server]

[[_category_257]]
====== link:#_category_257[]Category

Functional conformance

[[_purpose_262]]
====== link:#_purpose_262[]Purpose

Verifies the DUT behaviour when it receives Set Credential, Get
Credential Status and Clear Credential for multiple credential types
from TH.

[[_pics_262]]
====== link:#_pics_262[]PICS

* DRLK.S
* DRLK.S.F00(PIN)
* DRLK.S.F01(RID)
* DRLK.S.F02(FGP)

[[_pre_conditions_37]]
====== link:#_pre_conditions_37[]Pre-Conditions

[width="100%",cols="11%,13%,40%,36%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | a|
Before executing the rest of the test plan, perform the following steps:

{empty}1. Send Set User Command and Get User for setting User.

{empty}2. Store UserIndex if it is not 1 and use for Set Credential
Commands.

|
|===

[[_required_devices_262]]
====== link:#_required_devices_262[]Required Devices

[width="100%",cols="11%,47%,42%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as server
|2 |TH |Test harness as client
|===

[[_device_topology_217]]
====== link:#_device_topology_217[]Device Topology

[[_test_setup_229]]
====== link:#_test_setup_229[]Test Setup

[[_test_procedure_262]]
====== link:#_test_procedure_262[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a | a|
DRLK.S.F08(USR),

DRLK.S.A0011(NumberOfTotalUsersSupported)

|TH reads NumberOfTotalUsersSupported attribute and saves for future
use. |Verify that NumberOfTotalUsersSupported contains a valid number in
the inclusive range of 0 to 65535

|1b | a|
DRLK.S.F08(USR),

DRLK.S.F00(PIN),

|TH reads MinPINCodeLength attribute and saves for future use. |Verify
that MinPINCodeLength contains a valid number in the inclusive range of
0 to 255

|1c | a|
DRLK.S.F08(USR),

DRLK.S.F00(PIN),

|TH reads MaxPINCodeLength attribute and saves for future use. |Verify
that MaxPINCodeLength contains a valid number in the inclusive range of
0 to 255

|1d | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.A001a(MinRFIDCodeLength)

|TH reads MinRFIDCodeLength attribute and save for future use. |Verify
that MinRFIDCodeLength contains a valid number in the inclusive range of
0 to 255

|1e | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.A0019(MaxRFIDCodeLength)

|TH reads MaxRFIDCodeLength attribute and save for future use. |Verify
that MaxRFIDCodeLength contains a valid number in the inclusive range of
0 to 255

|2a | a|
DRLK.S.F08(USR),

DRLK.S.F00(PIN),

DRLK.S.C22.Rsp (Set Credential),

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields: Set
CredentialData Length in inclusive range MinPINCodeLength to
MaxPINCodeLength. i.e. MinPINCodeLength=4 and MaxPINCodeLength=8,
CredentialData="1234":

* OperationType: 0
* CredentialIndex: 1
* CredentialType: 1
* CredentialData: See above
* UserIndex: From pre-condition step 2
* UserStatus: null
* UserType: null

a|
* Verify that the DUT responds with Set Credential Response command.
* Verify that the DUT responds with Status as SUCCESS.
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not null if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is null if the entries are not
available

|2b | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.C22.Rsp (Set Credential),

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields: Set
CredentialData Length in inclusive range MinRFIDCodeLength to
MaxRFIDCodeLength. i.e. MinRFIDCodeLength=10 and MaxRFIDCodeLength=20,
CredentialData="123456789A".

* OperationType: 0
* CredentialIndex: 1
* CredentialType: 2
* CredentialData: See above
* UserIndex: From pre-condition step 2
* UserStatus: null
* UserType: null

a|
* Verify that the DUT responds with Set Credential Response command.
* Verify that the DUT responds with Status as SUCCESS.
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not null if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is null if the entries are not
available

|2c | a|
DRLK.S.F08(USR),

DRLK.S.F02(FGP),

DRLK.S.C22.Rsp (Set Credential),

DRLK.S.C23.Tx (Set Credential Response)

a|
TH sends Set Credential Command to DUT with the following fields:

* OperationType: 0
* CredentialIndex: 1
* CredentialType: 4
* CredentialData: "123456789A"
* UserIndex: From pre-condition step 2
* UserStatus: null
* UserType: null

a|
* Verify that the DUT responds with Set Credential Response command.
* Verify that the DUT responds with Status as SUCCESS, If Failure, skip
FingerVein type.
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is null.

|3a | a|
DRLK.S.F08(USR),

DRLK.S.F00(PIN),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 1
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is True and of bool type .
* Verify that the DUT responds with UserIndex as from pre-condition step
2.
* Verify that the NextCredentialIndex is null .

|3b | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 2
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is True and is of bool type .
* Verify that the DUT responds with UserIndex as from pre-condition step
2.
* Verify that the NextCredentialIndex is null .

|3c | a|
DRLK.S.F08(USR),

DRLK.S.F02(FGP),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 4
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists True and is of bool type .
* Verify that the DUT responds with UserIndex as from pre-condition step
2.
* Verify that the NextCredentialIndex is null

|4a | a|
DRLK.S.F08(USR),

DRLK.S.F00(PIN),

DRLK.S.C26.Rsp (Clear Credential)

a|
TH sends Clear Credential Command to DUT with the following fields:

* CredentialType as 1
* CredentialIndex as 1

a|
* Verify that the DUT sends SUCCESS response

|4b | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 2
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is True and is of bool type .
* Verify that the DUT responds with UserIndex as from pre-condition step
2 .
* Verify that the NextCredentialIndex is null .

|4c | a|
DRLK.S.F08(USR),

DRLK.S.F02(FGP),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 4
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists True and is of bool type .
* Verify that the DUT responds with UserIndex as from pre-condition step
2 .
* Verify that the NextCredentialIndex is null .

|4d | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.C26.Rsp (Clear Credential)

a|
TH sends Clear Credential Command to DUT with the following fields:

* CredentialType as 2
* CredentialIndex as 1

a|
* Verify that the DUT sends SUCCESS response

|4e | a|
DRLK.S.F08(USR),

DRLK.S.F02(FGP),

DRLK.S.C24.Rsp (Get Credential)

DRLK.S.C25.Tx (Get Credential Response)

a|
TH sends Get Credential Status Command with

* CredentialType as 4
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists True and is of bool type .
* Verify that the DUT responds with UserIndex as from pre-condition step
2.
* Verify that the NextCredentialIndex value is null
* Verify that the NextCredentialIndex is null if the entries are not
available

|4f | a|
DRLK.S.F08(USR),

DRLK.S.F02(FGP),

DRLK.S.C26.Rsp (Clear Credential)

a|
TH sends Clear Credential Command to DUT with the following fields:

* CredentialType as 4
* CredentialIndex as 1

a|
* Verify that the DUT sends SUCCESS response

|5a | a|
DRLK.S.F08(USR),

DRLK.S.F00(PIN),

DRLK.S.C24.Rsp (Get Credential)

a|
TH sends Get Credential Status command to DUT with the following fields:

* CredentialType as 1
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is False and of bool type .
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not null if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is null if the entries are not
available

|5b | a|
DRLK.S.F08(USR),

DRLK.S.F01(RID),

DRLK.S.C24.Rsp (Get Credential)

a|
TH sends Get Credential Status Command with

* CredentialType as 2
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is False and of bool type .
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not null if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is null if the entries are not
available

|5c | a|
DRLK.S.F08(USR),

DRLK.S.F02(FGP),

DRLK.S.C24.Rsp (Get Credential)

a|
TH sends Get Credential Status Command with

* CredentialType as 4
* CredentialIndex as 1

a|
* Verify that the DUT responds with Get Credential Status Response
Command .
* Verify that the CredentialExists is False and of bool type .
* Verify that the DUT responds with UserIndex as null.
* Verify that the NextCredentialIndex value is not null if there is at
least one available entry after the requested credential index
* Verify that the NextCredentialIndex is null if the entries are not
available

|===

[[_tc_drlk_2_12_verification_for_unbolt_door_command_dut_server]]
===== link:#_tc_drlk_2_12_verification_for_unbolt_door_command_dut_server[]124.2.12. [TC-DRLK-2.12] Verification for Unbolt Door command [DUT-Server]

[[_category_258]]
====== link:#_category_258[]Category

Functional conformance

[[_purpose_263]]
====== link:#_purpose_263[]Purpose

Verifies the DUT behaviour when it receives Unbolt Door command from TH

[[_pics_263]]
====== link:#_pics_263[]PICS

* DRLK.S.F0c(UBOLT)

[[_pre_conditions_38]]
====== link:#_pre_conditions_38[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |

|2 | |Lock device is the DUT |

|3 | |PINCode valid value is 123456 |

|4 | |Door is in locked state |

|5 | a|
Before sending the Unbolt Door command proceed following steps:

{empty}1. Send Set User Command and Get User for setting User.

{empty}2. Send Set Credential Command and Get Credential Status for
setting PIN code.

After sending Unbolt Door Command with all condition proceed following
step

{empty}1. Send Clear Credential and Clear User Command.

|
|===

[[_required_devices_263]]
====== link:#_required_devices_263[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |server
|2 |TH |client
|===

[[_device_topology_218]]
====== link:#_device_topology_218[]Device Topology

[[_test_setup_230]]
====== link:#_test_setup_230[]Test Setup

[[_test_procedure_263]]
====== link:#_test_procedure_263[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) |TH writes the
RequirePINforRemoteOperation attribute value as False on the DUT a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0033(RequirePINForRemoteOperation).Write is True, and otherwise
responds with UNSUPPORTED_WRITE

|2 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation) |TH reads the
RequirePINforRemoteOperation attribute from the DUT. Save the current
attribute value as Current_RequirePINValue a|
Verify that the read attribute operation completes successfully

|2a |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation).Write |TH evaluates the value
of saved value Current_RequirePINValue a|
Verify that value of Current_RequirePINValue is FALSE

|3 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door Command
to the DUT without PINCode |Verify that DUT sends SUCCESS response to
the TH if value of Current_RequirePINValue == FALSE, and otherwise
responds with FAILURE if value of Current_RequirePINValue == TRUE

|4 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door Command
to the DUT with valid PINCode |Verify that DUT sends SUCCESS response to
the TH

|5 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) |TH writes the
RequirePINforRemoteOperation attribute value as true on the DUT a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0033(RequirePINForRemoteOperation).Write is True, and otherwise
responds with UNSUPPORTED_WRITE

|6 |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation) |TH reads the
RequirePINforRemoteOperation attribute from the DUT. Save the current
attribute value as Current_RequirePINValue a|
Verify that the read attribute operation completes successfully

|6a |5.2.3.36 |DRLK.S.F07(COTA) & DRLK.S.F00(PIN) &
DRLK.S.A0033(RequirePINForRemoteOperation).Write |TH evaluates the value
of saved value Current_RequirePINValue a|
Verify that value of Current_RequirePINValue is TRUE

|7 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door Command
to the DUT with Invalid PINCode a|
Verify that DUT sends failure response to the TH

|8 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door Command
to the DUT without PINCode a|
Verify that DUT sends SUCCESS response to the TH if value of
Current_RequirePINValue == FALSE, and otherwise responds with FAILURE if
value of Current_RequirePINValue == TRUE

|9 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door Command
to the DUT with valid PINCode |Verify that DUT sends SUCCESS response to
the TH

|10 |5.2.3.33 |DRLK.S.F00(PIN) | DRLK.S.F01(RID) |TH writes
WrongCodeEntryLimit attribute value as 3 on the DUT a|
Verify that the DUT sends Success response if DRLK.S.A0030
(WrongCodeEntryLimit).Write is True, and otherwise responds with
UNSUPPORTED_WRITE

|11 |5.2.3.33 |DRLK.S.F00(PIN) | DRLK.S.F01(RID) |TH writes
UserCodeTemporaryDisableTime attribute value as 15 seconds on the DUT a|
Verify that the DUT send the Success response if DRLK.S.A0031
(UserCodedTemporary DisableTime).Write is True, and otherwise responds
with UNSUPPORTED_WRITE

|12 |5.2.4.2,5.2.3.34 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door
Command to the DUT with invalid PINCode |Verify that DUT sends failure
response to the TH

|13 |5.4.2.1, 5.2.3.34 |(DRLK.S.F00(PIN) | DRLK.S.F01(RID)) &
DRLK.S.A0031(UserCodedTemporaryDisableTime) a|
Repeat the above step 3 times

* TH reads UserCodedTemporaryDisableTime attribute from DUT

a|
After sending 3 failure responses verify that
UserCodeTemporaryDisableTime attribute is triggered

|14 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends Unbolt Door Command
to the DUT with valid PINCode before UserCodeTemporaryDisableTime
expires |Verify that DUT sends failure response to the TH

|15 |5.2.3.25 | |TH writes AutoRelockTime attribute value as 60 seconds
on the DUT After UserCodeTemporaryDisableTime expires a|
Verify that the DUT sends SUCCESS response if
DRLK.S.A0023(AutoRelockTime).Write is True, and otherwise responds with
UNSUPPORTED_WRITE

|16 |5.2.3.25 |DRLK.S.A0023(AutoRelockTime) |TH reads AutoRelockTime
attribute from the DUT a|
Verify that the AutoRelockTime is changed to 60

|17 |5.2.4.2 |DRLK.S.C27.Rsp(Unbolt Door) |TH sends the Unbolt Door
command to the DUT with valid PINCode |Verify that DUT sends SUCCESS
response to the TH

|18 |5.2.3.1 |DRLK.S.A0000(LockState) |TH reads LockState attribute
after AutoRelockTime Expires and the lock action has been completed
(e.g. motor movement finished) |Verify that the DUT is locked.
|===

[[_client_as_dut_8]]
==== link:#_client_as_dut_8[]124.3. Client as DUT

[[_tc_drlk_3_2_commands_dut_client]]
===== link:#_tc_drlk_3_2_commands_dut_client[]124.3.1. [TC-DRLK-3.2] Commands [DUT - Client]

[[_category_259]]
====== link:#_category_259[]Category

Functional conformance

[[_purpose_264]]
====== link:#_purpose_264[]Purpose

To Verify the door lock commands sent by the DUT.

[[_pics_264]]
====== link:#_pics_264[]PICS

* DRLK.C

[[_pre_conditions_39]]
====== link:#_pre_conditions_39[]Pre-Conditions

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with the DUT |
|2 | |Steps 4- 12 need a User added to the lock. |
|===

[[_required_devices_264]]
====== link:#_required_devices_264[]Required Devices

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |DUT as Client
|2 |TH |Test harness as Server
|===

[[_device_topology_219]]
====== link:#_device_topology_219[]Device Topology

[[_test_setup_231]]
====== link:#_test_setup_231[]Test Setup

[[_test_procedure_264]]
====== link:#_test_procedure_264[]Test Procedure

[width="100%",cols="4%,12%,20%,32%,32%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | |DRLK.C.C00.Tx(Lock Door) |DUT sends Lock Door command to TH. |Test
Harness receives the Lock Door command from the DUT.

|2 | |DRLK.C.C01.Tx(Unlock Door) |DUT sends Unlock Door command to TH.
|Test Harness receives the Unlock Door command from the DUT.

|3 | |DRLK.C.C03.Tx(Unlock with Timeout) |DUT sends Unlock with Timeout
command to TH. |Test Harness receives the Unlock with Timeout command
from the DUT.

|4 | |DRLK.C.F04(SCH),DRLK.C.C0b.Tx(Set Week Day Schedule) |DUT sends
Set Week Day Schedule command to TH. |Test Harness receives the Set Week
Day Schedule command from the DUT.

|5 | |DRLK.C.F04(SCH),DRLK.C.C0c.Tx(Get Week Day Schedule) |DUT sends
Get Week Day Schedule command to TH. |Test Harness receives the Get Week
Day Schedule command

|6 | |DRLK.C.F04(SCH),DRLK.C.C0d.Tx(Clear Week Day Schedule) |DUT sends
Clear Week Day Schedule command to TH. |Test Harness receives the Clear
Week Day Schedule command from the DUT.

|7 | |DRLK.C.F04(SCH),DRLK.C.C0e.Tx(Set Year Day Schedule) |DUT sends
Set Year Day Schedule command to TH. |Test Harness receives the Set Year
Day Schedule command from the DUT.

|8 | |DRLK.C.F04(SCH),DRLK.C.C0f.Tx(Get Year Day Schedule) |DUT sends
Get Year Day Schedule command to TH. |Test Harness receives the Get Year
Day Schedule command from the DUT.

|9 | |DRLK.C.F04(SCH),DRLK.C.C10.Tx(Clear Year Day Schedule) |DUT sends
Clear Year Day Schedule command to TH. |Test Harness receives the Clear
Year Day Schedule command from the DUT.

|10 | |DRLK.C.F04(SCH),DRLK.C.C11.Tx(Set Holiday Schedule) |DUT sends
Set Holiday Day Schedule command to TH. |Test Harness receives the Set
Holiday Day Schedule command from the DUT.

|11 | |DRLK.C.F04(SCH),DRLK.C.C12.Tx(Get Holiday Schedule) |DUT sends
Get Holiday Day Schedule command to TH. |Test Harness receives the Get
Holiday Day Schedule command from the DUT.

|12 | |DRLK.C.F04(SCH),DRLK.C.C13.Tx(Clear Holiday Schedule) |DUT sends
Clear Holiday Day Schedule command to TH. |Test Harness receives the
Clear Holiday Day Schedule command from the DUT.

|13 | |DRLK.C.F08(USR),DRLK.C.C1a.Tx(Set User) |DUT sends Set USer
command to TH. |Test Harness receives the Set User command from the DUT.

|14 | |DRLK.C.F08(USR),DRLK.C.C1b.Tx(Get User) |DUT sends Get User to
TH. |Test Harness receives the Get User command from the DUT.

|15 | |DRLK.C.F08(USR),DRLK.C.C1d.Tx(Clear User) |DUT sends Clear User
command to TH.a |Test Harness receives the Clear User command from the
DUT.

|16 | |DRLK.C.F08(USR),DRLK.C.C22.Tx(Set Credential) |DUT sends Set
Credential command to TH.a |Test Harness receives the Set Credential
command from the DUT.

|17 | |DRLK.C.F08(USR),DRLK.C.C24.Tx(Get Credential) |DUT sends Get
Credential to TH. |Test Harness receives the Get Credential command from
the DUT.

|18 | |DRLK.C.F08(USR),DRLK.C.C26.Tx(Clear Credential) |DUT sends Clear
Credential command to TH. |Test Harness receives the Clear Credential
command command from the DUT.
|===

[[_binding_cluster_test_plan]]
== link:#_binding_cluster_test_plan[]**Binding Cluster Test Plan**

[[_pics_definition_36]]
=== link:#_pics_definition_36[]125. PICS Definition

This section covers the Binding Cluster Cluster related PICS items that
are referenced in the following test cases.

[[_role_38]]
==== link:#_role_38[]125.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BIND.S |Does the device implement the Binding Cluster as a server? |O |

|BIND.C |Does the device implement the Binding Cluster as a client? |O |
|===

[[_server_38]]
==== link:#_server_38[]125.2. Server

[[_attributes_41]]
===== link:#_attributes_41[]125.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BIND.S.A0000(Binding) |Does the DUT(server) support the Binding
attribute? |M |
|===

[[_client_19]]
==== link:#_client_19[]125.3. Client

[[_attributes_42]]
===== link:#_attributes_42[]125.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|GRPKEY.C.A0000(GroupKeyMap) |Does the DUT(client) have access
privileges for the GroupKeyMap attribute implemented on the server? |O |
|===

[[_commands_generated_23]]
===== link:#_commands_generated_23[]125.3.2. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OO.C.C00.Tx(Off) |Does the DUT(client) implement sending the Off
command? |O |

|OO.C.C01.Tx(On) |Does the DUT(client) implement sending the On command?
|O |

|GRPKEY.C.C00.Tx(KeySetWrite) |Does the DUT(Client) implement sending
KeySetWrite command? |O |

|G.C.C00.Tx(AddGroup) |Does the DUT(Client) implement sending AddGroup
command? |O |
|===

[[_test_case_list_38]]
=== link:#_test_case_list_38[]126. Test Case List

[width="100%",cols="34%,33%,33%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-BIND-1.1 |Global Attributes with DUT as Server

|2 |TC-BIND-2.1 |Binding Cluster Attributes-Node [DUT-Controller]

|3 |TC-BIND-2.2 |Binding Cluster Attributes-DUT handles its Groups
settings [DUT-Controller]

|4 |TC-BIND-2.3 |Binding Cluster Attributes-TH1 enables DUT to handle
its Group settings [DUT-Controller]
|===

[[_test_cases_38]]
=== link:#_test_cases_38[]127. Test Cases

[[_generic_test_case_2]]
==== link:#_generic_test_case_2[]127.1. Generic Test Case

[[_tc_bind_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_bind_1_1_global_attributes_with_dut_as_server[]127.1.1. [TC-BIND-1.1] Global Attributes with DUT as Server

[[_category_260]]
====== link:#_category_260[]Category

Functional conformance.

[[_purpose_265]]
====== link:#_purpose_265[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_265]]
====== link:#_pics_265[]PICS

* BIND.S

[[_required_devices_265]]
====== link:#_required_devices_265[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_265]]
====== link:#_test_procedure_265[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_233]]
====== link:#_notestesting_considerations_233[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_binding_cluster_test_case]]
==== link:#_binding_cluster_test_case[]127.2. Binding Cluster Test Case

[[_tc_bind_2_1_binding_cluster_attributes_node_dut_controller]]
===== link:#_tc_bind_2_1_binding_cluster_attributes_node_dut_controller[]127.2.1. [TC-BIND-2.1] Binding Cluster Attributes-Node [DUT-Controller]

[[_category_261]]
====== link:#_category_261[]Category

Functional conformance

[[_purpose_266]]
====== link:#_purpose_266[]Purpose

This test case verifies that TH receives the commands sent by DUT for
its binding entries.

[[_pics_266]]
====== link:#_pics_266[]PICS

* BIND.C

[[_pre_conditions_40]]
====== link:#_pre_conditions_40[]Pre-Conditions

[width="100%",cols="6%,14%,42%,38%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH2 supports On/Off server on Endpoint 1. |
|2 | |TH3 supports On/Off server on Endpoint 2. |
|3 | |DUT supports On/Off client. |
|===

[[_required_devices_266]]
======= link:#_required_devices_266[]Required Devices

[width="100%",cols="6%,44%,50%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH1 |Test Harness1 as Commissioner
|2 |TH2 |Test Harness2 as Controlee
|3 |TH3 |Test Harness3 as Controlee
|4 |DUT |Controller
|===

[[_device_topology_220]]
====== link:#_device_topology_220[]Device Topology

[[_test_setup_232]]
====== link:#_test_setup_232[]Test Setup

TH2, TH3 and DUT will be on TH1’s Fabric

[[_test_procedure_266]]
====== link:#_test_procedure_266[]Test Procedure

[width="100%",cols="6%,13%,8%,39%,34%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Factory Reset DUT |

|2 | | |Commission DUT to TH1’s fabric |

|3 | | |Commission TH2 to TH1’s fabric (Node ID = 2) |

|4 | | |Commission TH3 to TH1’s fabric (Node ID = 3) |

|5 |9.6 | a|
TH1 writes Binding entries into DUT on the endpoint with the On/Off
client with

* Entry 1:
+
. Node = 2
. Cluster = 0x0006(onoff)
. Endpoint = 1
* Entry 2:
+
. Node = 3
. Cluster = 0x0006(onoff)
. Endpoint = 2
* Note:
+
. Node 2 corresponds to TH2’s Node ID
. Node 3 corresponds to TH3’s Node ID

|

|6 | | |TH1 enables DUT as Controller |

|7 |appclusters-1.5.6.2 |OO.C.C01.Tx(On) |DUT is triggered to send On
command to its binding node entries a|
* TH2 receives On command(Endpoint 1)
* TH3 receives On command(Endpoint 2)

|8 | |OO.C.C01.Tx(On) |TH1 reads OnOff attribute from TH2 (Endpoint 1)
|Verify that the value is set to On

|9 | | |TH1 removes second binding entry corresponding to TH3 from DUT |

|10 |appclusters-1.5.6.2 |OO.C.C00.Tx(Off) |DUT is triggered to send off
command to its binding entries a|
* TH2 receives off command (Endpoint 1)
* TH3 does not receive off command (Endpoint 2)

|11 | |OO.C.C00.Tx(Off) |TH1 reads OnOff attribute from TH2 (Endpoint 1)
|Verify that the value is set to Off

|12 | |OO.C.C01.Tx(On) |TH1 reads OnOff attribute from TH3 (Endpoint 2)
|Verify that the value is set to On
|===

[[_tc_bind_2_2_binding_cluster_attributes_dut_handles_its_groups_settings_dut_controller]]
===== link:#_tc_bind_2_2_binding_cluster_attributes_dut_handles_its_groups_settings_dut_controller[]127.2.2. [TC-BIND-2.2] Binding Cluster Attributes-DUT handles its Groups settings [DUT-Controller]

[[_category_262]]
====== link:#_category_262[]Category

Functional conformance

[[_purpose_267]]
====== link:#_purpose_267[]Purpose

This test case verifies that TH2 receives the multicast commands sent by
DUT for its binding entries.

[[_pics_267]]
====== link:#_pics_267[]PICS

* BIND.C

[[_pre_conditions_41]]
====== link:#_pre_conditions_41[]Pre-Conditions

[width="100%",cols="6%,14%,42%,38%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH2 supports On/Off server on Endpoint 1. |
|2 | |TH2 supports Groups server on Endpoint 1. |
|3 | |DUT behaves as Group Admin |
|4 | |TH2 should have an ACL entry with the AuthMode as Group by DUT |
|5 | |DUT supports On/Off client |
|===

[[_required_devices_267]]
======= link:#_required_devices_267[]Required Devices

[width="100%",cols="6%,44%,50%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH1 |Test Harness1 as Commissioner
|2 |TH2 |Test Harness2 as Controlee
|3 |DUT |Controller
|===

[[_device_topology_221]]
====== link:#_device_topology_221[]Device Topology

[[_test_setup_233]]
====== link:#_test_setup_233[]Test Setup

TH1, TH2 and DUT will be on TH1’s Fabric

[[_test_procedure_267]]
====== link:#_test_procedure_267[]Test Procedure

[width="100%",cols="6%,13%,8%,39%,34%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Factory Reset DUT |

|2 | | |Commission DUT to TH1’s fabric |

|3 | | |TH1 enables DUT as Controller |

|4 | | |Commission TH2 to TH1’s fabric (Node ID = 2) |

|5 | | a|
DUT generates fabric-unique GroupID, GroupName, random key, EpochKey0
and GroupKeySetID.

|

|6 |11.2.9.1. |GRPKEY.C.C00.Tx(KeySetWrite) a|
DUT sends KeySetWrite command to GroupKeyManagement cluster to TH2 on
Endpoint 0.

a|
TH2 receives the KeySetWrite command from the DUT.

|7 |11.2.7.1 |GRPKEY.C.A0000(GroupKeyMap) |DUT binds GroupId with
GroupKeySetID in the GroupKeyMap attribute list on GroupKeyManagement
cluster to TH2 on Endpoint 0 |TH2 receives the binding of GroupKeySetID
with the GroupID from DUT

|8 |appclusters-1.3.6.1 |G.C.C00.Tx(AddGroup) |DUT sends AddGroup( Group
Name and Group-ID) Command to TH2 on Endpoint 1. a|
TH2 receives the AddGroup command from the DUT

|9 |9.6 | a|
TH1 writes Binding entry into DUT with

* Entry 1:
+
. Group = The Group ID in the AddGroup command sent from DUT to TH2

|

|10a |appclusters-1.5.6.2 |OO.C.C01.Tx(On) |DUT is triggered to send
Multicast message On command to its binding entries |TH2 receives On
command(Endpoint 1)

|10b | |OO.C.C01.Tx(On) |TH1 reads OnOff attribute from TH2 (Endpoint 1)
|Verify that the value is set to On

|11 | | |TH1 removes all the binding entries from DUT |

|12a |appclusters-1.5.6.2 |OO.C.C00.Tx(Off) |DUT is triggered to send
Multicast message off command to its binding entries |TH2 does not
receive Off command

|12b | |OO.C.C01.Tx(On) |TH1 reads OnOff attribute from TH2 (Endpoint 1)
|Verify that the value is set to On
|===

[[_tc_bind_2_3_binding_cluster_attributes_th1_enables_dut_to_handle_its_group_settings_dut_controller]]
===== link:#_tc_bind_2_3_binding_cluster_attributes_th1_enables_dut_to_handle_its_group_settings_dut_controller[]127.2.3. [TC-BIND-2.3] Binding Cluster Attributes-TH1 enables DUT to handle its Group settings [DUT-Controller]

[[_category_263]]
====== link:#_category_263[]Category

Functional conformance

[[_purpose_268]]
====== link:#_purpose_268[]Purpose

This test case verifies that TH2 receives the multicast commands sent by
DUT for its binding entries.

[[_pics_268]]
====== link:#_pics_268[]PICS

* BIND.C

[[_pre_conditions_42]]
====== link:#_pre_conditions_42[]Pre-Conditions

[width="100%",cols="6%,14%,42%,38%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH1 enables DUT to handle group communication |
|2 | |TH2 supports On/Off server on Endpoint 1 |
|3 | |TH2 supports Groups server on Endpoint 1 |
|4 | |TH2 should have an ACL entry with the AuthMode as Group by TH1 |
|5 | |DUT supports On/Off client |
|===

[[_required_devices_268]]
======= link:#_required_devices_268[]Required Devices

[width="100%",cols="6%,44%,50%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH1 |Test Harness1 as Commissioner
|2 |TH2 |Test Harness2 as Controlee
|3 |DUT |Controller
|===

[[_device_topology_222]]
====== link:#_device_topology_222[]Device Topology

[[_test_setup_234]]
====== link:#_test_setup_234[]Test Setup

TH1, TH2 and DUT will be on TH1’s Fabric

[[_test_procedure_268]]
====== link:#_test_procedure_268[]Test Procedure

[width="100%",cols="6%,13%,8%,39%,34%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Factory Reset DUT |

|2 | | |Commission DUT to TH1’s fabric |

|3 | | |TH1 enables DUT as Controller |

|4 | | |Commission TH2 to TH1’s fabric (Node ID = 2) |

|5 | | a|
TH1 generates fabric-unique GroupID, GroupName, random key, EpochKey0
and GroupKeySetID.

|

|6 |11.2.5.1. | a|
TH1 sends KeySetWrite command to GroupKeyManagement cluster to TH2 on
Endpoint 0.

a|
TH2 receives the KeySetWrite command from the TH1

|7 | | |TH1 binds GroupId with GroupKeySetID in the GroupKeyMap
attribute list on GroupKeyManagement cluster to TH2 on Endpoint 0 |TH2
receives the binding of GroupKeySetID with the GroupID from TH1

|8 |appclusters-1.3.6.1 | |TH1 sends AddGroup( Group Name and Group-ID)
Command to TH2 on Endpoint 1. a|
TH2 receives the AddGroup command from the TH1

|9 |9.6 | a|
TH1 writes Binding entry into DUT with

* Entry 1:
+
. Group = The Group ID in the AddGroup command sent from TH1 to TH2

|

|10 | | |TH1 sets up group settings on DUT |

|11a |appclusters-1.5.6.2 |OO.C.C01.Tx(On) |DUT is triggered to send
Multicast message On command to its binding entries a|
* TH2 receives On command(Endpoint 1)

|11b | |OO.C.C01.Tx(On) |TH1 reads OnOff attribute from TH2 (Endpoint 1)
|Verify that the value is set to On

|12 | | |TH1 removes all the binding entries from DUT |

|13a |appclusters-1.5.6.2 |OO.C.C00.Tx(Off) |DUT is triggered to send
Multicast message off command to its binding entries a|
* TH2 does not receive Off command

|13b | |OO.C.C01.Tx(On) |TH1 reads OnOff attribute from TH2 (Endpoint 1)
|Verify that the value is set to On
|===

[[_groups_cluster_test_plan]]
== link:#_groups_cluster_test_plan[]**Groups Cluster Test Plan**

[[_pics_definition_37]]
=== link:#_pics_definition_37[]128. PICS Definition

This section covers the Groups Test Plan related PICS items that are
referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_39]]
==== link:#_role_39[]128.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S |Does the device implement the Groups cluster as a server? |O |

|G.C |Does the device implement the Groups cluster as a client? |O |
|===

[[_server_39]]
==== link:#_server_39[]128.2. Server

[[_features_25]]
===== link:#_features_25[]128.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S.F00(GN) |Does the DUT(Server) support Group Names feature? |O |
|===

[[_attributes_43]]
===== link:#_attributes_43[]128.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S.A0000(NameSupport) |Does the DUT(Server) support NameSupport
attribute? |M |

|GRPKEY.S.A0001(GroupTable) |Does the DUT(Server) support GroupTable
attribute? |M |

|I.S.A0000(IdentifyTime) |Does the DUT(Server) support the IdentifyTime
attribute? |M |

|MCORE.G.MULTIENDPOINT |DUT(Server) support multiple endpoints with a
Groups cluster |O |
|===

[[_commands_received_24]]
===== link:#_commands_received_24[]128.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S.C00.Rsp(AddGroup) |Does the DUT(server) implement receiving
AddGroup Command? |M |

|G.S.C01.Rsp(ViewGroup) |Does the DUT(server) implement receiving
ViewGroup Command? |M |

|G.S.C02.Rsp(GetGroupMembership) |Does the DUT(server) implement
receiving GetGroupMembership Command? |M |

|G.S.C03.Rsp(RemoveGroup) |Does the DUT(server) implement receiving
RemoveGroup Command? |M |

|G.S.C04.Rsp(RemoveAllGroups) |Does the DUT(server) implement receiving
RemoveAllGroups Command? |M |

|G.S.C05.Rsp(AddGroupIfIdentifying) |Does the DUT(server) implement
receiving AddGroupIfIdentifying Command? |M |

|I.S.C00.Rsp(Identify) |Does the DUT(Server) implement receiving the
Identify command? |M |
|===

[[_commands_generated_24]]
===== link:#_commands_generated_24[]128.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S.C00.Tx(AddGroupResponse) |Does the DUT(server) invoking/generating
AddGroupResponse Command? |M |

|G.S.C01.Tx(ViewGroupResponse) |Does the DUT(server) invoking/generating
ViewGroupResponse Command? |M |

|G.S.C02.Tx(GetGroupMembershipResponse) |Does the DUT(server)
invoking/generating GetGroupMembershipResponse Command? |M |

|G.S.C03.Tx(RemoveGroupResponse) |Does the DUT(server)
invoking/generating RemoveGroupResponse Command? |M |
|===

[[_client_20]]
==== link:#_client_20[]128.3. Client

[[_commands_generated_25]]
===== link:#_commands_generated_25[]128.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.C.C00.Tx(AddGroup) |Does the DUT(client) implement
invoking/generating AddGroup Command? |O |

|G.C.C01.Tx(ViewGroup) |Does the DUT(client) implement
invoking/generating ViewGroup Command? |O |

|G.C.C02.Tx(GetGroupMembership) |Does the DUT(client) implement
invoking/generating GetGroupMembership Command? |O |

|G.C.C03.Tx(RemoveGroup) |Does the DUT(client) implement
invoking/generating RemoveGroup Command? |O |

|G.C.C04.Tx(RemoveAllGroups) |Does the DUT(client) implement
invoking/generating RemoveAllGroups Command? |O |

|G.C.C05.Tx(AddGroupIfIdentifying) |Does the DUT(client) implement
invoking/generating AddGroupIfIdentifying Command? |O |
|===

[[_pixit_definition_11]]
=== link:#_pixit_definition_11[]129. PIXIT Definition

This section covers the Groups’s Cluster related PIXIT items that are
referenced in the following test cases

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.G.ENDPOINT |Endpoint supported for Groups cluster is given by the
DUT Manufacturer |M |

|PIXIT.G.ENDPOINT2 |Second Endpoint supported for Groups cluster is
given by the DUT Manufacturer |M |Note: PIXIT.G.ENDPOINT2 is applicable
only for TC-G-2.4

|PIXIT.I.ENDPOINT |Endpoint supported for Identify cluster is given by
the DUT Manufacturer Note: The Groups and Identify Cluster should exist
on the same Endpoint for the test case execution |M |
|===

[[_test_case_list_39]]
=== link:#_test_case_list_39[]130. Test Case List

[width="100%",cols="12%,44%,44%",options="header",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-G-1.1 |Global Attributes [DUT-Server]

|2 |TC-G-2.1 |Attributes [DUT-Server]

|3 |TC-G-2.2 |Commands - AddGroup, ViewGroup, RemoveGroup,
RemoveAllGroups [DUT-Server]

|4 |TC-G-2.4 |Commands - AddGroup Command with same GroupID on Multiple
Endpoint [DUT-Server]

|5 |TC-G-2.3 |Commands - GetGroupMembership, AddGroupIfIdentifying
[DUT-Server]

|6 |TC-G-3.2 |Commands [DUT-Client]
|===

[[_test_cases_39]]
=== link:#_test_cases_39[]131. Test Cases

'''''

[[_generic_test_cases_33]]
==== link:#_generic_test_cases_33[]131.1. Generic test cases

'''''

[[_tc_g_1_1_global_attributes_dut_server]]
===== link:#_tc_g_1_1_global_attributes_dut_server[]131.1.1. [TC-G-1.1] Global Attributes [DUT-Server]

[[_category_264]]
====== link:#_category_264[]Category

Functional conformance

[[_purpose_269]]
====== link:#_purpose_269[]Purpose

To verify the Global Attributes available in the Groups Cluster

[[_pics_269]]
====== link:#_pics_269[]PICS

* G.S

[[_pre_conditions_43]]
====== link:#_pre_conditions_43[]Pre-Conditions

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|===

[[_required_devices_269]]
====== link:#_required_devices_269[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_device_topology_223]]
====== link:#_device_topology_223[]Device Topology

[[_test_setup_235]]
====== link:#_test_setup_235[]Test Setup

[[_test_procedure_269]]
====== link:#_test_procedure_269[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 |7.13.1 | |TH reads the ClusterRevision from DUT a|
* Verify that the ClusterRevision attribute is of uint16.
* Verify that the DUT response indicates that the ClusterRevision
attribute has the value 4.

|3 |7.13.2 | |TH reads the FeatureMap from DUT a|
* Verify that the FeatureMap attribute is either 0x00 or 0x01
* Verify that the FeatureMap attribute has the bit 0 is set to 1, if
G.S.F00(GN) is true
* Verify that the FeatureMap attribute has the bit 0 is set to 0, if
G.S.F00(GN) is false

|4 |7.13.3 | |TH reads AttributeList from DUT a|
Verify that the DUT response provides a list of supported attributes

* It SHALL include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.
* This list should include all mandatory attributes (value 0x0000)

|5 |7.13.4 | |TH reads EventList from DUT a|
Verify that the DUT response provides a list of supported events.

* For this cluster the list is empty .

|6 |7.13.3.1 | |TH reads AcceptedCommandList from DUT a|
Verify that the DUT response provides a list of Accepted Commands

* This list should include the mandatory commands(values 0,1,2,3,4,5)

|7 |7.13.3.2 | |TH reads GeneratedCommandList from DUT a|
Verify that the DUT response provides a list of Generated Commands

* This list should include the mandatory commands(values 0,1,2,3)

|===

[[_notestesting_considerations_234]]
====== link:#_notestesting_considerations_234[]Notes/Testing Considerations

Test Step #5 cannot be executed with V1.0 SDK.

'''''

[[_server_as_dut_23]]
==== link:#_server_as_dut_23[]131.2. Server as DUT

'''''

[[_tc_g_2_1_attributes_dut_server]]
===== link:#_tc_g_2_1_attributes_dut_server[]131.2.1. [TC-G-2.1] Attributes [DUT-Server]

[[_category_265]]
====== link:#_category_265[]Category

Functional conformance

[[_purpose_270]]
====== link:#_purpose_270[]Purpose

This test case verifies the attributes provided by the Groups Cluster.

[[_pics_270]]
====== link:#_pics_270[]PICS

* G.S

[[_pre_conditions_44]]
====== link:#_pre_conditions_44[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with DUT |
|===

[[_required_devices_270]]
====== link:#_required_devices_270[]Required Devices

[width="100%",cols="6%,47%,47%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Device Under Test as Commissionee
|2 |TH |Test Harness as Commissioner
|===

[[_device_topology_224]]
====== link:#_device_topology_224[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_236]]
====== link:#_test_setup_236[]Test Setup

[[_test_procedure_270]]
====== link:#_test_procedure_270[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |1.3.6.1 |G.S.A0000(NameSupport) |TH reads NameSupport attribute from
DUT a|
* If G.S.F00(GN) is set to 1, Verify that NameSupport is 0x80 (bit 7 is
1)
* If G.S.F00(GN) is set to 0, Verify that NameSupport is 0x00 (bit 7 is
0)

|2 |1.3.6.1 | |TH writes NameSupport attribute as 0x80 EXOR the value as
read in step 1 a|
* Verify that the DUT responds with UNSUPPORTED_WRITE

|3 |1.3.6.1 | |TH reads NameSupport attribute from DUT |Verify that the
NameSupport attribute value has the same value read on step 1.
|===

[[_tc_g_2_2_commands_addgroup_viewgroup_removegroup_removeallgroups_dut_server]]
===== link:#_tc_g_2_2_commands_addgroup_viewgroup_removegroup_removeallgroups_dut_server[]131.2.2. [TC-G-2.2] Commands - AddGroup, ViewGroup, RemoveGroup, RemoveAllGroups [DUT-Server]

[[_category_266]]
====== link:#_category_266[]Category

Functional conformance

[[_purpose_271]]
====== link:#_purpose_271[]Purpose

Verifies the DUT behaviour when it receives the following Groups
commands from TH.

. AddGroup
. ViewGroup
. RemoveGroup
. RemoveAllGroups

[[_pics_271]]
====== link:#_pics_271[]PICS

* G.S

[[_pre_conditions_45]]
====== link:#_pre_conditions_45[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with DUT |

|2 |11.2.3.3 |TH reads the MaxGroupsPerFabric from Group key Management
Cluster and saves it as maxgroups |
|===

[[_required_devices_271]]
====== link:#_required_devices_271[]Required Devices

[width="100%",cols="6%,47%,47%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Device Under Test as Commissionee
|2 |TH |Test Harness as Commissioner
|===

[[_device_topology_225]]
====== link:#_device_topology_225[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_237]]
====== link:#_test_setup_237[]Test Setup

[[_test_procedure_271]]
====== link:#_test_procedure_271[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 using a key that is pre-installed on the TH. GroupKeySet fields are
as follows:

* GroupKeySetID: 1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|1b |CoreSpec-11.2.7.2 | a|
TH writes the GroupKeyMap attribute in the GroupKeyManagement cluster on
EP0 with maxgroups entries binding GroupId(0x0001 to (maxgroups)) with
GroupKeySetID 1

|Verify that the DUT sends SUCCESS response.

|1c |appclusters-1.3.7.5 | |TH cleans up the groups by sending the
RemoveAllGroups command to the DUT on PIXIT.MOD.ENDPOINT |Verify that
the DUT sends SUCCESS response

|1d |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields :
+
. GroupID as 0x0001
. GroupName as Gp1

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as SUCCESS
. Group ID is 0x0001
. GroupID is same as the one which is sent in AddGroup command

|2a |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 a|
Verify that the GroupTable contains an entry with the following fields:

. GroupId as 0x0001
. Endpoints list includes PIXIT.G.ENDPOINT

|2b |1.3.7.1 |G.S.F00(GN) | a|
Verify that the GroupTable contains an entry with the GroupName as Gp1

|3 |1.3.7.1 a|
G.S.C00.Rsp(AddGroup)

G.S.C00.Tx(AddGroupResponse)

a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields :
+
. GroupID as 0x0002
. GroupName as Gp2

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as SUCCESS
. Group ID is 0x0002

|4a |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on Ep0 a|
Verify that the GroupTable contains an entry with the following fields:

. GroupId as 0x0002
. Endpoints list includes PIXIT.G.ENDPOINT

|4b |1.3.7.1 |G.S.F00(GN) | a|
Verify that the GroupTable contains an entry with the GroupName as Gp2

|5 |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) |TH
sends AddGroup command to DUT on PIXIT.G.ENDPOINT (maxgroups-2) more
times, starting with GroupID 0x0003 and incrementing by 1 each time. a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as SUCCESS

|6 |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on Ep0 a|
Verify that the GroupTable contains entries for each of the IDs added in
step 5.

|7a |11.2.7 | |TH binds GroupId (maxgroups+1) with GroupKeySetID 1
|Verify that the DUT sends SUCCESS response.

|7b |1.3.7.1 |G.S.C00.Rsp(AddGroup) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the GroupID set to (maxgroups+1)

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as RESOURCE_EXHAUSTED

|8 |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 a|
Verify that the GroupTable does not include an entry for GroupId
(maxgroups+1)

|9 |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields :
+
. GroupID as 0x0000
. GroupName as Gp0

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as CONSTRAINT_ERROR as GroupID is not in the inclusive range of
0x0001 to 0xffff

|10 |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields :
+
. GroupID as maxgroups+0x0005
. GroupName as Gp5

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as UNSUPPORTED_ACCESS as GroupID in the AddGroup command does
not have the security key

|11 |1.3.7.2 |G.S.C01.Rsp(ViewGroup) G.S.C01.Tx(ViewGroupResponse) a|
* TH sends ViewGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields:
+
. GroupID as 0x0001

a|
* Verify that the DUT sends a ViewGroupResponse with the following
fields :
+
. GroupID is 0x0001
. Status as SUCCESS

|12 |1.3.7.1 |G.S.F00(GN) | a|
Verify that the ViewGroupResponse contains GroupName belongs to the
GroupID in the ViewGroup command

|13 |1.3.7.2 |G.S.C01.Rsp(ViewGroup) G.S.C01.Tx(ViewGroupResponse) a|
* TH sends ViewGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields:
+
. GroupID as 0x0000

a|
* Verify that the DUT sends a ViewGroupResponse with the following
fields :
+
. Status as CONSTRAINT_ERROR as GroupID is not in the inclusive range of
0x0001 to 0xffff

|14 |1.3.7. |G.S.C03.Rsp(RemoveGroup) G.S.C03.Tx(RemoveGroupResponse) a|
* TH sends RemoveGroup command to DUT on PIXIT.G.ENDPOINT as unicast
with the following field :
+
. GroupID as 0x0001

a|
* Verify that the DUT sends a RemoveGroupResponse with the Status as
SUCCESS
* GroupID is 0x0001

|15 |1.3.7.2 |G.S.C01.Rsp(ViewGroup) G.S.C01.Tx(ViewGroupResponse) a|
* TH sends ViewGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following field :
+
. GroupID as 0x0001

a|
* Verify that the DUT sends a ViewGroupResponse with the following
fields :
+
. Verify that the Status is NOT_FOUND

|16 |1.3.7.2 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 |Verify that none of
the entries have a GroupId of 0x0001 associated with the
PIXIT.G.ENDPOINT

|17 |1.3.7. |G.S.C03.Rsp(RemoveGroup) G.S.C03.Tx(RemoveGroupResponse) a|
* TH sends RemoveGroup command to DUT on PIXIT.G.ENDPOINT as unicast
with the following field :
+
. GroupID as 0x0000

a|
* Verify that the DUT sends a RemoveGroupResponse with the following
fields:
+
. Status as CONSTRAINT_ERROR as GroupID is not in the inclusive range of
0x0001 to 0xffff

|18 |1.3.7. |G.S.C03.Rsp(RemoveGroup) G.S.C03.Tx(RemoveGroupResponse) a|
* TH sends RemoveGroup command to DUT on PIXIT.G.ENDPOINT as unicast
with the following field :
+
. GroupID as 0x0001

a|
* Verify that the DUT sends a RemoveGroupResponse with the following
fields:
+
. Verify that the Status is NOT_FOUND

|19 |1.3.7. |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 |Verify that none of
the entries have a GroupId of 0x0001 associated with the
PIXIT.G.ENDPOINT

|20 |1.3.7. |G.S.C04.Rsp(RemoveAllGroups) |TH sends RemoveAllGroups
command to DUT on PIXIT.G.ENDPOINT as unicast method |Verify that the
DUT sends a response with the Status set as SUCCESS

|21 |1.3.7.2 |G.S.C01.Rsp(ViewGroup) G.S.C01.Tx(ViewGroupResponse) a|
* TH sends ViewGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields:
+
. GroupID as 0x0002

a|
* Verify that the DUT sends a ViewGroupResponse with the following
fields :
+
. Verify that the Status is NOT_FOUND

|22 |1.3.7.2 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 |Verify that there
are no entries associated with the PIXIT.G.ENDPOINT
|===

[[_tc_g_2_3_commands_getgroupmembership_addgroupifidentifying_dut_server]]
===== link:#_tc_g_2_3_commands_getgroupmembership_addgroupifidentifying_dut_server[]131.2.3. [TC-G-2.3] Commands - GetGroupMembership, AddGroupIfIdentifying [DUT-Server]

[[_category_267]]
====== link:#_category_267[]Category

Functional conformance

[[_purpose_272]]
====== link:#_purpose_272[]Purpose

Verifies the DUT behaviour when it receives the following Groups
commands from TH.

. GetGroupMembership
. AddGroupIfIdentifying

[[_pics_272]]
====== link:#_pics_272[]PICS

* G.S

[[_pre_conditions_46]]
====== link:#_pre_conditions_46[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |TH is commissioned with DUT |

|2 |11.2.3.3 |TH reads the MaxGroupsPerFabric from Group key Management
Cluster and saves it as maxgroups |
|===

[[_required_devices_272]]
====== link:#_required_devices_272[]Required Devices

[width="100%",cols="6%,47%,47%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Device Under Test as Commissionee
|2 |TH |Test Harness as Commissioner
|===

[[_device_topology_226]]
====== link:#_device_topology_226[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_238]]
====== link:#_test_setup_238[]Test Setup

[[_test_procedure_272]]
====== link:#_test_procedure_272[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1a |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 using a key that is pre-installed on the TH. GroupKeySet fields are
as follows:

* GroupKeySetID: 1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|1b |CoreSpec-11.2.7.2 | a|
TH writes the GroupKeyMap attribute in the GroupKeyManagement cluster of
DUT on EP0 with maxgroups entries binding GroupId(0x0002 to
(maxgroups+1)) with GroupKeySetID 1

|Verify that the DUT sends SUCCESS response.

|1c |appclusters-1.3.7.5 | |TH cleans up the groups by sending the
RemoveAllGroups command to the DUT on PIXIT.G.ENDPOINT |Verify that the
DUT sends SUCCESS response

|1d |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields :
+
. GroupID as 0x0002
. GroupName as Gp2

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as SUCCESS
. GroupID is 0x0002

|2a |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 a|
Verify that the DUT responds with the GroupTable with the following
entry associated to the PIXIT.G.ENDPOINT

. GroupID as 0x0002

|2b |1.3.7.1 |G.S.F00(GN) | a|
Verify that the GroupTable contains an entry with the GroupName as Gp2

|3 |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT as unicast with
the following fields :
+
. GroupID as 0x0003
. GroupName as Gp3

a|
* Verify that the DUT sends a AddGroupResponse with the following:
+
. Status as SUCCESS
. GroupID is 0x0003

|4a |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 a|
Verify that the GroupTable list includes two entries and and has one
entry with the following fields:

. GroupId as 0x0003

|4b |1.3.7.1 |G.S.F00(GN) | a|
Verify that the GroupTable contains an entry with the GroupName as Gp3

|5 |1.3.7.3 |G.S.C02.Rsp(GetGroupMembership)
G.S.C02.Tx(GetGroupMembershipResponse) a|
* TH sends GetGroupMembership command to DUT on PIXIT.G.ENDPOINT with
the following fields :
+
. GroupList as NULL

a|
* Verify that the DUT sends a GetGroupMembershipResponse with the
following fields:
+
. Verify that the Capacity is in the inclusive range of 0 to 254 or null
. GroupList is in the inclusive range of 0x0001 - 0xffff
. Verify that the response contains all the GroupID associated with the
PIXIT.G.ENDPOINT

|6 |1.3.7.3 |G.S.C02.Rsp(GetGroupMembership)
G.S.C02.Tx(GetGroupMembershipResponse) a|
* TH sends GetGroupMembership command to DUT on PIXIT.G.ENDPOINT with
the following fields :
+
. GroupList as [0x0002]

a|
* Verify that the DUT sends a GetGroupMembershipResponse with the
following fields:
+
. Verify that the Capacity is in the inclusive range of 0 to 254 or null
. GroupList contains one item: 0x0002

|7 |1.3.7.3 |G.S.C02.Rsp(GetGroupMembership)
G.S.C02.Tx(GetGroupMembershipResponse) a|
* TH sends GetGroupMembership command to DUT on PIXIT.G.ENDPOINT as
unicast with the following fields :
+
. GroupList as [0x0002, 0x0003]

a|
* Verify that the DUT sends a GetGroupMembershipResponse with the
following fields:
+
. Verify that the Capacity is in the inclusive range of 0 to 254 or null
. GroupList contains two items: 0x0002 and 0x0003

|8 |1.3.7. |G.S.C04.Rsp(RemoveAllGroups) |TH sends RemoveAllGroups
command to DUT on PIXIT.G.ENDPOINT as unicast method |Verify that the
DUT sends a response with the Status set as SUCCESS

|9a |11.2.7 | |TH writes the GroupKeyMap attribute in the
GroupKeyManagement cluster of DUT on EP0 to binds GroupId(0x0006 to
0x0006 + maxgroups-1 ) with GroupKeySetID 1 |Verify that the DUT sends
SUCCESS response

|9b |1.2.6 |I.S.C00.Rsp(Identify) |TH sends Identify command to DUT on
PIXIT.I.ENDPOINT with the IdentifyTime as (0x0078) 120 seconds |

|9c |1.2.7 |I.S.A0000(IdentifyTime) |TH reads immediately IdentifyTime
attribute from DUT |Verify that the IdentifyTime attribute has a value
approximately equal to 0x0078

|10 |1.3.7. |G.S.C05.Rsp(AddGroupIfIdentifying) a|
* TH sends AddGroupIfIdentifying command to DUT on PIXIT.G.ENDPOINT as
unicast method with the following fields:
+
. GroupID as 0x0006
. GroupName as Gp6

a|
* Verify that the DUT sends a response with
+
. Status as SUCCESS
. GroupId is 0x0006

|11a |1.3.7. |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster of DUT on EP0 |Verify DUT responds
with the groups that are added in the GroupTable with provided GroupId
associated with the PIXIT.G.ENDPOINT

|11b |1.3.7.1 |G.S.F00(GN) | a|
Verify DUT responds with provided GroupName as Gp6 associated with the
PIXIT.G.ENDPOINT

|12 |1.3.7. |G.S.C05.Rsp(AddGroupIfIdentifying) a|
* TH sends AddGroupIfIdentifying command to DUT on PIXIT.G.ENDPOINT as
unicast method with the following fields:
+
. GroupID as 0x0007
. GroupName as Gp7

a|
* Verify that the DUT sends a response with
+
. Status as SUCCESS
. GroupId is 0x0007

|13 |1.3.7. |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 |Verify DUT responds
with the groups that are added in the GroupTable with provided GroupId
associated with the PIXIT.G.ENDPOINT

|14 |1.3.7.1 |G.S.F00(GN) | a|
Verify DUT responds with provided GroupName as Gp7 associated with the
PIXIT.G.ENDPOINT

|15 |1.3.7 |G.S.C05.Rsp(AddGroupIfIdentifying) |TH sends
AddGroupIfIdentifying command to DUT PIXIT.G.ENDPOINT with (maxgroups -
2) groups, incrementing the GroupId each time starting from 0x0008.
|Verify that the DUT sends a response with Status as SUCCESS with the
GroupId specified in the command

|16a |11.2.7 | |TH binds GroupId( 0x0006 + maxgroups to 0x0006 +
maxgroups+1) with GroupKeySetID 1 |Verify that the DUT sends SUCCESS
response

|16b |1.3.7. |G.S.C05.Rsp(AddGroupIfIdentifying) |TH sends
AddGroupIfIdentifying command to DUT PIXIT.G.ENDPOINT once as unicast
method with different GroupID a|
* Verify that the DUT sends a response with
+
. Status of RESOURCE_EXHAUSTED when the number of entries in GroupTable
is greater than the MaxGroupsPerFabric attribute.

|17 |1.3.7. |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 |Verify that GroupId
( 0x0006 + maxgroups to 0x0006 + maxgroups+1) is not present in the
GroupTable

|18 |1.3.7. |G.S.C04.Rsp(RemoveAllGroups) |TH sends RemoveAllGroups
command to DUT on PIXIT.G.ENDPOINT as unicast method |Verify that the
DUT sends a response with the Status set as SUCCESS

|19 |1.3.7. |G.S.C05.Rsp(AddGroupIfIdentifying) a|
* TH sends AddGroupIfIdentifying command to DUT on PIXIT.G.ENDPOINT as
unicast method with the following fields:
+
. GroupID as 0x0000
. GroupName as Gp45

a|
* Verify that the DUT sends a response with
+
. Status as CONSTRAINT_ERROR as GroupId is not in the inclusive range of
0x0001 to 0xffff

|20 |1.3.7. |G.S.C05.Rsp(AddGroupIfIdentifying) a|
* TH sends AddGroupIfIdentifying command to DUT on PIXIT.G.ENDPOINT as
unicast method with the following fields:
+
. GroupId as 0x0046
. GroupName as Gp46

a|
* Verify that the DUT sends a response with
+
. Status as UNSUPPORTED_ACCESS as GroupId in the AddGroupIfIdentifying
command does not have the security key

|21a |1.2.6 |I.S.C00.Rsp(Identify) |TH sends Identify command to DUT on
PIXIT.I.ENDPOINT with the IdentifyTime as 0x0000 (stop identifying) |

|21b |1.2.7 |I.S.A0000(IdentifyTime) |TH reads immediately IdentifyTime
attribute from DUT |Verify that the IdentifyTime attribute has the value
as 0x0000

|22 |1.3.7. |G.S.C05.Rsp(AddGroupIfIdentifying) a|
* TH sends AddGroupIfIdentifying command to DUT on PIXIT.G.ENDPOINT as
unicast method with the following fields:
+
. GroupId as 0x0004
. GroupName as Gp4

a|
* Verify that the DUT sends a response with
+
. Status as SUCCESS
. GroupId is 0x0004

|23 |1.3.7. |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster of DUT on EP0 |Verify DUT responds
that the group is not added in the GroupTable with provided
GroupId(0x0004) associated with the PIXIT.G.ENDPOINT
|===

[[_tc_g_2_4_commands_addgroup_command_with_same_groupid_on_multiple_endpoint_dut_server]]
===== link:#_tc_g_2_4_commands_addgroup_command_with_same_groupid_on_multiple_endpoint_dut_server[]131.2.4. [TC-G-2.4] Commands - AddGroup Command with same GroupID on Multiple Endpoint [DUT-Server]

[[_category_268]]
====== link:#_category_268[]Category

Functional conformance

[[_purpose_273]]
====== link:#_purpose_273[]Purpose

Verifies the DUT behaviour when it receives the following Groups
commands from TH with same Group ID on Multiple Endpoint.

. AddGroup
. RemoveGroup

[[_pics_273]]
====== link:#_pics_273[]PICS

* G.S
* MCORE.G.MULTIENDPOINT

[[_pre_conditions_47]]
====== link:#_pre_conditions_47[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Note: This test case is applicable only when DUT supports Group
Cluster at least on two end points: PIXIT.G.ENDPOINT,PIXIT.G.ENDPOINT2 |

|2 | |TH is commissioned with DUT |
|===

[[_required_devices_273]]
====== link:#_required_devices_273[]Required Devices

[width="100%",cols="6%,47%,47%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Device Under Test as Commissionee
|2 |TH |Test Harness as Commissioner
|===

[[_device_topology_227]]
====== link:#_device_topology_227[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_239]]
====== link:#_test_setup_239[]Test Setup

[[_test_procedure_273]]
====== link:#_test_procedure_273[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |CoreSpec-11.2.7.2 | a| |Verify that PIXIT.G.ENDPOINT and
PIXIT.G.ENDPOINT2 are different.

|2 |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT on
EP0 using a key that is pre-installed on the TH. GroupKeySet fields are
as follows:

* GroupKeySetID: 1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|3 |CoreSpec-11.2.7.2 | a|
TH writes the GroupKeyMap attribute in the GroupKeyManagement cluster on
EP0 with one entry binding GroupId(0x0001) with GroupKeySetID 1

|Verify that the DUT sends SUCCESS response.

|4 |appclusters-1.3.7.5 | |TH cleans up the groups by sending the
RemoveAllGroups command to the DUT on PIXIT.G.ENDPOINT,PIXIT.G.ENDPOINT2
|Verify that the DUT sends SUCCESS response

|5a |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT with the
following fields:
+
. GroupID as 0x0001
. GroupName as 'Gp1'

a|
* Verify that the TH receives a AddGroupResponse the following:
+
. Status as SUCCESS
. Group ID is 0x0001

|5b |1.3.7.1 |G.S.C00.Rsp(AddGroup) G.S.C00.Tx(AddGroupResponse) a|
* TH sends AddGroup command to DUT on PIXIT.G.ENDPOINT2 with the
following fields:
+
. GroupID as 0x0001
. GroupName as 'Gp2'

a|
* Verify that the TH receives a AddGroupResponse with the following:
+
. Status as SUCCESS
. GroupID is 0x0001

|6 |1.3.7.1 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 a|
Verify that the GroupTable contains an entry with the following fields:

. GroupID as 0x0001
. Endpoints list includes PIXIT.G.ENDPOINT,PIXIT.G.ENDPOINT2

|7 |1.3.7.1 |G.S.F00(GN) | a|
Verify that the GroupTable contains an entry with the GroupName as 'Gp2'

|8 |1.3.7.2 |G.S.C01.Rsp(ViewGroup) G.S.C01.Tx(ViewGroupResponse) a|
TH sends ViewGroup command to DUT on PIXIT.G.ENDPOINT with the following
fields:

. GroupID as 0x0001

a|
* Verify that the DUT sends a ViewGroupResponse with the following
fields :
+
. GroupID as 0x0001
. Status as SUCCESS

|9 |1.3.7.1 |G.S.F00(GN) | a|
* Verify that the ViewGroupResponse contains GroupName as 'GP2'
* Note: GroupName for GroupID 0x0001 is same on PIXIT.G.ENDPOINT and
PIXIT.G.ENDPOINT2

|10 |1.3.7. |G.S.C03.Rsp(RemoveGroup) G.S.C03.Tx(RemoveGroupResponse) a|
* TH sends RemoveGroup command to DUT on PIXIT.G.ENDPOINT as unicast
with the following field:
+
. GroupID as 0x0001

a|
* Verify that the DUT sends a RemoveGroupResponse with the Status as
SUCCESS
* GroupID is 0x0001

|11 |1.3.7.2 |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 a|
* Verify that there is one entry with GroupID 0x0001 associated with the
PIXIT.G.ENDPOINT2
* Verify that there is no entry with GroupID 0x0001 associated with the
PIXIT.G.ENDPOINT

|12 |1.3.7. |G.S.C03.Rsp(RemoveGroup) G.S.C03.Tx(RemoveGroupResponse) a|
* TH sends RemoveGroup command to DUT on PIXIT.G.ENDPOINT2 as unicast
with the following field:
+
. GroupID as 0x0001

a|

|13 |1.3.7. |GRPKEY.S.A0001(GroupTable) |TH reads GroupTable attribute
from the GroupKeyManagement cluster from DUT on EP0 |Verify that there
is no entry that has GroupID 0x0001 associated with the
PIXIT.G.ENDPOINT2
|===

'''''

[[_client_as_dut_9]]
==== link:#_client_as_dut_9[]131.3. Client as DUT

'''''

[[_tc_g_3_2_commands_dut_client]]
===== link:#_tc_g_3_2_commands_dut_client[]131.3.1. [TC-G-3.2] Commands [DUT-Client]

[[_category_269]]
====== link:#_category_269[]Category

Functional conformance

[[_purpose_274]]
====== link:#_purpose_274[]Purpose

To Verify the Groups Cluster Commands sent by the DUT.

[[_pics_274]]
====== link:#_pics_274[]PICS

* G.C

[[_pre_conditions_48]]
====== link:#_pre_conditions_48[]Pre-Conditions

[width="100%",cols="5%,10%,45%,40%",options="header",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |Commission TH to DUT |

|2 | a|
* DUT generates fabric-unique GroupID, GroupName, random key, EpochKey0
and GroupKeySetID.
* DUT generates an EpochKey and saves as `epoch_key_set1_epoch0`
* DUT sends a KeySetWriteCommand to the Group Key Management cluster
with the following fields set in the GroupKeySet struct:
* GroupKeySetId is 1
* EpochKey0 is `epoch_key_set0_epoch0`
+
. GroupKeySecurityPolicy = TrustFirst (0)
. GroupKeyMulticastPolicy = PerGroupID (0)
. EpochStartTime0 = 0
* TH binds GroupId with GroupKeySetID in the GroupKeyMap attribute list
on GroupKeyManagement cluster with the values provided in the above
steps

|
|===

[[_required_devices_274]]
====== link:#_required_devices_274[]Required Devices

[width="100%",cols="6%,47%,47%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |DUT |Device Under Test as Commissioner
|2 |TH |Test Harness as Commissionee
|===

[[_device_topology_228]]
====== link:#_device_topology_228[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_240]]
====== link:#_test_setup_240[]Test Setup

[[_test_procedure_274]]
====== link:#_test_procedure_274[]Test Procedure

[width="100%",cols="6%,9%,9%,40%,36%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |1.3.7.3 |G.C.C02.Tx(GetGroupMembership) |DUT sends
GetGroupMembership command to TH |Test Harness receives the
GetGroupMembership command from the DUT.

|2 |1.3.7.4 |G.C.C03.Tx(RemoveGroup) |DUT sends RemoveGroup command to
TH |Test Harness receives the RemoveGroup command from the DUT.

|3 |1.3.7.4 |G.C.C04.Tx(RemoveAllGroups) |DUT sends RemoveAllGroups
command to TH |Test Harness receives the RemoveAllGroups command from
the DUT.

|4 |1.3.7.4 |G.C.C05.Tx(AddGroupIfIdentifying) |DUT sends
AddGroupIfIdentifying command to TH |Test Harness receives the
AddGroupIfIdentifying command from the DUT.
|===

[[_scenes_cluster_test_plan]]
== link:#_scenes_cluster_test_plan[]**Scenes Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |2022-04-25 |`Leo Rozendaal` |first version

|0.2 |2022-05-30 |`Leo Rozendaal` |PICS rework

|1.1 |2023-05-01 |`Yinyi Hu` |Update tests with updated spec

|1.1.1 |2023-07-11 |`Yinyi Hu` |Update tests based on spec 0.7 updates.

|1.1.2 |2023-07-23 |`Krithika Ananthakrishnan` |Remove Client Tests -
Issue #2961
|===

[[_pixit_items]]
=== link:#_pixit_items[]132. PIXIT items

[width="100%",cols="34%,33%,33%",options="header",]
|===
|Item number |Feature |Support
|PIXIT.S.SceneTableEntriesOnFactoryNew |How many scene table entries are
automatically created on the device when factory new? |_"Number of
entries"_
|===

[[_pics_definition_38]]
=== link:#_pics_definition_38[]133. PICS Definition

This section covers the Scenes Cluster Test Plan related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_40]]
==== link:#_role_40[]133.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|S.S |Does the device implement the Scenes cluster as a server? |O |

|S.C |Does the device implement the Scenes cluster as a client? |O |
|===

[[_server_40]]
==== link:#_server_40[]133.2. Server

[[_features_26]]
===== link:#_features_26[]133.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|S.S.F00(SN) |Does the device support this specific cluster feature? |O
|

|S.S.F01(EX) |Does the device support this specific cluster feature? |O
|

|S.S.F02(TS) |Does the device support this specific cluster feature? |O
|

|S.S.F03(FS) |Does the device support this specific cluster feature? |O
|
|===

[[_attributes_44]]
===== link:#_attributes_44[]133.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|S.S.A0000(SceneCount) |Does the device implement the SceneCount
attribute? |!S.S.F03(FS) |

|S.S.A0001(CurrentScene) |Does the device implement the CurrentScene
attribute? |!S.S.F03(FS) |

|S.S.A0002(CurrentGroup) |Does the device implement the CurrentGroup
attribute? |!S.S.F03(FS) |

|S.S.A0003(SceneValid) |Does the device implement the SceneValid
attribute? |!S.S.F03(FS) |

|S.S.A0004(NameSupport) |Does the device implement the NameSupport
attribute? |M |

|S.S.A0005(LastConfiguredBy) |Does the device implement the
LastConfiguredBy attribute? |O |

|S.S.A0006(SceneTableSize) |Does the device implement the SceneTableSize
attribute? |S.S.F02(TS) |

|S.S.A0007(FabricSceneInfo) |Does the device implement the
FabricSceneInfo attribute? |S.S.F03(FS) |
|===

[[_commands_received_25]]
===== link:#_commands_received_25[]133.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|S.S.C00.Rsp(AddScene) |Does the device implement receiving the AddScene
command? |M |

|S.S.C01.Rsp(ViewScene) |Does the device implement receiving the
ViewScene command? |M |

|S.S.C02.Rsp(RemoveScene) |Does the device implement receiving the
RemoveScene command? |M |

|S.S.C03.Rsp(RemoveAllScenes) |Does the device implement receiving the
RemoveAllScenes command? |M |

|S.S.C04.Rsp(StoreScene) |Does the device implement receiving the
StoreScene command? |M |

|S.S.C05.Rsp(RecallScene) |Does the device implement receiving the
RecallScene command? |M |

|S.S.C06.Rsp(GetSceneMembership) |Does the device implement receiving
the GetSceneMembership command? |M |

|S.S.C40.Rsp(EnhancedAddScene) |Does the device implement receiving the
EnhancedAddScene command? |O |

|S.S.C41.Rsp(EnhancedViewScene) |Does the device implement receiving the
EnhancedViewScene command? |O |

|S.S.C42.Rsp(CopyScene) |Does the device implement receiving the
CopyScene command? |O |
|===

[[_commands_generated_26]]
===== link:#_commands_generated_26[]133.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|S.S.C00.Tx(AddSceneResponse) |Does the device implement
invoking/generating AddSceneResponse command? |M |

|S.S.C01.Tx(ViewSceneResponse) |Does the device implement
invoking/generating ViewSceneResponse command? |M |

|S.S.C02.Tx(RemoveSceneResponse) |Does the device implement
invoking/generating RemoveSceneResponse command? |M |

|S.S.C03.Tx(RemoveAllScenesResponse) |Does the device implement
invoking/generating RemoveAllScenesResponse command? |M |

|S.S.C04.Tx(StoreSceneResponse) |Does the device implement
invoking/generating StoreSceneResponse command? |M |

|S.S.C06.Tx(GetSceneMembershipResponse) |Does the device implement
invoking/generating GetSceneMembershipResponse command? |M |

|S.S.C40.Tx(EnhancedAddSceneResponse) |Does the device implement
invoking/generating EnhancedAddSceneResponse command?
|S.S.C40.Rsp(EnhancedAddScene) |

|S.S.C41.Tx(EnhancedViewSceneResponse) |Does the device implement
invoking/generating EnhancedViewSceneResponse command?
|S.S.C41.Rsp(EnhancedViewScene) |

|S.S.C42.Tx(CopySceneResponse) |Does the device implement
invoking/generating CopySceneResponse command? |S.S.C42.Rsp(CopyScene) |
|===

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PICS_SC_RECALL_SCENE_TRANSITION_TIME |Does the device process the
_TransitionTime_ parameter of the _RecallScene_ command? |O |
|===

Additionally, these PICS items from the Groups cluster are used in this
test plan - these definitions are copies from the relevant test plan:

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|G.S.C00.Rsp(AddGroup) |Does the device receive the AddGroup Command?
|G.S: Mandatory |

|G.S.C04.Rsp(RemoveAllGroups) |Does the device receive the
RemoveAllGroups Command? |G.S: Mandatory |
|===

[[_client_21]]
==== link:#_client_21[]133.3. Client

[[_commands_generated_27]]
===== link:#_commands_generated_27[]133.3.1. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|S.C.C00.Tx(AddScene) |Does the device implement receiving the AddScene
command? |O |

|S.C.C01.Tx(ViewScene) |Does the device implement receiving the
ViewScene command? |O |

|S.C.C02.Tx(RemoveScene) |Does the device implement receiving the
RemoveScene command? |O |

|S.C.C03.Tx(RemoveAllScenes) |Does the device implement receiving the
RemoveAllScenes command? |O |

|S.C.C04.Tx(StoreScene) |Does the device implement receiving the
StoreScene command? |O |

|S.C.C05.Tx(RecallScene) |Does the device implement receiving the
RecallScene command? |O |

|S.C.C06.Tx(GetSceneMembership) |Does the device implement receiving the
GetSceneMembership command? |O |

|S.C.C40.Tx(EnhancedAddScene) |Does the device implement receiving the
EnhancedAddScene command? |O |

|S.C.C41.Tx(EnhancedViewScene) |Does the device implement receiving the
EnhancedViewScene command? |O |

|S.C.C42.Tx(CopyScene) |Does the device implement receiving the
CopyScene command? |O |
|===

[[_test_case_list_40]]
=== link:#_test_case_list_40[]134. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*

|1 |TC-S-1.1 |Global attributes with DUT as Server

|2 |TC-S-2.1 |Attributes with DUT as Server

|3 |TC-S-2.2 |Primary functionality with DUT as Server

|4 |TC-S-2.3 |Secondary functionality with DUT as Server

|5 |TC-S-2.4 |Recall scene with transition time functionality DUT as
Server

|6 |TC-S-2.5 |RemainingCapacity functionality with DUT as Server

|7 |TC-S-2.6 |RemainingCapacity functionality with DUT as Server -
Multi-Fabric
|===

[[_testing_tolerances]]
==== link:#_testing_tolerances[]134.1. Testing tolerances

In test cases where a change in an attribute value is tested over time,
it is permitted for the devices involved in the test to be within a
tolerance of ±15% of the expected value. As such, these test cases
indicate that the attribute value must be approximately equal to an
expected value, to which the ±15% tolerance should then be applied. All
other attribute values presented are expected to be exact.

[[_test_steps_manipulating_attributes]]
==== link:#_test_steps_manipulating_attributes[]134.2. Test steps manipulating attributes

In test case steps that require more than one attribute to be
manipulated (e.g. read), the tester may decide whether it is appropriate
or practical to send a single attribute manipulation command, containing
multiple attributes, or multiple attribute manipulation commands, each
containing a single attribute. The test case is designed to verify the
behavior of the device supporting the attribute rather that verifying
the attribute manipulation command in question.

[[_test_cases_40]]
=== link:#_test_cases_40[]135. Test Cases

'''''

[[_generic_test_cases_34]]
==== link:#_generic_test_cases_34[]135.1. Generic test cases

'''''

[[_tc_s_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_s_1_1_global_attributes_with_dut_as_server[]135.1.1. [TC-S-1.1] Global attributes with DUT as Server

[[_purpose_275]]
====== link:#_purpose_275[]Purpose

This test case verifies the Scenes Global Attributes.

[[_pics_275]]
====== link:#_pics_275[]PICS

* S.S

[[_required_devices_275]]
====== link:#_required_devices_275[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as client
|2 |DUT |Device Under Test as server
|===

[[_device_topology_229]]
====== link:#_device_topology_229[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_241]]
====== link:#_test_setup_241[]Test Setup

Verify that the global attributes are set correctly.

[[_test_procedure_275]]
====== link:#_test_procedure_275[]Test Procedure

[width="100%",cols="20%,20%,20%,20%,20%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |DUT and TH are on same fabric

|2 | | |TH reads from the DUT the _ClusterRevision attribute_ |Verify
that the DUT response contains a Minimal revision of 5

|3 | | |TH reads from the DUT the _FeatureMap attribute_ a|
Verify that the DUT response contains the following bitmap32

- bit 0 is set to 1 if S.S.F00(SN) is true, and 0 otherwise - other bits
SHALL be set to 0

|4 | | |TH reads from the DUT the _AttributeList attribute_ a|
Verify that the DUT response contains a list of supported attributes
based on its PICS support: bit for an attribute must be set to 1 if the
corresponding PICS is true, and set to 0 otherwise

- S.S.A0000(SceneCount) - S.S.A0001(CurrentScene) -
S.S.A0002(CurrentGroup) - S.S.A0003(SceneValid) - S.S.A0004(NameSupport)
- S.S.A0005(LastConfiguredBy) - S.S.A0006(SceneTableSize) -
S.S.A0007(FabricSceneInfo) - It SHALL include global attributes
(0xFFFD)ClusterRevision, (0xFFFC)FeatureMap, (0xFFFB)AttributeList,
(0xFFF9)AcceptedCommandList & (0xFFF8)GeneratedCommandList.

|5 | | |TH reads from the DUT the _EventList attribute_ |Verify that the
DUT response contains a list of supported events - SHALL be empty for
this cluster.

|6 | | |TH reads from the DUT the _AcceptedCommandList attribute_ a|
Verify that the DUT response contains a list of Accepted commands based
on its PICS support: bit for a command must be set to 1 if the
corresponding PICS is true, and set to 0 otherwise

- S.S.C00.Rsp(AddScene)) - S.S.C01.Rsp(ViewScene) -
S.S.C02.Rsp(RemoveScene) - S.S.C03.Rsp(RemoveAllScenes) -
S.S.C04.Rsp(StoreScene) - S.S.C05.Rsp(RecallScene) -
S.S.C06.Rsp(GetSceneMembership) - S.S.C40.Rsp(EnhancedAddScene) -
S.S.C41.Rsp(EnhancedViewScene) - S.S.C42.Rsp(CopyScene)

|7 | | |TH reads from the DUT the _GeneratedCommandList attribute_ a|
Verify that the DUT response contains a list of Generated commands based
on its PICS support: bit for a command must be set to 1 if the
corresponding PICS is true, and set to 0 otherwise

- S.S.C00.Tx(AddSceneResponse) - S.S.C01.Tx(ViewSceneResponse) -
S.S.C02.Tx(RemoveSceneResponse) - S.S.C03.Tx(RemoveAllScenesResponse) -
S.S.C04.Tx(StoreSceneResponse) - S.S.C06.Tx(GetSceneMembershipResponse)
- S.S.C40.Tx(EnhancedAddSceneResponse) -
S.S.C41.Tx(EnhancedViewSceneResponse) - S.S.C42.Tx(CopySceneResponse)

|===

[[_notestesting_considerations_235]]
====== link:#_notestesting_considerations_235[]Notes/Testing Considerations

Based on Spec commit: de14338c6 on Jun 30, 2023

'''''

[[_server_as_dut_24]]
==== link:#_server_as_dut_24[]135.2. Server as DUT

'''''

[[_tc_s_2_1_attributes_with_dut_as_server]]
===== link:#_tc_s_2_1_attributes_with_dut_as_server[]135.2.1. [TC-S-2.1] Attributes with DUT as Server

[[_category_270]]
====== link:#_category_270[]Category

Functional conformance

[[_purpose_276]]
====== link:#_purpose_276[]Purpose

This test case verifies the Scenes Cluster attributes with server as DUT

[[_pics_276]]
====== link:#_pics_276[]PICS

* S.S

[[_required_devices_276]]
====== link:#_required_devices_276[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as client
|2 |DUT |Device Under Test as server
|===

[[_test_procedure_276]]
====== link:#_test_procedure_276[]Test Procedure

[width="100%",cols="6%,8%,8%,39%,39%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |S.S.A0000(SceneCount) |TH reads from the DUT the _SceneCount
attribute_ |Verify that the DUT response contains an uint8

|3 | |S.S.A0001(CurrentScene) |TH reads from the DUT the _CurrentScene
attribute_ |Verify that the DUT response contains an uint8

|4 | |S.S.A0002(CurrentGroup) |TH reads from the DUT the _CurrentGroup
attribute_ |Verify that the DUT response contains a group-id

|5 | |S.S.A0003(SceneValid) |TH reads from the DUT the _SceneValid
attribute_ |Verify that the DUT response contains a boolean

|6 | |S.S.A0004(NameSupport) |TH reads from the DUT the _NameSupport
attribute_ |Verify that the DUT response contains a map8 +
IF S.S.F00(SN) THEN value returned SHALL be 0x80 ELSE value returned
SHALL be 0x00

|7 | |S.S.A0005(LastConfiguredBy) |TH reads from the DUT the
_LastConfiguredBy attribute_ |Verify that the DUT response contains a
node-id

|8 | |S.S.A0006(SceneTableSize) |TH reads from the DUT the
_SceneTableSize attribute_ |Verify that the DUT response contains an
uint16

|9 | |S.S.A0007(FabricSceneInfo) |TH reads from the DUT the
_FabricSceneInfo attribute_ |Verify that the DUT response contains a
list of SceneInfoStruct
|===

[[_notestesting_considerations_236]]
====== link:#_notestesting_considerations_236[]Notes/Testing Considerations

Based on Spec commit: de14338c6 on Jun 30, 2023

[[_tc_s_2_2_primary_functionality_with_dut_as_server]]
===== link:#_tc_s_2_2_primary_functionality_with_dut_as_server[]135.2.2. [TC-S-2.2] Primary functionality with DUT as Server

[[_category_271]]
====== link:#_category_271[]Category

Functional

[[_purpose_277]]
====== link:#_purpose_277[]Purpose

This test case verifies the primary functionality of the Scenes cluster
server.

This test case requires an _application configuration_, _AC_, to be set
on the device in order to create a scene. An _AC_ is essentially a set
of cluster attribute settings which affect the scene and is dependent on
the application clusters supported on the server device. When the test
calls for a specific _AC~i~_ it is up to the tester to manipulate the
attributes on the DUT according to the supported clusters such that each
_AC~i~_ is unique.

Since Scenes are using concepts from the Groups cluster, some commands
from the Groups cluster are used in this test, e.g. _AddGroup_,
_AddGroupResponse_ and _RemoveAllGroups_.

[[_pics_277]]
====== link:#_pics_277[]PICS

* S.S

[[_required_devices_277]]
====== link:#_required_devices_277[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as client
|2 |DUT |Device Under Test as server
|===

[[_device_topology_230]]
====== link:#_device_topology_230[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_242]]
====== link:#_test_setup_242[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test)

[[_test_procedure_277]]
====== link:#_test_procedure_277[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|0a |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|0b |CoreSpec-11.2.7.2 | a|
TH binds GroupIds 0x0001 and 0x0002 with GroupKeySetID 0x01a1 in the
GroupKeyMap attribute list on GroupKeyManagement cluster by writing the
GroupKeyMap attribute with two entries as follows:

* List item 1:
+
** FabricIndex: 1
** GroupId: 0x0001
** GroupKeySetId: 0x01a1
* List item 2:
+
** FabricIndex: 1
** GroupId: 0x0002
** GroupKeySetId: 0x01a1

|Verify that the DUT sends SUCCESS response.

|0c | |G.S.C04.Rsp(RemoveAllGroups) |TH sends a _RemoveAllGroups_
command to DUT. |If a status response is expected, DUT sends a response
to TH with the _Status_ field equal to 0x00 (SUCCESS).

|1a | |G.S.C00.Rsp(AddGroup) |TH sends a _AddGroup_ command to DUT with
the _GroupID_ field set to _G~1~_. |DUT sends a _AddGroupResponse_
command to TH with the _Status_ field set to 0x00 (SUCCESS) and the
_GroupID_ field set to _G~1~_.

|1b | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~1~_.

|1c | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field recorded into _SC~0~_ for later
use, the _GroupID_ field set to _G~1~_ and the _SceneList_ field
containing 0 entry

|2a | |- |TH configures _AC~1~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~1~_.

|2b | |S.S.C04.Rsp(StoreScene) |TH sends a StoreScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. |DUT sends a StoreSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x01.

|3a | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different from _AC~1~_.

|3b | |S.S.C05.Rsp(RecallScene) |TH sends a RecallScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. a|
If a status response is expected, DUT sends a response to TH with the
_Status_ field equal to 0x00 (SUCCESS).

DUT returns to _AC~1~_.

|3c | |!S.S.F03(FS) |TH reads attribute SceneCount from DUT. |DUT
responds with the value (PIXIT.S.SceneTableEntriesOnFactoryNew + 1)

|3d | |!S.S.F03(FS) |TH reads attribute CurrentScene from DUT. |DUT
responds with the value 0x01

|3e | |!S.S.F03(FS) |TH reads attribute CurrentGroup from DUT. |DUT
responds with the value _G~1~_

|3f | |!S.S.F03(FS) |TH reads attribute SceneValid from DUT. |DUT
responds with the value TRUE.

|3g | |S.S.F02(TS) & S.S.F03(FS) |TH reads attribute SceneTableSize from
DUT. |DUT responds with an uint16.

|3h | |S.S.F03(FS) |TH reads attribute FabricSceneInfo from DUT. a|
DUT provides FabricSceneInfo containing (for the current fabric)
following fields:

* _SceneCount_ has the value (PIXIT.S.SceneTableEntriesOnFactoryNew + 1)
* _CurrentScene_ has the value 0x01
* _CurrentGroup_ has the value _G~1~_
* _SceneValid_ has the value TRUE.
* if S.S.F02(TS), _RemainingCapacity_ has the value _SceneTableSize/2_

|4a | |- |By application specific means, remove the power source from
DUT. |DUT is powered off.

|4b | |- |By application specific means, return the power source to DUT.
|DUT is powered on.

|4c | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different from _AC~1~_.

|4d | |S.S.C05.Rsp(RecallScene) |TH sends a RecallScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. a|
If a status response is expected, DUT sends a response to TH with the
_Status_ field equal to 0x00 (SUCCESS).

DUT returns to _AC~1~_.

|5 | |S.S.C01.Rsp(ViewScene) |TH sends a ViewScene command to DUT with
the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to 0x01.
|DUT sends a ViewSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_, the _SceneID_
field set to 0x01, the _TransitionTime_ field set to 0x0000 and a set of
extension fields appropriate to _AC~1~_.

|6 | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
1), 0xfe or null, the _GroupID_ field set to _G~1~_, the _SceneList_
field containing only the scene ID 0x01.

|7a | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~1~_.

|7b | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values _SC~0~_,
0xfe or null, the _GroupID_ field set to _G~1~_ and the _SceneList_
field containing 0 entry

|8a | |S.S.C00.Rsp(AddScene) |TH sends a AddScene command to DUT with
the _GroupID_ field set to _G~1~_, the _SceneID_ field set to 0x01, the
_TransitionTime_ field set to 0x0001 and a set of extension fields
appropriate to _AC~1~_. |DUT sends a AddSceneResponse command to TH with
the _Status_ field set to 0x00 (SUCCESS), the _GroupID_ field set to
_G~1~_ and the _SceneID_ field set to 0x01.

|8b | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
1), 0xfe or null, the _GroupID_ field set to _G~1~_ and the _SceneList_
field containing only the scene ID 0x01.

|9a | |S.S.C02.Rsp(RemoveScene) |TH sends a RemoveScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. |DUT sends a RemoveSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x01.

|9b | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values _SC~0~_,
0xfe or null, the _GroupID_ field set to _G~1~_ and the _SceneList_
field containing 0 entry

|10a | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different from _AC~1~_.

|10b | |S.S.C05.Rsp(RecallScene) |TH sends a RecallScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. a|
If a status response is expected, DUT sends a response to TH with the
_Status_ field equal to 0x8b (NOT_FOUND).

|11a | |- |TH configures _AC~1~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~1~_.

|11b | |S.S.C04.Rsp(StoreScene) |TH sends a StoreScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. |DUT sends a StoreSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x01.

|12a | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different to _AC~1~_.

|12b | |S.S.C04.Rsp(StoreScene) |TH sends a StoreScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x02. a|
DUT sends a StoreSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS) or 0x89 (INSUFFICIENT_SPACE).

* If SUCCESS, with the _GroupID_ field set to _G~1~_ and the _SceneID_
field set to 0x02.
* If INSUFFICIENT_SPACE, the following steps SHALL NOT be executed.

|12c | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
2), 0xfe or null, the _GroupID_ field set to _G~1~_ and the _SceneList_
field containing the scene IDs 0x01 and 0x02.

|13a | |G.S.C00.Rsp(AddGroup) |If capacity allows, TH sends a _AddGroup_
command to DUT with the _GroupID_ field set to _G~2~_. |DUT sends a
_AddGroupResponse_ command to TH with the _Status_ field set to 0x00
(SUCCESS) and the _GroupID_ field set to _G~2~_.

|13b | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~2~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~2~_.

|13c | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~2~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
2), 0xfe or null, the _GroupID_ field set to _G~2~_ and the _SceneList_
field containing 0 entry

|14a | |- |TH configures _AC~3~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~3~_ which is
different to both _AC~1~_ and _AC~2~_.

|14b | |S.S.C04.Rsp(StoreScene) |TH sends a StoreScene command to DUT
with the _GroupID_ field set to _G~2~_ and the _SceneID_ field set to
0x03. a|
DUT sends a StoreSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS) or 0x89 (INSUFFICIENT_SPACE).

* If SUCCESS, with the _GroupID_ field set to _G~2~_ and the _SceneID_
field set to 0x03.
* IF INSUFFICIENT_SPACE, the following steps SHALL NOT be executed.

|14c | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~2~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
3), 0xfe or null, the _GroupID_ field set to _G~2~_ and the _SceneList_
field containing only the scene ID 0x03.

|15 |CoreSpec-11.2.9.4 | |TH removes the Group key set that was added by
sending a KeySetRemove command to the GroupKeyManagement cluster with
the GroupKeySetID field set to 0x01a1 |Verify that the DUT sends SUCCESS
response
|===

[[_notestesting_considerations_237]]
====== link:#_notestesting_considerations_237[]Notes/Testing Considerations

[[_tc_s_2_3_secondary_functionality_with_dut_as_server]]
===== link:#_tc_s_2_3_secondary_functionality_with_dut_as_server[]135.2.3. [TC-S-2.3] Secondary functionality with DUT as Server

[[_category_272]]
====== link:#_category_272[]Category

Functional

[[_purpose_278]]
====== link:#_purpose_278[]Purpose

This test case verifies the secondary functionality of the Scenes
cluster server.

This test case requires an _application configuration_, _AC_, to be set
on the device in order to create a scene. An _AC_ is essentially a set
of cluster attribute settings which affect the scene and is dependent on
the application clusters supported on the server device. When the test
calls for a specific _AC~i~_ it is up to the tester to manipulate the
attributes on the DUT according to the supported clusters such that each
_AC~i~_ is unique.

This test case requires one group to be configured on the device,
_G~1~_. Before the test, the tester should evaluate PIXIT items
PIXIT.G.01 and PIXIT.G.02 and select _G~1~_ accordingly so that the
group IDs are different to those of PIXIT.G.02. If the device
pre-configures all its groups such that a new group cannot be added,
then _G~1~_ needs to be taken from group list of PIXIT.G.02.

[[_pics_278]]
====== link:#_pics_278[]PICS

* S.S

[[_required_devices_278]]
====== link:#_required_devices_278[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as client
|2 |DUT |Device Under Test as server
|===

[[_device_topology_231]]
====== link:#_device_topology_231[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_243]]
====== link:#_test_setup_243[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test)

[[_test_procedure_278]]
====== link:#_test_procedure_278[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|0a |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|0b |CoreSpec-11.2.7.2 | a|
TH binds GroupId _G~1~_ with GroupKeySetID 0x01a1 in the GroupKeyMap
attribute list on GroupKeyManagement cluster by writing the GroupKeyMap
attribute with one entry as follows:

* List item 1:
+
** FabricIndex: 1
** GroupId :_G~1~_
** GroupKeySetId: 0x01a1

|Verify that the DUT sends SUCCESS response.

|1a | |G.S.C00.Rsp(AddGroup) |TH sends a _AddGroup_ command to DUT with
the _GroupID_ field set to _G~1~_. |DUT sends a _AddGroupResponse_
command to TH with the _Status_ field set to 0x00 (SUCCESS) or 0x8a
(DUPLICATE_EXISTS) and the _GroupID_ field set to _G~1~_.

|1b | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~1~_.

|1c | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field recorded into _SC~0~_ for later
use, the _GroupID_ field set to _G~1~_ and the _SceneList_ field
containing 0 entry

|2a | |S.S.C40.Rsp(EnhancedAddScene) a|
TH sends a EnhancedAddScene command to DUT with the _GroupID_ field set
to _G~1~_, the _SceneID_ field set to 0x01, the _TransitionTime_ field
set to 0x000a (1s) and a set of extension fields appropriate to _AC~1~_.

a|
DUT sends a EnhancedAddSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x01.

|2b | |S.S.C00.Rsp(AddScene) a|
TH sends a AddScene command to DUT with the _GroupID_ field set to
_G~1~_, the _SceneID_ field set to 0x01, the _TransitionTime_ field set
to 0x0001 (1s) and a set of extension fields appropriate to _AC~1~_.

a|
DUT sends a AddSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the _SceneID_
field set to 0x01.

|3a | |S.S.C41.Rsp(EnhancedViewScene) a|
TH sends a EnhancedViewScene command to DUT with the _GroupID_ field set
to _G~1~_ and the _SceneID_ field set to 0x01.

a|
DUT sends a EnhancedViewSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_, the
_SceneID_ field set to 0x01, the _TransitionTime_ field set to 0x000a
(1s) and a set of extension fields appropriate to _AC~1~_.

|3b | |S.S.C01.Rsp(ViewScene) a|
TH sends a ViewScene command to DUT with the _GroupID_ field set to
_G~1~_ and the _SceneID_ field set to 0x01.

a|
DUT sends a ViewSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the _SceneID_
field set to 0x01, the _TransitionTime_ field set to 0x0001 (1s) and a
set of extension fields appropriate to _AC~1~_.

|4 | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
1), 0xfe or null, the _GroupID_ field set to _G~1~_ and the _SceneList_
field containing only the scene ID 0x01.

|5a | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different from _AC~1~_.

|5b | |S.S.C05.Rsp(RecallScene) |TH sends a RecallScene command to group
_G~1~_ with the _GroupID_ field set to _G~1~_ and the _scene ID_ field
set to 0x01. a|
(There is no Status response since this was a groupcast)

DUT returns to _AC~1~_.

|6a | |S.S.C42.Rsp(CopyScene) |TH sends a CopyScene command to DUT with
the _mode_ field set to 0x00, the _group identifier from_ field set to
_G~1~_, the _scene identifier from_ field set to 0x01, the _group
identifier to_ field set to _G~1~_ and the _scene identifier to_ field
set to 0x02. |DUT sends a CopySceneResponse command to TH with the
_Status_ field set to 0x00 (SUCCESS), the _group identifier from_ field
set to _G~1~_ and the _scene identifier from_ field set to 0x01.

|6b | |S.S.C06.Rsp(GetSceneMembership) |TH sends a GetSceneMembership
command to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
GetSceneMembershipResponse command to TH with the _Status_ field set to
0x00 (SUCCESS), the _Capacity_ field set to one of the values (_SC~0~_ -
2), 0xfe or null, the _GroupID_ field set to _G~1~_, the _SceneList_
field containing the scene IDs 0x01 and 0x02.

|7 |CoreSpec-11.2.9.4 | |TH removes the Group key set that was added by
sending a KeySetRemove command to the GroupKeyManagement cluster with
the GroupKeySetID field set to 0x01a1 |Verify that the DUT sends SUCCESS
response
|===

[[_notestesting_considerations_238]]
====== link:#_notestesting_considerations_238[]Notes/Testing Considerations

[[_tc_s_2_4_recall_scene_with_transition_time_functionality_with_dut_as_server]]
===== link:#_tc_s_2_4_recall_scene_with_transition_time_functionality_with_dut_as_server[]135.2.4. [TC-S-2.4] Recall scene with transition time functionality with DUT as Server

[[_category_273]]
====== link:#_category_273[]Category

Functional

[[_purpose_279]]
====== link:#_purpose_279[]Purpose

This test case verifies the RecallScene command with transition time
functionality of the Scenes cluster server.

This test case requires an _application configuration_, _AC_, to be set
on the device in order to create a scene. An _AC_ is essentially a set
of cluster attribute settings which affect the scene and is dependent on
the application clusters supported on the server device. When the test
calls for a specific _AC~i~_ it is up to the tester to manipulate the
attributes on the DUT according to the supported clusters such that each
_AC~i~_ is unique.

[[_pics_279]]
====== link:#_pics_279[]PICS

* S.S

[[_required_devices_279]]
====== link:#_required_devices_279[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as client
|2 |DUT |Device Under Test as server
|===

[[_device_topology_232]]
====== link:#_device_topology_232[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_244]]
====== link:#_test_setup_244[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test)

[[_test_procedure_279]]
====== link:#_test_procedure_279[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|0a |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|0b |CoreSpec-11.2.7.2 | a|
TH binds GroupId 0x0001 with GroupKeySetID 0x01a1 in the GroupKeyMap
attribute list on GroupKeyManagement cluster by writing the GroupKeyMap
attribute with one entry as follows:

* List item 1:
+
** FabricIndex: 1
** GroupId: 0x0001
** GroupKeySetId: 0x01a1

|Verify that the DUT sends SUCCESS response.

|1 | |G.S.C04.Rsp(RemoveAllGroups) |TH sends a _RemoveAllGroups_ command
to DUT. |If a status response is expected, DUT sends a response to TH
with the _Status_ field equal to 0x00 (SUCCESS).

|2a | |G.S.C00.Rsp(AddGroup) |TH sends a _AddGroup_ command to DUT with
the _GroupID_ field set to _G~1~_. |DUT sends a _AddGroupResponse_
command to TH with the _Status_ field set to 0x00 (SUCCESS) and the
_GroupID_ field set to _G~1~_.

|2b | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~1~_.

|3 | |S.S.C00.Rsp(AddScene) |TH sends a AddScene command to DUT with the
_GroupID_ field set to _G~1~_, the _SceneID_ field set to 0x01, the
_TransitionTime_ field set to 0x0014 (20s) and no extension field sets.
|DUT sends a AddSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the _SceneID_
field set to 0x01.

|4a | |- |TH configures _AC~1~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~1~_.

|4b | |S.S.C04.Rsp(StoreScene) |TH sends a StoreScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. |DUT sends a StoreSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x01.

|5a | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different from _AC~1~_.

|5b | |S.S.C05.Rsp(RecallScene) |TH sends a RecallScene command to DUT
with the _GroupID_ field set to _G~1~_, the _SceneID_ field set to 0x01
and the _TransitionTime_ field omitted. a|
If a status response is expected, DUT sends a response to TH with the
_Status_ field equal to 0x00 (SUCCESS).

DUT transitions to _AC~1~_ over 20s.

|6a | |S.S.C05.Rsp(RecallScene) & PICS_SC_RECALL_SCENE_TRANSITION_TIME
|TH configures _AC~2~_ on DUT for all implemented application clusters
supporting scenes. |DUT is configured with _AC~2~_ which is different
from _AC~1~_.

|6b | |S.S.C05.Rsp(RecallScene) & PICS_SC_RECALL_SCENE_TRANSITION_TIME
|TH sends a RecallScene command to DUT with the _GroupID_ field set to
_G~1~_, the _SceneID_ field set to 0x01 and the _TransitionTime_ field
set to 0x0032 (5s). a|
If a status response is expected, DUT sends a response to TH with the
_Status_ field equal to 0x00 (SUCCESS).

DUT transitions to _AC~1~_ over 5s.

|7a | |- |TH configures _AC~2~_ on DUT for all implemented application
clusters supporting scenes. |DUT is configured with _AC~2~_ which is
different from _AC~1~_.

|7b | |S.S.C05.Rsp(RecallScene) |TH sends a RecallScene command to DUT
with the _GroupID_ field set to _G~1~_, the _SceneID_ field set to 0x01
and the _TransitionTime_ field set to null (no transition time
override). a|
If a status response is expected, DUT sends a response to TH with the
_Status_ field equal to 0x00 (SUCCESS).

DUT transitions to _AC~1~_ over 20s.

|8 |CoreSpec-11.2.9.4 | |TH removes the Group key set that was added by
sending a KeySetRemove command to the GroupKeyManagement cluster with
the GroupKeySetID field set to 0x01a1 |Verify that the DUT sends SUCCESS
response
|===

[[_notestesting_considerations_239]]
====== link:#_notestesting_considerations_239[]Notes/Testing Considerations

[[_tc_s_2_5_remainingcapacity_functionality_with_dut_as_server]]
===== link:#_tc_s_2_5_remainingcapacity_functionality_with_dut_as_server[]135.2.5. [TC-S-2.5] RemainingCapacity functionality with DUT as Server

[[_category_274]]
====== link:#_category_274[]Category

Functional

[[_purpose_280]]
====== link:#_purpose_280[]Purpose

This test case verifies the RemainingCapacity attribute is reported via
subscriptions by Scenes cluster server.

[[_pics_280]]
====== link:#_pics_280[]PICS

* S.S
* S.S.F03(FS)

[[_required_devices_280]]
====== link:#_required_devices_280[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness as client
|2 |DUT |Device Under Test as server
|===

[[_device_topology_233]]
====== link:#_device_topology_233[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_245]]
====== link:#_test_setup_245[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test) A
given fabric SHALL NOT consume more than half (rounded down towards 0)
of the Scene Table entries (as indicated in the SceneTableSize
attribute). MaxRemainingCapacity is SceneTableSize/2.

[[_test_procedure_280]]
====== link:#_test_procedure_280[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|0a |CoreSpec-11.2.5.1. | a|
TH sends KeySetWrite command in the GroupKeyManagement cluster to DUT
using a key that is pre-installed on the TH. GroupKeySet fields are as
follows:

* GroupKeySetID: 0x01a1
* GroupKeySecurityPolicy: TrustFirst (0)
* EpochKey0: d0d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime0: 2220000
* EpochKey1: d1d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime1: 2220001
* EpochKey2: d2d1d2d3d4d5d6d7d8d9dadbdcdddedf
* EpochStartTime2: 2220002

|Verify DUT responds w/ status SUCCESS(0x00)

|0b |CoreSpec-11.2.7.2 | a|
TH binds GroupId 0x0001 with GroupKeySetID 0x01a1 in the GroupKeyMap
attribute list on GroupKeyManagement cluster by writing the GroupKeyMap
attribute with one entry as follows:

* List item 1:
+
** FabricIndex: 1
** GroupId: 0x0001
** GroupKeySetId: 0x01a1

|Verify that the DUT sends SUCCESS response.

|1 | |G.S.C04.Rsp(RemoveAllGroups) |TH sends a _RemoveAllGroups_ command
to DUT. |If a status response is expected, DUT sends a response to TH
with the _Status_ field equal to 0x00 (SUCCESS).

|2 | |G.S.C00.Rsp(AddGroup) |TH sends a _AddGroup_ command to DUT with
the _GroupID_ field set to _G~1~_. |DUT sends a _AddGroupResponse_
command to TH with the _Status_ field set to 0x00 (SUCCESS) and the
_GroupID_ field set to _G~1~_.

|3 | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~1~_.

|4a | |S.S.A0006(SceneTableSize) |TH reads from the DUT the
_SceneTableSize attribute_ |Verify that the DUT response contains with
value; record this value in SceneTableSize

|4b | |S.S.A0007(FabricSceneInfo) |TH sends a subscription request
action for FabricSceneInfo to the DUT. |Verify that the DUT sends a
report data for FabricSceneInfo after the MinIntervalFloor time; store
the RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into RemainingCapacity; verify RemainingCapacity equals
(MaxRemainingCapacity).

|4c | | |Keep subscription session active for the remainder of the test
|

|5a | |S.S.C00.Rsp(AddScene) |TH sends a AddScene command to DUT with
the _GroupID_ field set to _G~1~_, the _SceneID_ field set to 0x01, the
_TransitionTime_ field set to 0x0014 (20s) and no extension field sets.
|DUT sends a AddSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the _SceneID_
field set to 0x01.

|5b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data for FabricSceneInfo after the MinIntervalFloor time; store the
RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into RemainingCapacity; verify RemainingCapacity equals
(MaxRemainingCapacity-1).

|6a | |S.S.C04.Rsp(StoreScene) a|
If RemainingCapacity is greater than 0, TH sends a StoreScene command to
DUT with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set
to 0x02.

If RemainingCapacity is 0, continue to Step 8a.

|DUT sends a StoreSceneResponse command to TH with the _Status_ field
set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x02.

|6b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data for FabricSceneInfo after the MinIntervalFloor time; store the
RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into RemainingCapacity; verify RemainingCapacity equals
(MaxRemainingCapacity-2).

|7a | |S.S.C00.Rsp(AddScene) a|
If RemainingCapacity is greater than 0, TH sends a AddScene command to
DUT with the _GroupID_ field set to _G~1~_, the _SceneID_ field set to
0x03, the _TransitionTime_ field set to 0x0014 (20s) and no extension
field sets.

If RemainingCapacity is 0, continue to Step 8a.

|DUT sends a AddSceneResponse command to TH with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the _SceneID_
field set to 0x03.

|7b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data for FabricSceneInfo after the MinIntervalFloor time; store the
RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into RemainingCapacity; verify RemainingCapacity equals
(MaxRemainingCapacity-3).

|8a | |S.S.C02.Rsp(RemoveScene) |TH sends a RemoveScene command to DUT
with the _GroupID_ field set to _G~1~_ and the _SceneID_ field set to
0x01. |DUT sends a RemoveSceneResponse command to TH with the _Status_
field set to 0x00 (SUCCESS), the _GroupID_ field set to _G~1~_ and the
_SceneID_ field set to 0x01.

|8b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data for FabricSceneInfo after the MinIntervalFloor time; store the
RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into RemainingCapacity; verify RemainingCapacity equals
(MaxRemainingCapacity-2).

|9a | |S.S.C03.Rsp(RemoveAllScenes) |TH sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to _G~1~_. |DUT sends a
RemoveAllScenesResponse command to TH with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to _G~1~_.

|9b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data for FabricSceneInfo after the MinIntervalFloor time; store the
RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into RemainingCapacity; verify RemainingCapacity equals
(MaxRemainingCapacity).

|10 |CoreSpec-11.2.9.4 | |TH removes the Group key set that was added by
sending a KeySetRemove command to the GroupKeyManagement cluster with
the GroupKeySetID field set to 0x01a1 |Verify that the DUT sends SUCCESS
response
|===

[[_notestesting_considerations_240]]
====== link:#_notestesting_considerations_240[]Notes/Testing Considerations

[[_tc_s_2_6_remainingcapacity_functionality_with_dut_as_server_multi_fabric]]
===== link:#_tc_s_2_6_remainingcapacity_functionality_with_dut_as_server_multi_fabric[]135.2.6. [TC-S-2.6] RemainingCapacity functionality with DUT as Server - Multi-Fabric

[[_category_275]]
====== link:#_category_275[]Category

Functional

[[_purpose_281]]
====== link:#_purpose_281[]Purpose

This test case verifies the RemainingCapacity attribute is reported via
subscriptions by Scenes cluster server with multi-fabrics.

[[_pics_281]]
====== link:#_pics_281[]PICS

* S.S
* S.S.F03(FS)

[[_required_devices_281]]
====== link:#_required_devices_281[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH1 |Test Harness as client
|2 |TH2 |Test Harness as client
|3 |TH3 |Test Harness as client
|4 |DUT |Device Under Test as server
|===

[[_device_topology_234]]
====== link:#_device_topology_234[]Device Topology

TH1, TH2, and TH3 should be on separate, distinct fabrics.

[[_test_setup_246]]
====== link:#_test_setup_246[]Test Setup

DUT should be commissioned onto TH1, TH2, and TH3. A given fabric SHALL
NOT consume more than half (rounded down towards 0) of the Scene Table
entries (as indicated in the SceneTableSize attribute).
MaxRemainingCapacity is SceneTableSize/2.

[[_test_procedure_281]]
====== link:#_test_procedure_281[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | |S.S.C03.Rsp(RemoveAllScenes) |TH1 sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to 0x0000. |DUT sends a
RemoveAllScenesResponse command to TH1 with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to 0x0000.

|1b | |S.S.C03.Rsp(RemoveAllScenes) |Repeat Step 1a with TH2 and TH3. |

|2a | |S.S.A0006(SceneTableSize) |TH1 reads from the DUT the
_SceneTableSize attribute_ |Verify that the DUT response contains with
value which is recorded into SceneTableSize

|2b | |S.S.A0007(FabricSceneInfo) |TH1 sends a subscription request
action for FabricSceneInfo to the DUT. |Verify that the DUT sends a
report data to TH1 for FabricSceneInfo after the MinIntervalFloor time;
store the RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into Remaining1stCapacity; verify Remaining1stCapacity
equals (MaxRemainingCapacity).

|2c | | |Keep subscription session active for the remaining of the test
|

|2d | | |Repeat Step 2b and 2c with TH2 and TH3 |

|3a | |S.S.C00.Rsp(AddScene) |TH1 sends a AddScene command to DUT with
the _GroupID_ field set to 0x0000, the _SceneID_ field set to 0x01, the
_TransitionTime_ field set to 0x0014 (20s) and no extension field sets.
|DUT sends a AddSceneResponse command to TH1 with the _Status_ field set
to 0x00 (SUCCESS), the _GroupID_ field set to 0x0000 and the _SceneID_
field set to 0x01.

|3b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data to TH1 for FabricSceneInfo after the MinIntervalFloor time; store
the RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into Remaining1stCapacity; verify Remaining1stCapacity
equals (MaxRemainingCapacity-1).

|4a | |S.S.C00.Rsp(AddScene) & S.S.A0007(FabricSceneInfo) |TH1 sends
AddScene command to DUT with same _GroupID_ and _SceneID_ value starting
at 2 and incrementing for each iteration for Remaining1stCapacity more
times until reported value to TH1 (after MinIntervalFloor) for
_RemainingCapacity_ field from FabricSceneInfo becomes 0. |DUT sends
success AddSceneResponse commands to TH1 for each of the AddScene
commands. Verify that the DUT sends a report data after the
MinIntervalFloor time to TH1 for _RemainingCapacity_ field from
FabricSceneInfo with updated value (decreasing to 0).

|4b | |S.S.C00.Rsp(AddScene) |TH1 sends a AddScene command to DUT with
the _GroupID_ field set to 0x0000, the _SceneID_ field set to 1 more
than last value used in step 4a, the _TransitionTime_ field set to
0x0014 (20s) and no extension field sets. |DUT sends a AddSceneResponse
command to TH1 with the _Status_ field set to status
RESOURCE_EXHAUSTED(0x89)

|5a | |S.S.C00.Rsp(AddScene) & S.S.A0007(FabricSceneInfo) |Repeat Step
4a with TH2 a|
DUT sends success AddSceneResponse commands to TH2 for each of the
AddScene commands. Verify that the DUT sends report data messages after
the MinIntervalFloor time to TH2 for _RemainingCapacity_ field in
FabricSceneInfo for that fabric with updated value (decreasing to 0).

Verify that the DUT sends report data messages after the
MinIntervalFloor time to TH3 for _RemainingCapacity_ field in
FabricSceneInfo for that fabric with updated value (decreasing to 0).

|5b | |S.S.C00.Rsp(AddScene) |Repeat Step 4b with TH2 |DUT sends a
AddSceneResponse command to TH2 with the _Status_ field set to status
RESOURCE_EXHAUSTED(0x89)

|6 | |S.S.C00.Rsp(AddScene) |TH3 sends a AddScene command to DUT with
the _GroupID_ field set to 0x0000, the _SceneID_ field set to 0x01, the
_TransitionTime_ field set to 0x0014 (20s) and no extension field sets.
|DUT sends a AddSceneResponse command to TH3 with the _Status_ field set
to status RESOURCE_EXHAUSTED(0x89)

|7a | |S.S.C03.Rsp(RemoveAllScenes) |TH1 sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to 0x0000. |DUT sends a
RemoveAllScenesResponse command to TH1 with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to 0x0000.

|7b | |S.S.A0007(FabricSceneInfo) |Verify that the DUT sends a report
data to TH1 for FabricSceneInfo after the MinIntervalFloor time; store
the RemainingCapacity field from this fabric’s entry the reported in
FabricSceneInfo into Remaining1stCapacity; verify Remaining1stCapacity
equals (MaxRemainingCapacity). |Verify that the DUT does not send report
data to TH2 for FabricSceneInfo after the MinIntervalFloor time with
updated value (it should send 'empty' report data since there is no
update for this attribute for TH2).

|8a | |S.S.C03.Rsp(RemoveAllScenes) |TH2 sends a RemoveAllScenes command
to DUT with the _GroupID_ field set to 0x0000. |DUT sends a
RemoveAllScenesResponse command to TH2 with the _Status_ field set to
0x00 (SUCCESS) and _GroupID_ field set to 0x0000.

|8b | |S.S.A0007(FabricSceneInfo) | |Verify that the DUT sends a report
data to TH2 for FabricSceneInfo after the MinIntervalFloor time; store
the RemainingCapacity field from this fabric’s entry reported in
FabricSceneInfo into Remaining2ndCapacity; verify Remaining2ndCapacity
equals (MaxRemainingCapacity).
|===

[[_notestesting_considerations_241]]
====== link:#_notestesting_considerations_241[]Notes/Testing Considerations

[[_access_control_cluster]]
== link:#_access_control_cluster[]**Access Control cluster**

[[_pics_definition_39]]
=== link:#_pics_definition_39[]136. PICS Definition

This section covers the Access Control Cluster Test Plan related items
that are referenced in the following test cases.

[[_role_41]]
==== link:#_role_41[]136.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACL.S |Does the device implement the Access Control Cluster as a
server? |O |

|ACL.C |Does the device implement the Access Control Cluster as a
client? |O |
|===

[[_server_41]]
==== link:#_server_41[]136.2. Server

[[_attributes_45]]
===== link:#_attributes_45[]136.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACL.S.A0000(ACL) |Does the device implement the ACL attribute? |M |

|ACL.S.A0001(Extension) |Does the device implement the extension
attribute? |O |

|ACL.S.A0002(SubjectsPerAccessControlEntry) |Does the device implement
the SubjectsPerAccessControlEntry attribute? |M |

|ACL.S.A0003(TargetsPerAccessControlEntry) |Does the device implement
the TargetsPerAccessControlEntry attribute? |M |

|ACL.S.A0004(AccessControlEntriesPerFabric) |Does the device implement
the AccessControlEntriesPerFabric attribute? |M |
|===

[[_events_9]]
===== link:#_events_9[]136.2.2. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACL.S.E00(AccessControlEntryChanged) |Does the device implement the
AccessControlEntryChanged Event? |M |

|ACL.S.E01(AccessControlExtensionChanged) |Does the device implement the
AccessControlExtensionChanged Event? |M |
|===

[[_test_case_list_41]]
=== link:#_test_case_list_41[]137. Test Case List

[width="99%",cols="18%,16%,66%",options="header",]
|===
|# |TC UUID |Test Case Name
|1 |TC-ACL-1.1 |Global Attributes with DUT as Server
|2 |TC-ACL-2.1 |Simple attributes [DUT-Commissionee]
|3 |TC-ACL-2.2 |Cluster endpoint [DUT-Commissionee]
|4 |TC-ACL-2.3 |Extension attribute [DUT-Commissionee]
|5 |TC-ACL-2.4 |ACL attribute [DUT-Commissionee]
|6 |TC-ACL-2.5 |AccessControlExtensionChanged event [DUT-Commissionee]
|7 |TC-ACL-2.6 |AccessControlEntryChanged event [DUT-Commissionee]
|8 |TC-ACL-2.7 |Extension multi-fabric [DUT-Commissionee]
|9 |TC-ACL-2.8 |ACL multi-fabric [DUT-Commissionee]
|10 |TC-ACL-2.9 |Cluster access [DUT-Commissionee]
|11 |TC-ACL-2.10 |Persistence [DUT-Commissionee]
|===

[[_test_cases_41]]
=== link:#_test_cases_41[]138. Test Cases

[[_generic_test_cases_35]]
==== link:#_generic_test_cases_35[]138.1. Generic test cases

[[_tc_acl_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_acl_1_1_global_attributes_with_dut_as_server[]138.1.1. [TC-ACL-1.1] Global Attributes with DUT as Server

[[_category_276]]
====== link:#_category_276[]Category

Functional conformance.

[[_purpose_282]]
====== link:#_purpose_282[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_282]]
====== link:#_pics_282[]PICS

* ACL.S

[[_required_devices_282]]
====== link:#_required_devices_282[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_282]]
====== link:#_test_procedure_282[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the _FeatureMap_ attribute and
has the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0002, 0x0003, 0x0004, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0001: SHALL be included if and only if ACL.S.A0001(Extension)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list SHALL include all the mandatory entries: +
0x00, 0x01.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_242]]
====== link:#_notestesting_considerations_242[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_cluster_attribute_test_cases_3]]
==== link:#_cluster_attribute_test_cases_3[]138.2. Cluster Attribute test cases

[[_tc_acl_2_1_simple_attributes]]
===== link:#_tc_acl_2_1_simple_attributes[]138.2.1. [TC-ACL-2.1] Simple attributes

[[_category_277]]
====== link:#_category_277[]Category

Functional conformance

[[_purpose_283]]
====== link:#_purpose_283[]Purpose

. Verify that Access Control Cluster simple attributes are present.
. Verify that Access Control Cluster simple attributes have correct
values.

[[_pics_283]]
====== link:#_pics_283[]PICS

* ACL.S

[[_pre_conditions_49]]
====== link:#_pre_conditions_49[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|===

[[_required_devices_283]]
====== link:#_required_devices_283[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_247]]
====== link:#_test_setup_247[]Test Setup

[[_test_procedure_283]]
====== link:#_test_procedure_283[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 |9.11.5.5 |ACL.S.A0002(SubjectsPerAccessControlEntry) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
SubjectsPerAccessControlEntry attribute

a|
Result is SUCCESS, value is an integer with value 4 or greater

|3 |9.11.5.6 |ACL.S.A0003(TargetsPerAccessControlEntry) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
TargetsPerAccessControlEntry attribute

a|
Result is SUCCESS, value is an integer with value 3 or greater

|4 |9.11.5.7 |ACL.S.A0004(AccessControlEntriesPerFabric) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlEntriesPerFabric attribute

a|
Result is SUCCESS, value is an integer with value 4 or greater

|===

[[_tc_acl_2_2_cluster_endpoint]]
===== link:#_tc_acl_2_2_cluster_endpoint[]138.2.2. [TC-ACL-2.2] Cluster endpoint

[[_category_278]]
====== link:#_category_278[]Category

Functional conformance

[[_purpose_284]]
====== link:#_purpose_284[]Purpose

. Verify that Access Control Cluster is present on Endpoint 0.
. Verify that Access Control Cluster is not present on any other
Endpoint.

[[_pics_284]]
====== link:#_pics_284[]PICS

* ACL.S

[[_pre_conditions_50]]
====== link:#_pre_conditions_50[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|===

[[_required_devices_284]]
====== link:#_required_devices_284[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_248]]
====== link:#_test_setup_248[]Test Setup

[[_test_procedure_284]]
====== link:#_test_procedure_284[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 |9.6 | a|
TH1 reads DUT Descriptor cluster ServerList attribute from Endpoint 0

a|
Result list contains an element with value 31 (0x001F)

|3 |9.6 | a|
TH1 reads DUT Descriptor cluster ServerList attribute from every
Endpoint except 0

a|
Result list does not contain an element with value 31 (0x001F)

|===

[[_tc_acl_2_3_extension_attribute]]
===== link:#_tc_acl_2_3_extension_attribute[]138.2.3. [TC-ACL-2.3] Extension attribute

[[_category_279]]
====== link:#_category_279[]Category

Functional conformance

[[_purpose_285]]
====== link:#_purpose_285[]Purpose

. Verify that Access Control cluster Extension attribute is present.
. Verify that Access Control cluster Extension attribute accepts valid
values.
. Verify that Access Control cluster Extension attribute rejects invalid
values.
. Verify that Access Control cluster Extension attribute respects
constraints and length restrictions.

[[_pics_285]]
====== link:#_pics_285[]PICS

* ACL.S
* ACL.S.A0001(Extension)

[[_pre_conditions_51]]
====== link:#_pre_conditions_51[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1

|2 | | a|
`D_OK_EMPTY`:"1718" which is an octstr of length 2 containing valid TLV:

- top-level anonymous list (empty)

|3 | | a|
`D_OK_SINGLE`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018"
which is an octstr of length 50-100 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form

|4 | | a|
`D_OK_FULL`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E6700D00000F1FF02003148656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E7420616761696E2E2E2E2E2E0018"
which is an octstr of length 128 containing valid TLV:

- top-level anonymous list, containing - two elements with
profile-specific tag in fully-qualified form

|5 | | a|
`D_BAD_LENGTH`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E6700D00000F1FF02003248656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E7420616761696E2E2E2E2E2E2E0018"
which is an octstr of length 129 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form

|6 | | a|
`D_BAD_STRUCT`: "1518" which is an octstr of length 2 containing valid
TLV:

- top-level anonymous struct, empty

|7 | | a|
`D_BAD_LIST`:"3701D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018"
which is an octstr of length 50-100 containing valid TLV:

- top-level list with context-specific tag, containing - one element
with profile-specific tag in fully-qualified form

|8 | | a|
`D_BAD_ELEM`:"17103D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018"
which is an octstr of length 50-100 containing valid TLV:

- top-level anonymous list, containing - one element with anonymous tag

|9 | | a|
`D_BAD_OVERFLOW`:
"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018FF"
which is an octstr of length 50-100 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form - but having extra bytes
after the top level list end-of-container

|10 | | a|
`D_BAD_UNDERFLOW`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E6700"
which is an octstr of length 50-100 containing invalid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form - but lacking the top-level
list end-of-container

|11 | | |`D_BAD_NONE`: "" which is an octstr of length 0
|===

[[_required_devices_285]]
====== link:#_required_devices_285[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_249]]
====== link:#_test_setup_249[]Test Setup

[[_test_procedure_285]]
====== link:#_test_procedure_285[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is an empty list

|4 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_EMPTY`

a|
Result is SUCCESS

|5 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element

. struct
+
* Data field: `D_OK_EMPTY`
* FabricIndex field: `F1`

|6 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_SINGLE`

a|
Result is SUCCESS

|7 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element

. struct
+
* Data field: `D_OK_SINGLE`
* FabricIndex field: `F1`

|8 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_FULL`

a|
Result is SUCCESS

|9 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element

. struct
+
* Data field: `D_OK_FULL`
* FabricIndex field: `F1`

|10 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_LENGTH`

a|
Result is CONSTRAINT_ERROR (0x87)

|11 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_STRUCT`

a|
Result is CONSTRAINT_ERROR (0x87)

|12 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_LIST`

a|
Result is CONSTRAINT_ERROR (0x87)

|13 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_ELEM`

a|
Result is CONSTRAINT_ERROR (0x87)

|14 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_OVERFLOW`

a|
Result is CONSTRAINT_ERROR (0x87)

|15 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_UNDERFLOW`

a|
Result is CONSTRAINT_ERROR (0x87)

|16 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_NONE`

a|
Result is CONSTRAINT_ERROR (0x87)

|17 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 2 elements

* value is list of AccessControlExtensionStruct containing 2 elements
* first element contains Data field: `D_OK_EMPTY`
* second element contains Data field: `D_OK_SINGLE`

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|18 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element

. struct
+
* Data field: `D_OK_EMPTY`
* FabricIndex field: `F1`

|19 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is an empty list

a|
Result is SUCCESS

|20 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is an empty list

|===

[[_tc_acl_2_4_acl_attribute]]
===== link:#_tc_acl_2_4_acl_attribute[]138.2.4. [TC-ACL-2.4] ACL attribute

[[_category_280]]
====== link:#_category_280[]Category

Functional conformance

[[_purpose_286]]
====== link:#_purpose_286[]Purpose

. Verify that Access Control cluster ACL attribute is present.
. Verify that Access Control cluster ACL attribute accepts valid values.
. Verify that Access Control cluster ACL attribute rejects invalid
values.
. Verify that Access Control cluster ACL attribute respects constraints
and length restrictions.

[[_pics_286]]
====== link:#_pics_286[]PICS

* ACL.S

[[_pre_conditions_52]]
====== link:#_pre_conditions_52[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|2 | | |`CAT1` is a valid CAT with arbitrary ID and arbitrary version
|3 | | |`CAT2` is a valid CAT with arbitrary ID and arbitrary version
|4 | | |`CAT3` is a valid CAT with arbitrary ID and arbitrary version
|5 | | |`CAT4` is a valid CAT with arbitrary ID and arbitrary version
|===

[[_required_devices_286]]
====== link:#_required_devices_286[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_250]]
====== link:#_test_setup_250[]Test Setup

[[_test_procedure_286]]
====== link:#_test_procedure_286[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
1 element

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`

|4 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: View (1)
* AuthMode field: Group (3)
* Subjects field: [111, 222, 333, 444]
* Targets field: [\{Cluster: 11}, \{Endpoint: 22}]
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [555, 666, 777, 888]
* Targets field: [\{Cluster: 55}, \{Endpoint: 66}]

a|
Result is SUCCESS

|5 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: View (1)
* AuthMode field: Group (3)
* Subjects field: [111, 222, 333, 444]
* Targets field: [\{Cluster: 11}, \{Endpoint: 22}]
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [555, 666, 777, 888]
* Targets field: [\{Cluster: 55}, \{Endpoint: 66}]
* FabricIndex field: `F1`

|6 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Manage (4)
* AuthMode field: Group (3)
* Subjects field: [444, 333, 222, 111]
* Targets field: [\{Cluster: 44}, \{Endpoint: 33}]
. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [888, 777, 666, 555]
* Targets field: [\{Cluster: 88}, \{Endpoint: 77}]

a|
Result is SUCCESS

|7 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Manage (4)
* AuthMode field: Group (3)
* Subjects field: [444, 333, 222, 111]
* Targets field: [\{Cluster: 44}, \{Endpoint: 33}]
* FabricIndex field: `F1`
. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [888, 777, 666, 555]
* Targets field: [\{Cluster: 88}, \{Endpoint: 77}]
* FabricIndex field: `F1`

|8 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [111, 222, 333, 444]
* Targets field: [\{Cluster: 11, Endpoint: 22}, \{Cluster: 33,
DeviceType: 44}]
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [555, 666, 777, 888]
* Targets field: [\{Cluster: 55, Endpoint: 66}, \{Cluster: 77,
DeviceType: 88}]

a|
Result is SUCCESS

|9 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [111, 222, 333, 444]
* Targets field: [\{Cluster: 11, Endpoint: 22}, \{Cluster: 33,
DeviceType: 44}]
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [555, 666, 777, 888]
* Targets field: [\{Cluster: 55, Endpoint: 66}, \{Cluster: 77,
DeviceType: 88}]
* FabricIndex field: `F1`

|10 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: 11, Endpoint: 22}, \{Cluster: 33,
DeviceType: 44}]
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: null
* Targets field: [\{Cluster: 55, Endpoint: 66}, \{Cluster: 77,
DeviceType: 88}]

a|
Result is SUCCESS

|11 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: 11, Endpoint: 22}, \{Cluster: 33,
DeviceType: 44}]
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: null
* Targets field: [\{Cluster: 55, Endpoint: 66}, \{Cluster: 77,
DeviceType: 88}]
* FabricIndex field: `F1`

|12 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [111, 222, 333, 444]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [555, 666, 777, 888]
* Targets field: null

a|
Result is SUCCESS

|13 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
3 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: View (1)
* AuthMode field: CASE (2)
* Subjects field: [111, 222, 333, 444]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [555, 666, 777, 888]
* Targets field: null
* FabricIndex field: `F1`

|14 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: null
* Targets field: null

a|
Result is SUCCESS

|15 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: null
* Targets field: null
* FabricIndex field: `F1`

|16 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: ProxyView (2)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: null

a|
Result is SUCCESS

|17 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: ProxyView (2)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: null
* FabricIndex field: `F1`

|18 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
SubjectsPerAccessControlEntry attribute

a|
Result is SUCCESS

* value is stored as `MAXSUBJECTS`

|19 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: list of `MAXSUBJECTS` random node IDs (stored as
`SUBJECTS`)
* Targets field: null

a|
Result is SUCCESS

|20 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: `SUBJECTS`
* Targets field: null
* FabricIndex field: `F1`

|21 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [`CAT1`, `CAT2`, `CAT3`, `CAT4`]
* Targets field: null

a|
Result is SUCCESS

|22 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [`CAT1`, `CAT2`, `CAT3`, `CAT4`]
* Targets field: null
* FabricIndex field: `F1`

|23 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
TargetsPerAccessControlEntry attribute

a|
Result is SUCCESS

* value is stored as `MAXTARGETS`

|24 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: list of `MAXTARGETS` targets \{Cluster: random} (stored
as `TARGETS`)

a|
Result is SUCCESS

|25 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: `TARGETS`
* FabricIndex field: `F1`

|26 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlEntriesPerFabric attribute

a|
Result is SUCCESS

* value is stored as `MAXENTRIES`

|27 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing `MAXENTRIES` elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: null
. subsequent elements same as second element

a|
Result is SUCCESS

|28 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
`MAXENTRIES` elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: null
* FabricIndex field: `F1`
. subsequent elements same as second element

|29 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: PASE (1)
* Subjects field: null
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|30 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
1 element

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
* FabricIndex field: `F1`

|31 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Administer (5)
* AuthMode field: Group (3)
* Subjects field: null
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|32 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: invalid value (not 1-5)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|33 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: invalid value (not 1-3)
* Subjects field: null
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|34 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [0]
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|35 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [0xFFFFFFFFFFFFFFFF]
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|36 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [0xFFFFFFFD00000000]
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|37 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: [0xFFFFFFFFFFFF0000]
* Targets field: null

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|38 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{}]

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|39 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: 0xFFFFFFFF}]

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|40 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Endpoint: 65535}]

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|41 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{DeviceType: 0xFFFFFFFF}]

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|42 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Endpoint: 22, DeviceType: 33}]

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|43 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: CASE (2)
* Subjects field: null
* Targets field: [\{Cluster: 11, Endpoint: 22, DeviceType: 33}]

a|
Result is

* SUCCESS for first element path
* CONSTRAINT_ERROR (0x87) for second element path

|44 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
an empty list

a|
Result is SUCCESS (note since all ACL entries removed, cannot perform
more operations)

|===

[[_tc_acl_2_5_accesscontrolextensionchanged_event]]
===== link:#_tc_acl_2_5_accesscontrolextensionchanged_event[]138.2.5. [TC-ACL-2.5] AccessControlExtensionChanged event

[[_category_281]]
====== link:#_category_281[]Category

Functional conformance

[[_purpose_287]]
====== link:#_purpose_287[]Purpose

. Verify that Access Control Cluster AccessControlExtensionChanged event
functions correctly.

[[_pics_287]]
====== link:#_pics_287[]PICS

* ACL.S
* ACL.S.A0001(Extension)

[[_pre_conditions_53]]
====== link:#_pre_conditions_53[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1

|2 | | a|
`D_OK_EMPTY`:"1718" which is an octstr of length 2 containing valid TLV:

- top-level anonymous list (empty)

|3 | | a|
`D_OK_SINGLE`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018"
which is an octstr of length 50-100 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form

|4 | | a|
`D_BAD_LENGTH`:
"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E6700D00000F1FF02003248656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E7420616761696E2E2E2E2E2E2E0018"
which is an octstr of length 129 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form

|===

[[_required_devices_287]]
====== link:#_required_devices_287[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_251]]
====== link:#_test_setup_251[]Test Setup

[[_test_procedure_287]]
====== link:#_test_procedure_287[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is empty list

|4 |9.11.7.2 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_EMPTY`

a|
Result is SUCCESS

|5 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing 1 element

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{Data: `D_OK_EMPTY`, FabricIndex: `F1`}
* FabricIndex field: `F1`

|6 |9.11.7.2 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_SINGLE`

a|
Result is SUCCESS

|7 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing at least 2 new elements

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{Data: `D_OK_EMPTY`, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{Data: `D_OK_SINGLE`, FabricIndex: `F1`}
* FabricIndex field: `F1`

|8 |9.11.7.2 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_BAD_LENGTH`

a|
Result is 0x87 (CONSTRAINT_ERROR)-Data value exceeds maximum length.

|9 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing at least 1 new element, and MUST NOT contain an added event
for the extension with data that is too large

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{Data: `D_OK_SINGLE`, FabricIndex: `F1`}
* FabricIndex field: `F1`

|10 |9.11.7.2 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 2 elements

. struct
+
* Data field: `D_OK_EMPTY`
. struct
+
* Data field: `D_OK_SINGLE`

a|
Result is 0x87 (CONSTRAINT_ERROR)-as there are more than 1 entry
associated with the given accessing fabric index in the extension list

|11 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing at least 1 new element, and MUST NOT contain an added event
for the second extension

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{Data: `D_OK_EMPTY`, FabricIndex: `F1`}
* FabricIndex field: `F1`

|12 |9.11.7.2 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is an empty list

a|
Result is SUCCESS

|13 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing at least 1 new element

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{Data: `D_OK_EMPTY`, FabricIndex: `F1`}
* FabricIndex field: `F1`

|===

[[_tc_acl_2_6_accesscontrolentrychanged_event]]
===== link:#_tc_acl_2_6_accesscontrolentrychanged_event[]138.2.6. [TC-ACL-2.6] AccessControlEntryChanged event

[[_category_282]]
====== link:#_category_282[]Category

Functional conformance

[[_purpose_288]]
====== link:#_purpose_288[]Purpose

. Verify that Access Control Cluster AccessControlEntryChanged event
functions correctly.

[[_pics_288]]
====== link:#_pics_288[]PICS

* ACL.S

[[_pre_conditions_54]]
====== link:#_pre_conditions_54[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|===

[[_required_devices_288]]
====== link:#_required_devices_288[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_252]]
====== link:#_test_setup_252[]Test Setup

[[_test_procedure_288]]
====== link:#_test_procedure_288[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster AccessControlEntryChanged
event

a|
Result is SUCCESS value is list of AccessControlEntryChangedEvent events
containing 1 element

. struct
+
* AdminNodeID field: null
* AdminPasscodeID field: 0
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`

|4 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: null
* Targets field: null

a|
Result is SUCCESS

|5 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster AccessControlEntryChanged
event

a|
Result is SUCCESS, value is list of AccessControlEntryChanged events
containing at least 3 new elements

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Operate (3), AuthMode: Group (3),
Subjects: null, Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`

|6 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements. The first item
is valid, the second item is invalid due to group ID 0 being used, which
is illegal.

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [0]
* Targets field: null

a|
Result is CONSTRAINT_ERROR

|7 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster AccessControlEntryChanged
event

a|
Result is SUCCESS, value is list of AccessControlEntryChanged events
containing at least 3 new elements and MUST NOT contain an added event
for second entry written at step 6

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{ Privilege: Operate (3), AuthMode: Group (3),
Subjects: null, Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`

|===

[[_tc_acl_2_7_extension_multi_fabric]]
===== link:#_tc_acl_2_7_extension_multi_fabric[]138.2.7. [TC-ACL-2.7] Extension multi-fabric

[[_category_283]]
====== link:#_category_283[]Category

Functional conformance

[[_purpose_289]]
====== link:#_purpose_289[]Purpose

. Verify that Access Control cluster Extension attribute and event
functions correctly.
. Focus on multi-fabric operation.

[[_pics_289]]
====== link:#_pics_289[]PICS

* ACL.S
* ACL.S.A0001(Extension)

[[_pre_conditions_55]]
====== link:#_pre_conditions_55[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1

|2 | | |`N2` is the node ID of TH2

|2 | | a|
`D_OK_EMPTY`: "1718" which is an octstr of length 2 containing valid
TLV:

- top-level anonymous list (empty)

|3 | | a|
`D_OK_SINGLE`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018"
which is an octstr of length 50-100 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form

|===

[[_required_devices_289]]
====== link:#_required_devices_289[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Commissioner
|===

[[_test_setup_253]]
====== link:#_test_setup_253[]Test Setup

[[_test_procedure_289]]
====== link:#_test_procedure_289[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 | | a|
TH1 puts DUT into commissioning mode, TH2 commissions DUT using admin
node ID `N2`

a|
DUT is commissioned on TH2 fabric

|4 | | a|
TH2 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F2`

|5 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_EMPTY`

a|
Result is SUCCESS

|6 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH2 writes DUT Endpoint 0 AccessControl cluster Extension attribute
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_SINGLE`

a|
Result is SUCCESS

|7 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element, and MUST NOT contain an element with FabricIndex
`F2` or Data `D_OK_SINGLE`

. struct
+
* Data field: `D_OK_EMPTY`
* FabricIndex field: `F1`

|8 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH2 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element, and MUST NOT contain an element with FabricIndex
`F1` or Data `D_OK_EMPTY`

. struct
+
* Data field: `D_OK_SINGLE`
* FabricIndex field: `F2`

|9 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing 1 element, and MUST NOT contain an element with FabricIndex
`F2` or Data `D_OK_SINGLE`

. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{Data: `D_OK_EMPTY`, FabricIndex: `F1`}
* FabricIndex field: `F1`

|10 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH2 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is SUCCESS, value is list of AccessControlExtensionChanged
containing 1 element, and MUST NOT contain an element with FabricIndex
`F1` or Data `D_OK_EMPTY`

. struct
+
* AdminNodeID field: `N2`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{Data: `D_OK_SINGLE`, FabricIndex: `F2`}
* FabricIndex field: `F2`

|===

[[_tc_acl_2_8_acl_multi_fabric]]
===== link:#_tc_acl_2_8_acl_multi_fabric[]138.2.8. [TC-ACL-2.8] ACL multi-fabric

[[_category_284]]
====== link:#_category_284[]Category

Functional conformance

[[_purpose_290]]
====== link:#_purpose_290[]Purpose

. Verify that Access Control cluster ACL attribute and event functions
correctly.
. Focus on multi-fabric operation.

[[_pics_290]]
====== link:#_pics_290[]PICS

* ACL.S

[[_pre_conditions_56]]
====== link:#_pre_conditions_56[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|2 | | |`N2` is the node ID of TH2
|===

[[_required_devices_290]]
====== link:#_required_devices_290[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Commissioner
|===

[[_test_setup_254]]
====== link:#_test_setup_254[]Test Setup

[[_test_procedure_290]]
====== link:#_test_procedure_290[]Test Procedure

[width="100%",cols="8%,13%,13%,26%,40%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 | | a|
TH1 puts DUT into commissioning mode, TH2 commissions DUT using admin
node ID `N2`

a|
DUT is commissioned on TH2 fabric

|4 | | a|
TH2 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F2`

|5 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 1 element

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, 1111]
* Targets field: null

a|
Result is SUCCESS

|6 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH2 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 1 element

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N2`, 2222]
* Targets field: null

a|
Result is SUCCESS

|7 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
1 element, and MUST NOT contain an element with FabricIndex `F2`

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, 1111]
* Targets field: null
* FabricIndex field: `F1`

|8 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH2 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
1 element, and MUST NOT contain an element with FabricIndex `F1`

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N2`, 2222]
* Targets field: null
* FabricIndex field: `F2`

|9 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster AccessControlEntryChanged
event

a|
Result is SUCCESS, value is list of AccessControlEntryChanged containing
3 elements, and MUST NOT contain any element with FabricIndex `F2`

. struct
+
* AdminNodeID field: null
* AdminPasscodeID field: 0
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`
. struct
+
* AdminNodeID field: `N1`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N1`, 1111], Targets: null, FabricIndex: `F1`}
* FabricIndex field: `F1`

|10 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH2 reads DUT Endpoint 0 AccessControl cluster AccessControlEntryChanged
event

a|
Result is SUCCESS, value is list of AccessControlEntryChanged containing
3 elements, and MUST NOT contain any element with FabricIndex `F1`

. struct
+
* AdminNodeID field: null
* AdminPasscodeID field: 0
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N2`], Targets: null, FabricIndex: `F2`}
* FabricIndex field: `F2`
. struct
+
* AdminNodeID field: `N2`
* AdminPasscodeID field: null
* ChangeType field: Removed (2)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N2`], Targets: null, FabricIndex: `F2`}
* FabricIndex field: `F2`
. struct
+
* AdminNodeID field: `N2`
* AdminPasscodeID field: null
* ChangeType field: Added (1)
* LatestValue field: \{ Privilege: Administer (5), AuthMode: CASE (2),
Subjects: [`N2`, 2222], Targets: null, FabricIndex: `F2`}
* FabricIndex field: `F2`

|===

[[_tc_acl_2_9_cluster_access]]
===== link:#_tc_acl_2_9_cluster_access[]138.2.9. [TC-ACL-2.9] Cluster access

[[_category_285]]
====== link:#_category_285[]Category

Functional conformance

[[_purpose_291]]
====== link:#_purpose_291[]Purpose

. Verify that Access Control Cluster contents require correct privilege
to access.

[[_pics_291]]
====== link:#_pics_291[]PICS

* ACL.S

[[_pre_conditions_57]]
====== link:#_pre_conditions_57[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1
|===

[[_required_devices_291]]
====== link:#_required_devices_291[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|===

[[_test_setup_255]]
====== link:#_test_setup_255[]Test Setup

[[_test_procedure_291]]
====== link:#_test_procedure_291[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 1 element

. struct
+
* Privilege field: Manage (4)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null

a|
Result is SUCCESS

|3 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|4 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 1 element

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`]
* Targets field: null

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|5 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|6 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is an empty list

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|7 |9.11.5.5 |ACL.S.A0002(SubjectsPerAccessControlEntry) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
SubjectsPerAccessControlEntry attribute

a|
Result is SUCCESS,value is an integer with value 4 or greater.

|8 |9.11.5.6 |ACL.S.A0003(TargetsPerAccessControlEntry) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
TargetsPerAccessControlEntry attribute

a|
Result is SUCCESS,value is an integer with value 3 or greater.

|9 |9.11.5.7 |ACL.S.A0004(AccessControlEntriesPerFabric) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlEntriesPerFabric attribute

a|
Result is SUCCESS, value is an integer with value 4 or greater.

|10 |9.11.7.1 |ACL.S.E00(AccessControlEntryChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster AccessControlEntryChanged
event

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|11 |9.11.7.2 |ACL.S.E01(AccessControlExtensionChanged) a|
TH1 reads DUT Endpoint 0 AccessControl cluster
AccessControlExtensionChanged event

a|
Result is UNSUPPORTED_ACCESS (0x7e)

|===

[[_tc_acl_2_10_persistence]]
===== link:#_tc_acl_2_10_persistence[]138.2.10. [TC-ACL-2.10] Persistence

[[_category_286]]
====== link:#_category_286[]Category

Functional conformance

[[_purpose_292]]
====== link:#_purpose_292[]Purpose

. Verify that Access Control cluster persistence functions correctly.

[[_pics_292]]
====== link:#_pics_292[]PICS

* ACL.S

[[_pre_conditions_58]]
====== link:#_pre_conditions_58[]Pre-Conditions

[width="100%",cols="10%,20%,30%,40%",options="header",]
|===
|# |Doc Ref |Condition |Notes
|1 | | |`N1` is the node ID of TH1

|2 | | |`N2` is the node ID of TH2

|2 | | a|
`D_OK_EMPTY`:"1718" which is an octstr of length 2 containing valid TLV:

- top-level anonymous list (empty)

|3 | | a|
`D_OK_SINGLE`:"17D00000F1FF01003D48656C6C6F20576F726C642E205468697320697320612073696E676C6520656C656D656E74206C6976696E6720617320612063686172737472696E670018"
which is an octstr of length 50-100 containing valid TLV:

- top-level anonymous list, containing - one element with
profile-specific tag in fully-qualified form

|===

[[_required_devices_292]]
====== link:#_required_devices_292[]Required Devices

[width="100%",cols="17%,33%,50%",options="header",]
|===
|# |Device Name |Device Description
|1 |DUT |Commissionee
|2 |TH1 |Commissioner
|3 |TH2 |Commissioner
|===

[[_test_setup_256]]
====== link:#_test_setup_256[]Test Setup

[[_test_procedure_292]]
====== link:#_test_procedure_292[]Test Procedure

[width="100%",cols="10%,15%,15%,30%,30%",options="header",]
|===
|# |Ref |PICS |Test Step |Expected Outcome
|1 | | a|
TH1 commissions DUT using admin node ID `N1`

a|
DUT is commissioned on TH1 fabric

|2 | | a|
TH1 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F1`

|3 | | a|
TH1 puts DUT into commissioning mode, TH2 commissions DUT using admin
node ID `N2`

a|
DUT is commissioned on TH2 fabric

|4 | | a|
TH2 reads DUT Endpoint 0 OperationalCredentials cluster
CurrentFabricIndex attribute

a|
Result is SUCCESS

* value is stored as `F2`

|5 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 writes DUT Endpoint 0 AccessControl cluster ACL attribute, value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, 1111]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [3333]
* Targets field: null

a|
Result is SUCCESS

|6 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH2 writes DUT Endpoint 0 AccessControl cluster ACL attribute value is
list of AccessControlEntryStruct containing 2 elements

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N2`, 2222]
* Targets field: null
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [4444]
* Targets field: null

a|
Result is SUCCESS

|7 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 writes DUT Endpoint 0 AccessControl cluster Extension attribute,
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_EMPTY`

a|
Result is SUCCESS

|8 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH2 writes DUT Endpoint 0 AccessControl cluster Extension attribute
value is list of AccessControlExtensionStruct containing 1 element

. struct
+
* Data field: `D_OK_SINGLE`

a|
Result is SUCCESS

|9 | | a|
Reboot the DUT

a|
DUT is rebooted

|10 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements, and MUST NOT contain an element with FabricIndex `F2`

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, 1111]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [3333]
* Targets field: null
* FabricIndex field: `F1`

|11 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element, and MUST NOT contain an element with FabricIndex
`F2` or Data `D_OK_SINGLE`

. struct
+
* Data field: `D_OK_EMPTY`
* FabricIndex field: `F1`

|12 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH2 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements, and MUST NOT contain an element with FabricIndex `F1`

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N2`, 2222]
* Targets field: null
* FabricIndex field: `F2`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [4444]
* Targets field: null
* FabricIndex field: `F2`

|13 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH2 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element, and MUST NOT contain an element with FabricIndex
`F1` or Data `D_OK_EMPTY`

. struct
+
* Data field: `D_OK_SINGLE`
* FabricIndex field: `F2`

|14 | | a|
If DUT is an app on host, examine persistent storage in `/tmp/chip_kvs`
text file

a|
Persistent storage in `/tmp/chip_kvs` contains keys for FabricIndex `F1`
and FabricIndex `F2`

* `F1` ACL attribute: `f/<F1>/ac/0/0`, `f/<F1>/ac/0/1`
* `F1` extension attribute: `f/<F1>/ac/1`
* `F2` ACL attribute: `f/<F2>/ac/0/0`, `f/<F2>/ac/0/1`
* `F2` extension attribute: `f/<F2>/ac/1`

|15 | | a|
TH1 removes fabric `F2` from DUT

a|
Result is SUCCESS

|16 |9.11.5.3 |ACL.S.A0000(ACL) a|
TH1 reads DUT Endpoint 0 AccessControl cluster ACL attribute

a|
Result is SUCCESS, value is list of AccessControlEntryStruct containing
2 elements, and MUST NOT contain an element with FabricIndex `F2`

. struct
+
* Privilege field: Administer (5)
* AuthMode field: CASE (2)
* Subjects field: [`N1`, 1111]
* Targets field: null
* FabricIndex field: `F1`
. struct
+
* Privilege field: Operate (3)
* AuthMode field: Group (3)
* Subjects field: [3333]
* Targets field: null
* FabricIndex field: `F1`

|17 |9.11.5.4 |ACL.S.A0001(Extension) a|
TH1 reads DUT Endpoint 0 AccessControl cluster Extension attribute

a|
Result is SUCCESS, value is list of AccessControlExtensionStruct
containing 1 element, and MUST NOT contain an element with FabricIndex
`F2` or Data `D_OK_SINGLE`

. struct
+
* Data field: `D_OK_EMPTY`
* FabricIndex field: `F1`

|18 | | a|
If DUT is an app on host, examine persistent storage in `/tmp/chip_kvs`
text file

a|
Persistent storage in `/tmp/chip_kvs` contains keys for FabricIndex
`F1`, and MUST NOT contain any keys for FabricIndex `F2`

* `F1` ACL attribute: `f/<F1>/ac/0/0`, `f/<F1>/ac/0/1`
* `F1` extension attribute: `f/<F1>/ac/1`
* `F2` ACL attribute: `f/<F2>/ac/0/0`, `f/<F2>/ac/0/1` MUST NOT BE
PRESENT
* `F2` extension attribute: `f/<F2>/ac/1` MUST NOT BE PRESENT

|===

[[_bridged_device_basic_information_test_plan]]
== link:#_bridged_device_basic_information_test_plan[]**Bridged Device Basic Information Test Plan**

[[_pics_definition_40]]
=== link:#_pics_definition_40[]139. PICS Definition

This section covers the PICS items that are referenced in the following
test cases. Support for an item is considered as "true" for conditional
statements within the test case steps.

[[_role_42]]
==== link:#_role_42[]139.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BRBINFO.S |Does the device implement the Bridged Device Basic
Information Cluster as a server? |O |
|===

[[_server_42]]
==== link:#_server_42[]139.2. Server

[[_attributes_46]]
===== link:#_attributes_46[]139.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BRBINFO.S.A0000(DataModelRevision) |Does the DUT(server) support the
DataModelRevision attribute? |X |

|BRBINFO.S.A0001(VendorName) |Does the DUT(server) support the
VendorName attribute? |O |

|BRBINFO.S.A0002(VendorID) |Does the DUT(server) support the VendorID
attribute? |O |

|BRBINFO.S.A0003(ProductName) |Does the DUT(server) support the
ProductName attribute? |O |

|BRBINFO.S.A0004(ProductID) |Does the DUT(server) support the ProductID
attribute? |X |

|BRBINFO.S.A0005(NodeLabel) |Does the DUT(server) support the NodeLabel
attribute? |O |

|BRBINFO.S.A0006(Location) |Does the DUT(server) support the Location
attribute? |X |

|BRBINFO.S.A0007(HardwareVersion) |Does the DUT(server) support the
HardwareVersion attribute? |O |

|BRBINFO.S.A0008(HardwareVersionString) |Does the DUT(server) support
the HardwareVersionString attribute? |O |

|BRBINFO.S.A0009(SoftwareVersion) |Does the DUT(server) support the
SoftwareVersion attribute? |O |

|BRBINFO.S.A000a(SoftwareVersionString) |Does the DUT(server) support
the SoftwareVersionString attribute? |O |

|BRBINFO.S.A000b(ManufacturingDate) |Does the DUT(server) support the
ManufacturingDate attribute? |O |

|BRBINFO.S.A000c(PartNumber) |Does the DUT(server) support the
PartNumber attribute? |O |

|BRBINFO.S.A000d(ProductURL) |Does the DUT(server) support the
ProductURL attribute? |O |

|BRBINFO.S.A000e(ProductLabel) |Does the DUT(server) support the
ProductLabel attribute? |O |

|BRBINFO.S.A000f(SerialNumber) |Does the DUT(server) support the
SerialNumber attribute? |O |

|BRBINFO.S.A0010(LocalConfigDisabled) |Does the DUT(server) support the
LocalConfigDisabled attribute? |X |

|BRBINFO.S.A0011(Reachable) |Does the DUT(server) support the Reachable
attribute? |M |

|BRBINFO.S.A0012(UniqueID) |Does the DUT(server) support the UniqueID
attribute? |O |

|BRBINFO.S.A0013(CapabilityMinima) |Does the DUT(server) support the
CapabilityMinima attribute? |X |

|BRBINFO.S.A0014(ProductAppearance) |Does the DUT(server) support the
ProductAppearance attribute? |O |
|===

[[_events_10]]
===== link:#_events_10[]139.2.2. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|BRBINFO.S.E00(E_STARTUP) |Does the DUT(server) support the StartUp
event? |O |

|BRBINFO.S.E01(E_SHUTDOWN) |Does the DUT(server) support the ShutDown
event? |O |

|BRBINFO.S.E02(E_LEAVE) |Does the DUT(server) support the Leave event?
|O |

|BRBINFO.S.E03(E_REACHABLECHANGED) |Does the DUT(server) support the
ReachableChanged event? |M |
|===

[[ref_testplan_BridgedDeviceBasicInformation]]
=== link:#ref_testplan_BridgedDeviceBasicInformation[]140. PIXIT Definition

This section covers the Bridged Device Basic Information Cluster’s Test
Plan related PIXIT items that might be required in the following test
cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.BRBINFO.PrimaryColor |ProductAppearance.PrimaryColor should
reflect the product’s color |BRBINFO.S.A0014(ProductAppearance) |

|PIXIT.BRBINFO.Finish |ProductAppearance.Finish should reflect the
product’s finish |BRBINFO.S.A0014(ProductAppearance) |
|===

[[_test_case_list_42]]
=== link:#_test_case_list_42[]141. Test Case List

[width="100%",cols="20%,80%",]
|===
|*TC UUID* |*Test Case Name*

|TC-BRBINFO-1.1 |Global Attributes for Bridged Device Basic Information
Cluster Cluster [DUT-Server]

|TC-BRBINFO-2.1 |Attributes [DUT-Server]

|TC-BRBINFO-2.2 |Events [DUT-Server]

|TC-BRBINFO-3.1 |Appearance Attribute DUT as Server
|===

[[_test_cases_42]]
=== link:#_test_cases_42[]142. Test Cases

'''''

[[_generic_test_cases_36]]
==== link:#_generic_test_cases_36[]142.1. Generic Test Cases

'''''

[[_tc_brbinfo_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_brbinfo_1_1_global_attributes_with_dut_as_server[]142.1.1. [TC-BRBINFO-1.1] Global Attributes with DUT as Server

[[_category_287]]
====== link:#_category_287[]Category

Functional conformance

[[_purpose_293]]
====== link:#_purpose_293[]Purpose

This test case verifies the behavior of the global attributes of the
cluster server.

[[_pics_293]]
====== link:#_pics_293[]PICS

* BRBINFO.S

[[_required_devices_293]]
====== link:#_required_devices_293[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_293]]
====== link:#_test_procedure_293[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute.
|Verify that the DUT response contains the FeatureMap attribute and has
the value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0011, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0001: SHALL be included if and only if BRBINFO.S.A0001(VendorName)

- 0x0002: SHALL be included if and only if BRBINFO.S.A0002(VendorID)

- 0x0003: SHALL be included if and only if BRBINFO.S.A0003(ProductName)

- 0x0005: SHALL be included if and only if BRBINFO.S.A0005(NodeLabel)

- 0x0007: SHALL be included if and only if
BRBINFO.S.A0007(HardwareVersion)

- 0x0008: SHALL be included if and only if
BRBINFO.S.A0008(HardwareVersionString)

- 0x0009: SHALL be included if and only if
BRBINFO.S.A0009(SoftwareVersion)

- 0x000a: SHALL be included if and only if
BRBINFO.S.A000a(SoftwareVersionString)

- 0x000b: SHALL be included if and only if
BRBINFO.S.A000b(ManufacturingDate)

- 0x000c: SHALL be included if and only if BRBINFO.S.A000c(PartNumber)

- 0x000d: SHALL be included if and only if BRBINFO.S.A000d(ProductURL)

- 0x000e: SHALL be included if and only if BRBINFO.S.A000e(ProductLabel)

- 0x000f: SHALL be included if and only if BRBINFO.S.A000f(SerialNumber)

- 0x0012: SHALL be included if and only if BRBINFO.S.A0012(UniqueID)

- 0x0014: SHALL be included if and only if
BRBINFO.S.A0014(ProductAppearance)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored.

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1)

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list SHALL include all the mandatory entries: +
0x03,

The list MAY include these optional entries: +
- 0x00: SHALL be included if and only if BRBINFO.S.E00(E_STARTUP)

- 0x01: SHALL be included if and only if BRBINFO.S.E01(E_SHUTDOWN)

- 0x02: SHALL be included if and only if BRBINFO.S.E02(E_LEAVE)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_243]]
====== link:#_notestesting_considerations_243[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_bridged_device_basic_information_cluster_cluster_test_cases]]
==== link:#_bridged_device_basic_information_cluster_cluster_test_cases[]142.2. Bridged Device Basic Information Cluster Cluster Test Cases

[[_tc_brbinfo_2_1_attributes_dut_server]]
===== link:#_tc_brbinfo_2_1_attributes_dut_server[]142.2.1. [TC-BRBINFO-2.1] Attributes [DUT-Server]

[[_category_288]]
====== link:#_category_288[]Category

Functional conformance

[[_purpose_294]]
====== link:#_purpose_294[]Purpose

Verify if all the server attributes have been implemented correctly on
the DUT.

[[_pics_294]]
====== link:#_pics_294[]PICS

* BRBINFO.S

[[_precondition]]
====== link:#_precondition[]Precondition

[width="100%",cols="10%,14%,38%,38%",]
|===
|*#* |*Ref* |*Condition* |*Notes*
|===

[[_required_devices_294]]
====== link:#_required_devices_294[]Required Devices

[width="100%",cols="9%,30%,61%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test Harness that will query/modify for Bridged Device Basic
Information Cluster cluster attributes.

|2 |DUT |DUT which will be queried.
|===

[[_device_topology_235]]
====== link:#_device_topology_235[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_257]]
====== link:#_test_setup_257[]Test Setup

This will describe how to set up for testing.

[width="100%",cols="50%,50%",]
|===
a|
Note

|This test plan is derived from the test plan for the Basic Information
cluster, and skips the steps from that test plan which are not
applicable. Therefore some steps (e.g. steps 1-4, steps 56-58) are
missing or skipped.
|===

[[_test_procedure_294]]
====== link:#_test_procedure_294[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|2 | |BRBINFO.S |TH reads attribute ID 0 from the DUT (matches in ID to
DataModelRevision in the parent cluster, but is absent on the
BridgedDeviceBasicInformation cluster). |Verify that DUT responds with
UNSUPPORTED_ATTRIBUTE

|5 | |BRBINFO.S.A0001(VendorName) |TH reads VendorName from the DUT. a|
Verify it is of type string.

Verify it is less than or equal to 32 bytes and (when not empty) a
meaningful name matching the manufacturer of the bridged device.

|6 | |BRBINFO.S.A0001(VendorName) |TH writes VendorName as "sample"
|Verify DUT responds with UNSUPPORTED_WRITE

|7 | |BRBINFO.S.A0001(VendorName) |TH reads VendorName |Verify that the
VendorName remains unchanged

|8 | |BRBINFO.S.A0002(VendorID) |TH reads VendorID from the DUT. |Verify
that the value is in the range of 0x0001 to 0xFFF0, and matches the
value assigned to this manufacturer of the bridged device, see list in
link:#ref_CSAManufacturerCodes[CSA Manufacturer Code Database].

|9 | |BRBINFO.S.A0002(VendorID) |TH writes VendorID as "0x0011" |Verify
DUT responds with UNSUPPORTED_WRITE

|10 | |BRBINFO.S.A0002(VendorID) |TH reads VendorID |Verify that the
VendorID remains unchanged

|11 | |BRBINFO.S.A0003(ProductName) |TH reads ProductName from the DUT.
a|
Verify it is a human readable string.

Verify that the length is less than or equal to 32 bytes.

|12 | |BRBINFO.S.A0003(ProductName) |TH writes ProductName as
"newproduct" |Verify DUT responds with UNSUPPORTED_WRITE

|13 | |BRBINFO.S.A0003(ProductName) |TH reads ProductName |Verify that
the ProductName remains unchanged

|14 | |BRBINFO.S |TH reads attribute ID 4 from the DUT (matches in ID to
ProductID in the parent cluster, but is absent on the
BridgedDeviceBasicInformation cluster). |Verify that DUT responds with
UNSUPPORTED_ATTRIBUTE

|17 | |BRBINFO.S.A0005(NodeLabel) |TH reads NodeLabel from the DUT a|
Verify it is of type string.

Verify that the current value has a length between 0 and 32 bytes
inclusive.

|18 | |BRBINFO.S.A0005(NodeLabel) |TH writes "newnode" to NodeLabel
|Verify that the DUT sends success response

|19 | |BRBINFO.S.A0005(NodeLabel) |TH reads NodeLabel |Verify that the
NodeLabel is changed as "newnode"

|20 | |BRBINFO.S |TH reads attribute ID 6 from the DUT (matches in ID to
Location in the parent cluster, but is absent on the
BridgedDeviceBasicInformation cluster). |Verify that DUT responds with
UNSUPPORTED_ATTRIBUTE

|21 | |BRBINFO.S.A0007(HardwareVersion) |TH reads HardwareVersion from
the DUT. |Verify that the value is in range of 0 to 65534

|22 | |BRBINFO.S.A0007(HardwareVersion) |TH writes HardwareVersion as
"0x4531" |Verify DUT responds with UNSUPPORTED_WRITE

|23 | |BRBINFO.S.A0007(HardwareVersion) |TH reads HardwareVersion
|Verify that the HardwareVersion remains unchanged

|24 | |BRBINFO.S.A0008(HardwareVersionString) |TH reads
HardwareVersionString from the DUT. a|
Verify it is of type string.

Verify it has a length in the inclusive range of 1 to 64 bytes

|25 | |BRBINFO.S.A0008(HardwareVersionString) |TH writes
HardwareVersionString as "newhardwareversion" |Verify DUT responds with
UNSUPPORTED_WRITE

|26 | |BRBINFO.S.A0008(HardwareVersionString) |TH reads
HardwareVersionString |Verify that the HardwareVersionString remains
unchanged

|27 | |BRBINFO.S.A0009(SoftwareVersion) |TH reads SoftwareVersion from
the DUT. |Verify that the value is the range of 0 to 4294967294

|28 | |BRBINFO.S.A0009(SoftwareVersion) |TH writes SoftwareVersion as
"0x8213" |Verify DUT responds with UNSUPPORTED_WRITE

|29 | |BRBINFO.S.A0009(SoftwareVersion) |TH reads SoftwareVersion
|Verify that the SoftwareVersion remains unchanged

|30 | |BRBINFO.S.A000a(SoftwareVersionString) |TH reads
SoftwareVersionString from the DUT. a|
Verify it is of type string.

Verify that it has a length of 1 to 64 bytes of UTF-8 characters.

Verify that it uses 7-bit ASCII alphanumeric or punctuation characters.

|31 | |BRBINFO.S.A000a(SoftwareVersionString) |TH writes
SoftwareVersionString as "1.0" |Verify DUT responds with
UNSUPPORTED_WRITE

|32 | |BRBINFO.S.A000a(SoftwareVersionString) |TH reads
SoftwareVersionString |Verify that the SoftwareVersionString remains
unchanged

|33 | |BRBINFO.S.A000b(ManufacturingDate) |TH reads ManufacturingDate
from the DUT. a|
Verify it is of type string.

Verify it has length in the inclusive range of 8 to 16 bytes.

Verify if the first 8 characters specify date according to ISO 8601,
i.e, YYYYMMDD.

|34 | |BRBINFO.S.A000b(ManufacturingDate) |TH writes ManufacturingDate
as "20210814789452IN" |Verify DUT responds with UNSUPPORTED_WRITE

|35 | |BRBINFO.S.A000b(ManufacturingDate) |TH reads ManufacturingDate
|Verify that the ManufacturingDate remains unchanged

|36 | |BRBINFO.S.A000c(PartNumber) |TH reads PartNumber from the DUT. a|
Verify it is a human readable string.

Verify that the string has a maximum length of 32 bytes

|37 | |BRBINFO.S.A000c(PartNumber) |TH writes PartNumber as "newpart"
|Verify DUT responds with UNSUPPORTED_WRITE

|38 | |BRBINFO.S.A000c(PartNumber) |TH reads PartNumber |Verify that the
PartNumber remains unchanged

|39 | |BRBINFO.S.A000d(ProductURL) |TH reads ProductURL from the DUT. a|
Verify it is of type string.

Verify it is less than or equal to 256 ASCII characters.

Verify that it specifies a link to a specific web page.

Verify that it follows the syntax rules specified in
link:#RFC3986[RFC 3986].

|40 | |BRBINFO.S.A000d(ProductURL) |TH writes ProductURL as
"https://www.example.com" |Verify DUT responds with UNSUPPORTED_WRITE

|41 | |BRBINFO.S.A000d(ProductURL) |TH reads ProductURL |Verify that the
ProductURL remains unchanged

|42 | |BRBINFO.S.A000e(ProductLabel) |TH reads ProductLabel from the
DUT. a|
Verify it is of type string.

Verify it is less than or equal to 64 bytes.

Verify that it does not include the name of the vendor as defined within
the VendorName attribute

|43 | |BRBINFO.S.A000e(ProductLabel) |TH writes ProductLabel as
"newproductlabel" |Verify DUT responds with UNSUPPORTED_WRITE

|44 | |BRBINFO.S.A000e(ProductLabel) |TH reads ProductLabel |Verify that
the ProductLabel remains unchanged

|45 | |BRBINFO.S.A000f(SerialNumber) |TH reads SerialNumber from the
DUT. a|
Verify it is of type string.

Verify it is less than or equal to 32 bytes.

|46 | |BRBINFO.S.A000f(SerialNumber) |TH writes SerialNumber_test as
"newserialnumber" |Verify DUT responds with UNSUPPORTED_WRITE

|47 | |BRBINFO.S.A000f(SerialNumber) |TH reads SerialNumber |Verify that
the SerialNumber remains unchanged

|48 | |BRBINFO.S |TH reads attribute ID 0x0010 from the DUT (matches in
ID to LocalConfigDisabled in the parent cluster, but is absent on the
BridgedDeviceBasicInformation cluster). |Verify that DUT responds with
UNSUPPORTED_ATTRIBUTE

|51 | |BRBINFO.S.A0011(Reachable) |TH reads Reachable from the DUT. a|
Verify it is of type bool

Verify that the value is true

|52 | |BRBINFO.S.A0011(Reachable) |TH sends Write request message to DUT
to change value of Reachable to "false". |Verify DUT responds with
UNSUPPORTED_WRITE

|52b | |BRBINFO.S.A0011(Reachable) |TH reads Reachable from the DUT.
|Verify that the Reachable flag remains unchanged

|53 | |BRBINFO.S.A0012(UniqueID) |TH reads UniqueID from the DUT. a|
Verify it is of type string

Verify that the value is not be identical to SerialNumber attribute

Verify that the value is not be printed on the bridged device or on any
included materials.

|54 | |BRBINFO.S.A0012(UniqueID) |TH writes UniqueID as "newid" |Verify
DUT responds with UNSUPPORTED_WRITE

|55 | |BRBINFO.S.A0012(UniqueID) |TH reads UniqueID |Verify that the
UniqueID remains unchanged

|56 | |BRBINFO.S |TH reads attribute ID 0x0013 from the DUT (matches in
ID to CapabilityMinima in the parent cluster, but is absent on the
BridgedDeviceBasicInformation cluster). |Verify that DUT responds with
UNSUPPORTED_ATTRIBUTE

|59 | |BRBINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance
from the DUT. |Verify it is of type ProductAppearanceStruct.

|60 | |BRBINFO.S.A0014(ProductAppearance) |TH writes ProductAppearance
to the DUT. |Verify DUT responds with UNSUPPORTED_WRITE

|61 | |BRBINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance
from the DUT. |Verify that the ProductAppearance remains unchanged
|===

[[_tc_brbinfo_2_2_events_dut_server]]
===== link:#_tc_brbinfo_2_2_events_dut_server[]142.2.2. [TC-BRBINFO-2.2] Events [DUT-Server]

[[_category_289]]
====== link:#_category_289[]Category

Functional conformance

[[_purpose_295]]
====== link:#_purpose_295[]Purpose

Verify if all the events have been implemented correctly on the DUT.

[[_pics_295]]
====== link:#_pics_295[]PICS

* BRBINFO.S

[[_precondition_2]]
====== link:#_precondition_2[]Precondition

[width="100%",cols="5%,15%,40%,40%",options="header",]
|===
|*#* |*Ref* |*Condition* |*Notes*
|1 | |DUT and TH can interact with each other. DUT is commissioned. |

|2 | |TH reads SoftwareVersion attribute from DUT and saves for future
use |

|3 | |TH reads Reachable attribute from DUT and saves for future use |

|4 | |TH subscribes to StartUp, ShutDown, ReachableChanged and Leave
events on the Basic cluster of the DUT |

|5 | |TH saves the FabricIndex during commissioning |
|===

[[_required_devices_295]]
====== link:#_required_devices_295[]Required Devices

[width="100%",cols="15%,28%,57%",options="header",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness which will be used to send and receive events and
messages to the DUT

|2 |DUT |DUT which will send events to the TH
|===

[[_device_topology_236]]
====== link:#_device_topology_236[]Device Topology

DUT and TH are on the same fabric

[[_test_procedure_295]]
====== link:#_test_procedure_295[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | |BRBINFO.S.E00(StartUp) a|
* Reboot the DUT (i.e. restart by power cycle, not by making it factory
new)
* TH receives the StartUp event from DUT

a|
* Verify that the DUT sends the StartUp event before other events to TH
* Verify that the SoftwareVersion field in the event data is equivalent
to the precondition
* Verify that StartUp event has priority set as CRITICAL

|2 | |BRBINFO.S.E03(ReachableChanged) |Make the device on the bridged
endpoint unreachable across the bridge, such that the Reachable
attribute changes, in a manufacturer-specific way, such as powering off
or otherwise disabling the bridged device or the connectivity to it. a|
* Verify that the DUT sends the ReachableChanged event when the
Reachable attribute is changed from the precondition.
* Verify that the ReachableNewValue is of boolean type and not
equivalent to precondition.
* Verify that the Reachable event has priority set as INFO

|3 | |BRBINFO.S.E01(ShutDown) a|
TH subscribes to the shutdown event on the DUT. Shutdown DUT.

a|
Verify that ShutDown event is received and has priority set as CRITICAL

|===

[[_tc_brbinfo_3_1_appearance_attribute_dut_as_server]]
===== link:#_tc_brbinfo_3_1_appearance_attribute_dut_as_server[]142.2.3. [TC-BRBINFO-3.1] Appearance Attribute DUT as Server

[[_category_290]]
====== link:#_category_290[]Category

Functional conformance

[[_purpose_296]]
====== link:#_purpose_296[]Purpose

Verify if the appearance is correctly set within the allowed ranges.
Finish and PrimaryColor should reasonably reflect the appearance of the
product.

[[_pics_296]]
====== link:#_pics_296[]PICS

* BRBINFO.S

[[_precondition_3]]
====== link:#_precondition_3[]Precondition

[width="100%",cols="10%,14%,38%,38%",]
|===
|*#* |*Ref* |*Condition* |*Notes*
|===

[[_required_devices_296]]
====== link:#_required_devices_296[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_237]]
====== link:#_device_topology_237[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_258]]
====== link:#_test_setup_258[]Test Setup

This will describe how to set up for testing.

[width="100%",cols="50%,50%",]
|===
a|
Note

|This test plan is derived from the test plan for the Basic Information
cluster.
|===

[[_test_procedure_296]]
====== link:#_test_procedure_296[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | |BRBINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance
from the DUT. |ProductAppearance.Finish Value has to be between a range
of [min=Other(0), max=Fabric(5)]

|2 | |BRBINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance
from the DUT. |ProductAppearance.PrimaryColor Value has to be between a
range of [min=Black(0), max=Gold(20) ]

|3 | |BRBINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance
from the DUT. |ProductAppearance.Finish Value has to be equal to
PIXIT.BRBINFO.Finish

|4 | |BRBINFO.S.A0014(ProductAppearance) |TH reads ProductAppearance
from the DUT. |ProductAppearance.PrimaryColor Value has to be equal to
PIXIT.BRBINFO.PrimaryColor
|===

[[_time_synchronization_cluster_test_plan]]
== link:#_time_synchronization_cluster_test_plan[]**Time Synchronization Cluster Test Plan**

[[_pics_definition_41]]
=== link:#_pics_definition_41[]143. PICS Definition

This section covers the Time Synchronization Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_43]]
==== link:#_role_43[]143.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TIMESYNC.S |Does the device implement the Time Synchronization cluster
as a server? |O |

|TIMESYNC.C |Does the device implement the Time Synchronization cluster
as a client? |O |
|===

[[_server_43]]
==== link:#_server_43[]143.2. Server

[[_features_27]]
===== link:#_features_27[]143.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TIMESYNC.S.F00(TZ) |Does the device support time zone feature? |O |

|TIMESYNC.S.F01(NTPC) |Does the device support NTP client feature? |O |

|TIMESYNC.S.F02(NTPS) |Does the device support NTP server feature? |O |

|TIMESYNC.S.F03(TSC) |Does the device support time synchronization
client feature? |O |
|===

[[_attributes_47]]
===== link:#_attributes_47[]143.2.2. Attributes

[width="100%",cols="45%,35%,10%,10%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TIMESYNC.S.A0000(UTCTime) |Does the device implement the _UTCTime_
attribute? |M |

|TIMESYNC.S.A0001(Granularity) |Does the device implement the
_Granularity_ attribute? |M |

|TIMESYNC.S.A0002(TimeSource) |Does the device implement the
_TimeSource_ attribute? |O |

|TIMESYNC.S.A0003(TrustedTimeSource) |Does the device implement the
_TrustedTimeSource_ attribute? |TIMESYNC.S.F03(TSC) |

|TIMESYNC.S.A0004(DefaultNTP) |Does the device implement the
_DefaultNTP_ attribute? |TIMESYNC.S.F01(NTPC) |

|TIMESYNC.S.A0005(TimeZone) |Does the device implement the _TimeZone_
attribute? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.A0006(DSTOffset) |Does the device implement the _DSTOffset_
attribute? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.A0007(LocalTime) |Does the device implement the _LocalTime_
attribute? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.A0008(TimeZoneDatabase) |Does the device implement the
_TimeZoneDatabase_ attribute? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.A0009(NTPServerAvailable) |Does the device implement the
_NTPServerAvailable_ attribute? |TIMESYNC.S.F02(NTPS) |

|TIMESYNC.S.A000A(TimeZoneListMaxSize) |Does the device implement the
_TimeZoneListMaxSize_ attribute? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.A000B(DSTOffsetListMaxSize) |Does the device implement the
_DSTOffsetListMaxSize_ attribute? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.A000C(SupportsDNSResolve) |Does the device implement the
_SupportsDNSResolve_ attribute? |TIMESYNC.S.F01(NTPC) |
|===

[[_commands_received_26]]
===== link:#_commands_received_26[]143.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TIMESYNC.S.C00.Rsp(SetUTCTime) |Does the device implement receiving the
_SetUTCTime_ command? |M |

|TIMESYNC.S.C01.Rsp(SetTrustedTimeSource) |Does the device implement
receiving the _SetTrustedTimeSource_ command? |TIMESYNC.S.F03(TSC) |

|TIMESYNC.S.C02.Rsp(SetTimeZone) |Does the device implement receiving
the _SetTimeZone_ command? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.C04.Rsp(SetDSTOffset) |Does the device implement receiving
the _SetDSTOffset_ command? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.C05.Rsp(SetDefaultNTP) |Does the device implement receiving
the _SetDefaultNTP_ command? |TIMESYNC.S.F01(NTPC) |
|===

[[_commands_generated_28]]
===== link:#_commands_generated_28[]143.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TIMESYNC.S.C03.Tx(SetTimeZoneResponse) |Does the device implement
sending the _SetTimeZoneResponse_ command? |TIMESYNC.S.F00(TZ) |
|===

[[_events_11]]
===== link:#_events_11[]143.2.5. Events

[width="100%",cols="50%,30%,10%,10%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TIMESYNC.S.E00(DSTTableEmpty) |Does the device implement generating the
_DSTTableEmpty_ event? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.E01(DSTStatus) |Does the device implement generating the
_DSTStatus_ event? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.E02(TimeZoneStatus) |Does the device implement generating
the _TimeZoneStatus_ event? |TIMESYNC.S.F00(TZ) |

|TIMESYNC.S.E03(TimeFailure) |Does the device implement generating the
_TimeFailure_ event? |M |

|TIMESYNC.S.E04(MissingTrustedTimeSource) |Does the device implement
generating the _MissingTrustedTimeSource_ event? |M |
|===

[[_test_case_list_43]]
=== link:#_test_case_list_43[]144. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*

|1 |TC-TIMESYNC-1.1 |Global attributes with DUT as Server

|2 |TC-TIMESYNC-2.1 |Attributes with DUT as Server

|3 |TC-TIMESYNC-2.2 |SetUTCTime command with DUT as Server

|4 |TC-TIMESYNC-2.3 |SetTrustedTimeSource command with DUT as Server

|5 |TC-TIMESYNC-2.4 |SetTimeZone command with DUT as Server

|6 |TC-TIMESYNC-2.5 |SetDSTOffset command with DUT as Server

|7 |TC-TIMESYNC-2.6 |SetDefaultNTP command with DUT as Server

|8 |TC-TIMESYNC-2.7 |LocalTime calculation for time zone with DUT as
Server

|9 |TC-TIMESYNC-2.8 |LocalTime calculation for DST offset with DUT as
Server

|10 |TC-TIMESYNC-2.9 |LocalTime calculation for time zone with DST
offset with DUT as Server

|9 |TC-TIMESYNC-2.10 |DSTTableEmpty event generation with DUT as Server

|10 |TC-TIMESYNC-2.11 |DSTStatus event generation with DUT as Server

|11 |TC-TIMESYNC-2.12 |TimeZoneStatus event generation with DUT as
Server

|12 |TC-TIMESYNC-2.13 |MissingTrustedTimeSource event generation with
DUT as Server

|13 |TC-TIMESYNC-3.1 |Endpoint composition with DUT as Server
|===

[[_test_cases_43]]
=== link:#_test_cases_43[]145. Test Cases

'''''

[[_generic_test_cases_37]]
==== link:#_generic_test_cases_37[]145.1. Generic test cases

'''''

[[_tc_timesync_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_timesync_1_1_global_attributes_with_dut_as_server[]145.1.1. [TC-TIMESYNC-1.1] Global attributes with DUT as Server

[[_category_291]]
====== link:#_category_291[]Category

Functional conformance.

[[_purpose_297]]
====== link:#_purpose_297[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_297]]
====== link:#_pics_297[]PICS

* TIMESYNC.S

[[_required_devices_297]]
====== link:#_required_devices_297[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_297]]
====== link:#_test_procedure_297[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 2.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

* bit 0: SHALL be 1 if and only if TZ
* bit 1: SHALL be 1 if and only if NTPC
* bit 2: SHALL be 1 if and only if NTPS
* bit 3: SHALL be 1 if and only if TSC

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if TIMESYNC.S.A0002(TimeSource)

The list include entries based on feature support: +

* 0x0003 SHALL be included if and only if TIMESYNC.S.F03(TSC)
* 0x0004 SHALL be included if and only if TIMESYNC.S.F01(NTPC)
* 0x0005 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x0006 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x0007 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x0008 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x0009 SHALL be included if and only if TIMESYNC.S.F02(NTPS)
* 0x000A SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x000B SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x000C SHALL be included if and only if TIMESYNC.S.F01(NTPC)

and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |\{EVENTLIST} | |TH reads from the DUT the _EventList_ attribute.
a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list SHALL include all the mandatory entries: +

* 0x03

The list include entries based on feature support: +

* 0x00 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x01 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x02 SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x04 SHALL be included if and only if TIMESYNC.S.F03(TSC)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00

The list include entries based on feature support: +

* 0x01: SHALL be included if and only if TIMESYNC.S.F03(TSC)
* 0x02: SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x04: SHALL be included if and only if TIMESYNC.S.F00(TZ)
* 0x05: SHALL be included if and only if TIMESYNC.S.F01(NTPC)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list include entries based on feature support: +

- 0x03: SHALL be included if and only if TIMESYNC.S.F00(TZ)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_244]]
====== link:#_notestesting_considerations_244[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_44]]
==== link:#_server_44[]145.2. Server

'''''

[[_tc_timesync_2_1_attributes_with_dut_as_server]]
===== link:#_tc_timesync_2_1_attributes_with_dut_as_server[]145.2.1. [TC-TIMESYNC-2.1] Attributes with DUT as Server

[[_category_292]]
====== link:#_category_292[]Category

Functional.

[[_purpose_298]]
====== link:#_purpose_298[]Purpose

This test case verifies the non-global attributes of the Time
Synchronization cluster server.

[[_pics_298]]
====== link:#_pics_298[]PICS

* TIMESYNC.S

[[_required_devices_298]]
====== link:#_required_devices_298[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_238]]
====== link:#_device_topology_238[]Device Topology

TH and DUT are on the same fabric. TH has access to the current time.

[[_test_setup_259]]
====== link:#_test_setup_259[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_298]]
====== link:#_test_procedure_298[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |11.16.8.2 |TIMESYNC.S.A0001(Granularity) |TH reads from the DUT the
_Granularity_ attribute. |Verify that the DUT response contains a value
in the GranularityEnum range. Save the value as `granularity_dut`

|3 |11.16.8.3 |TIMESYNC.S.A0002(TimeSource) |TH reads from the DUT the
_TimeSource_ attribute. |Verify that the DUT response contains a value
in the GranularityEnum range. If `granularity_dut` is
`NoTimeGranularity`, verify that the returned value is `None`. if
`granularity_dut` is not `NoTimeGranularity`, verify that the returned
value is not `None`

|4 |11.16.8.4 |TIMESYNC.S.A0003(TrustedTimeSource) |TH reads from the
DUT the _TrustedTimeSource_ attribute. |If the returned value is
non-null, verify that the FabricIndex is in the range of 1 to 0xFE.

|5 |11.16.8.5 |TIMESYNC.S.A0004(DefaultNTP) |TH reads from the DUT the
_DefaultNTP_ attribute. |Verify that the DUT response contains either a
null value, or a character string that is less than 128 bytes. If the
value is a string, verify that it contains either an IPv6 address as
specified in https://tools.ietf.org/html/rfc5952[RFC 5952] OR a domain
name

|6 |11.16.8.6 |TIMESYNC.S.A0005(TimeZone) |TH reads from the DUT the
_TimeZone_ attribute. a|
* Verify that the DUT response contains a lit of TimeZoneStructs with 1
or 2 entries.
* Save the list as `tz_dut`.
* For each entry in the list, verify that the Offset is in the range of
-43200 to 50400.
* For each entry in the list, verify that if the Name field is present
it contains contains a character string in the range of 0 to 64 bytes.
* Verify that the ValidAt time for the first entry is 0.
* If there is a second entry in the list, verify that the ValidAt time
is non-zero.

|7 |11.16.8.7 |TIMESYNC.S.A0006(DSTOffset) |TH reads from the DUT the
_DSTOffset_ attribute. a|
* Verify that the DUT response contains a list of DSTOffsetStruct with 0
or more entries.
* Save the list as `dst_dut`.
* Verify that the list is sorted by ValidStarting time.
* Verify that no list entry has a ValidStarting time that is smaller
than the ValidUntil time of the previous entry.
* Verify that there is at most one entry with a null ValidUntil time.
* If there exists an entry with a null ValidUntil time, verify it is at
the end of the list.

|8 |11.16.8.1 |TIMESYNC.S.A0000(UTCTime) |TH reads from the DUT the
_UTCTime_ attribute. a|
* Save the returned UTCTime as 'utc_dut'
* Save the current TH UTC time in epoch-us as 'utc_th'
* If the `utc_dut` is null, verify that the `granularity_dut` is
`NoTimeGranularity`.
* If the `utc_dut` is not null, verify that the `granularity_dut` is not
`NoTimeGranularity`.
* If `granularity_dut` is `MinutesGranularity`, verify that `utc_dut` is
equal to `utc_th` +/- 10 minutes.
* If `granularity_dut` is `SecondsGramularity`,
`MillisecondsGranularity` or `MicrosecondsGranularity` verify that
`utc_dut` is equal to `utc_th` +/- 1 minute.

|9 |11.16.8.8 |TIMESYNC.S.A0007(LocalTime) |TH reads from the DUT the
_LocalTime_ attribute. a|
* If `utc_dut` is null, verify that the returned value is null.
* If the returned value is non-null, TH calculates the local time using
the information in `utc_dut`, `dst_dut` and `tz_dut` and verifies that
the returned value is equal to the calculated value +/1 1 minute.

|10 |11.16.8.9 |TIMESYNC.S.A0008(TimeZoneDatabase) |TH reads from the
DUT the _TimeZoneDatabase_ attribute. |Verify that the DUT response
contains a value in the range of TimeZoneDatabaseEnum.

|11 |11.16.8.10 |TIMESYNC.S.A0009(NTPServerAvailable) |TH reads from the
DUT the _NTPServerAvailable_ attribute. |Verify that the DUT response
contains any boolean value.

|12 |11.16.8.11 |TIMESYNC.S.A000A(TimeZoneListMaxSize) |TH reads from
the DUT the _TimeZoneListMaxSize_ attribute. |Verify that the DUT
response contains either a 1 or a 2.

|13 |11.16.8.12 |TIMESYNC.S.A000B(DSTOffsetListMaxSize) |TH reads from
the DUT the _DSTOffsetListMaxSize_ attribute. |Verify that the DUT
response contains a value of at least 1.

|14 |11.16.8.13 |TIMESYNC.S.A000C(SupportsDNSResolve) |TH reads from the
DUT the _SupportsDNSResolve_ attribute. |Verify that the DUT response
contains any boolean value.
|===

[[_notestesting_considerations_245]]
====== link:#_notestesting_considerations_245[]Notes/Testing Considerations

[[_tc_timesync_2_2_setutctime_command_with_dut_as_server]]
===== link:#_tc_timesync_2_2_setutctime_command_with_dut_as_server[]145.2.2. [TC-TIMESYNC-2.2] SetUTCTime command with DUT as Server

[[_category_293]]
====== link:#_category_293[]Category

Functional.

[[_purpose_299]]
====== link:#_purpose_299[]Purpose

This test case verifies the SetUTCTime command of the Time
Synchronization cluster server.

[[_pics_299]]
====== link:#_pics_299[]PICS

* TIMESYNC.S
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.A0001(Granularity)
* TIMESYNC.S.A0000(UTCTime)

[[_required_devices_299]]
====== link:#_required_devices_299[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_239]]
====== link:#_device_topology_239[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_260]]
====== link:#_test_setup_260[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_299]]
====== link:#_test_procedure_299[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |Save
the value as `utc_dut_initial`

|2 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetUTCTime_ command to the DUT with

* UTCTime field set to `utc_th`
* Granularity field set to MillisecondsGranularity
* TimeSource set to CloudSource.

a|
....
If `utc_dut_initial` is null:
....

* Verify DUT responds w/ status SUCCESS(0x00)
+
....
If `utc_dut_initial` is non-null:
....
* Verify DUT responds w/ status SUCCESS(0x00) or with the
cluster-specific error code TimeNotAccepted

|3 |11.16.8.2 |TIMESYNC.S.A0001(Granularity) |TH reads from the DUT the
_Granularity_ attribute. a|
* Verify that the DUT response contains a value in the GranularityEnum
range.
* Save the value as `granularity_dut`
* Verify that `granularity_dut` is not `NoTimeGranularity`

|4 |11.16.8.1 | |TH saves the current UTC time expressed in the Matter
epoch as `th_utc` and TH reads from the DUT the _UTCTime_ attribute. a|
* Save the response as `utc_dut`
* Verify that `utc_dut` is not null
* If `granularity_dut` is `MinutesGranularity`, verify that `utc_dut` is
equal to `utc_th` +/- 10 minutes.
* If `granularity_dut` is `SecondsGramularity`,
`MillisecondsGranularity` or `MicrosecondsGranularity` verify that
`utc_dut` is equal to `utc_th` +/- 1 minute.

|5 |11.16.8.3 |TIMESYNC.S.A0002(TimeSource) |TH reads from the DUT the
_TimeSource_ attribute. |if `utc_dut_initial` is null, verify that the
returned value is set to Admin.
|===

[[_tc_timesync_2_3_settrustedtimesource_command_with_dut_as_server]]
===== link:#_tc_timesync_2_3_settrustedtimesource_command_with_dut_as_server[]145.2.3. [TC-TIMESYNC-2.3] SetTrustedTimeSource command with DUT as Server

[[_category_294]]
====== link:#_category_294[]Category

Functional.

[[_purpose_300]]
====== link:#_purpose_300[]Purpose

This test case verifies the SetTrustedTimeSource command of the Time
Synchronization cluster server.

[[_pics_300]]
====== link:#_pics_300[]PICS

* TIMESYNC.S
* TIMESYNC.S.F03(TSC)
* TIMESYNC.S.C01.Rsp(SetTrustedTimeSource)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.A0001(Granularity)
* TIMESYNC.S.A0000(UTCTime)

[[_required_devices_300]]
====== link:#_required_devices_300[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_240]]
====== link:#_device_topology_240[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.
The node ID of the TH is saved as `th_node_id`

[[_test_setup_261]]
====== link:#_test_setup_261[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_300]]
====== link:#_test_procedure_300[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.9.2 | a|
TH sends the _SetTrustedTimeSource_ command to the DUT with the
TrustedTimeSource fields set as follows:

* NodeID: `th_node_id`
* Endpoint: 0

|Verify DUT responds w/ status SUCCESS(0x00)

|2 |11.17.5.6 | |TH reads from the DUT the _CurrentFabricIndex_
attribute from the Node Operational Credentials Cluster and saves as
`th_fabric_idx` |

|3 |11.16.8.4 | |TH reads from the DUT the _TrustedTimeSource_
attribute. a|
* Verify that FabricIndex field is `th_fabric_idx`
* Verify that NodeID is `th_node_id`
* Verify that Endpoint is 0

|4 |11.16.9.2 | a|
TH sends the _SetTrustedTimeSource_ command to the DUT with the
TrustedTimeSource set to null.

|

|5 |11.16.8.4 | |TH reads from the DUT the _TrustedTimeSource_
attribute. a|
Verify that the returned value is null.

|===

[[_tc_timesync_2_4_settimezone_command_with_dut_as_server]]
===== link:#_tc_timesync_2_4_settimezone_command_with_dut_as_server[]145.2.4. [TC-TIMESYNC-2.4] SetTimeZone command with DUT as Server

[[_category_295]]
====== link:#_category_295[]Category

Functional.

[[_purpose_301]]
====== link:#_purpose_301[]Purpose

This test case verifies the SetTimeZone command of the Time
Synchronization cluster server.

[[_pics_301]]
====== link:#_pics_301[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.C02.Rsp(SetTimeZone)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.A0000(UTCTime)
* TIMESYNC.S.A0005(TimeZone)
* TIMESYNC.S.A000A(TimeZoneListMaxSize)

[[_required_devices_301]]
====== link:#_required_devices_301[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_241]]
====== link:#_device_topology_241[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_262]]
====== link:#_test_setup_262[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_301]]
====== link:#_test_procedure_301[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.8.9 | |TH reads from the DUT the _TimeZoneDatabase_ attribute.
|Save the response as `tz_database_dut`.

|2 |11.16.8.11 | |TH reads from the DUT the _TimeZoneListMaxSize_
attribute. |Save the response as `tz_max_size_dut`.

|3 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 3600
* ValidAt: 0
* Name: omitted

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* Verify that the DSTOffsetsRequired field is set to true since no time
zone name was given

|4 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 3600
* ValidAt: 0
* Name: ""

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* Verify that the DSTOffsetsRequired field is set to true since no time
zone name was given

|5 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: -43200
* ValidAt: 0
* Name: omitted

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* Verify that the DSTOffsetsRequired field is set to true since no time
zone name was given

|6 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 50400
* ValidAt: 0
* Name: omitted

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* Verify that the DSTOffsetsRequired field is set to true since no time
zone name was given

|7 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 3600
* ValidAt: 0
* Name: "FakeCountry/FakeCity"

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* Verify that the DSTOffsetsRequired field is set to true since this
name will not match the database

|8 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 3600
* ValidAt: 0
* Name: "Europe/Dublin"

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* If `tz_database_dut` None, Verify that the DSTOffsetsRequired field is
set to true

|9 |11.16.9.3 | a|
If `tz_max_size_dut` is 2, TH saves the current UTC time expressed in
the Matter epoch as `th_utc` and sends the _SetTimeZone_ command with
the TimeZone field as a two list entry as:

* List entry 1:
+
** Offset: 3600
** ValidAt: 0
** Name: "Europe/Dublin"
* List entry 2:
+
** Offset: 7200
** ValidAt: `utc_th` + 2 minutes (1.2e+8)
** Name: "Europe/Athens"

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* If `tz_database_dut` None, Verify that the DSTOffsetsRequired field is
set to true

|10 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 3600
* ValidAt: `th_utc`
* Name: "Europe/Dublin"

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|11 |11.16.9.3 | a|
If `tz_max_size_dut` is 2, TH sends the _SetTimeZone_ command with the
TimeZone field as a two list entry as:

* List entry 1:
+
** Offset: 3600
** ValidAt: 0
** Name: "Europe/Dublin"
* List entry 2:
+
** Offset: 0
** ValidAt: 0
** Name: "Europe/Athens"

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|12 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: -43201
* ValidAt: `th_utc`
* Name: omitted

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|13 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 50401
* ValidAt: `th_utc`
* Name: omitted

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|14 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 0
* ValidAt: 0
* Name:
"AVeryLongStringWithSixtyFourChars/ThisIsSomeExtraPaddingForTheSt"

a|
* Verify that the DUT responds with a _SetTimeZoneResponse_.
* Verify that the DSTOffsetsRequired field is set to true since this
name will not match the database

|15 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 0
* ValidAt: 0
* Name:
"AVeryLongStringWithSixtyFiveChars/ThisIsSomeExtraPaddingForTheStr"

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|16 |11.16.9.3 | a|
If `tz_max_size_dut` is 2, TH saves the current UTC time expressed in
the Matter epoch as `th_utc` and sends the _SetTimeZone_ command with
the TimeZone field as a three list entry as:

* List entry 1:
+
** Offset: 3600
** ValidAt: 0
** Name: "Europe/Dublin"
* List entry 2:
+
** Offset: 7200
** ValidAt: `utc_th` + 2 minutes (1.2e+8)
** Name: "Europe/Athens"
* List entry 3:
+
** Offset: 10800
** ValidAt: `utc_th` + 4 minutes (2.4e+8)
** Name: "Europe/Istanbul"

|Verify DUT responds w/ status RESOURCE_EXHAUSTED(0x89)

|17 |11.16.9.3 | a|
If `tz_max_size_dut` is 1, TH sends the _SetTimeZone_ command with the
TimeZone field as a two list entry as:

* List entry 1:
+
** Offset: 3600
** ValidAt: 0
** Name: "Europe/Dublin"
* List entry 2:
+
** Offset: 7200
** ValidAt: `utc_th` + 2 minutes (1.2e+8)
** Name: "Europe/Athens"

|Verify DUT responds w/ status RESOURCE_EXHAUSTED(0x89)

|18 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command with the TimeZone field as a single
list entry as:

* Offset: 0
* ValidAt: 0
* Name: Omitted

a|
|===

[[_tc_timesync_2_5_setdstoffset_command_with_dut_as_server]]
===== link:#_tc_timesync_2_5_setdstoffset_command_with_dut_as_server[]145.2.5. [TC-TIMESYNC-2.5] SetDSTOffset command with DUT as Server

[[_category_296]]
====== link:#_category_296[]Category

Functional.

[[_purpose_302]]
====== link:#_purpose_302[]Purpose

This test case verifies the SetDSTOffset command of the Time
Synchronization cluster server.

[[_pics_302]]
====== link:#_pics_302[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.C04.Rsp(SetDSTOffset)
* TIMESYNC.S.A0005(TimeZone)
* TIMESYNC.S.A000B(DSTOffsetListMaxSize)

[[_required_devices_302]]
====== link:#_required_devices_302[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_242]]
====== link:#_device_topology_242[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_263]]
====== link:#_test_setup_263[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_302]]
====== link:#_test_procedure_302[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.8.12 | |TH reads from the DUT the _DSTOffsetListMaxSize_
attribute. |Save the response as `dst_max_size_dut`. Verify that
`dst_max_size_dut` is at least 1.

|2 |11.16.9.5 | a|
TH sends a _SetDSTOffset_ command to the DUT with the DSTOffset field
set to an empty list.

|Verify DUT responds w/ status SUCCESS(0x00)

|3 |11.16.8.7 | a|
TH reads from the DUT the _DSTOffset_ attribute.

|Verify the returned list is empty.

|4 |11.16.9.5 | a|
If `dst_max_size_dut` > 1, TH saves the current UTC time expressed in
the Matter epoch as `th_utc` and sends a _SetDSTOffset_ command to the
DUT with the DSTOffset field containing a 2 item list that is not sorted
by ValidStarting time. The list is as follows:

* List entry 1:
+
** Offset: 3600
** ValidStarting: `th_utc`
** ValidUntil: 'th_utc' + 1.577e+13 (6 months)
* List entry 2:
+
** offset: 3600
** ValidStarting: 0
** ValidUntil: `th_utc`

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|5 |11.16.8.7 | a|
If `dst_max_size_dut` > 1, TH reads from the DUT the _DSTOffset_
attribute.

|Verify the returned list is empty.

|6 |11.16.9.5 | a|
If `dst_max_size_dut` > 1, TH saves the current UTC time expressed in
the Matter epoch as `th_utc` and sends a _SetDSTOffset_ command to the
DUT with the DSTOffset field containing a 2 item list where the second
entry has a ValidStarting time that is smaller than the previous
ValidUntil time. The list is as follows:

* List entry 1:
+
** Offset: 3600
** ValidStarting: 0
** ValidUntil: 'th_utc' + 3e+8 (5 minutes)
* List entry 2:
+
** offset: 1800
** ValidStarting: `th_utc`
** ValidUntil: `th_utc` + 1.577e+13 (6 months)

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|7 |11.16.8.7 | a|
If `dst_max_size_dut` > 1, TH reads from the DUT the _DSTOffset_
attribute.

|Verify the returned list is empty.

|8 |11.16.9.5 | a|
If `dst_max_size_dut` > 1, TH saves the current UTC time expressed in
the Matter epoch as `th_utc` and sends a _SetDSTOffset_ command to the
DUT with the DSTOffset field containing a 2 item list with 2 null
ValidUntil entries. The list is as follows:

* List entry 1:
+
** Offset: 3600
** ValidStarting: 0
** ValidUntil: null
* List entry 2:
+
** offset: 1800
** ValidStarting: `th_utc` + 3e+8 (5 minutes)
** ValidUntil: null

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|9 |11.16.8.7 | a|
If `dst_max_size_dut` > 1, TH reads from the DUT the _DSTOffset_
attribute.

|Verify the returned list is empty.

|10 |11.16.9.5 | a|
If `dst_max_size_dut` > 1, TH saves the current UTC time expressed in
the Matter epoch as `th_utc` and sends a _SetDSTOffset_ command to the
DUT with the DSTOffset field containing a 2 item list with null
ValidUntil entry not at the end. The list is as follows:

* List entry 1:
+
** Offset: 3600
** ValidStarting: 0
** ValidUntil: null
* List entry 2:
+
** offset: 1800
** ValidStarting: `th_utc` + 3e+8 (5 minutes)
** ValidUntil: `th_utc` + 1.577e+13 (6 months)

|Verify DUT responds w/ status CONSTRAINT_ERROR(0x87)

|11 |11.16.8.7 | a|
If `dst_max_size_dut` > 1, TH reads from the DUT the _DSTOffset_
attribute.

|Verify the returned list is empty.

|12 |11.16.9.5 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetDSTOffset_ command to the DUT with the DSTOffset field
containing a list with `dst_max_size_dut` + 1 items.

....
For each list item at index i=(0:`dst_max_size_dut`):
- Offset: 3600
- ValidStarting: (`th_utc` + (3.156e+13 * i) + (1.577e+13)) : (1 year * i + 6 months)
- ValidUntil: (`th_utc` + (3.156e+13 * i+1)) : (1 year * i+1)
....

|Verify DUT responds w/ status RESOURCE_EXHAUSTED(0x89)

|13 |11.16.8.7 | a|
TH reads from the DUT the _DSTOffset_ attribute.

|Verify the returned list is empty.

|14 |11.16.9.5 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetDSTOffset_ command to the DUT with the DSTOffset field
containing a 1 item list with null ValidUntil entry. The list is as
follows:

* List entry 1:
+
** Offset: 3600
** ValidStarting: `th_utc` + 3e+8 (5 minutes)
** ValidUntil: null

|Verify DUT responds w/ status SUCCESS(0x00)

|15 |11.16.8.7 | a|
TH reads from the DUT the _DSTOffset_ attribute.

|Verify the returned list contains a single entry that matches the list
sent in the previous step.

|16 |11.16.9.5 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
sends a _SetDSTOffset_ command to the DUT with the DSTOffset field
containing a 1 item list with non-null ValidUntil entry. The list is as
follows:

* List entry 1:
+
** Offset: 3600
** ValidStarting: `th_utc` + 3e+8 (5 minutes)
** ValidUntil: `th_utc` + 1.577e+13 (6 months)

|Verify DUT responds w/ status SUCCESS(0x00)

|17 |11.16.8.7 | a|
TH reads from the DUT the _DSTOffset_ attribute.

|Verify the returned list contains a single entry that matches the list
sent in the previous step.

|18 |11.16.9.5 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetDSTOffset_ command to the DUT with the DSTOffset field
containing a list with `dst_max_size_dut` items. For each list item at
index i=(0:`dst_max_size_dut`-1):

* Offset: 3600
* ValidStarting: (`th_utc` + (3.156e+13 * i) + (1.577e+13)) : (1 year *
i + 6 months)
* ValidUntil: (`th_utc` + (3.156e+13 * i+1)) : (1 year * i+1)

|Verify DUT responds w/ status SUCCESS(0x00)

|19 |11.16.8.7 | a|
TH reads from the DUT the _DSTOffset_ attribute.

|Verify the returned list has `dst_max_size_dut` entries that matches
the list sent in the previous step.

|20 |11.16.9.5 | a|
TH sends a _SetDSTOffset_ command to the DUT with the DSTOffset field
set to an empty list.

|Verify DUT responds w/ status SUCCESS(0x00)
|===

[[_tc_timesync_2_6_setdefaultntp_command_with_dut_as_server]]
===== link:#_tc_timesync_2_6_setdefaultntp_command_with_dut_as_server[]145.2.6. [TC-TIMESYNC-2.6] SetDefaultNTP command with DUT as Server

[[_category_297]]
====== link:#_category_297[]Category

Functional.

[[_purpose_303]]
====== link:#_purpose_303[]Purpose

This test case verifies the SetDefaultNTP command of the Time
Synchronization cluster server.

[[_pics_303]]
====== link:#_pics_303[]PICS

* TIMESYNC.S
* TIMESYNC.S.F01(NTPC)
* TIMESYNC.S.C05.Rsp(SetDefaultNTP)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.A0000(UTCTime)
* TIMESYNC.S.A0004(DefaultNTP)
* TIMESYNC.S.A000C(SupportsDNSResolve)

[[_required_devices_303]]
====== link:#_required_devices_303[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_243]]
====== link:#_device_topology_243[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_264]]
====== link:#_test_setup_264[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_303]]
====== link:#_test_procedure_303[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.8.13 | |TH reads from the DUT the _SupportsDNSResolve_
attribute |Save as `dns_resolve_supported`

|2 |11.16.9.6 | |TH clears the _DefaultNTP_ attribute by sending a
_SetDefaultNTP_ command with the DefaultNTP field set to null. |

|3 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is null.

|4 |11.16.9.6 | |TH sends a _SetDefaultNTP_ command to with the
DefaultNTP field set to "time.nist.gov" a|
* If `dns_resolve_supported` is true, Verify DUT responds w/ status
SUCCESS(0x00)
* If `dns_resolve_supported` is false, Verify DUT responds w/ status
INVALID_COMMAND(0x85)

|5 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute a|
* If `dns_resolve_supported` is true, verify that _DefaultNTP_ is
"time.nist.gov".
* If `dns_resolve_supported` is false, _DefaultNTP_ is null.

|6 |11.16.9.6 | |TH clears the _DefaultNTP_ attribute by sending a
_SetDefaultNTP_ command with the DefaultNTP field set to null. |

|7 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is null.

|8 |11.16.9.6 | |TH sends a _SetDefaultNTP_ command to with the
DefaultNTP field set to "RandomString" |Verify DUT responds w/ status
INVALID_COMMAND(0x85)

|9 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is null.

|10 |11.16.9.6 | |TH sends a _SetDefaultNTP_ command to with the
DefaultNTP field set to "fe80:1" (malformed IPv6 address) |Verify DUT
responds w/ status INVALID_COMMAND(0x85)

|11 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is null.

|12 |11.16.9.6 | |TH sends a _SetDefaultNTP_ command to with the
DefaultNTP field set to "fz80::1" (malformed IPv6 address) |Verify DUT
responds w/ status INVALID_COMMAND(0x85)

|13 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is null.

|14 |11.16.9.6 | |TH sends a _SetDefaultNTP_ command to with the
DefaultNTP field set to "fe80::1" (good IPv6 address) |Verify DUT
responds w/ status SUCCESS(0x00)

|15 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is "fe80::1"

|16 |11.16.9.6 | |TH clears the _DefaultNTP_ attribute by sending a
_SetDefaultNTP_ command with the DefaultNTP field set to null. |

|17 |11.16.8.5 | |TH reads from the DUT the _DefaultNTP_ attribute
|Verify that _DefaultNTP_ is null.
|===

[[_tc_timesync_2_7_localtime_calculation_for_time_zone_with_dut_as_server]]
===== link:#_tc_timesync_2_7_localtime_calculation_for_time_zone_with_dut_as_server[]145.2.7. [TC-TIMESYNC-2.7] LocalTime calculation for time zone with DUT as Server

[[_category_298]]
====== link:#_category_298[]Category

Functional.

[[_purpose_304]]
====== link:#_purpose_304[]Purpose

This test case verifies the LocalTime is calculated correct for the
given TZ values and changes as appropriate.

[[_pics_304]]
====== link:#_pics_304[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.C02.Rsp(SetTimeZone)
* TIMESYNC.S.C03.Tx(SetTimeZoneResponse)
* TIMESYNC.S.C04.Rsp(SetDSTOffset)
* TIMESYNC.S.A0000(UTCTime)
* TIMESYNC.S.A0007(LocalTime)
* TIMESYNC.S.A000A(TimeZoneListMaxSize)

[[_required_devices_304]]
====== link:#_required_devices_304[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_244]]
====== link:#_device_topology_244[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_265]]
====== link:#_test_setup_265[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_304]]
====== link:#_test_procedure_304[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|2 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|

|3 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetUTCTime_ command to the DUT with the fields set as
follows:

* UTCTime: `th_utc`
* Granularity: MillisecondsGranularity
* TimeSource: omitted

|

|4 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|5 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6) (no offset).

|6 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 3600
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|7 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|

|8 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6)

|9 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + the
time zone offset ((`th_utc` + 3.6e+9) +/- 5e+6).

|10 |11.16.8.11 | |TH reads from the DUT the _TimeZoneListMaxSize_
attribute and saves as `tz_list_size`. |

|11 |11.16.9.3 | a|
If `tz_list_size` > 1, TH saves the current UTC time expressed in the
Matter epoch as `th_utc` and sends the _SetTimeZone_ command to the DUT
with the TimeZone field set to a list with a single elements as follows:

* List item 1:
+
** Offset 3600
** ValidAt: 0
** Name: omitted
* List Item 2:
+
** Offset: 7200
** ValidAt: `th_utc` + 1e+7 (10 seconds)
** Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|12 |11.16.9.4 | a|
If `tz_list_size` > 1, TH sends the _SetDSTOffset_ command to the DUT
with the DSTOffset field set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|

|13 |11.16.8.8 | |If `tz_list_size` > 1, TH reads from the DUT the
_LocalTime_ attribute. |TH saves the current UTC time expressed in the
Matter epoch as `th_utc` Verify the returned time is within 5 seconds of
`th_utc` + 3600s ((`th_utc` + 3.6e+9) +/- 5e+6).

|14 |11.16.8.8 | |If `tz_list_size` > 1, TH waits 15 seconds and TH
reads from the DUT the _LocalTime_ attribute. |TH saves the current UTC
time expressed in the Matter epoch as `th_utc` Verify the returned time
is within 5 seconds of `th_utc` + 7200s ((`th_utc` + 7.2e+9) +/- 5e+6).

|15 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: -3600
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|16 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|

|17 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + the
time zone offset ((`th_utc` - 3.6e+9) +/- 5e+6).

|18 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|19 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|
|===

[[_tc_timesync_2_8_localtime_calculation_for_dst_offset_with_dut_as_server]]
===== link:#_tc_timesync_2_8_localtime_calculation_for_dst_offset_with_dut_as_server[]145.2.8. [TC-TIMESYNC-2.8] LocalTime calculation for DST offset with DUT as Server

[[_category_299]]
====== link:#_category_299[]Category

Functional.

[[_purpose_305]]
====== link:#_purpose_305[]Purpose

This test case verifies the LocalTime is calculated correct for the
given DST values and changes as appropriate.

[[_pics_305]]
====== link:#_pics_305[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.C02.Rsp(SetTimeZone)
* TIMESYNC.S.C03.Tx(SetTimeZoneResponse)
* TIMESYNC.S.C04.Rsp(SetDSTOffset)
* TIMESYNC.S.A0000(UTCTime)
* TIMESYNC.S.A0007(LocalTime)
* TIMESYNC.S.A000B(DSTOffsetListMaxSize)

[[_required_devices_305]]
====== link:#_required_devices_305[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_245]]
====== link:#_device_topology_245[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_266]]
====== link:#_test_setup_266[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_305]]
====== link:#_test_procedure_305[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|2 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|

|3 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
sends a _SetUTCTime_ command to the DUT with the fields set as follows:

* UTCTime: `th_utc`
* Granularity: MillisecondsGranularity
* TimeSource: omitted

|

|4 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|5 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6) (no offset).

|6 |11.16.9.4 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: `th_utc` + 1e+7 (10 seconds)

|

|7 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|8 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + DST
offset ((`th_utc` + 3.6e+9) +/- 5e+6).

|9 | | |TH waits 15 seconds |

|10 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|11 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute.
|Verify the returned value is null.

|12 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: null

|

|13 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + DST
offset ((`th_utc` + 3.6e+9) +/- 5e+6).

|14 | | |TH waits 15 seconds |

|15 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + DST
offset ((`th_utc` + 3.6e+9) +/- 5e+6).

|16 |11.16.8.12 | |TH reads from the DUT the _DSTOffsetListMaxSize_
attribute and saves as `dst_list_size`. |

|17 |11.16.9.4 | a|
If `dst_list_size` > 1, TH saves the current UTC time expressed in the
Matter epoch as `th_utc` and sends a _SetDSTOffset_ command to the DUT
with the DSTOffset field set to a list with a two items as follows:

* List item 1:
+
** Offset: 3600
** ValidStarting: 0
** ValidUntil: `th_utc` + 1e+7 (10 seconds)
* List item 2:
+
** Offset: 7200
** ValidStarting: `th_utc` + 2.5e+7 (25 seconds)
** ValidUntil: `th_utc` + 4e+7 (40 seconds)

|

|18 |11.16.8.8 | |If `dst_list_size` > 1, TH reads from the DUT the
_LocalTime_ attribute. |TH saves the current UTC time expressed in the
Matter epoch as `th_utc`. Verify the returned time is within 5 seconds
of `th_utc` + 3600s ((`th_utc` + 3.6e+9) +/- 5e+6)

|19 | | |If `dst_list_size` > 1, TH waits 15 seconds |

|20 |11.16.8.8 | |If `dst_list_size` > 1, TH reads from the DUT the
_LocalTime_ attribute. |TH saves the current UTC time expressed in the
Matter epoch as `th_utc`. Verify the returned time is within 5 seconds
of the saved time (`th_utc` +/- 5e+6) (no offset).

|21 | | |If `dst_list_size` > 1, TH waits 15 seconds |

|22 |11.16.8.8 | |If `dst_list_size` > 1, TH reads from the DUT the
_LocalTime_ attribute. |TH saves the current UTC time expressed in the
Matter epoch as `th_utc`. Verify the returned time is within 5 seconds
of `th_utc` + 7200s ((`th_utc` + 7.2e+9) +/- 5e+6)

|23 | | |If `dst_list_size` > 1, TH waits 15 seconds |

|24 |11.16.8.8 | |If `dst_list_size` > 1, TH reads from the DUT the
_LocalTime_ attribute. |Verify the returned value is null.

|25 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: -3600
* ValidStarting: 0
* ValidUntil: null

|

|26 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + DST
offset ((`th_utc` - 3.6e+9) +/- 5e+6).

|27 |11.16.9.4 | a|
TH saves the current time as `th_utc` and sends the _SetDSTOffset_
command to the DUT with the DSTOffset field set to a list with a single
item as follows:

* Offset: 3600
* ValidStarting: `th_utc` + 1e+7 (10 seconds)
* ValidUntil: null

|

|28 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6) (no offset).

|29 | | |TH waits 15 seconds |

|30 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + DST
offset ((`th_utc` + 3.6e+9) +/- 5e+6).

|31 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|
|===

[[_tc_timesync_2_9_localtime_calculation_for_time_zone_with_dst_offset_with_dut_as_server]]
===== link:#_tc_timesync_2_9_localtime_calculation_for_time_zone_with_dst_offset_with_dut_as_server[]145.2.9. [TC-TIMESYNC-2.9] LocalTime calculation for time zone with DST offset with DUT as Server

[[_category_300]]
====== link:#_category_300[]Category

Functional.

[[_purpose_306]]
====== link:#_purpose_306[]Purpose

This test case verifies the LocalTime is calculated correct for the
given DST values and changes as appropriate.

[[_pics_306]]
====== link:#_pics_306[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.C02.Rsp(SetTimeZone)
* TIMESYNC.S.C03.Tx(SetTimeZoneResponse)
* TIMESYNC.S.C04.Rsp(SetDSTOffset)
* TIMESYNC.S.A0000(UTCTime)
* TIMESYNC.S.A0007(LocalTime)

[[_required_devices_306]]
====== link:#_required_devices_306[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_246]]
====== link:#_device_topology_246[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_267]]
====== link:#_test_setup_267[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_306]]
====== link:#_test_procedure_306[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetUTCTime_ command to the DUT with the fields set as
follows:

* UTCTime: `th_utc`
* Granularity: MillisecondsGranularity
* TimeSource: omitted

|

|2 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 7200
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|3 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: null

|

|4 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|5 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + time
zone offset + DST offset ((`th_utc` + 1.08e+10) +/- 5e+6).

|6 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: -3600
* ValidStarting: 0
* ValidUntil: null

|

|7 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|8 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + time
zone offset + DST offset ((`th_utc` + 3.6+9) +/- 5e+6).

|9 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: -7200
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|10 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: null

|

|11 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|12 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + time
zone offset + DST offset ((`th_utc` - 3.6+9) +/- 5e+6).

|13 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: -3600
* ValidStarting: 0
* ValidUntil: null

|

|14 |11.16.8.1 | |TH reads from the DUT the _UTCTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time (`th_utc`
+/- 5e+6).

|15 |11.16.8.8 | |TH reads from the DUT the _LocalTime_ attribute. |TH
saves the current UTC time expressed in the Matter epoch as `th_utc`.
Verify the returned time is within 5 seconds of the saved time + time
zone offset + DST offset ((`th_utc` - 1.08e+10) +/- 5e+6).

|16 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|17 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|
|===

[[_tc_timesync_2_10_dsttableempty_event_generation_with_dut_as_server]]
===== link:#_tc_timesync_2_10_dsttableempty_event_generation_with_dut_as_server[]145.2.10. [TC-TIMESYNC-2.10] DSTTableEmpty event generation with DUT as Server

[[_category_301]]
====== link:#_category_301[]Category

Functional.

[[_purpose_307]]
====== link:#_purpose_307[]Purpose

This test case verifies the DSTTableEmpty is correctly generated

[[_pics_307]]
====== link:#_pics_307[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.E00(DSTTableEmpty)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.C02.Rsp(SetTimeZone)
* TIMESYNC.S.C03.Tx(SetTimeZoneResponse)
* TIMESYNC.S.C04.Rsp(SetDSTOffset)

[[_required_devices_307]]
====== link:#_required_devices_307[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_247]]
====== link:#_device_topology_247[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.
DUT NodeID is `N1`

[[_test_setup_268]]
====== link:#_test_setup_268[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_307]]
====== link:#_test_procedure_307[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetUTCTime_ command to the DUT with the fields set as
follows:

* UTCTime: `th_utc`
* Granularity: MillisecondsGranularity
* TimeSource: omitted

|

|2 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 7200
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|3 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: null

|

|4 |11.16.10.1 | a|
TH subscribes to the _DSTTableEmpty_ event by sending a SubscribeRequest
action with:

* KeepSubscriptions: false
* MinIntervalFloor: 3
* MaxIntervalCeiling: 60
* AttributeRequests: []
* DataVersionFilters: []
* EventRequests: [\{
+
** Path: \{
+
*** Node: `N1`,
*** Endpoint: 0,
*** Cluster: 0x0038 (Time sync ClusterID)},
** Event: 0x00 (DSTTableEmpty event ID),
** IsUrgent: true}]
* EventFilters: []
* FabricFiltered: true

|

|5 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 3600
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|6 |11.16.10.1 | |TH waits for a _DSTTableEmpty_ event with a timeout of
5 seconds |Confirm receipt of the _DSTTableEmpty_ event

|7 |11.16.9.4 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: `th_utc` + 1e+7 (10 seconds)

|

|8 | | |TH waits until `th_utc` + 15 seconds |

|9 | | |TH reads the _LocalTime_ attribute from the DUT |

|10 | | |TH waits for a _DSTTableEmpty_ event until `th_utc` + 20s
seconds |Confirm receipt of the _DSTTableEmpty_ event

|11 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|12 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|
|===

[[_tc_timesync_2_11_dststatus_event_generation_with_dut_as_server]]
===== link:#_tc_timesync_2_11_dststatus_event_generation_with_dut_as_server[]145.2.11. [TC-TIMESYNC-2.11] DSTStatus event generation with DUT as Server

[[_category_302]]
====== link:#_category_302[]Category

Functional.

[[_purpose_308]]
====== link:#_purpose_308[]Purpose

This test case verifies the DSTStatus is correctly generated

[[_pics_308]]
====== link:#_pics_308[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.E01(DSTStatus)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.C02.Rsp(SetTimeZone)
* TIMESYNC.S.C03.Tx(SetTimeZoneResponse)
* TIMESYNC.S.C04.Rsp(SetDSTOffset)

[[_required_devices_308]]
====== link:#_required_devices_308[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_248]]
====== link:#_device_topology_248[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_269]]
====== link:#_test_setup_269[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_308]]
====== link:#_test_procedure_308[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetUTCTime_ command to the DUT with the fields set as
follows:

* UTCTime: `th_utc`
* Granularity: MillisecondsGranularity
* TimeSource: omitted

|

|2 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 7200
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|3 |11.16.10.2 | a|
TH subscribes to the _DSTStatus_ event by sending a SubscribeRequest
action with:

* KeepSubscriptions: false
* MinIntervalFloor: 1
* MaxIntervalCeiling: 3
* AttributeRequests: []
* DataVersionFilters: []
* EventRequests: [\{
+
** Path: \{
+
*** Node: `N1`,
*** Endpoint: 0,
*** Cluster: 0x0038 (Time sync ClusterID)},
** Event: 0x01 (DSTStatus event ID),
** IsUrgent: true}]
* EventFilters: []
* FabricFiltered: true

|

|4 |11.16.8.12 | |TH reads from the DUT the _DSTOffsetListMaxSize_
attribute and saves as `dst_list_size`. |

|5 |11.16.9.4 | a|
If `dst_list_size` > 1, TH saves the current UTC time expressed in the
Matter epoch as `th_utc` and sends a _SetDSTOffset_ command to the DUT
with the DSTOffset field set to a list with a two items as follows:

* List item 1:
+
** Offset: 3600
** ValidStarting: 0
** ValidUntil: `th_utc` + 1e+7 (10 seconds)
* List item 2:
+
** Offset: 7200
** ValidStarting: `th_utc` + 2.5e+7 (25 seconds)
** ValidUntil: `th_utc` + 4e+7 (40 seconds)

|

|6 |11.16.9.4 | a|
If `dst_list_size` == 1, TH saves the current UTC time expressed in the
Matter epoch as `th_utc` and sends the _SetDSTOffset_ command to the DUT
with the DSTOffset field set to a list with a single item as follows:

* Offset: 3600
* ValidStarting: 0
* ValidUntil: `th_utc` + 1e+7 (10 seconds)

|

|7 | | |TH reads the _LocalTime_ attribute from the DUT |

|8 |11.16.10.1 | |TH waits for a _DSTStatus_ event until `th_utc` + 5s
|Confirm receipt of the _DSTStatus_ event with the DSTOffsetActive field
set to True.

|9 | | |TH waits until `th_utc` + 15s |

|10 | | |TH reads the _LocalTime_ attribute from the DUT |

|11 | | |TH waits for a _DSTStatus_ event until `th_utc` + 20s |Confirm
receipt of the _DSTStatus_ event with the DSTOffsetActive field set to
False.

|12 | | |If `dst_list_size` > 1, TH waits until `th_utc` + 30s |

|13 | | |If `dst_list_size` > 1, TH reads the _LocalTime_ attribute from
the DUT |

|14 |11.16.10.1 | |If `dst_list_size` > 1 TH waits for a _DSTStatus_
event until `th_utc` + 35s |Confirm receipt of the _DSTStatus_ event
with the DSTOffsetActive field set to True.

|15 | | |If `dst_list_size` > 1, TH waits until `th_utc` + 45s |

|16 | | |If `dst_list_size` > 1, TH reads the _LocalTime_ attribute from
the DUT |

|17 | | |If `dst_list_size` > 1, TH waits for a _DSTStatus_ event until
`th_utc` + 50s |Confirm receipt of the _DSTStatus_ event with the
DSTOffsetActive field set to False.

|18 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|19 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|
|===

[[_tc_timesync_2_12_timezonestatus_event_generation_with_dut_as_server]]
===== link:#_tc_timesync_2_12_timezonestatus_event_generation_with_dut_as_server[]145.2.12. [TC-TIMESYNC-2.12] TimeZoneStatus event generation with DUT as Server

[[_category_303]]
====== link:#_category_303[]Category

Functional.

[[_purpose_309]]
====== link:#_purpose_309[]Purpose

This test case verifies the TimeZoneStatus is correctly generated

[[_pics_309]]
====== link:#_pics_309[]PICS

* TIMESYNC.S
* TIMESYNC.S.F00(TZ)
* TIMESYNC.S.E02(TimeZoneStatus)
* TIMESYNC.S.C00.Rsp(SetUTCTime)
* TIMESYNC.S.C02.Rsp(SetTimeZone)

[[_required_devices_309]]
====== link:#_required_devices_309[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_249]]
====== link:#_device_topology_249[]Device Topology

TH and DUT are on the same fabric and TH has access to the current time.

[[_test_setup_270]]
====== link:#_test_setup_270[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_309]]
====== link:#_test_procedure_309[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.16.9.1 | a|
TH saves the current UTC time expressed in the Matter epoch as `th_utc`
and sends a _SetUTCTime_ command to the DUT with the fields set as
follows:

* UTCTime: `th_utc`
* Granularity: MillisecondsGranularity
* TimeSource: omitted

|

|2 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 7200
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|3 |11.16.10.3 | a|
TH subscribes to the _TimeZoneStatus_ event by sending a
SubscribeRequest action with:

* KeepSubscriptions: false
* MinIntervalFloor: 1
* MaxIntervalCeiling: 3
* AttributeRequests: []
* DataVersionFilters: []
* EventRequests: [\{
+
** Path: \{
+
*** Node: `N1`,
*** Endpoint: 0,
*** Cluster: 0x0038 (Time sync ClusterID)},
** Event: 0x02 (TimeZoneStatus event ID),
** IsUrgent: true}]
* EventFilters: []
* FabricFiltered: true

|

|4 |11.16.8.11 | |TH reads from the DUT the _TimeZoneListMaxSize_
attribute and saves as `tz_list_size`. |

|5 |11.16.9.3 | a|
If `tz_list_size` > 1, TH saves the current UTC time expressed in the
Matter epoch as `th_utc` and sends the _SetTimeZone_ command to the DUT
with the TimeZone field set to a list with a single elements as follows:

* List item 1:
+
** Offset 3600
** ValidAt: 0
** Name: "Not/Real"
* List Item 2:
+
** Offset: 7200
** ValidAt: `th_utc` + 1e+7 (10 seconds)
** Name: "Un/Real"

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|6 |11.16.9.3 | a|
If `tz_list_size` == 1, TH sends the _SetTimeZone_ command to the DUT
with the TimeZone field set to a list with a single elements as follows:

* Offset: 3600
* ValidAt: 0
* Name: "Not/Real"

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|7 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|

|8 | | |TH reads the _LocalTime_ attribute from the DUT |

|9 |11.16.10.1 | |TH waits for a _TimeZoneStatus_ event until `th_utc` +
5s |Confirm receipt of the _TimeZoneStatus_ event with the Offset set to
3600 and the Name set to "Not/Real".

|10 | | |If `tz_list_size` > 1, TH waits until `th_utc` + 15s |

|11 | | |If `tz_list_size` > 1, TH reads the _LocalTime_ attribute from
the DUT |

|12 |11.16.10.1 | |If `tz_list_size` > 1, TH waits for a
_TimeZoneStatus_ event until `th_utc` + 20s |Confirm receipt of the
_TimeZoneStatus_ event with the Offset set to 7200 and the Name set to
"Un/Real".

|13 |11.16.9.3 | a|
TH sends the _SetTimeZone_ command to the DUT with the TimeZone field
set to a list with a single elements as follows:

* Offset: 0
* ValidAt: 0
* Name: Omitted

|Verify the DUT returns a _SetTimeZoneResponse_ with the
DSTOffsetsRequired field set to true.

|14 |11.16.9.4 | a|
TH sends the _SetDSTOffset_ command to the DUT with the DSTOffset field
set to a list with a single item as follows:

* Offset: 0
* ValidStarting: 0
* ValidUntil: null

|
|===

[[_tc_timesync_2_13_missingtrustedtimesource_event_generation_with_dut_as_server]]
===== link:#_tc_timesync_2_13_missingtrustedtimesource_event_generation_with_dut_as_server[]145.2.13. [TC-TIMESYNC-2.13] MissingTrustedTimeSource event generation with DUT as Server

[[_category_304]]
====== link:#_category_304[]Category

Functional.

[[_purpose_310]]
====== link:#_purpose_310[]Purpose

This test case verifies the DSTStatus is correctly generated

[[_pics_310]]
====== link:#_pics_310[]PICS

* TIMESYNC.S
* TIMESYNC.S.F01(NTPC)
* TIMESYNC.S.E03(TimeFailure)
* TIMESYNC.S.C01.Rsp(SetTrustedTimeSource)

[[_required_devices_310]]
====== link:#_required_devices_310[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_250]]
====== link:#_device_topology_250[]Device Topology

TH1 and DUT are on the same fabric. TH2 is on a different fabric. DUT is
commissioned to TH1. TH1 has a nodeID of `th1_node_id`. TH2 has a nodeID
of `th2_node_id`

[[_test_setup_271]]
====== link:#_test_setup_271[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_310]]
====== link:#_test_procedure_310[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 |11.18.8.1 | |TH1 opens a commissioning window on the DUT by sending
an OpenCommissioningWindow command to the Administrator Commissioning
Cluster on EP0. TH1 saves the generated QR or manual setup code for
commissioning as `WindowSetupPayload` |Verify DUT responds w/ status
SUCCESS(0x00)

|2 |5.5 | |TH2 fully commissions the DUT using `WindowSetupPayload` |

|3 |11.17.5.6 | |TH2 reads the _CurrentFabricIndex_ attribute from the
Node Operational Credentials Cluster on EP0 and saves as
`th2_fabric_idx` |

|4 |11.16.9.2 | a|
TH2 send the _SetTrustedTimeSource_ command to the DUT with the
TrustedTimeSource fields set as follows:

* NodeID: `th2_node_id`
* Endpoint: 0

|Verify DUT responds w/ status SUCCESS(0x00)

|5 |11.16.10.5 | a|
TH1 subscribes to the _MissingTrustedTimeSource_ event by sending a
SubscribeRequest action with:

* KeepSubscriptions: false
* MinIntervalFloor: 1
* MaxIntervalCeiling: 3
* AttributeRequests: []
* DataVersionFilters: []
* EventRequests: [\{
+
** Path: \{
+
*** Node: `N1`,
*** Endpoint: 0,
*** Cluster: 0x0038 (Time sync ClusterID)},
** Event: 0x03 (MissingTrustedTimeSource event ID),
** IsUrgent: true}]
* EventFilters: []
* FabricFiltered: true

|

|6 |11.17.7.12 | a|
TH1 removes the TH2 fabric by sending the RemoveFabric command to the
DUT with the FabricIndex set to `th2_fabric_idx`

|Verify DUT responds w/ status SUCCESS(0x00)

|7 |11.16.10.1 | |TH waits for a _MissingTrustedTimeSource_ event with a
timeout of 5 seconds |Confirm receipt of the _MissingTrustedTimeSource_
event.

|8 |11.16.9.2 | a|
TH1 send the _SetTrustedTimeSource_ command to the DUT with the
TrustedTimeSource fields set as follows:

* NodeID: `th1_node_id`
* Endpoint: 0

|Verify DUT responds w/ status SUCCESS(0x00)

|9 | | |TH1 Waits 5 seconds |

|10 |11.16.9.2 | a|
TH1 sends the _SetTrustedTimeSource_ command to the DUT with the
TrustedTimeSource set to null.

|

|11 |11.16.10.1 | |TH waits for a _MissingTrustedTimeSource_ event with
a timeout of 5 seconds |Confirm receipt of the
_MissingTrustedTimeSource_ event.
|===

[[_tc_timesync_3_1_endpoint_composition_with_dut_as_server]]
===== link:#_tc_timesync_3_1_endpoint_composition_with_dut_as_server[]145.2.14. [TC-TIMESYNC-3.1] Endpoint composition with DUT as Server

[[_category_305]]
====== link:#_category_305[]Category

Functional.

[[_purpose_311]]
====== link:#_purpose_311[]Purpose

This test case verifies the node properly implements the endpoint
composition requirements.

[[_pics_311]]
====== link:#_pics_311[]PICS

* TIMESYNC.S

[[_required_devices_311]]
====== link:#_required_devices_311[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_251]]
====== link:#_device_topology_251[]Device Topology

TH1 and DUT are on the same fabric.

[[_test_setup_272]]
====== link:#_test_setup_272[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_311]]
====== link:#_test_procedure_311[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |C.11.16 | |TH does a wildcard read of the time sync cluster UTCTime
attribute across all endpoints. |Verify that only one AttributeReportIB
is returned for endpoint 0.

|2 |C.11.16 | |TH does a wildcard read of the descriptor cluster
ServerList attribute across all endpoint. |Verify that the time
synchronization cluster id (0x0038) is listed in the ServerList
attribute from endpoint 0 and is not listed in the ServerList attribute
for any other endpoints.
|===

[[_carbon_monoxide_concentration_measurement_cluster_test_plan]]
== link:#_carbon_monoxide_concentration_measurement_cluster_test_plan[]**Carbon Monoxide Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for CMOCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_42]]
=== link:#_pics_definition_42[]146. PICS Definition

This section covers the Carbon Monoxide Concentration Measurement
Cluster Test Plan related PICS items that are referenced in the
following test cases. Support for an item is considered as "true" for
conditional statements within the test case steps.

[[_role_44]]
==== link:#_role_44[]146.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CMOCONC.S |Does the device implement the Carbon Monoxide Concentration
Measurement cluster as a server? |O |

|CMOCONC.C |Does the device implement the Carbon Monoxide Concentration
Measurement cluster as a client? |O |
|===

[[_server_45]]
==== link:#_server_45[]146.2. Server

[[_features_28]]
===== link:#_features_28[]146.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CMOCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|CMOCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|CMOCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|CMOCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|CMOCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|CMOCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_48]]
===== link:#_attributes_48[]146.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CMOCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |CMOCONC.S.F00(MEA) |

|CMOCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |CMOCONC.S.F00(MEA) |

|CMOCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |CMOCONC.S.F00(MEA) |

|CMOCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |CMOCONC.S.F04(PEA) |

|CMOCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |CMOCONC.S.F04(PEA) |

|CMOCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |CMOCONC.S.F05(AVG) |

|CMOCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |CMOCONC.S.F05(AVG) |

|CMOCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[CMOCONC.S.F00(MEA)] |

|CMOCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |CMOCONC.S.F00(MEA) |

|CMOCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|CMOCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |CMOCONC.S.F01(LEV) |
|===

[[_test_case_list_44]]
=== link:#_test_case_list_44[]147. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-CMOCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-CMOCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_44]]
=== link:#_test_cases_44[]148. Test Cases

'''''

[[_generic_test_cases_38]]
==== link:#_generic_test_cases_38[]148.1. Generic test cases

'''''

[[_tc_cmoconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_cmoconc_1_1_global_attributes_with_dut_as_server[]148.1.1. [TC-CMOCONC-1.1] Global attributes with DUT as Server

[[_category_306]]
====== link:#_category_306[]Category

Functional conformance.

[[_purpose_312]]
====== link:#_purpose_312[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_312]]
====== link:#_pics_312[]PICS

* CMOCONC.S

[[_required_devices_312]]
====== link:#_required_devices_312[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_312]]
====== link:#_test_procedure_312[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if CMOCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if CMOCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if CMOCONC.S.F02(MED) &
CMOCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if CMOCONC.S.F03(CRI) &
CMOCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if CMOCONC.S.F04(PEA) &
CMOCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if CMOCONC.S.F05(AVG) &
CMOCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if CMOCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if CMOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if CMOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if CMOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if CMOCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if CMOCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if CMOCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if CMOCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if CMOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if CMOCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_246]]
====== link:#_notestesting_considerations_246[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_46]]
==== link:#_server_46[]148.2. Server

'''''

[[_tc_cmoconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_cmoconc_2_1_attributes_with_dut_as_server[]148.2.1. [TC-CMOCONC-2.1] Attributes with DUT as Server

[[_category_307]]
====== link:#_category_307[]Category

Functional.

[[_purpose_313]]
====== link:#_purpose_313[]Purpose

This test case verifies the non-global attributes of the Carbon Monoxide
Concentration Measurement cluster server.

[[_pics_313]]
====== link:#_pics_313[]PICS

* CMOCONC.S

[[_required_devices_313]]
====== link:#_required_devices_313[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_252]]
====== link:#_device_topology_252[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_273]]
====== link:#_test_setup_273[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_313]]
====== link:#_test_procedure_313[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |CMOCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |CMOCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |CMOCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |CMOCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |CMOCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |CMOCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |CMOCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |CMOCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |CMOCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |CMOCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_247]]
====== link:#_notestesting_considerations_247[]Notes/Testing Considerations

[[_carbon_dioxide_concentration_measurement_cluster_test_plan]]
== link:#_carbon_dioxide_concentration_measurement_cluster_test_plan[]**Carbon Dioxide Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for CDOCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_43]]
=== link:#_pics_definition_43[]149. PICS Definition

This section covers the Carbon Dioxide Concentration Measurement Cluster
Test Plan related PICS items that are referenced in the following test
cases. Support for an item is considered as "true" for conditional
statements within the test case steps.

[[_role_45]]
==== link:#_role_45[]149.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CDOCONC.S |Does the device implement the Carbon Dioxide Concentration
Measurement cluster as a server? |O |

|CDOCONC.C |Does the device implement the Carbon Dioxide Concentration
Measurement cluster as a client? |O |
|===

[[_server_47]]
==== link:#_server_47[]149.2. Server

[[_features_29]]
===== link:#_features_29[]149.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CDOCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|CDOCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|CDOCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|CDOCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|CDOCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|CDOCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_49]]
===== link:#_attributes_49[]149.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|CDOCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |CDOCONC.S.F00(MEA) |

|CDOCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |CDOCONC.S.F00(MEA) |

|CDOCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |CDOCONC.S.F00(MEA) |

|CDOCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |CDOCONC.S.F04(PEA) |

|CDOCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |CDOCONC.S.F04(PEA) |

|CDOCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |CDOCONC.S.F05(AVG) |

|CDOCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |CDOCONC.S.F05(AVG) |

|CDOCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[CDOCONC.S.F00(MEA)] |

|CDOCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |CDOCONC.S.F00(MEA) |

|CDOCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|CDOCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |CDOCONC.S.F01(LEV) |
|===

[[_test_case_list_45]]
=== link:#_test_case_list_45[]150. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-CDOCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-CDOCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_45]]
=== link:#_test_cases_45[]151. Test Cases

'''''

[[_generic_test_cases_39]]
==== link:#_generic_test_cases_39[]151.1. Generic test cases

'''''

[[_tc_cdoconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_cdoconc_1_1_global_attributes_with_dut_as_server[]151.1.1. [TC-CDOCONC-1.1] Global attributes with DUT as Server

[[_category_308]]
====== link:#_category_308[]Category

Functional conformance.

[[_purpose_314]]
====== link:#_purpose_314[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_314]]
====== link:#_pics_314[]PICS

* CDOCONC.S

[[_required_devices_314]]
====== link:#_required_devices_314[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_314]]
====== link:#_test_procedure_314[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if CDOCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if CDOCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if CDOCONC.S.F02(MED) &
CDOCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if CDOCONC.S.F03(CRI) &
CDOCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if CDOCONC.S.F04(PEA) &
CDOCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if CDOCONC.S.F05(AVG) &
CDOCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if CDOCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if CDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if CDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if CDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if CDOCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if CDOCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if CDOCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if CDOCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if CDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if CDOCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_248]]
====== link:#_notestesting_considerations_248[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_48]]
==== link:#_server_48[]151.2. Server

'''''

[[_tc_cdoconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_cdoconc_2_1_attributes_with_dut_as_server[]151.2.1. [TC-CDOCONC-2.1] Attributes with DUT as Server

[[_category_309]]
====== link:#_category_309[]Category

Functional.

[[_purpose_315]]
====== link:#_purpose_315[]Purpose

This test case verifies the non-global attributes of the Carbon Dioxide
Concentration Measurement cluster server.

[[_pics_315]]
====== link:#_pics_315[]PICS

* CDOCONC.S

[[_required_devices_315]]
====== link:#_required_devices_315[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_253]]
====== link:#_device_topology_253[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_274]]
====== link:#_test_setup_274[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_315]]
====== link:#_test_procedure_315[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |CDOCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |CDOCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |CDOCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |CDOCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |CDOCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |CDOCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |CDOCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |CDOCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |CDOCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |CDOCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_249]]
====== link:#_notestesting_considerations_249[]Notes/Testing Considerations

[[_nitrogen_dioxide_concentration_measurement_cluster_test_plan]]
== link:#_nitrogen_dioxide_concentration_measurement_cluster_test_plan[]**Nitrogen Dioxide Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for NDOCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_44]]
=== link:#_pics_definition_44[]152. PICS Definition

This section covers the Nitrogen Dioxide Concentration Measurement
Cluster Test Plan related PICS items that are referenced in the
following test cases. Support for an item is considered as "true" for
conditional statements within the test case steps.

[[_role_46]]
==== link:#_role_46[]152.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|NDOCONC.S |Does the device implement the Nitrogen Dioxide Concentration
Measurement cluster as a server? |O |

|NDOCONC.C |Does the device implement the Nitrogen Dioxide Concentration
Measurement cluster as a client? |O |
|===

[[_server_49]]
==== link:#_server_49[]152.2. Server

[[_features_30]]
===== link:#_features_30[]152.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|NDOCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|NDOCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|NDOCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|NDOCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|NDOCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|NDOCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_50]]
===== link:#_attributes_50[]152.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|NDOCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |NDOCONC.S.F00(MEA) |

|NDOCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |NDOCONC.S.F00(MEA) |

|NDOCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |NDOCONC.S.F00(MEA) |

|NDOCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |NDOCONC.S.F04(PEA) |

|NDOCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |NDOCONC.S.F04(PEA) |

|NDOCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |NDOCONC.S.F05(AVG) |

|NDOCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |NDOCONC.S.F05(AVG) |

|NDOCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[NDOCONC.S.F00(MEA)] |

|NDOCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |NDOCONC.S.F00(MEA) |

|NDOCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|NDOCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |NDOCONC.S.F01(LEV) |
|===

[[_test_case_list_46]]
=== link:#_test_case_list_46[]153. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-NDOCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-NDOCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_46]]
=== link:#_test_cases_46[]154. Test Cases

'''''

[[_generic_test_cases_40]]
==== link:#_generic_test_cases_40[]154.1. Generic test cases

'''''

[[_tc_ndoconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_ndoconc_1_1_global_attributes_with_dut_as_server[]154.1.1. [TC-NDOCONC-1.1] Global attributes with DUT as Server

[[_category_310]]
====== link:#_category_310[]Category

Functional conformance.

[[_purpose_316]]
====== link:#_purpose_316[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_316]]
====== link:#_pics_316[]PICS

* NDOCONC.S

[[_required_devices_316]]
====== link:#_required_devices_316[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_316]]
====== link:#_test_procedure_316[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if NDOCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if NDOCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if NDOCONC.S.F02(MED) &
NDOCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if NDOCONC.S.F03(CRI) &
NDOCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if NDOCONC.S.F04(PEA) &
NDOCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if NDOCONC.S.F05(AVG) &
NDOCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if NDOCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if NDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if NDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if NDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if NDOCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if NDOCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if NDOCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if NDOCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if NDOCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if NDOCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_250]]
====== link:#_notestesting_considerations_250[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_50]]
==== link:#_server_50[]154.2. Server

'''''

[[_tc_ndoconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_ndoconc_2_1_attributes_with_dut_as_server[]154.2.1. [TC-NDOCONC-2.1] Attributes with DUT as Server

[[_category_311]]
====== link:#_category_311[]Category

Functional.

[[_purpose_317]]
====== link:#_purpose_317[]Purpose

This test case verifies the non-global attributes of the Nitrogen
Dioxide Concentration Measurement cluster server.

[[_pics_317]]
====== link:#_pics_317[]PICS

* NDOCONC.S

[[_required_devices_317]]
====== link:#_required_devices_317[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_254]]
====== link:#_device_topology_254[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_275]]
====== link:#_test_setup_275[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_317]]
====== link:#_test_procedure_317[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |NDOCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |NDOCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |NDOCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |NDOCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |NDOCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |NDOCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |NDOCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |NDOCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |NDOCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |NDOCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_251]]
====== link:#_notestesting_considerations_251[]Notes/Testing Considerations

[[_ozone_concentration_measurement_cluster_test_plan]]
== link:#_ozone_concentration_measurement_cluster_test_plan[]**Ozone Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for OZCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_45]]
=== link:#_pics_definition_45[]155. PICS Definition

This section covers the Ozone Concentration Measurement Cluster Test
Plan related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_47]]
==== link:#_role_47[]155.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OZCONC.S |Does the device implement the Ozone Concentration Measurement
cluster as a server? |O |

|OZCONC.C |Does the device implement the Ozone Concentration Measurement
cluster as a client? |O |
|===

[[_server_51]]
==== link:#_server_51[]155.2. Server

[[_features_31]]
===== link:#_features_31[]155.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OZCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|OZCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|OZCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|OZCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|OZCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|OZCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_51]]
===== link:#_attributes_51[]155.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OZCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |OZCONC.S.F00(MEA) |

|OZCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |OZCONC.S.F00(MEA) |

|OZCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |OZCONC.S.F00(MEA) |

|OZCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |OZCONC.S.F04(PEA) |

|OZCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |OZCONC.S.F04(PEA) |

|OZCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |OZCONC.S.F05(AVG) |

|OZCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |OZCONC.S.F05(AVG) |

|OZCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[OZCONC.S.F00(MEA)] |

|OZCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |OZCONC.S.F00(MEA) |

|OZCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|OZCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |OZCONC.S.F01(LEV) |
|===

[[_test_case_list_47]]
=== link:#_test_case_list_47[]156. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-OZCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-OZCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_47]]
=== link:#_test_cases_47[]157. Test Cases

'''''

[[_generic_test_cases_41]]
==== link:#_generic_test_cases_41[]157.1. Generic test cases

'''''

[[_tc_ozconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_ozconc_1_1_global_attributes_with_dut_as_server[]157.1.1. [TC-OZCONC-1.1] Global attributes with DUT as Server

[[_category_312]]
====== link:#_category_312[]Category

Functional conformance.

[[_purpose_318]]
====== link:#_purpose_318[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_318]]
====== link:#_pics_318[]PICS

* OZCONC.S

[[_required_devices_318]]
====== link:#_required_devices_318[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_318]]
====== link:#_test_procedure_318[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if OZCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if OZCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if OZCONC.S.F02(MED) &
OZCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if OZCONC.S.F03(CRI) &
OZCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if OZCONC.S.F04(PEA) &
OZCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if OZCONC.S.F05(AVG) & OZCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if OZCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if OZCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if OZCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if OZCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if OZCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if OZCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if OZCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if OZCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if OZCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if OZCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_252]]
====== link:#_notestesting_considerations_252[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_52]]
==== link:#_server_52[]157.2. Server

'''''

[[_tc_ozconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_ozconc_2_1_attributes_with_dut_as_server[]157.2.1. [TC-OZCONC-2.1] Attributes with DUT as Server

[[_category_313]]
====== link:#_category_313[]Category

Functional.

[[_purpose_319]]
====== link:#_purpose_319[]Purpose

This test case verifies the non-global attributes of the Ozone
Concentration Measurement cluster server.

[[_pics_319]]
====== link:#_pics_319[]PICS

* OZCONC.S

[[_required_devices_319]]
====== link:#_required_devices_319[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_255]]
====== link:#_device_topology_255[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_276]]
====== link:#_test_setup_276[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_319]]
====== link:#_test_procedure_319[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |OZCONC.S.A0001(MinMeasuredValue) |TH reads from the DUT
the _MinMeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Save this value for
later.

|3 |AC.2.10.6.3 |OZCONC.S.A0002(MaxMeasuredValue) |TH reads from the DUT
the _MaxMeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Save this value for
later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |OZCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |OZCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |OZCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |OZCONC.S.A0005(AverageMeasuredValue) |TH reads from the
DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |OZCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |OZCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |OZCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |OZCONC.S.A000a(LevelValue) |TH reads from the DUT the
_LevelValue_ attribute. |Verify that the DUT response contains an enum
between 0 and 4.
|===

[[_notestesting_considerations_253]]
====== link:#_notestesting_considerations_253[]Notes/Testing Considerations

[[_pm2_5_concentration_measurement_cluster_test_plan]]
== link:#_pm2_5_concentration_measurement_cluster_test_plan[]**PM2.5 Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for PMICONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_46]]
=== link:#_pics_definition_46[]158. PICS Definition

This section covers the PM2.5 Concentration Measurement Cluster Test
Plan related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_48]]
==== link:#_role_48[]158.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMICONC.S |Does the device implement the PM2.5 Concentration
Measurement cluster as a server? |O |

|PMICONC.C |Does the device implement the PM2.5 Concentration
Measurement cluster as a client? |O |
|===

[[_server_53]]
==== link:#_server_53[]158.2. Server

[[_features_32]]
===== link:#_features_32[]158.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMICONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|PMICONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|PMICONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|PMICONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|PMICONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|PMICONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_52]]
===== link:#_attributes_52[]158.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMICONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |PMICONC.S.F00(MEA) |

|PMICONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |PMICONC.S.F00(MEA) |

|PMICONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |PMICONC.S.F00(MEA) |

|PMICONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |PMICONC.S.F04(PEA) |

|PMICONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |PMICONC.S.F04(PEA) |

|PMICONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |PMICONC.S.F05(AVG) |

|PMICONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |PMICONC.S.F05(AVG) |

|PMICONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[PMICONC.S.F00(MEA)] |

|PMICONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |PMICONC.S.F00(MEA) |

|PMICONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|PMICONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |PMICONC.S.F01(LEV) |
|===

[[_test_case_list_48]]
=== link:#_test_case_list_48[]159. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-PMICONC-1.1 |Global Attributes with DUT as Server
|2 |TC-PMICONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_48]]
=== link:#_test_cases_48[]160. Test Cases

'''''

[[_generic_test_cases_42]]
==== link:#_generic_test_cases_42[]160.1. Generic test cases

'''''

[[_tc_pmiconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_pmiconc_1_1_global_attributes_with_dut_as_server[]160.1.1. [TC-PMICONC-1.1] Global attributes with DUT as Server

[[_category_314]]
====== link:#_category_314[]Category

Functional conformance.

[[_purpose_320]]
====== link:#_purpose_320[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_320]]
====== link:#_pics_320[]PICS

* PMICONC.S

[[_required_devices_320]]
====== link:#_required_devices_320[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_320]]
====== link:#_test_procedure_320[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if PMICONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if PMICONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if PMICONC.S.F02(MED) &
PMICONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if PMICONC.S.F03(CRI) &
PMICONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if PMICONC.S.F04(PEA) &
PMICONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if PMICONC.S.F05(AVG) &
PMICONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if PMICONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if PMICONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if PMICONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if PMICONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if PMICONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if PMICONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if PMICONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if PMICONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if PMICONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if PMICONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_254]]
====== link:#_notestesting_considerations_254[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_54]]
==== link:#_server_54[]160.2. Server

'''''

[[_tc_pmiconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_pmiconc_2_1_attributes_with_dut_as_server[]160.2.1. [TC-PMICONC-2.1] Attributes with DUT as Server

[[_category_315]]
====== link:#_category_315[]Category

Functional.

[[_purpose_321]]
====== link:#_purpose_321[]Purpose

This test case verifies the non-global attributes of the PM2.5
Concentration Measurement cluster server.

[[_pics_321]]
====== link:#_pics_321[]PICS

* PMICONC.S

[[_required_devices_321]]
====== link:#_required_devices_321[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_256]]
====== link:#_device_topology_256[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_277]]
====== link:#_test_setup_277[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_321]]
====== link:#_test_procedure_321[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |PMICONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |PMICONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |PMICONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |PMICONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |PMICONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |PMICONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |PMICONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |PMICONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |PMICONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |PMICONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_255]]
====== link:#_notestesting_considerations_255[]Notes/Testing Considerations

[[_formaldehyde_concentration_measurement_cluster_test_plan]]
== link:#_formaldehyde_concentration_measurement_cluster_test_plan[]**Formaldehyde Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for FLDCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_47]]
=== link:#_pics_definition_47[]161. PICS Definition

This section covers the Formaldehyde Concentration Measurement Cluster
Test Plan related PICS items that are referenced in the following test
cases. Support for an item is considered as "true" for conditional
statements within the test case steps.

[[_role_49]]
==== link:#_role_49[]161.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLDCONC.S |Does the device implement the Formaldehyde Concentration
Measurement cluster as a server? |O |

|FLDCONC.C |Does the device implement the Formaldehyde Concentration
Measurement cluster as a client? |O |
|===

[[_server_55]]
==== link:#_server_55[]161.2. Server

[[_features_33]]
===== link:#_features_33[]161.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLDCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|FLDCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|FLDCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|FLDCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|FLDCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|FLDCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_53]]
===== link:#_attributes_53[]161.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FLDCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |FLDCONC.S.F00(MEA) |

|FLDCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |FLDCONC.S.F00(MEA) |

|FLDCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |FLDCONC.S.F00(MEA) |

|FLDCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |FLDCONC.S.F04(PEA) |

|FLDCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |FLDCONC.S.F04(PEA) |

|FLDCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |FLDCONC.S.F05(AVG) |

|FLDCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |FLDCONC.S.F05(AVG) |

|FLDCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[FLDCONC.S.F00(MEA)] |

|FLDCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |FLDCONC.S.F00(MEA) |

|FLDCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|FLDCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |FLDCONC.S.F01(LEV) |
|===

[[_test_case_list_49]]
=== link:#_test_case_list_49[]162. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-FLDCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-FLDCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_49]]
=== link:#_test_cases_49[]163. Test Cases

'''''

[[_generic_test_cases_43]]
==== link:#_generic_test_cases_43[]163.1. Generic test cases

'''''

[[_tc_fldconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_fldconc_1_1_global_attributes_with_dut_as_server[]163.1.1. [TC-FLDCONC-1.1] Global attributes with DUT as Server

[[_category_316]]
====== link:#_category_316[]Category

Functional conformance.

[[_purpose_322]]
====== link:#_purpose_322[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_322]]
====== link:#_pics_322[]PICS

* FLDCONC.S

[[_required_devices_322]]
====== link:#_required_devices_322[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_322]]
====== link:#_test_procedure_322[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if FLDCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if FLDCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if FLDCONC.S.F02(MED) &
FLDCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if FLDCONC.S.F03(CRI) &
FLDCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if FLDCONC.S.F04(PEA) &
FLDCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if FLDCONC.S.F05(AVG) &
FLDCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if FLDCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if FLDCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if FLDCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if FLDCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if FLDCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if FLDCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if FLDCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if FLDCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if FLDCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if FLDCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_256]]
====== link:#_notestesting_considerations_256[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_56]]
==== link:#_server_56[]163.2. Server

'''''

[[_tc_fldconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_fldconc_2_1_attributes_with_dut_as_server[]163.2.1. [TC-FLDCONC-2.1] Attributes with DUT as Server

[[_category_317]]
====== link:#_category_317[]Category

Functional.

[[_purpose_323]]
====== link:#_purpose_323[]Purpose

This test case verifies the non-global attributes of the Formaldehyde
Concentration Measurement cluster server.

[[_pics_323]]
====== link:#_pics_323[]PICS

* FLDCONC.S

[[_required_devices_323]]
====== link:#_required_devices_323[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_257]]
====== link:#_device_topology_257[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_278]]
====== link:#_test_setup_278[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_323]]
====== link:#_test_procedure_323[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |FLDCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |FLDCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |FLDCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |FLDCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |FLDCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |FLDCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |FLDCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |FLDCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |FLDCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |FLDCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_257]]
====== link:#_notestesting_considerations_257[]Notes/Testing Considerations

[[_pm1_concentration_measurement_cluster_test_plan]]
== link:#_pm1_concentration_measurement_cluster_test_plan[]**PM1 Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for PMHCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_48]]
=== link:#_pics_definition_48[]164. PICS Definition

This section covers the PM1 Concentration Measurement Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_50]]
==== link:#_role_50[]164.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMHCONC.S |Does the device implement the PM1 Concentration Measurement
cluster as a server? |O |

|PMHCONC.C |Does the device implement the PM1 Concentration Measurement
cluster as a client? |O |
|===

[[_server_57]]
==== link:#_server_57[]164.2. Server

[[_features_34]]
===== link:#_features_34[]164.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMHCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|PMHCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|PMHCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|PMHCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|PMHCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|PMHCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_54]]
===== link:#_attributes_54[]164.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMHCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |PMHCONC.S.F00(MEA) |

|PMHCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |PMHCONC.S.F00(MEA) |

|PMHCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |PMHCONC.S.F00(MEA) |

|PMHCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |PMHCONC.S.F04(PEA) |

|PMHCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |PMHCONC.S.F04(PEA) |

|PMHCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |PMHCONC.S.F05(AVG) |

|PMHCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |PMHCONC.S.F05(AVG) |

|PMHCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[PMHCONC.S.F00(MEA)] |

|PMHCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |PMHCONC.S.F00(MEA) |

|PMHCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|PMHCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |PMHCONC.S.F01(LEV) |
|===

[[_test_case_list_50]]
=== link:#_test_case_list_50[]165. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-PMHCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-PMHCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_50]]
=== link:#_test_cases_50[]166. Test Cases

'''''

[[_generic_test_cases_44]]
==== link:#_generic_test_cases_44[]166.1. Generic test cases

'''''

[[_tc_pmhconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_pmhconc_1_1_global_attributes_with_dut_as_server[]166.1.1. [TC-PMHCONC-1.1] Global attributes with DUT as Server

[[_category_318]]
====== link:#_category_318[]Category

Functional conformance.

[[_purpose_324]]
====== link:#_purpose_324[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_324]]
====== link:#_pics_324[]PICS

* PMHCONC.S

[[_required_devices_324]]
====== link:#_required_devices_324[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_324]]
====== link:#_test_procedure_324[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if PMHCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if PMHCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if PMHCONC.S.F02(MED) &
PMHCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if PMHCONC.S.F03(CRI) &
PMHCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if PMHCONC.S.F04(PEA) &
PMHCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if PMHCONC.S.F05(AVG) &
PMHCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if PMHCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if PMHCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if PMHCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if PMHCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if PMHCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if PMHCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if PMHCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if PMHCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if PMHCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if PMHCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_258]]
====== link:#_notestesting_considerations_258[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_58]]
==== link:#_server_58[]166.2. Server

'''''

[[_tc_pmhconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_pmhconc_2_1_attributes_with_dut_as_server[]166.2.1. [TC-PMHCONC-2.1] Attributes with DUT as Server

[[_category_319]]
====== link:#_category_319[]Category

Functional.

[[_purpose_325]]
====== link:#_purpose_325[]Purpose

This test case verifies the non-global attributes of the PM1
Concentration Measurement cluster server.

[[_pics_325]]
====== link:#_pics_325[]PICS

* PMHCONC.S

[[_required_devices_325]]
====== link:#_required_devices_325[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_258]]
====== link:#_device_topology_258[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_279]]
====== link:#_test_setup_279[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_325]]
====== link:#_test_procedure_325[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |PMHCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |PMHCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |PMHCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |PMHCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |PMHCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |PMHCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |PMHCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |PMHCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |PMHCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |PMHCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_259]]
====== link:#_notestesting_considerations_259[]Notes/Testing Considerations

[[_pm10_concentration_measurement_cluster_test_plan]]
== link:#_pm10_concentration_measurement_cluster_test_plan[]**PM10 Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for PMKCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_49]]
=== link:#_pics_definition_49[]167. PICS Definition

This section covers the PM10 Concentration Measurement Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_51]]
==== link:#_role_51[]167.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMKCONC.S |Does the device implement the PM10 Concentration Measurement
cluster as a server? |O |

|PMKCONC.C |Does the device implement the PM10 Concentration Measurement
cluster as a client? |O |
|===

[[_server_59]]
==== link:#_server_59[]167.2. Server

[[_features_35]]
===== link:#_features_35[]167.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMKCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|PMKCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|PMKCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|PMKCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|PMKCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|PMKCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_55]]
===== link:#_attributes_55[]167.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PMKCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |PMKCONC.S.F00(MEA) |

|PMKCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |PMKCONC.S.F00(MEA) |

|PMKCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |PMKCONC.S.F00(MEA) |

|PMKCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |PMKCONC.S.F04(PEA) |

|PMKCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |PMKCONC.S.F04(PEA) |

|PMKCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |PMKCONC.S.F05(AVG) |

|PMKCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |PMKCONC.S.F05(AVG) |

|PMKCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[PMKCONC.S.F00(MEA)] |

|PMKCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |PMKCONC.S.F00(MEA) |

|PMKCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|PMKCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |PMKCONC.S.F01(LEV) |
|===

[[_test_case_list_51]]
=== link:#_test_case_list_51[]168. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-PMKCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-PMKCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_51]]
=== link:#_test_cases_51[]169. Test Cases

'''''

[[_generic_test_cases_45]]
==== link:#_generic_test_cases_45[]169.1. Generic test cases

'''''

[[_tc_pmkconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_pmkconc_1_1_global_attributes_with_dut_as_server[]169.1.1. [TC-PMKCONC-1.1] Global attributes with DUT as Server

[[_category_320]]
====== link:#_category_320[]Category

Functional conformance.

[[_purpose_326]]
====== link:#_purpose_326[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_326]]
====== link:#_pics_326[]PICS

* PMKCONC.S

[[_required_devices_326]]
====== link:#_required_devices_326[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_326]]
====== link:#_test_procedure_326[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if PMKCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if PMKCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if PMKCONC.S.F02(MED) &
PMKCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if PMKCONC.S.F03(CRI) &
PMKCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if PMKCONC.S.F04(PEA) &
PMKCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if PMKCONC.S.F05(AVG) &
PMKCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if PMKCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if PMKCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if PMKCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if PMKCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if PMKCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if PMKCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if PMKCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if PMKCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if PMKCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if PMKCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_260]]
====== link:#_notestesting_considerations_260[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_60]]
==== link:#_server_60[]169.2. Server

'''''

[[_tc_pmkconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_pmkconc_2_1_attributes_with_dut_as_server[]169.2.1. [TC-PMKCONC-2.1] Attributes with DUT as Server

[[_category_321]]
====== link:#_category_321[]Category

Functional.

[[_purpose_327]]
====== link:#_purpose_327[]Purpose

This test case verifies the non-global attributes of the PM10
Concentration Measurement cluster server.

[[_pics_327]]
====== link:#_pics_327[]PICS

* PMKCONC.S

[[_required_devices_327]]
====== link:#_required_devices_327[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_259]]
====== link:#_device_topology_259[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_280]]
====== link:#_test_setup_280[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_327]]
====== link:#_test_procedure_327[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |PMKCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |PMKCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |PMKCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |PMKCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |PMKCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |PMKCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |PMKCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |PMKCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |PMKCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |PMKCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_261]]
====== link:#_notestesting_considerations_261[]Notes/Testing Considerations

[[_total_volatile_organic_compounds_concentration_measurement_cluster_test_plan]]
== link:#_total_volatile_organic_compounds_concentration_measurement_cluster_test_plan[]**Total Volatile Organic Compounds Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for TVOCCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_50]]
=== link:#_pics_definition_50[]170. PICS Definition

This section covers the Total Volatile Organic Compounds Concentration
Measurement Cluster Test Plan related PICS items that are referenced in
the following test cases. Support for an item is considered as "true"
for conditional statements within the test case steps.

[[_role_52]]
==== link:#_role_52[]170.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TVOCCONC.S |Does the device implement the Total Volatile Organic
Compounds Concentration Measurement cluster as a server? |O |

|TVOCCONC.C |Does the device implement the Total Volatile Organic
Compounds Concentration Measurement cluster as a client? |O |
|===

[[_server_61]]
==== link:#_server_61[]170.2. Server

[[_features_36]]
===== link:#_features_36[]170.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TVOCCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|TVOCCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|TVOCCONC.S.F02(MED) |Does the device implement the Medium Level
feature? |[LEV] |

|TVOCCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|TVOCCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|TVOCCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_56]]
===== link:#_attributes_56[]170.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TVOCCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |TVOCCONC.S.F00(MEA) |

|TVOCCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |TVOCCONC.S.F00(MEA) |

|TVOCCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |TVOCCONC.S.F00(MEA) |

|TVOCCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |TVOCCONC.S.F04(PEA) |

|TVOCCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement
the _PeakMeasuredValueWindow_ attribute? |TVOCCONC.S.F04(PEA) |

|TVOCCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |TVOCCONC.S.F05(AVG) |

|TVOCCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |TVOCCONC.S.F05(AVG) |

|TVOCCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[TVOCCONC.S.F00(MEA)] |

|TVOCCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |TVOCCONC.S.F00(MEA) |

|TVOCCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|TVOCCONC.S.A000a(LevelValue) |Does the device implement the
_LevelValue_ attribute? |TVOCCONC.S.F01(LEV) |
|===

[[_test_case_list_52]]
=== link:#_test_case_list_52[]171. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-TVOCCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-TVOCCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_52]]
=== link:#_test_cases_52[]172. Test Cases

'''''

[[_generic_test_cases_46]]
==== link:#_generic_test_cases_46[]172.1. Generic test cases

'''''

[[_tc_tvocconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_tvocconc_1_1_global_attributes_with_dut_as_server[]172.1.1. [TC-TVOCCONC-1.1] Global attributes with DUT as Server

[[_category_322]]
====== link:#_category_322[]Category

Functional conformance.

[[_purpose_328]]
====== link:#_purpose_328[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_328]]
====== link:#_pics_328[]PICS

* TVOCCONC.S

[[_required_devices_328]]
====== link:#_required_devices_328[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_328]]
====== link:#_test_procedure_328[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if TVOCCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if TVOCCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if TVOCCONC.S.F02(MED) &
TVOCCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if TVOCCONC.S.F03(CRI) &
TVOCCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if TVOCCONC.S.F04(PEA) &
TVOCCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if TVOCCONC.S.F05(AVG) &
TVOCCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if TVOCCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if TVOCCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if TVOCCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if TVOCCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if TVOCCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if TVOCCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if TVOCCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if TVOCCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if TVOCCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if TVOCCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_262]]
====== link:#_notestesting_considerations_262[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_62]]
==== link:#_server_62[]172.2. Server

'''''

[[_tc_tvocconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_tvocconc_2_1_attributes_with_dut_as_server[]172.2.1. [TC-TVOCCONC-2.1] Attributes with DUT as Server

[[_category_323]]
====== link:#_category_323[]Category

Functional.

[[_purpose_329]]
====== link:#_purpose_329[]Purpose

This test case verifies the non-global attributes of the Total Volatile
Organic Compounds Concentration Measurement cluster server.

[[_pics_329]]
====== link:#_pics_329[]PICS

* TVOCCONC.S

[[_required_devices_329]]
====== link:#_required_devices_329[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_260]]
====== link:#_device_topology_260[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_281]]
====== link:#_test_setup_281[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_329]]
====== link:#_test_procedure_329[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |TVOCCONC.S.A0001(MinMeasuredValue) |TH reads from the
DUT the _MinMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later.

|3 |AC.2.10.6.3 |TVOCCONC.S.A0002(MaxMeasuredValue) |TH reads from the
DUT the _MaxMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Save this value
for later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |TVOCCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |TVOCCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |TVOCCONC.S.A0004(PeakMeasuredValueWindow) |TH reads
from the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the
DUT response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |TVOCCONC.S.A0005(AverageMeasuredValue) |TH reads from
the DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT
response contains single-precision floating-point number or null. Verify
that MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |TVOCCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |TVOCCONC.S.A0008(MeasurementUnit) |TH reads from the
DUT the _MeasurementUnit_ attribute. |Verify that the DUT response
contains an enum between 0 and 7.

|10 |AC.2.10.6.10 |TVOCCONC.S.A0009(MeasurementMedium) |TH reads from
the DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |TVOCCONC.S.A000a(LevelValue) |TH reads from the DUT
the _LevelValue_ attribute. |Verify that the DUT response contains an
enum between 0 and 4.
|===

[[_notestesting_considerations_263]]
====== link:#_notestesting_considerations_263[]Notes/Testing Considerations

[[_radon_concentration_measurement_cluster_test_plan]]
== link:#_radon_concentration_measurement_cluster_test_plan[]**Radon Concentration Measurement Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |15-May-2023 |`William Hicklin` |Initial Test Plan for RNCONC

|0.1.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_51]]
=== link:#_pics_definition_51[]173. PICS Definition

This section covers the Radon Concentration Measurement Cluster Test
Plan related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_53]]
==== link:#_role_53[]173.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RNCONC.S |Does the device implement the Radon Concentration Measurement
cluster as a server? |O |

|RNCONC.C |Does the device implement the Radon Concentration Measurement
cluster as a client? |O |
|===

[[_server_63]]
==== link:#_server_63[]173.2. Server

[[_features_37]]
===== link:#_features_37[]173.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RNCONC.S.F00(MEA) |Does the device implement the Numeric Measurement
feature? |O.a+ |at least one of `a` is True

|RNCONC.S.F01(LEV) |Does the device implement the Level Indication
feature? |O.a+ |at least one of `a` is True

|RNCONC.S.F02(MED) |Does the device implement the Medium Level feature?
|[LEV] |

|RNCONC.S.F03(CRI) |Does the device implement the Critical Level
feature? |[LEV] |

|RNCONC.S.F04(PEA) |Does the device implement the Peak Measurement
feature? |[MEA] |

|RNCONC.S.F05(AVG) |Does the device implement the Average Measurement
feature? |[MEA] |
|===

[[_attributes_57]]
===== link:#_attributes_57[]173.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RNCONC.S.A0000(MeasuredValue) |Does the device implement the
_MeasuredValue_ attribute? |RNCONC.S.F00(MEA) |

|RNCONC.S.A0001(MinMeasuredValue) |Does the device implement the
_MinMeasuredValue_ attribute? |RNCONC.S.F00(MEA) |

|RNCONC.S.A0002(MaxMeasuredValue) |Does the device implement the
_MaxMeasuredValue_ attribute? |RNCONC.S.F00(MEA) |

|RNCONC.S.A0003(PeakMeasuredValue) |Does the device implement the
_PeakMeasuredValue_ attribute? |RNCONC.S.F04(PEA) |

|RNCONC.S.A0004(PeakMeasuredValueWindow) |Does the device implement the
_PeakMeasuredValueWindow_ attribute? |RNCONC.S.F04(PEA) |

|RNCONC.S.A0005(AverageMeasuredValue) |Does the device implement the
_AverageMeasuredValue_ attribute? |RNCONC.S.F05(AVG) |

|RNCONC.S.A0006(AverageMeasuredValueWindow) |Does the device implement
the _AverageMeasuredValueWindow_ attribute? |RNCONC.S.F05(AVG) |

|RNCONC.S.A0007(Uncertainty) |Does the device implement the
_Uncertainty_ attribute? |[RNCONC.S.F00(MEA)] |

|RNCONC.S.A0008(MeasurementUnit) |Does the device implement the
_MeasurementUnit_ attribute? |RNCONC.S.F00(MEA) |

|RNCONC.S.A0009(MeasurementMedium) |Does the device implement the
_MeasurementMedium_ attribute? |M |

|RNCONC.S.A000a(LevelValue) |Does the device implement the _LevelValue_
attribute? |RNCONC.S.F01(LEV) |
|===

[[_test_case_list_53]]
=== link:#_test_case_list_53[]174. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-RNCONC-1.1 |Global Attributes with DUT as Server
|2 |TC-RNCONC-2.1 |Attributes with DUT as Server
|===

[[_test_cases_53]]
=== link:#_test_cases_53[]175. Test Cases

'''''

[[_generic_test_cases_47]]
==== link:#_generic_test_cases_47[]175.1. Generic test cases

'''''

[[_tc_rnconc_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_rnconc_1_1_global_attributes_with_dut_as_server[]175.1.1. [TC-RNCONC-1.1] Global attributes with DUT as Server

[[_category_324]]
====== link:#_category_324[]Category

Functional conformance.

[[_purpose_330]]
====== link:#_purpose_330[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_330]]
====== link:#_pics_330[]PICS

* RNCONC.S

[[_required_devices_330]]
====== link:#_required_devices_330[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_330]]
====== link:#_test_procedure_330[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 3.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set: +
- bit 0: SHALL be 1 if and only if RNCONC.S.F00(MEA) +
- bit 1: SHALL be 1 if and only if RNCONC.S.F01(LEV) +
- bit 2: SHALL be 1 if and only if RNCONC.S.F02(MED) &
RNCONC.S.F01(LEV) +
- bit 3: SHALL be 1 if and only if RNCONC.S.F03(CRI) &
RNCONC.S.F01(LEV) +
- bit 4: SHALL be 1 if and only if RNCONC.S.F04(PEA) &
RNCONC.S.F00(MEA) +
- bit 5: SHALL be 1 if and only if RNCONC.S.F05(AVG) & RNCONC.S.F00(MEA)

At least one of bit 0 and bit 1 SHALL be 1.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0009, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0007: MAY be included if and only if RNCONC.S.F00(MEA)

The list include entries based on feature support: +
- 0x0000 SHALL be included if RNCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0001 SHALL be included if RNCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0002 SHALL be included if RNCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x0003 SHALL be included if RNCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0004 SHALL be included if RNCONC.S.F04(PEA) and SHALL NOT be
included otherwise. +
- 0x0005 SHALL be included if RNCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0006 SHALL be included if RNCONC.S.F05(AVG) and SHALL NOT be
included otherwise. +
- 0x0007 SHALL be included if \{PICS_SF_CLUSTER_FEATURE} and SHALL NOT
be included otherwise. +
- 0x0008 SHALL be included if RNCONC.S.F00(MEA) and SHALL NOT be
included otherwise. +
- 0x000a SHALL be included if RNCONC.S.F01(LEV) and SHALL NOT be
included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_264]]
====== link:#_notestesting_considerations_264[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_64]]
==== link:#_server_64[]175.2. Server

'''''

[[_tc_rnconc_2_1_attributes_with_dut_as_server]]
===== link:#_tc_rnconc_2_1_attributes_with_dut_as_server[]175.2.1. [TC-RNCONC-2.1] Attributes with DUT as Server

[[_category_325]]
====== link:#_category_325[]Category

Functional.

[[_purpose_331]]
====== link:#_purpose_331[]Purpose

This test case verifies the non-global attributes of the Radon
Concentration Measurement cluster server.

[[_pics_331]]
====== link:#_pics_331[]PICS

* RNCONC.S

[[_required_devices_331]]
====== link:#_required_devices_331[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_261]]
====== link:#_device_topology_261[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_282]]
====== link:#_test_setup_282[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_331]]
====== link:#_test_procedure_331[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.10.6.2 |RNCONC.S.A0001(MinMeasuredValue) |TH reads from the DUT
the _MinMeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Save this value for
later.

|3 |AC.2.10.6.3 |RNCONC.S.A0002(MaxMeasuredValue) |TH reads from the DUT
the _MaxMeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Save this value for
later. Verify that MaxMeasuredValue > MinMeasuredValue.

|4 |AC.2.10.6.1 |RNCONC.S.A0000(MeasuredValue) |TH reads from the DUT
the _MeasuredValue_ attribute. |Verify that the DUT response contains
single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ MeasuredValue and MeasuredValue ≤ MaxMeasuredValue
unless any of the values being compared are null.

|5 |AC.2.10.6.4 |RNCONC.S.A0003(PeakMeasuredValue) |TH reads from the
DUT the _PeakMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ PeakMeasuredValue and PeakMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|6 |AC.2.10.6.5 |RNCONC.S.A0004(PeakMeasuredValueWindow) |TH reads from
the DUT the _PeakMeasuredValueWindow_ attribute. |Verify that the DUT
response contains an integer number less that or equal to 604800.

|7 |AC.2.10.6.6 |RNCONC.S.A0005(AverageMeasuredValue) |TH reads from the
DUT the _AverageMeasuredValue_ attribute. |Verify that the DUT response
contains single-precision floating-point number or null. Verify that
MinMeasuredValue ≤ AverageMeasuredValue and AverageMeasuredValue ≤
MaxMeasuredValue unless any of the values being compared are null.

|8 |AC.2.10.6.7 |RNCONC.S.A0006(AverageMeasuredValueWindow) |TH reads
from the DUT the _AverageMeasuredValueWindow_ attribute. |Verify that
the DUT response contains an integer number less that or equal to
604800.

|9 |AC.2.10.6.9 |RNCONC.S.A0008(MeasurementUnit) |TH reads from the DUT
the _MeasurementUnit_ attribute. |Verify that the DUT response contains
an enum between 0 and 7.

|10 |AC.2.10.6.10 |RNCONC.S.A0009(MeasurementMedium) |TH reads from the
DUT the _MeasurementMedium_ attribute. |Verify that the DUT response
contains an enum between 0 and 2.

|11 |AC.2.10.6.11 |RNCONC.S.A000a(LevelValue) |TH reads from the DUT the
_LevelValue_ attribute. |Verify that the DUT response contains an enum
between 0 and 4.
|===

[[_notestesting_considerations_265]]
====== link:#_notestesting_considerations_265[]Notes/Testing Considerations

[[_temperature_control_cluster_test_plan]]
== link:#_temperature_control_cluster_test_plan[]**Temperature Control Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |4-May-2023 |`Austin Beck` |Initial Document upload to github

|0.2 |2-Jun-2023 |`Rob Bultman` |Adds step feature, general cleanup per
template

|0.3 |3-Jul-2023 |`Suma KY` |Updated TC-1.1 to new format. Fix for 2947

|0.4 |12-Jul-2023 |`Rob Bultman` |Fix attribute name

|0.5 |19-Jul-2023 |`Rob Bultman` |Account for failed SetTemperature
command

|0.6 |27-Jul-2023 |`Rob Bultman` |Account for INVALID_IN_MODE responses

|0.7 |10-Aug-2023 |`Rob Bultman` |Improve tests for temperature number

|0.7.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_52]]
=== link:#_pics_definition_52[]176. PICS Definition

This section covers the Temperature Control Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_54]]
==== link:#_role_54[]176.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCTL.S |Does the device implement the TemperatureControl cluster as a
server? |O |

|TCTL.C |Does the device implement the TemperatureControl cluster as a
client? |O |
|===

[[_server_65]]
==== link:#_server_65[]176.2. Server

[[_features_38]]
===== link:#_features_38[]176.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCTL.S.F00(TN) |Does the device support temperature number feature |O |

|TCTL.S.F01(TL) |Does the device support temperature level feature |O |

|TCTL.S.F02(A_STEP) |Does the device support step feature
|[TCTL.S.F00(TN)] |
|===

[[_attributes_58]]
===== link:#_attributes_58[]176.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCTL.S.A0000(TemperatureSetpoint) |Does the device implement the
_TemperatureSetpoint_ attribute? |TCTL.S.F00(TN) |

|TCTL.S.A0001(MinTemperature) |Does the device implement the
_MinTemperature_ attribute? |TCTL.S.F00(TN) |

|TCTL.S.A0002(MaxTemperature) |Does the device implement the
_MaxTemperature_ attribute? |TCTL.S.F00(TN) |

|TCTL.S.A0003(Step) |Does the device implement the _Step_ attribute?
|[TCTL.S.F00(TN)] |

|TCTL.S.A0004(SelectedTemperatureLevel) |Does the device implement the
_SelectedTemperatureLevel_ attribute? |TCTL.S.F01(TL) |

|TCTL.S.A0005(SupportedTemperatureLevels) |Does the device implement the
_SupportedTemperatureLevels_ attribute? |TCTL.S.F01(TL) |
|===

[[_manual_controllable_18]]
===== link:#_manual_controllable_18[]176.2.3. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCTL.S.M.SupportsInvalidInMode |Does the device support the
INVALID_IN_MODE response |O |
|===

[[_commands_received_27]]
===== link:#_commands_received_27[]176.2.4. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCTL.S.C00.Rsp(SetTemperatureCommand) |Does the device implement
receiving the _SetTemperatureCommand_ command?
|TCTL.S.C00.Rsp(SetTemperatureCommand) |
|===

[[_test_case_list_54]]
=== link:#_test_case_list_54[]177. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|TC-TCTL-1.1 |Global attributes with DUT as Server

|TC-TCTL-2.1 |Attributes with with DUT as Server

|TC-TCTL-2.2 |Optional temperature number attributes with DUT as Server

|TC-TCTL-2.3 |Optional temperature level attributes with DUT as Server

|TC-TCTL-3.2 |Optional temperature number functionality with DUT as
Server

|TC-TCTL-3.3 |Optional temperature level functionality with DUT as
Server
|===

[[_test_cases_54]]
=== link:#_test_cases_54[]178. Test Cases

'''''

[[_generic_test_cases_48]]
==== link:#_generic_test_cases_48[]178.1. Generic test cases

'''''

[[_tc_tctl_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_tctl_1_1_global_attributes_with_dut_as_server[]178.1.1. [TC-TCTL-1.1] Global attributes with DUT as Server

[[_category_326]]
====== link:#_category_326[]Category

Functional conformance

[[_purpose_332]]
====== link:#_purpose_332[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_332]]
====== link:#_pics_332[]PICS

* TCTL.S

[[_required_devices_332]]
====== link:#_required_devices_332[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_332]]
====== link:#_test_procedure_332[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute
|Verify that the DUT response contains the _ClusterRevision_ attribute
with the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if TCTL.S.F00(TN) & !TCTL.S.F01(TL)

- bit 1: SHALL be 1 if and only if TCTL.S.F01(TL) & !TCTL.S.F00(TN)

- bit 2: SHALL be 1 if and only if TCTL.S.F02(A_STEP) & TCTL.S.F00(TN)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list include entries based on feature support: +
- 0x0000: SHALL be included if and only if TCTL.S.F00(TN)

- 0x0001: SHALL be included if and only if TCTL.S.F00(TN)

- 0x0002: SHALL be included if and only if TCTL.S.F00(TN)

- 0x0003: SHALL be included if and only if TCTL.S.F02(A_STEP)

- 0x0004: SHALL be included if and only if TCTL.S.F01(TL)

- 0x0005: SHALL be included if and only if TCTL.S.F01(TL)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
- 0x0000

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_266]]
====== link:#_notestesting_considerations_266[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_25]]
==== link:#_server_as_dut_25[]178.2. Server as DUT

'''''

[[_tc_tctl_2_1_attributes_with_dut_as_server]]
===== link:#_tc_tctl_2_1_attributes_with_dut_as_server[]178.2.1. [TC-TCTL-2.1] Attributes with DUT as Server

[[_category_327]]
====== link:#_category_327[]Category

Functional conformance

[[_purpose_333]]
====== link:#_purpose_333[]Purpose

This test case verifies that the DUT can respond to TemperatureControl
cluster attribute read commands. This test case is only required if the
A_STEP and TN features are supported (TCTL.S.F02(A_STEP) and
TCTL.S.F00(TN)).

[[_pics_333]]
====== link:#_pics_333[]PICS

* TCTL.S
* TCTL.S.F02(A_STEP)
* TCTL.S.F00(TN)

[[_required_devices_333]]
====== link:#_required_devices_333[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_262]]
====== link:#_device_topology_262[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_283]]
====== link:#_test_setup_283[]Test Setup

Commission DUT to TH

[[_test_procedure_333]]
====== link:#_test_procedure_333[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |TCTL.S.A0001(MinTemperature) |TH reads from the DUT the
_MinTemperature_ attribute |Save value to minTemperature

|3 | |TCTL.S.A0002(MaxTemperature) |TH reads from the DUT the
_MaxTemperature_ attribute |Save value to maxTemperature

|4 | |TCTL.S.A0003(Step) |TH reads from the DUT the _Step_ attribute
|Verify that the DUT response contains a temperature value <=
maxTemperature - minTemperature +
and (maxTemperature - minTemperature) % the received value of the _Step_
attribute == 0.

|5 | |TCTL.S.A0000(TemperatureSetpoint) |TH reads from the DUT the
_TemperatureSetpoint_ attribute |Verify that the DUT response contains a
temperature with value between minTemperature and maxTemperature
inclusive and (temperature value - minTemperature) % the received value
of the _Step_ attribute from step 4 == 0.
|===

[[_tc_tctl_2_2_optional_temperature_number_attributes_with_dut_as_server]]
===== link:#_tc_tctl_2_2_optional_temperature_number_attributes_with_dut_as_server[]178.2.2. [TC-TCTL-2.2] Optional Temperature number attributes with DUT as Server

[[_category_328]]
====== link:#_category_328[]Category

Functional conformance

[[_purpose_334]]
====== link:#_purpose_334[]Purpose

This test case verifies that the DUT can respond to TemperatureControl
cluster attribute read commands. This test case is only required if the
TN feature is supported (TCTL.S.F00(TN)). ===== PICS

* TCTL.S
* TCTL.S.F00(TN)

[[_required_devices_334]]
====== link:#_required_devices_334[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_263]]
====== link:#_device_topology_263[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_284]]
====== link:#_test_setup_284[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_334]]
====== link:#_test_procedure_334[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |TCTL.S.A0001(MinTemperature) |TH reads from the DUT the
_MinTemperature_ attribute |Save value to minTemperature

|3 | |TCTL.S.A0002(MaxTemperature) |TH reads from the DUT the
_MaxTemperature_ attribute |Save value to maxTemperature. +
Verify that the DUT response contains a temperature with value greater
than minTemperature.

|4 | |TCTL.S.A0000(TemperatureSetpoint) |TH reads from the DUT the
_TemperatureSetpoint_ attribute |Verify that the DUT response contains a
temperature with value between minTemperature and maxTemperature
inclusive.
|===

[[_tc_tctl_2_3_optional_temperature_level_attributes_with_dut_as_server]]
===== link:#_tc_tctl_2_3_optional_temperature_level_attributes_with_dut_as_server[]178.2.3. [TC-TCTL-2.3] Optional temperature level attributes with DUT as Server

[[_category_329]]
====== link:#_category_329[]Category

Functional conformance

[[_purpose_335]]
====== link:#_purpose_335[]Purpose

This test case verifies that the DUT can respond to TemperatureControl
cluster attribute read commands. This test case is only required if the
TL feature is supported (TCTL.S.F01(TL)).

[[_pics_334]]
====== link:#_pics_334[]PICS

* TCTL.S
* TCTL.S.F01(TL)

[[_required_devices_335]]
====== link:#_required_devices_335[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_264]]
====== link:#_device_topology_264[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_285]]
====== link:#_test_setup_285[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_335]]
====== link:#_test_procedure_335[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |TCTL.S.A0004(SelectedTemperatureLevel) |TH reads from the DUT the
_SelectedTemperatureLevel_ attribute |Verify that the DUT response
contains a uint8 with value between 0 and 31 inclusive.

|3 | |TCTL.S.A0005(SupportedTemperatureLevels) |TH reads from the DUT
the _SupportedTemperatureLevels_ attribute |Verify that the DUT response
contains a list of up to 32 strings with each string length not
exceeding 16 characters.
|===

[[_tc_tctl_3_2_optional_temperature_number_functionality_with_dut_as_server]]
===== link:#_tc_tctl_3_2_optional_temperature_number_functionality_with_dut_as_server[]178.2.4. [TC-TCTL-3.2] Optional temperature number functionality with DUT as Server

[[_category_330]]
====== link:#_category_330[]Category

Functional

[[_purpose_336]]
====== link:#_purpose_336[]Purpose

This test case verifies the optional functionality of the
TemperatureControl cluster server. This test case is only required if
the TN feature is supported (TCTL.S.F00(TN)).

[[_pics_335]]
====== link:#_pics_335[]PICS

* TCTL.S
* TCTL.S.F00(TN)

[[_required_devices_336]]
====== link:#_required_devices_336[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_265]]
====== link:#_device_topology_265[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_286]]
====== link:#_test_setup_286[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_336]]
====== link:#_test_procedure_336[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | | |Operate device such that a temperature number can be accepted |

|3 | |TCTL.S.A0001(MinTemperature) |TH reads from the DUT the
_MinTemperature_ attribute |Save response as minTemp

|4 | |TCTL.S.A0002(MaxTemperature) |TH reads from the DUT the
_MaxTemperature_ attribute |Save response as maxTemp

|5 | |TCTL.S.C00.Rsp(SetTemperatureCommand) |TH sends command
_SetTemperatureCommand_ with a temperature number between minTemp and
maxTemp inclusive, saved as setTemp. |Verify that the DUT response
contains SUCCESS

|6 | |TCTL.S.A0000(TemperatureSetpoint) |After a few seconds, TH reads
from the DUT the _TemperatureSetpoint_ attribute. |Value is the same
setTemp value written in step 5

|7 | |TCTL.S.C00.Rsp(SetTemperatureCommand) |TH sends command
_SetTemperatureCommand_ with an invalid value. |Verify DUT responds w/
status CONSTRAINT_ERROR(0x87)

|8 | |TCTL.S.A0000(TemperatureSetpoint) |After a few seconds, TH reads
from the DUT the _TemperatureSetpoint_ attribute. |Value is the same
setTemp value written in step 5

|9 | |TCTL.S.M.SupportsInvalidInMode |Operate device such that a
temperature number cannot be accepted |

|10 | |TCTL.S.M.SupportsInvalidInMode&
TCTL.S.C00.Rsp(SetTemperatureCommand) |TH sends command
_SetTemperatureCommand_ with a temperature number between minTemp and
maxTemp inclusive that is different from setTemp. |Verify that the DUT
response contains INVALID_IN_MODE

|11 | |TCTL.S.M.SupportsInvalidInMode& TCTL.S.A0000(TemperatureSetpoint)
|after a few seconds, TH reads from the DUT the _TemperatureSetpoint_
attribute. |Value is the same setTemp value written in step 5
|===

[[_tc_tctl_3_3_optional_temperature_level_functionality_with_dut_as_server]]
===== link:#_tc_tctl_3_3_optional_temperature_level_functionality_with_dut_as_server[]178.2.5. [TC-TCTL-3.3] Optional temperature level functionality with DUT as Server

[[_category_331]]
====== link:#_category_331[]Category

Functional

[[_purpose_337]]
====== link:#_purpose_337[]Purpose

This test case verifies the optional functionality of the
TemperatureControl cluster server. This test case is only required if
the TL feature is supported (TCTL.S.F01(TL)).

[[_pics_336]]
====== link:#_pics_336[]PICS

* TCTL.S
* TCTL.S.F01(TL)

[[_required_devices_337]]
====== link:#_required_devices_337[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_266]]
====== link:#_device_topology_266[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_287]]
====== link:#_test_setup_287[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_337]]
====== link:#_test_procedure_337[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | | |Operate device such that a temperature level can be accepted |

|3 | |TCTL.S.A0005(SupportedTemperatureLevels) |TH reads from the DUT
the _SupportedTemperatureLevels_ attribute |Save result list as
supportedLevels

|4 | |TCTL.S.C00.Rsp(SetTemperatureCommand) |TH sends command
_SetTemperatureCommand_ with a value from supportedLevels saved as
setLevel |Verify that the DUT response contains SUCCESS

|5 | |TCTL.S.A0004(SelectedTemperatureLevel) |After a few seconds, TH
reads from the DUT the _SelectedTemperatureLevel_ attribute |Value is
the same setLevel written in step 4

|6 | |TCTL.S.M.SupportsInvalidInMode |Operate device such that a
temperature level cannot be accepted |

|7 | |TCTL.S.M.SupportsInvalidInMode&
TCTL.S.C00.Rsp(SetTemperatureCommand) |TH sends command
_SetTemperatureCommand_ with a value from supportedLevels that is
different from setLevel |Verify that the DUT response contains
CONSTRAINT_ERROR

|8 | |TCTL.S.M.SupportsInvalidInMode&
TCTL.S.A0004(SelectedTemperatureLevel) |after a few seconds, TH reads
from the DUT the _SelectedTemperatureLevel_ attribute |Value is the same
setLevel written in step 4
|===

[[_laundry_washer_mode_cluster_test_plan]]
== link:#_laundry_washer_mode_cluster_test_plan[]**Laundry Washer Mode Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|1.0 |10-May-2023 |`Austin Beck` |Initial test plan
|2.0 |14-Jul-2023 |`Rob Bultman` |Fix test names
|===

[[_laundry_washer_mode_cluster_testing_overview]]
=== link:#_laundry_washer_mode_cluster_testing_overview[]179. Laundry Washer Mode Cluster Testing Overview

The Laundry Washer Mode cluster is derived from the Mode Base cluster.
This document describes the tests specific to this derived cluster.

[[_pics_definition_53]]
=== link:#_pics_definition_53[]180. PICS Definition

This section covers the Laundry Washer Mode Cluster related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_55]]
==== link:#_role_55[]180.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LWM.S |Does the device implement the LWM cluster as a server? |O |
|===

[[_server_66]]
==== link:#_server_66[]180.2. Server

[[_features_39]]
===== link:#_features_39[]180.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LWM.S.F00(DEPONOFF) |Does the device support depending on an On/Off
cluster implemented on the same endpoint? |O |
|===

[[_attributes_59]]
===== link:#_attributes_59[]180.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LWM.S.A0000(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |M |

|LWM.S.A0001(CurrentMode) |Does the device implement the _CurrentMode_
attribute? |M |

|LWM.S.A0002(StartUpMode) |Does the device implement the _StartUpMode_
attribute? |O |

|LWM.S.A0003(OnMode) |Does the device implement the _OnMode_ attribute?
|DEPONOFF |
|===

[[_commands_received_28]]
===== link:#_commands_received_28[]180.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LWM.S.C00.Rsp(ChangeToMode) |Does the device implement receiving the
_ChangeToMode_ command? |M |
|===

[[_commands_generated_29]]
===== link:#_commands_generated_29[]180.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LWM.S.C01.Tx(ChangeToModeResponse) |Does the device implement sending
the _ChangeToModeResponse_ command? |M |
|===

[[_manual_controllable_19]]
===== link:#_manual_controllable_19[]180.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|LWM.S.M.CAN_TEST_MODE_FAILURE |Does the DUT support testing the failed
_ChangeToMode_ command? |O |Declared by manufacturer
|===

[[_pixit_definition_12]]
=== link:#_pixit_definition_12[]181. PIXIT Definition

This section covers the Laundry Washer Mode Test Plan related PIXIT
items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.LWM.MODE_CHANGE_FAIL |Id of mode the device will fail to
transition to, given its current state |O |

|PIXIT.LWM.MODE_CHANGE_OK |Id of mode the device will successfully
transition to, given its current state |O |
|===

[[_test_case_list_55]]
=== link:#_test_case_list_55[]182. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|[TC-LWM-1.1] |Global attributes with DUT as Server
|[TC-LWM-1.2] |Cluster attributes with DUT as Server
|[TC-LWM-2.1] |Change to Mode functionality with DUT as Server
|[TC-LWM-3.1] |On Mode functionality with DUT as Server
|[TC-LWM-3.2] |Startup Mode functionality with DUT as Server
|[TC-LWM-3.3] |On Mode and Startup Mode functionality with DUT as Server
|===

[[_test_cases_55]]
=== link:#_test_cases_55[]183. Test Cases

'''''

[[_attribute_test_cases_2]]
==== link:#_attribute_test_cases_2[]183.1. Attribute test cases

'''''

[[_tc_lwm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_lwm_1_1_global_attributes_with_dut_as_server[]183.1.1. [TC-LWM-1.1] Global attributes with DUT as Server

[[_category_332]]
====== link:#_category_332[]Category

Functional conformance

[[_purpose_338]]
====== link:#_purpose_338[]Purpose

This test case verifies the cluster server global attributes.

[[_pics_337]]
====== link:#_pics_337[]PICS

* LWM.S

[[_required_devices_338]]
====== link:#_required_devices_338[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_267]]
====== link:#_device_topology_267[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_288]]
====== link:#_test_setup_288[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_338]]
====== link:#_test_procedure_338[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

* bit 0: SHALL be 1 if and only if LWM.S.F00(DEPONOFF)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if LWM.S.A0002(StartUpMode)

The list include entries based on feature support: +

* 0x0003 SHALL be included if and only if LWM.S.F00(DEPONOFF)

and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute with a
list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +

0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +

0x01

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_267]]
====== link:#_notestesting_considerations_267[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_tc_lwm_1_2_cluster_attributes_with_dut_as_server]]
===== link:#_tc_lwm_1_2_cluster_attributes_with_dut_as_server[]183.1.2. [TC-LWM-1.2] Cluster attributes with DUT as Server

[[_category_333]]
====== link:#_category_333[]Category

Functional.

[[_purpose_339]]
====== link:#_purpose_339[]Purpose

This test case verifies the non-global attributes of the Laundry Washer
Mode cluster server.

[[_pics_338]]
====== link:#_pics_338[]PICS

* LWM.S

[[_required_devices_339]]
====== link:#_required_devices_339[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_268]]
====== link:#_device_topology_268[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_289]]
====== link:#_test_setup_289[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_339]]
====== link:#_test_procedure_339[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8, AC.8.6.5 |LWM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has at least 2 and at most 255 entries
* Verify that each ModeOptionsStruct entry has a unique Mode field value
* Verify that each ModeOptionsStruct entry has a unique Label field
value
* Verify that each ModeOptionsStruct entry’s ModeTags field, if not
empty, has:
+
** the values of the Value fields that are not larger than 16 bits
** for each Value field: Is the mode tag value a defined common tag
value ( Auto(0x0000), Quick(0x0001), Quiet(0x0002), LowNoise(0x0003),
LowEnergy(0x0004), Vacation(0x0005), Min(0x0006), Max(0x0007),
Night(0x0008), Day(0x0009)) or a defined cluster derived tag value (
Normal, Delicate, Heavy, Whites) or in the MfgTags (0x8000 to 0xBFFF)
range
** if the Value field is in the MfgTags (0x8000 to 0xBFFF) range, the
TagName field is a string with a length between 1 and 64
* Verify that at least one ModeOptionsStruct entry includes the Normal
mode tag
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut`

|4 |AC.1.9.6.4 |LWM.S.A0003(OnMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|5 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|===

[[_notestesting_considerations_268]]
====== link:#_notestesting_considerations_268[]Notes/Testing Considerations

. Step 2 - The mode tag values may be standard (if from the CommonTags
range) or manufacturer specific (if from the MfgTags range). Refer to
the manufacturer documentation for details regarding the MfgTags values.

[[_changetomode_test_cases_4]]
==== link:#_changetomode_test_cases_4[]183.2. ChangeToMode Test Cases

'''''

[[_tc_lwm_2_1_change_to_mode_functionality_with_dut_as_server]]
===== link:#_tc_lwm_2_1_change_to_mode_functionality_with_dut_as_server[]183.2.1. [TC-LWM-2.1] Change to Mode functionality with DUT as Server

[[_category_334]]
====== link:#_category_334[]Category

Functional conformance

[[_purpose_340]]
====== link:#_purpose_340[]Purpose

This test case verifies the functionality associated with the
ChangeToMode command.

[[_pics_339]]
====== link:#_pics_339[]PICS

* LWM.S

[[_required_devices_340]]
====== link:#_required_devices_340[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_269]]
====== link:#_device_topology_269[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_290]]
====== link:#_test_setup_290[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_340]]
====== link:#_test_procedure_340[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8 |LWM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* Select a value which is NOT in `supported_modes_dut` and save it as
`invalid_mode_th`

|4 |AC.1.9.7.1, AC.1.9.7.2 |LWM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`old_current_mode_dut`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|5 | |LWM.S.M.CAN_TEST_MODE_FAILURE a|
Manually put the device in a state from which it will FAIL to transition
to PIXIT.LWM.MODE_CHANGE_FAIL

a|

|6 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|7 |AC.1.9.7.1, AC.1.9.7.2 |LWM.S.M.CAN_TEST_MODE_FAILURE &
LWM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.LWM.MODE_CHANGE_FAIL

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to GenericFailure(0x02) or in the
MfgCodes (0x80 to 0xBF) range
* Verify that the StatusText field has a length between 1 and 64

|8 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
`old_current_mode_dut`

|9 | | a|
Manually put the device in a state from which it will SUCCESSFULLY
transition to PIXIT.LWM.MODE_CHANGE_OK

a|

|10 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|11 |AC.1.9.7.1, AC.1.9.7.2 |LWM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.LWM.MODE_CHANGE_OK

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to Success(0x00)

|12 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.LWM.MODE_CHANGE_OK

|13 |AC.1.9.7.1, AC.1.9.7.2 |LWM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`invalid_mode_th`

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to UnsupportedMode(0x01).

|14 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.LWM.MODE_CHANGE_OK

|===

[[_notestesting_considerations_269]]
====== link:#_notestesting_considerations_269[]Notes/Testing Considerations

[[_onoff_and_startup_mode_test_cases_4]]
==== link:#_onoff_and_startup_mode_test_cases_4[]183.3. On/Off and StartUp Mode Test Cases

'''''

[[_tc_lwm_3_1_on_mode_functionality_with_dut_as_server]]
===== link:#_tc_lwm_3_1_on_mode_functionality_with_dut_as_server[]183.3.1. [TC-LWM-3.1] On Mode functionality with DUT as Server

[[_category_335]]
====== link:#_category_335[]Category

Functional conformance

[[_purpose_341]]
====== link:#_purpose_341[]Purpose

This test case verifies that the DUT switches to the proper OnMode when
the On/Off attribute of the On/Off cluster changes.

[[_pics_340]]
====== link:#_pics_340[]PICS

* LWM.S

[[_preconditions_78]]
====== link:#_preconditions_78[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |Laundry Washer Mode and OnOff clusters are available on the same
endpoint |

|2 | |The _OnMode_ attribute is set to a non-NULL value from the mode
values indicated by the _SupportedModes_ attribute. |
|===

[[_required_devices_341]]
====== link:#_required_devices_341[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_270]]
====== link:#_device_topology_270[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_291]]
====== link:#_test_setup_291[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_341]]
====== link:#_test_procedure_341[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.4 |LWM.S.A0003(OnMode), LWM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `on_mode_dut`

|3 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode), LWM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `on_mode_dut` is equal to `old_current_mode_dut` proceed to step 4.
Else proceed to step 6.

|4 |AC.1.9.6.1 |LWM.S.A0000(SupportedModes), LWM.S.F00(DEPONOFF) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`on_mode_dut`. Save the value as `new_mode_th`.

|5 |AC.1.9.7.1, AC.1.9.7.2 |LWM.S.C00.Rsp(ChangeToMode),
LWM.S.F00(DEPONOFF) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|6 |AC.1.5.7.1 |OO.S.C00.Rsp LWM.S.F00(DEPONOFF) a|
TH sends a _Off_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|7 |AC.1.5.7.2 |OO.S.C01.Rsp, LWM.S.F00(DEPONOFF) a|
TH sends a _On_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode), LWM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `on_mode_dut`

|===

[[_notestesting_considerations_270]]
====== link:#_notestesting_considerations_270[]Notes/Testing Considerations

[[_tc_lwm_3_2_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_lwm_3_2_startup_mode_functionality_with_dut_as_server[]183.3.2. [TC-LWM-3.2] Startup Mode functionality with DUT as Server

[[_category_336]]
====== link:#_category_336[]Category

Functional conformance

[[_purpose_342]]
====== link:#_purpose_342[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled.

[[_pics_341]]
====== link:#_pics_341[]PICS

* LWM.S

[[_preconditions_79]]
====== link:#_preconditions_79[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |!LWM.S.F00(DEPONOFF) | OnOff cluster’s _StartUpOnOff_ attribute is
NULL | _StartUpOnOff_ is 0 | _OnMode_ is NULL |
|===

[[_required_devices_342]]
====== link:#_required_devices_342[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_271]]
====== link:#_device_topology_271[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_292]]
====== link:#_test_setup_292[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_342]]
====== link:#_test_procedure_342[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |LWM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `startup_mode_dut` is equal to `old_current_mode_dut` proceed to
step 6. Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |LWM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.7.1, AC.1.9.7.2 |LWM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|8 | | a|
Physically power cycle the device

a|

|9 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_start_up_mode_dut`
* The value is equal to `new_start_up_mode_th`

|10 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_dut`

|===

[[_notestesting_considerations_271]]
====== link:#_notestesting_considerations_271[]Notes/Testing Considerations

[[_tc_lwm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_lwm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[]183.3.3. [TC-LWM-3.3] On Mode and Startup Mode functionality with DUT as Server

[[_category_337]]
====== link:#_category_337[]Category

Functional conformance

[[_purpose_343]]
====== link:#_purpose_343[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled, if the device supports OnMode, and StartUpOnOff (from the
OnOff cluster).

[[_pics_342]]
====== link:#_pics_342[]PICS

* LWM.S

[[_required_devices_343]]
====== link:#_required_devices_343[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_272]]
====== link:#_device_topology_272[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_293]]
====== link:#_test_setup_293[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_343]]
====== link:#_test_procedure_343[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |LWM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.4 |LWM.S.A0003(OnMode), LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_on_mode_dut`
* If `startup_mode_dut` is equal to `old_on_mode_dut` proceed to step 6.
Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |LWM.S.A0000(SupportedModes),
LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.6.4 |LWM.S.A0003(OnMode) a|
TH writes to the DUT the _OnMode_ attribute with the `new_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.4 |LWM.S.A0003(OnMode), LWM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_on_mode_dut`
* The value is equal to `new_mode_th`

|9 |AC.1.5.6.5 |OO.S.A4003 a|
TH writes to the DUT the _StartUpOnOff_ attribute with the value 1.

a|
Verify DUT responds w/ status SUCCESS(0x00)

|10 | | a|
Physically power cycle the device

a|

|11 |AC.1.9.6.3 |LWM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_th`

|12 |AC.1.9.6.2 |LWM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_on_mode_dut`

|===

[[_notestesting_considerations_272]]
====== link:#_notestesting_considerations_272[]Notes/Testing Considerations

[[_washer_controls_cluster_test_plan]]
== link:#_washer_controls_cluster_test_plan[]**Washer Controls Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date*. |*Author* |*Description*
|0.1. |30-March-2023 |`Austin Beck` |Initial Document upload to github
|===

[[_pics_definition_54]]
=== link:#_pics_definition_54[]184. PICS Definition

This section covers the Laundry Washer Controls Cluster Test Plan
related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_56]]
==== link:#_role_56[]184.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WASHERCTRL.S |Does the device implement the Laundry Washer Controls
cluster as a server? |O |

|WASHERCTRL.C |Does the device implement the Laundry Washer Controls
cluster as a client? |O |
|===

[[_server_67]]
==== link:#_server_67[]184.2. Server

[[_features_40]]
===== link:#_features_40[]184.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WASHERCTRL.S.F00(SPIN) |Does the device support spin feature |O |

|WASHERCTRL.S.F01(RINSE) |Does the device support rinse feature |O |
|===

[[_attributes_60]]
===== link:#_attributes_60[]184.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WASHERCTRL.S.A0000(SpinSpeeds) |Does the device implement the
_SpinSpeeds_ attribute? |SPIN |

|WASHERCTRL.S.A0001(SpinSpeedCurrent) |Does the device implement the
_SpinSpeedCurrent_ attribute? |SPIN |

|WASHERCTRL.S.A0002(NumberOfRinses) |Does the device implement the
_NumberOfRinses_ attribute? |RINSE |

|WASHERCTRL.S.A0003(SupportedRinses) |Does the device implement the
_SupportedRinses_ attribute? |RINSE |
|===

[[_manual_controllable_20]]
===== link:#_manual_controllable_20[]184.2.3. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|WASHERCTRL.S.M.ManuallyControlledSpin |Can the Spin attribute changed
by physical control at the device? |O |

|WASHERCTRL.S.M.ManuallyControlledRinse |Can the Rinse attribute changed
by physical control at the device? |O |
|===

[[_test_case_list_56]]
=== link:#_test_case_list_56[]185. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-WASHERCTRL-1.1 |Global attributes with DUT as Server
|TC-WASHERCTRL-2.1 |Optional spin attributes with DUT as Server
|TC-WASHERCTRL-2.2 |Optional rinse attributes with DUT as Server
|TC-WASHERCTRL-3.1 |Optional rinse functionality with DUT as Server
|TC-WASHERCTRL-3.2 |Optional spin functionality with DUT as Server
|===

[[_test_cases_56]]
=== link:#_test_cases_56[]186. Test Cases

'''''

[[_generic_test_cases_49]]
==== link:#_generic_test_cases_49[]186.1. Generic test cases

'''''

[[_tc_washerctrl_1_1_global_attributes_with_server_as_dut]]
===== link:#_tc_washerctrl_1_1_global_attributes_with_server_as_dut[]186.1.1. [TC-WASHERCTRL-1.1] Global attributes with server as DUT

[[_category_338]]
====== link:#_category_338[]Category

Functional conformance

[[_purpose_344]]
====== link:#_purpose_344[]Purpose

This test case verifies that the DUT can provide the washer controls
cluster global attributes

[[_pics_343]]
====== link:#_pics_343[]PICS

* WASHERCTRL.S

[[_required_devices_344]]
====== link:#_required_devices_344[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |Test harness as client
|2 |DUT. |DUT as server
|===

[[_device_topology_273]]
====== link:#_device_topology_273[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_294]]
====== link:#_test_setup_294[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_344]]
====== link:#_test_procedure_344[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute
|Verify that the DUT response contains the _ClusterRevision_ attribute
with the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute |Verify
that the DUT response contains the FeatureMap attribute with +
* bit 0 set to 1 if the DUT is capable of controlling the washer using
the spin attributes (WASHERCTRL.S.F00(SPIN) is true) +
* bit 1 set to 1 if the DUT supports rinse attributes
(WASHERCTRL.S.F01(RINSE) is true)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute
|Verify that the DUT response provides a list of supported attributes. +
This list SHALL include all mandatory attributes: 0 +
Depending on its feature support it SHALL also contain following
mandatory attributes: +
if WASHERCTRL.S.F00(SPIN): 1 and 2 +
if WASHERCTRL.S.F01(RINSE): 3 and 4

|5 | | |TH reads from the DUT the (0xFFFA) _EventList_ attribute |Verify
that the DUT response contains a list of supported events empty for this
cluster.

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute |Verify that the DUT response contains a list of supported
commands. +
For this cluster, this list is usually empty.

|7 | | |TH reads from the DUT the (0xFFF8) _GeneratedCommandList_
attribute |Verify that the DUT response contains a list of Generated
commands empty for this cluster.
|===

'''''

[[_server_as_dut_26]]
==== link:#_server_as_dut_26[]186.2. Server as DUT

'''''

[[_tc_washerctrl_2_1_optional_spin_attributes_with_dut_as_server]]
===== link:#_tc_washerctrl_2_1_optional_spin_attributes_with_dut_as_server[]186.2.1. [TC-WASHERCTRL-2.1] Optional Spin attributes with DUT as Server

[[_category_339]]
====== link:#_category_339[]Category

Functional conformance

[[_purpose_345]]
====== link:#_purpose_345[]Purpose

This test case verifies that the DUT can respond to Laundry Washer
Controls cluster attribute read commands. This test case is only
required if the SPIN feature is supported (WASHERCTRL.S.F00(SPIN)).

[[_pics_344]]
====== link:#_pics_344[]PICS

* WASHERCTRL.S.F00(SPIN)

[[_required_devices_345]]
====== link:#_required_devices_345[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_274]]
====== link:#_device_topology_274[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_295]]
====== link:#_test_setup_295[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_345]]
====== link:#_test_procedure_345[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |WASHERCTRL.S.A0000(SpinSpeeds) |TH reads from the DUT the the
_SpinSpeeds attribute_ |Verify that the DUT response contains a list of
strings with a maximum number of 16.

|3 | |WASHERCTRL.S.A0001(SpinSpeedCurrent) |TH reads from the DUT the
the _SpinSpeedCurrent attribute_ |Verify that the DUT response contains
a uint8 with value between 0 and 15 inclusive.
|===

[[_tc_washerctrl_2_2_optional_rinse_attributes_with_dut_as_server]]
===== link:#_tc_washerctrl_2_2_optional_rinse_attributes_with_dut_as_server[]186.2.2. [TC-WASHERCTRL-2.2] Optional rinse attributes with DUT as Server

[[_category_340]]
====== link:#_category_340[]Category

Functional conformance

[[_purpose_346]]
====== link:#_purpose_346[]Purpose

This test case verifies that the DUT can respond to Laundry Washer
Controls cluster attribute read commands. This test case is only
required if the RINSE feature is supported (WASHERCTRL.S.F01(RINSE)).

[[_pics_345]]
====== link:#_pics_345[]PICS

* WASHERCTRL.S.F01(RINSE)

[[_required_devices_346]]
====== link:#_required_devices_346[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_275]]
====== link:#_device_topology_275[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_296]]
====== link:#_test_setup_296[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_346]]
====== link:#_test_procedure_346[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |WASHERCTRL.S.A0002(NumberOfRinses) |TH reads from the DUT the the
_NumberOfRinses attribute_ |Verify that the DUT response contains if not
null, an enum with up to 4 values.

|3 | |WASHERCTRL.S.A0003(SupportedRinses) |TH reads from the DUT the the
_SupportedRinses attribute_ |Verify that the DUT response contains a
list of enums each containing up to 4 values.
|===

[[_tc_washerctrl_3_1_rinse_functionality_with_dut_as_server]]
===== link:#_tc_washerctrl_3_1_rinse_functionality_with_dut_as_server[]186.2.3. [TC-WASHERCTRL-3.1] Rinse functionality with DUT as Server

[[_category_341]]
====== link:#_category_341[]Category

Functional

[[_purpose_347]]
====== link:#_purpose_347[]Purpose

This test case verifies the optional functionality of the Laundry Washer
Controls cluster server. This test case is only required if the RINSE
feature is supported (WASHERCTRL.S.F01(RINSE)).

[[_pics_346]]
====== link:#_pics_346[]PICS

* WASHERCTRL.S.F01(RINSE)

[[_required_devices_347]]
====== link:#_required_devices_347[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_276]]
====== link:#_device_topology_276[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_297]]
====== link:#_test_setup_297[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_347]]
====== link:#_test_procedure_347[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |WASHERCTRL.S.A0002(NumberOfRinses) |TH writes a supported
_NumberOfRinses_ attribute to DUT within the range of the enum provided
with a max value of 4. |Verify DUT responds w/ status SUCCESS(0x00)

|3 | |WASHERCTRL.S.A0002(NumberOfRinses) |after a few seconds, TH reads
from the DUT the _NumberOfRinses_ attribute |Value is the same as was
written in step 2

|4 | |WASHERCTRL.S.A0002(NumberOfRinses) |TH writes an unsupported
_NumberOfRinses_ attribute to DUT while DUT is not in a valid state.
|Verify that the DUT response contains Status INVALID_IN_STATE response
|===

[[_tc_washerctrl_3_2_optional_spin_functionality_with_dut_as_server]]
===== link:#_tc_washerctrl_3_2_optional_spin_functionality_with_dut_as_server[]186.2.4. [TC-WASHERCTRL-3.2] Optional spin functionality with DUT as Server

[[_category_342]]
====== link:#_category_342[]Category

Functional

[[_purpose_348]]
====== link:#_purpose_348[]Purpose

This test case verifies the optional functionality of the Laundry Washer
Controls cluster server. This test case is only required if the SPIN
feature is supported (WASHERCTRL.S.F00(SPIN)).

[[_pics_347]]
====== link:#_pics_347[]PICS

* WASHERCTRL.S.F00(SPIN)

[[_required_devices_348]]
====== link:#_required_devices_348[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_277]]
====== link:#_device_topology_277[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_298]]
====== link:#_test_setup_298[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_348]]
====== link:#_test_procedure_348[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |WASHERCTRL.S.A0001(SpinSpeedCurrent) |TH writes a supported
_SpinSpeedCurrent_ attribute that is other than 0 to DUT |Verify DUT
responds w/ status SUCCESS(0x00)

|3 | |WASHERCTRL.S.A0001(SpinSpeedCurrent) |after a few seconds, TH
reads from the DUT the _SpinSpeedCurrent_ attribute |Value is the same
as was written in step 2

|4 | |WASHERCTRL.S.A0001(SpinSpeedCurrent) |TH writes an unsupported
_SpinSpeedCurrent_ attribute that is other than 0 to DUT |Verify that
the DUT response contains Status CONSTRAINT_ERROR response
|===

[[_fan_control_cluster_test_plan]]
== link:#_fan_control_cluster_test_plan[]**Fan Control Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|1.0 |May 5, 2023 |`Rob Bultman` |Initial revision of this test plan

|1.1 |Jul 11, 2023 |`Matt Hazley` |Updated 3.2, 3.3, 3.4 & 3.5 to
improve robustness and coverage

|1.1.1 |Aug 15, 2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_55]]
=== link:#_pics_definition_55[]187. PICS Definition

This section covers the Fan Control Cluster Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_57]]
==== link:#_role_57[]187.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FAN.S |Does the device implement the Fan Control cluster as a server?
|O |

|FAN.C |Does the device implement the Fan Control cluster as a client?
|O |
|===

[[_server_68]]
==== link:#_server_68[]187.2. Server

[[_features_41]]
===== link:#_features_41[]187.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FAN.S.F00(SPD) |Does the device support multiple speeds from 0-100 |O |

|FAN.S.F01(AUT) |Does the device support automatic mode |O |

|FAN.S.F02(RCK) |Does the device support rocking movement |O |

|FAN.S.F03(WND) |Does the device support wind emulation |O |

|FAN.S.F04(STEP) |Does the device support the step command |O |

|FAN.S.F05(DIR) |Does the device support the direction attribute |O |
|===

[[_attributes_61]]
===== link:#_attributes_61[]187.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FAN.S.A0000(FanMode) |Does the device implement the _FanMode_
attribute? |M |

|FAN.S.A0001(FanModeSequence) |Does the device implement the
_FanModeSequence_ attribute? |M |

|FAN.S.A0002(PercentSetting) |Does the device implement the
_PercentSetting_ attribute? |M |

|FAN.S.A0003(PercentCurrent) |Does the device implement the
_PercentCurrent_ attribute? |M |

|FAN.S.A0004(SpeedMax) |Does the device implement the _SpeedMax_
attribute? |SPD |

|FAN.S.A0005(SpeedSetting) |Does the device implement the _SpeedSetting_
attribute? |SPD |

|FAN.S.A0006(SpeedCurrent) |Does the device implement the _SpeedCurrent_
attribute? |SPD |

|FAN.S.A0007(RockSupport) |Does the device implement the _RockSupport_
attribute? |RCK |

|FAN.S.A0008(RockSetting) |Does the device implement the _RockSetting_
attribute? |RCK |

|FAN.S.A0009(WindSupport) |Does the device implement the _WindSupport_
attribute? |WND |

|FAN.S.A000A(WindSetting) |Does the device implement the _WindSetting_
attribute? |WND |

|FAN.S.A000B(AirflowDirection) |Does the device implement the
_AirflowDirection_ attribute? |DIR |
|===

[[_commands_received_29]]
===== link:#_commands_received_29[]187.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|FAN.S.C00.Rsp(Step) |Does the device implement receiving the _Step_
command? |STEP |
|===

[[_test_case_list_57]]
=== link:#_test_case_list_57[]188. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-FAN-1.1 |Global attributes with DUT as Server
|TC-FAN-2.1 |Mandatory attributes with DUT as Server
|TC-FAN-2.2 |Optional speed attributes with DUT as Server
|TC-FAN-2.3 |Optional rock attributes with DUT as Server
|TC-FAN-2.4 |Optional wind attributes with DUT as Server
|TC-FAN-2.5 |Optional direction attributes with DUT as Server
|TC-FAN-3.1 |Mandatory functionality with DUT as Server
|TC-FAN-3.2 |Optional speed functionality with DUT as Server
|TC-FAN-3.3 |Optional rock functionality with DUT as Server
|TC-FAN-3.4 |Optional wind functionality with DUT as Server
|TC-FAN-3.5 |Optional step functionality with DUT as Server
|TC-FAN-3.6 |Optional direction functionality with DUT as Server
|===

[[_test_cases_57]]
=== link:#_test_cases_57[]189. Test Cases

'''''

[[_generic_test_cases_50]]
==== link:#_generic_test_cases_50[]189.1. Generic test cases

'''''

[[_tc_fan_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_fan_1_1_global_attributes_with_dut_as_server[]189.1.1. [TC-FAN-1.1] Global attributes with DUT as Server

[[_category_343]]
====== link:#_category_343[]Category

Functional conformance

[[_purpose_349]]
====== link:#_purpose_349[]Purpose

This test case verifies that the DUT can provide the Fan Control Cluster
global attributes

[[_pics_348]]
====== link:#_pics_348[]PICS

* FAN.S

[[_required_devices_349]]
====== link:#_required_devices_349[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_278]]
====== link:#_device_topology_278[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_299]]
====== link:#_test_setup_299[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_349]]
====== link:#_test_procedure_349[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 4.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if FAN.S.F00(SPD) +

- bit 1: SHALL be 1 if and only if FAN.S.F01(AUT) +

- bit 2: SHALL be 1 if and only if FAN.S.F02(RCK) +

- bit 3: SHALL be 1 if and only if FAN.S.F03(WND) +

- bit 4: SHALL be 1 if and only if FAN.S.F04(STEP) +

- bit 5: SHALL be 1 if and only if FAN.S.F05(DIR)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002, 0x0003, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list include entries based on feature support: +
- 0x0004, 0x0005, and 0x0006: SHALL be included if and only if
FAN.S.F00(SPD) +

- 0x0007 and 0x0008: SHALL be included if and only if FAN.S.F02(RCK) +

- 0x0009 and 0x000A: SHALL be included if and only if FAN.S.F03(WND) +

- 0x000B: SHALL be included if and only if FAN.S.F05(DIR)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list include entries based on feature support: +
- 0x00: SHALL be included if and only if FAN.S.F00(SPD) +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_273]]
====== link:#_notestesting_considerations_273[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut_27]]
==== link:#_server_as_dut_27[]189.2. Server as DUT

[[_tc_fan_2_1_mandatory_attributes_with_dut_as_server]]
===== link:#_tc_fan_2_1_mandatory_attributes_with_dut_as_server[]189.2.1. [TC-FAN-2.1] Mandatory Attributes with DUT as Server

[[_category_344]]
====== link:#_category_344[]Category

Functional conformance

[[_purpose_350]]
====== link:#_purpose_350[]Purpose

This test case verifies that the DUT can respond to Fan Control cluster
attribute read commands.

[[_pics_349]]
====== link:#_pics_349[]PICS

* FAN.S

[[_required_devices_350]]
====== link:#_required_devices_350[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_279]]
====== link:#_device_topology_279[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_300]]
====== link:#_test_setup_300[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_350]]
====== link:#_test_procedure_350[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0000(FanMode) |TH reads from the DUT the the _FanMode_
attribute |Verify that the DUT response contains an enum8 with value
between 0 and 6 inclusive.

|3 | |FAN.S.A0001(FanModeSequence) |TH reads from the DUT the the
_FanModeSequence_ attribute |Verify that the DUT response contains an
enum8 with value between 0 and 5 inclusive.

|4 | |FAN.S.A0002(PercentSetting) |TH reads from the DUT the the
_PercentSetting_ attribute |Verify that the DUT response contains a
uint8 with value between 0 and 100 inclusive.

|5 | |FAN.S.A0003(PercentCurrent) |TH reads from the DUT the the
_PercentCurrent_ attribute |Verify that the DUT response contains a
uint8 with value between 0 and 100 inclusive.
|===

[[_tc_fan_2_2_optional_speed_attributes_with_dut_as_server]]
===== link:#_tc_fan_2_2_optional_speed_attributes_with_dut_as_server[]189.2.2. [TC-FAN-2.2] Optional speed attributes with DUT as Server

[[_category_345]]
====== link:#_category_345[]Category

Functional conformance

[[_purpose_351]]
====== link:#_purpose_351[]Purpose

This test case verifies that the DUT can respond to Fan Control cluster
attribute read commands. This test case is only required if the SPD
feature is supported (FAN.S.F00(SPD)).

[[_pics_350]]
====== link:#_pics_350[]PICS

* FAN.S
* FAN.S.F00(SPD)

[[_required_devices_351]]
====== link:#_required_devices_351[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_280]]
====== link:#_device_topology_280[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_301]]
====== link:#_test_setup_301[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_351]]
====== link:#_test_procedure_351[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0004(SpeedMax) |TH reads from the DUT the the _SpeedMax_
attribute |Verify that the DUT response contains a uint8 with value
between 1 and 100 inclusive.

|3 | |FAN.S.A0005(SpeedSetting) |TH reads from the DUT the the
_SpeedSetting_ attribute |Verify that the DUT response contains a uint8
with value between 0 and the value of SpeedMax inclusive.

|4 | |FAN.S.A0006(SpeedCurrent) |TH reads from the DUT the the
_SpeedCurrent_ attribute |Verify that the DUT response contains a uint8
with value between 0 and the value of SpeedMax inclusive.
|===

[[_tc_fan_2_3_optional_rock_attributes_with_dut_as_server]]
===== link:#_tc_fan_2_3_optional_rock_attributes_with_dut_as_server[]189.2.3. [TC-FAN-2.3] Optional rock attributes with DUT as Server

[[_category_346]]
====== link:#_category_346[]Category

Functional conformance

[[_purpose_352]]
====== link:#_purpose_352[]Purpose

This test case verifies that the DUT can respond to Fan Control cluster
attribute read commands. This test case is only required if the RCK
feature is supported (FAN.S.F02(RCK)).

[[_pics_351]]
====== link:#_pics_351[]PICS

* FAN.S
* FAN.S.F02(RCK)

[[_required_devices_352]]
====== link:#_required_devices_352[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_281]]
====== link:#_device_topology_281[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_302]]
====== link:#_test_setup_302[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_352]]
====== link:#_test_procedure_352[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0007(RockSupport) |TH reads from the DUT the the
_RockSupport_ attribute |Verify that the DUT response contains a map8
bitmap.

|3 | |FAN.S.A0008(RockSetting) |TH reads from the DUT the the
_RockSetting_ attribute |Verify that the DUT response contains a map8
bitmap.
|===

[[_tc_fan_2_4_optional_wind_attributes_with_dut_as_server]]
===== link:#_tc_fan_2_4_optional_wind_attributes_with_dut_as_server[]189.2.4. [TC-FAN-2.4] Optional wind attributes with DUT as Server

[[_category_347]]
====== link:#_category_347[]Category

Functional conformance

[[_purpose_353]]
====== link:#_purpose_353[]Purpose

This test case verifies that the DUT can respond to Fan Control cluster
attribute read commands. This test case is only required if the WND
feature is supported (FAN.S.F03(WND)).

[[_pics_352]]
====== link:#_pics_352[]PICS

* FAN.S
* FAN.S.F03(WND)

[[_required_devices_353]]
====== link:#_required_devices_353[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_282]]
====== link:#_device_topology_282[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_303]]
====== link:#_test_setup_303[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_353]]
====== link:#_test_procedure_353[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0009(WindSupport) |TH reads from the DUT the the
_WindSupport_ attribute |Verify that the DUT response contains a map8
bitmap.

|3 | |FAN.S.A000A(WindSetting) |TH reads from the DUT the the
_WindSetting_ attribute |Verify that the DUT response contains a map8
bitmap.
|===

[[_tc_fan_2_5_optional_direction_attributes_with_dut_as_server]]
===== link:#_tc_fan_2_5_optional_direction_attributes_with_dut_as_server[]189.2.5. [TC-FAN-2.5] Optional direction attributes with DUT as Server

[[_category_348]]
====== link:#_category_348[]Category

Functional conformance

[[_purpose_354]]
====== link:#_purpose_354[]Purpose

This test case verifies that the DUT can respond to Fan Control cluster
attribute read commands. This test case is only required if the DIR
feature is supported (FAN.S.F05(DIR)).

[[_pics_353]]
====== link:#_pics_353[]PICS

* FAN.S
* FAN.S.F05(DIR)

[[_required_devices_354]]
====== link:#_required_devices_354[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_283]]
====== link:#_device_topology_283[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_304]]
====== link:#_test_setup_304[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_354]]
====== link:#_test_procedure_354[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.F05(DIR) |TH reads from the DUT the the _AirflowDirection_
attribute |Verify that the DUT response contains an
AirflowDirectionEnum.
|===

[[_tc_fan_3_1_mandatory_functionality_with_dut_as_server]]
===== link:#_tc_fan_3_1_mandatory_functionality_with_dut_as_server[]189.2.6. [TC-FAN-3.1] Mandatory functionality with DUT as Server

[[_category_349]]
====== link:#_category_349[]Category

Functional

[[_purpose_355]]
====== link:#_purpose_355[]Purpose

This test case verifies the mandatory functionality of the Fan Control
cluster server.

[[_pics_354]]
====== link:#_pics_354[]PICS

* FAN.S

[[_required_devices_355]]
====== link:#_required_devices_355[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_284]]
====== link:#_device_topology_284[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_305]]
====== link:#_test_setup_305[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_355]]
====== link:#_test_procedure_355[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2a | |FAN.S.A0000(FanMode) |TH writes a supported _FanMode_ attribute
that is other than off to DUT |

|2b | |FAN.S.A0000(FanMode) |after a few seconds, TH reads from the DUT
the _FanMode_ attribute |Value is the same as was written in step 2a

|2.1a | |FAN.S.A0000(FanMode) |TH writes the Off value of _FanMode_
attribute to DUT |

|2.1b | |FAN.S.A0002(PercentSetting) |after a few seconds, TH reads from
the DUT the _PercentSetting_ attribute |Value is zero

|2.1c | |FAN.S.A0003(PercentCurrent) |TH reads from the DUT the
_PercentCurrent_ attribute |Value is zero

|3a | |FAN.S.A0002(PercentSetting) |TH writes a non-zero value to DUT |

|3b | |FAN.S.A0003(PercentCurrent) |after a few seconds, TH reads from
the DUT the _PercentCurrent_ attribute |Value is the same as was written
in step 3a

|3c | |FAN.S.A0002(PercentSetting) |after a few seconds, TH reads from
the DUT the _PercentSetting_ attribute |Value is the same as was written
in step 3a

|3.1a | |FAN.S.A0002(PercentSetting) |TH writes a zero value to DUT |

|3.1b | |FAN.S.A0000(FanMode) |after a few seconds, TH reads from the
DUT the _FanMode_ attribute |Value is 0
|===

[[_tc_fan_3_2_optional_speed_functionality_with_dut_as_server]]
===== link:#_tc_fan_3_2_optional_speed_functionality_with_dut_as_server[]189.2.7. [TC-FAN-3.2] Optional speed functionality with DUT as Server

[[_category_350]]
====== link:#_category_350[]Category

Functional

[[_purpose_356]]
====== link:#_purpose_356[]Purpose

This test case verifies the optional functionality of the Fan Control
cluster server. This test case is only required if the SPD feature is
supported (FAN.S.F00(SPD)).

[[_pics_355]]
====== link:#_pics_355[]PICS

* FAN.S
* FAN.S.F00(SPD)

[[_required_devices_356]]
====== link:#_required_devices_356[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_285]]
====== link:#_device_topology_285[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_306]]
====== link:#_test_setup_306[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_356]]
====== link:#_test_procedure_356[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0004(SpeedMax) |TH reads from the DUT the _SpeedMax_
attribute |

|3 | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the a value less
than or equal to the value read in step 2 |

|4 | |FAN.S.A0005(SpeedSetting) |After a few seconds, TH reads from the
DUT the _SpeedSetting_ attribute |Value is the same as was written in
step 3

|5 | |FAN.S.A0006(SpeedCurrent) |After a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value is the same as was written in
step 3
|===

[[_tc_fan_3_3_optional_rock_functionality_with_dut_as_server]]
===== link:#_tc_fan_3_3_optional_rock_functionality_with_dut_as_server[]189.2.8. [TC-FAN-3.3] Optional rock functionality with DUT as Server

[[_category_351]]
====== link:#_category_351[]Category

Functional

[[_purpose_357]]
====== link:#_purpose_357[]Purpose

This test case verifies the optional functionality of the Fan Control
cluster server. This test case is only required if the RCK feature is
supported (FAN.S.F02(RCK)).

[[_pics_356]]
====== link:#_pics_356[]PICS

* FAN.S
* FAN.S.F02(RCK)

[[_required_devices_357]]
====== link:#_required_devices_357[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_286]]
====== link:#_device_topology_286[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_307]]
====== link:#_test_setup_307[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_357]]
====== link:#_test_procedure_357[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0007(RockSupport) |TH reads from the DUT the _RockSupport_
attribute and store |

|3 | |FAN.S.A0008(RockSetting) |If the _RockSupport_ attribute read
above has bit 0 set, then TH writes to the DUT the _RockSetting_
attribute with 0x01 |

|4 | |FAN.S.A0008(RockSetting) |If the previous step is written, after a
few seconds, TH reads from the DUT the _RockSetting_ attribute |Value is
0x01

|5 | |FAN.S.A0008(RockSetting) |If the _RockSupport_ attribute read
above has bit 1 set, then TH writes to the DUT the _RockSetting_
attribute with 0x02 |

|6 | |FAN.S.A0008(RockSetting) |If the previous step is written, after a
few seconds, TH reads from the DUT the _RockSetting_ attribute |Value is
0x02

|7 | |FAN.S.A0008(RockSetting) |If the _RockSupport_ attribute read
above has bit 2 set, then TH writes to the DUT the _RockSetting_
attribute with 0x04 |

|8 | |FAN.S.A0008(RockSetting) |If the previous step is written, after a
few seconds, TH reads from the DUT the _RockSetting_ attribute |Value is
0x04

|9 | |FAN.S.A0008(RockSetting) |TH writes to the DUT the _RockSetting_
attribute with 0x00 |
|===

[[_tc_fan_3_4_optional_wind_functionality_with_dut_as_server]]
===== link:#_tc_fan_3_4_optional_wind_functionality_with_dut_as_server[]189.2.9. [TC-FAN-3.4] Optional wind functionality with DUT as Server

[[_category_352]]
====== link:#_category_352[]Category

Functional

[[_purpose_358]]
====== link:#_purpose_358[]Purpose

This test case verifies the optional functionality of the Fan Control
cluster server. This test case is only required if the WND feature is
supported (FAN.S.F03(WND)).

[[_pics_357]]
====== link:#_pics_357[]PICS

* FAN.S
* FAN.S.F03(WND)

[[_required_devices_358]]
====== link:#_required_devices_358[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_287]]
====== link:#_device_topology_287[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_308]]
====== link:#_test_setup_308[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_358]]
====== link:#_test_procedure_358[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A0009(WindSupport) |TH reads from the DUT the _WindSupport_
attribute and store |

|3 | |FAN.S.A000A(WindSetting) |If the _WindSupport_ attribute read
above has bit 0 set, then TH writes to the DUT the _WindSetting_
attribute with 0x01 |

|4 | |FAN.S.A000A(WindSetting) |If the previous step is written, after a
few seconds, TH reads from the DUT the _WindSetting_ attribute |Value is
0x01

|5 | |FAN.S.A000A(WindSetting) |If the _WindSupport_ attribute read
above has bit 1 set, then TH writes to the DUT the _WindSetting_
attribute with 0x02 |

|6 | |FAN.S.A000A(WindSetting) |If the previous step is written, after a
few seconds, TH reads from the DUT the _WindSetting_ attribute |Value is
0x02

|7 | |FAN.S.A000A(WindSetting) |TH writes to the DUT the _WindSetting_
attribute with 0x00 |
|===

[[_tc_fan_3_5_optional_step_functionality_with_dut_as_server]]
===== link:#_tc_fan_3_5_optional_step_functionality_with_dut_as_server[]189.2.10. [TC-FAN-3.5] Optional step functionality with DUT as Server

[[_category_353]]
====== link:#_category_353[]Category

Functional

[[_purpose_359]]
====== link:#_purpose_359[]Purpose

This test case verifies the optional functionality of the Fan Control
cluster server. This test case is only required if the STEP feature is
supported (FAN.S.F04(STEP)).

[[_pics_358]]
====== link:#_pics_358[]PICS

* FAN.S
* FAN.S.F04(STEP)

[[_required_devices_359]]
====== link:#_required_devices_359[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_288]]
====== link:#_device_topology_288[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_309]]
====== link:#_test_setup_309[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_359]]
====== link:#_test_procedure_359[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2a | |FAN.S.A0002(PercentSetting) |TH writes to the DUT the
_PercentSetting_ attribute with _50_ |

|2b | |FAN.S.A0003(PercentCurrent) |after a few seconds, TH reads from
the DUT the _PercentCurrent_ attribute |

|2c | |FAN.S.C00.Rsp(Step) |TH sends _Step command_ to DUT with
Direction set to Increase |

|2d | |FAN.S.A0003(PercentCurrent) |after a few seconds, TH reads from
the DUT the _PercentCurrent_ attribute |Value is higher than the value
read in step 2b

|3a | |FAN.S.A0002(PercentSetting) |TH writes to the DUT the
_PercentSetting_ attribute with _50_ |

|3b | |FAN.S.A0003(PercentCurrent) |after a few seconds, TH reads from
the DUT the _PercentCurrent_ attribute |

|3c | |FAN.S.C00.Rsp(Step) |TH sends _Step command_ to DUT with
Direction set to Decrease |

|3d | |FAN.S.A0003(PercentCurrent) |after a few seconds, TH reads from
the DUT the _PercentCurrent_ attribute |Value is lower than the value
read in step 3b

|[#read-speed-max]## 4a | |FAN.S.A0004(SpeedMax) |TH reads from the DUT
the _SpeedMax_ attribute |

|4b | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the
_SpeedSetting_ attribute with value read from step
link:#read-speed-max[4a] |

|4c | |FAN.S.C00.Rsp(Step) |after a few seconds, TH sends _Step command_
to DUT with Direction set to Increase and Wrap set to false |

|4d | |FAN.S.A0006(SpeedCurrent) |after a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value is the same as the value read in
step 4a

|5a | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the
_SpeedSetting_ attribute with value read from step
link:#read-speed-max[4a] |

|5b | |FAN.S.C00.Rsp(Step) |after a few seconds, TH sends _Step command_
to DUT with Direction set to Increase, Wrap set to true, and LowestOff
set to false |

|5c | |FAN.S.A0006(SpeedCurrent) |after a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value should be 1 (one)

|6a | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the
_SpeedSetting_ attribute with value read from step
link:#read-speed-max[4a] |

|6b | |FAN.S.C00.Rsp(Step) |after a few seconds, TH sends _Step command_
to DUT with Direction set to Increase, Wrap set to true, and LowestOff
set to true |

|6c | |FAN.S.A0006(SpeedCurrent) |after a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value should be 0 (zero)

|7a | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the
_SpeedSetting_ attribute with a value of 1 |

|7b | |FAN.S.C00.Rsp(Step) |after a few seconds, TH sends _Step command_
to DUT with Direction set to Decrease and Wrap set to false and
LowestOff set to false |

|7c | |FAN.S.A0006(SpeedCurrent) |after a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value should be 1 (one)

|8a | |FAN.S.A0004(SpeedMax) |TH reads from the DUT the _SpeedMax_
attribute |

|8b | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the
_SpeedSetting_ attribute with a value of 1 |

|8c | |FAN.S.C00.Rsp(Step) |after a few seconds, TH sends _Step command_
to DUT with Direction set to Decrease, Wrap set to true, and LowestOff
set to false |

|8d | |FAN.S.A0006(SpeedCurrent) |after a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value should be the same as the value
read in step 8a

|9a | |FAN.S.A0004(SpeedMax) |TH reads from the DUT the _SpeedMax_
attribute |

|9b | |FAN.S.A0005(SpeedSetting) |TH writes to the DUT the
_SpeedSetting_ attribute with value of zero |

|9c | |FAN.S.C00.Rsp(Step) |after a few seconds, TH sends _Step command_
to DUT with Direction set to Decrease, Wrap set to true, and LowestOff
set to true |

|9d | |FAN.S.A0006(SpeedCurrent) |after a few seconds, TH reads from the
DUT the _SpeedCurrent_ attribute |Value should be the same as the value
read in step 9a
|===

[[_tc_fan_3_6_optional_direction_functionality_with_dut_as_server]]
===== link:#_tc_fan_3_6_optional_direction_functionality_with_dut_as_server[]189.2.11. [TC-FAN-3.6] Optional direction functionality with DUT as Server

[[_category_354]]
====== link:#_category_354[]Category

Functional

[[_purpose_360]]
====== link:#_purpose_360[]Purpose

This test case verifies the optional functionality of the Fan Control
cluster server. This test case is only required if the DIR feature is
supported (FAN.S.F05(DIR)).

[[_pics_359]]
====== link:#_pics_359[]PICS

* FAN.S
* FAN.S.F05(DIR)

[[_required_devices_360]]
====== link:#_required_devices_360[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_289]]
====== link:#_device_topology_289[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_310]]
====== link:#_test_setup_310[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_360]]
====== link:#_test_procedure_360[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |FAN.S.A000B(AirflowDirection) |TH writes a value of _Forward_ to
the DUT |

|3 | |FAN.S.A000B(AirflowDirection) |after a few seconds, TH reads from
the DUT the _AirflowDirection_ attribute |Value is _Forward_

|4 | |FAN.S.A000B(AirflowDirection) |TH writes a value of _Reverse_ to
the DUT |

|5 | |FAN.S.A000B(AirflowDirection) |after a few seconds, TH reads from
the DUT the _AirflowDirection_ attribute |Value is _Reverse_
|===

[[_dishwasher_mode_cluster_test_plan]]
== link:#_dishwasher_mode_cluster_test_plan[]**Dishwasher Mode Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|1.0 |10-May-2023 |`Rob Bultman` |Initial test plan
|1.1 |14-Jul-2023 |`Rob Bultman` |Fix test names
|===

[[_dishwasher_mode_cluster_testing_overview]]
=== link:#_dishwasher_mode_cluster_testing_overview[]190. Dishwasher Mode Cluster Testing Overview

The Dishwasher Mode cluster is a derived version of the Mode Base
cluster. This document describes the tests specific to this derived
cluster.

[[_pics_definition_56]]
=== link:#_pics_definition_56[]191. PICS Definition

This section covers the Dishwasher Mode Cluster related PICS items that
are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_58]]
==== link:#_role_58[]191.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHM.S |Does the device implement the DISHM cluster as a server? |O |
|===

[[_server_69]]
==== link:#_server_69[]191.2. Server

[[_features_42]]
===== link:#_features_42[]191.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHM.S.F00(DEPONOFF) |Does the device support depending on an On/Off
cluster implemented on the same endpoint? |O |
|===

[[_attributes_62]]
===== link:#_attributes_62[]191.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHM.S.A0000(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |M |

|DISHM.S.A0001(CurrentMode) |Does the device implement the _CurrentMode_
attribute? |M |

|DISHM.S.A0002(StartUpMode) |Does the device implement the _StartUpMode_
attribute? |O |

|DISHM.S.A0003(OnMode) |Does the device implement the _OnMode_
attribute? |DEPONOFF |
|===

[[_commands_received_30]]
===== link:#_commands_received_30[]191.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHM.S.C00.Rsp(ChangeToMode) |Does the device implement receiving the
_ChangeToMode_ command? |M |
|===

[[_commands_generated_30]]
===== link:#_commands_generated_30[]191.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHM.S.C01.Tx(ChangeToModeResponse) |Does the device implement sending
the _ChangeToModeResponse_ command? |M |
|===

[[_manual_controllable_21]]
===== link:#_manual_controllable_21[]191.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHM.S.M.CAN_TEST_MODE_FAILURE |Does the DUT support testing the
failed _ChangeToMode_ command? |O |Declared by manufacturer
|===

[[_pixit_definition_13]]
=== link:#_pixit_definition_13[]192. PIXIT Definition

This section covers the Dishwasher Mode Test Plan related PIXIT items
that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.DISHM.MODE_CHANGE_FAIL |Id of mode the device will fail to
transition to, given its current state |O |

|PIXIT.DISHM.MODE_CHANGE_OK |Id of mode the device will successfully
transition to, given its current state |O |
|===

[[_test_case_list_58]]
=== link:#_test_case_list_58[]193. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|[TC-DISHM-1.1] |Global attributes with DUT as Server

|[TC-DISHM-1.2] |Cluster attributes with DUT as Server

|[TC-DISHM-2.1] |Change to Mode functionality with DUT as Server

|[TC-DISHM-3.1] |On Mode functionality with DUT as Server

|[TC-DISHM-3.2] |Startup Mode functionality with DUT as Server

|[TC-DISHM-3.3] |On Mode and Startup Mode functionality with DUT as
Server
|===

[[_test_cases_58]]
=== link:#_test_cases_58[]194. Test Cases

'''''

[[_attribute_test_cases_3]]
==== link:#_attribute_test_cases_3[]194.1. Attribute test cases

'''''

[[_tc_dishm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_dishm_1_1_global_attributes_with_dut_as_server[]194.1.1. [TC-DISHM-1.1] Global attributes with DUT as Server

[[_category_355]]
====== link:#_category_355[]Category

Functional conformance

[[_purpose_361]]
====== link:#_purpose_361[]Purpose

This test case verifies the cluster server global attributes.

[[_pics_360]]
====== link:#_pics_360[]PICS

* DISHM.S

[[_required_devices_361]]
====== link:#_required_devices_361[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_290]]
====== link:#_device_topology_290[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_311]]
====== link:#_test_setup_311[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_361]]
====== link:#_test_procedure_361[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

* bit 0: SHALL be 1 if and only if DISHM.S.F00(DEPONOFF)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if DISHM.S.A0002(StartUpMode)

The list include entries based on feature support: +

* 0x0003 SHALL be included if and only if DISHM.S.F00(DEPONOFF)

and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute with a
list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +

0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +

0x01

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_274]]
====== link:#_notestesting_considerations_274[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_tc_dishm_1_2_cluster_attributes_with_dut_as_server]]
===== link:#_tc_dishm_1_2_cluster_attributes_with_dut_as_server[]194.1.2. [TC-DISHM-1.2] Cluster attributes with DUT as Server

[[_category_356]]
====== link:#_category_356[]Category

Functional.

[[_purpose_362]]
====== link:#_purpose_362[]Purpose

This test case verifies the non-global attributes of the Dishwasher Mode
cluster server.

[[_pics_361]]
====== link:#_pics_361[]PICS

* DISHM.S

[[_required_devices_362]]
====== link:#_required_devices_362[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_291]]
====== link:#_device_topology_291[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_312]]
====== link:#_test_setup_312[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_362]]
====== link:#_test_procedure_362[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8, AC.8.4.5 |DISHM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has at least 2 and at most 255 entries
* Verify that each ModeOptionsStruct entry has a unique Mode field value
* Verify that each ModeOptionsStruct entry has a unique Label field
value
* Verify that each ModeOptionsStruct entry’s ModeTags field, if not
empty, has:
+
** the values of the Value fields that are not larger than 16 bits
** for each Value field: Is the mode tag value a defined common tag
value (Auto(0x0000), Quick(0x0001), Quiet(0x0002), LowNoise(0x0003),
LowEnergy(0x0004), Vacation(0x0005), Min(0x0006), Max(0x0007),
Night(0x0008), Day(0x0009)) or a defined cluster-derived tag value
(Normal, Heavy, Light) or in the MfgTags (0x8000 to 0xBFFF) range
** if the Value field is in the MfgTags (0x8000 to 0xBFFF) range, the
TagName field is a string with a length between 1 and 64
* Verify that at least one ModeOptionsStruct entry includes the Normal
mode tag
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut`

|4 |AC.1.9.6.4 |DISHM.S.A0003(OnMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|5 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|===

[[_notestesting_considerations_275]]
====== link:#_notestesting_considerations_275[]Notes/Testing Considerations

. Step 2 - The mode tag values may be standard (if from the CommonTags
range) or manufacturer specific (if from the MfgTags range). Refer to
the manufacturer documentation for details regarding the MfgTags values.

[[_changetomode_test_cases_5]]
==== link:#_changetomode_test_cases_5[]194.2. ChangeToMode Test Cases

'''''

[[_tc_dishm_2_1_change_to_mode_functionality_with_dut_as_server]]
===== link:#_tc_dishm_2_1_change_to_mode_functionality_with_dut_as_server[]194.2.1. [TC-DISHM-2.1] Change to Mode functionality with DUT as Server

[[_category_357]]
====== link:#_category_357[]Category

Functional conformance

[[_purpose_363]]
====== link:#_purpose_363[]Purpose

This test case verifies the functionality associated with the
ChangeToMode command.

[[_pics_362]]
====== link:#_pics_362[]PICS

* DISHM.S

[[_required_devices_363]]
====== link:#_required_devices_363[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_292]]
====== link:#_device_topology_292[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_313]]
====== link:#_test_setup_313[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_363]]
====== link:#_test_procedure_363[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8 |DISHM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* Select a value which is NOT in `supported_modes_dut` and save it as
`invalid_mode_th`

|4 |AC.1.9.7.1, AC.1.9.7.2 |DISHM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`old_current_mode_dut`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|5 | |DISHM.S.M.CAN_TEST_MODE_FAILURE a|
Manually put the device in a state from which it will FAIL to transition
to PIXIT.DISHM.MODE_CHANGE_FAIL

a|

|6 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|7 |AC.1.9.7.1, AC.1.9.7.2 |DISHM.S.M.CAN_TEST_MODE_FAILURE &
DISHM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.DISHM.MODE_CHANGE_FAIL

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to GenericFailure(0x02) or in the
MfgCodes (0x80 to 0xBF) range
* Verify that the StatusText field has a length between 1 and 64

|8 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
`old_current_mode_dut`

|9 | | a|
Manually put the device in a state from which it will SUCCESSFULLY
transition to PIXIT.DISHM.MODE_CHANGE_OK

a|

|10 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|11 |AC.1.9.7.1, AC.1.9.7.2 |DISHM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.DISHM.MODE_CHANGE_OK

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to Success(0x00)

|12 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.DISHM.MODE_CHANGE_OK

|13 |AC.1.9.7.1, AC.1.9.7.2 |DISHM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`invalid_mode_th`

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to UnsupportedMode(0x01).

|14 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.DISHM.MODE_CHANGE_OK

|===

[[_notestesting_considerations_276]]
====== link:#_notestesting_considerations_276[]Notes/Testing Considerations

[[_onoff_and_startup_mode_test_cases_5]]
==== link:#_onoff_and_startup_mode_test_cases_5[]194.3. On/Off and StartUp Mode Test Cases

'''''

[[_tc_dishm_3_1_on_mode_functionality_with_dut_as_server]]
===== link:#_tc_dishm_3_1_on_mode_functionality_with_dut_as_server[]194.3.1. [TC-DISHM-3.1] On Mode functionality with DUT as Server

[[_category_358]]
====== link:#_category_358[]Category

Functional conformance

[[_purpose_364]]
====== link:#_purpose_364[]Purpose

This test case verifies that the DUT switches to the proper OnMode when
the On/Off attribute of the On/Off cluster changes.

[[_pics_363]]
====== link:#_pics_363[]PICS

* DISHM.S

[[_preconditions_80]]
====== link:#_preconditions_80[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |Dishwasher Mode and OnOff clusters are available on the same
endpoint |

|2 | |The _OnMode_ attribute is set to a non-NULL value from the mode
values indicated by the _SupportedModes_ attribute. |
|===

[[_required_devices_364]]
====== link:#_required_devices_364[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_293]]
====== link:#_device_topology_293[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_314]]
====== link:#_test_setup_314[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_364]]
====== link:#_test_procedure_364[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.4 |DISHM.S.A0003(OnMode), DISHM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `on_mode_dut`

|3 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode), DISHM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `on_mode_dut` is equal to `old_current_mode_dut` proceed to step 4.
Else proceed to step 6.

|4 |AC.1.9.6.1 |DISHM.S.A0000(SupportedModes), DISHM.S.F00(DEPONOFF) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`on_mode_dut`. Save the value as `new_mode_th`.

|5 |AC.1.9.7.1, AC.1.9.7.2 |DISHM.S.C00.Rsp(ChangeToMode),
DISHM.S.F00(DEPONOFF) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|6 |AC.1.5.7.1 |OO.S.C00.Rsp DISHM.S.F00(DEPONOFF) a|
TH sends a _Off_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|7 |AC.1.5.7.2 |OO.S.C01.Rsp, DISHM.S.F00(DEPONOFF) a|
TH sends a _On_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode), DISHM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `on_mode_dut`

|===

[[_notestesting_considerations_277]]
====== link:#_notestesting_considerations_277[]Notes/Testing Considerations

[[_tc_dishm_3_2_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_dishm_3_2_startup_mode_functionality_with_dut_as_server[]194.3.2. [TC-DISHM-3.2] Startup Mode functionality with DUT as Server

[[_category_359]]
====== link:#_category_359[]Category

Functional conformance

[[_purpose_365]]
====== link:#_purpose_365[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled.

[[_pics_364]]
====== link:#_pics_364[]PICS

* DISHM.S

[[_preconditions_81]]
====== link:#_preconditions_81[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |!DISHM.S.F00(DEPONOFF) | OnOff cluster’s _StartUpOnOff_ attribute
is NULL | _StartUpOnOff_ is 0 | _OnMode_ is NULL |
|===

[[_required_devices_365]]
====== link:#_required_devices_365[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_294]]
====== link:#_device_topology_294[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_315]]
====== link:#_test_setup_315[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_365]]
====== link:#_test_procedure_365[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |DISHM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `startup_mode_dut` is equal to `old_current_mode_dut` proceed to
step 6. Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |DISHM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.7.1, AC.1.9.7.2 |DISHM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|8 | | a|
Physically power cycle the device

a|

|9 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_start_up_mode_dut`
* The value is equal to `new_start_up_mode_th`

|10 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_dut`

|===

[[_notestesting_considerations_278]]
====== link:#_notestesting_considerations_278[]Notes/Testing Considerations

[[_tc_dishm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_dishm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[]194.3.3. [TC-DISHM-3.3] On Mode and Startup Mode functionality with DUT as Server

[[_category_360]]
====== link:#_category_360[]Category

Functional conformance

[[_purpose_366]]
====== link:#_purpose_366[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled, if the device supports OnMode, and StartUpOnOff (from the
OnOff cluster).

[[_pics_365]]
====== link:#_pics_365[]PICS

* DISHM.S

[[_required_devices_366]]
====== link:#_required_devices_366[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_295]]
====== link:#_device_topology_295[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_316]]
====== link:#_test_setup_316[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_366]]
====== link:#_test_procedure_366[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |DISHM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.4 |DISHM.S.A0003(OnMode), DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_on_mode_dut`
* If `startup_mode_dut` is equal to `old_on_mode_dut` proceed to step 6.
Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |DISHM.S.A0000(SupportedModes),
DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.6.4 |DISHM.S.A0003(OnMode) a|
TH writes to the DUT the _OnMode_ attribute with the `new_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.4 |DISHM.S.A0003(OnMode), DISHM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_on_mode_dut`
* The value is equal to `new_mode_th`

|9 |AC.1.5.6.5 |OO.S.A4003 a|
TH writes to the DUT the _StartUpOnOff_ attribute with the value 1.

a|
Verify DUT responds w/ status SUCCESS(0x00)

|10 | | a|
Physically power cycle the device

a|

|11 |AC.1.9.6.3 |DISHM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_th`

|12 |AC.1.9.6.2 |DISHM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_on_mode_dut`

|===

[[_notestesting_considerations_279]]
====== link:#_notestesting_considerations_279[]Notes/Testing Considerations

[[_dishwasher_alarm_cluster_test_plan]]
== link:#_dishwasher_alarm_cluster_test_plan[]**Dishwasher Alarm Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|1.0 |29-May-2023 |`Rob Bultman` |Initial test plan

|1.0.1 |15-Aug-2023 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_57]]
=== link:#_pics_definition_57[]195. PICS Definition

This section covers the Dishwasher Alarm Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_59]]
==== link:#_role_59[]195.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHALM.S |Does the device implement the Dishwasher Alarm cluster as a
server? |O |

|DISHALM.C |Does the device implement the Dishwasher Alarm cluster as a
client? |O |
|===

[[_server_70]]
==== link:#_server_70[]195.2. Server

[[_features_43]]
===== link:#_features_43[]195.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHALM.S.F00(Reset) |Does the device support the _Reset_ command |O |
|===

[[_attributes_63]]
===== link:#_attributes_63[]195.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHALM.S.A0000(Mask) |Does the device implement the _Mask_ attribute?
|M |

|DISHALM.S.A0001(Latch) |Does the device implement the _Latch_
attribute? |_Reset_ |

|DISHALM.S.A0002(State) |Does the device implement the _State_
attribute? |M |

|DISHALM.S.A0003(Supported) |Does the device implement the _Supported_
attribute? |M |
|===

[[_manual_controllable_22]]
===== link:#_manual_controllable_22[]195.2.3. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHALM.S.M.ManuallyControlled |Can the Dishwasher Alarm attribute
changed by physical control at the device? |O |

|DISHALM.S.M.InflowAlarmSupported |Does the device support the Inflow
alarm? |O.a+ |

|DISHALM.S.M.DrainAlarmSupported |Does the device support the Drain
alarm? |O.a+ |

|DISHALM.S.M.DoorAlarmSupported |Does the device support the Door alarm?
|O.a+ |

|DISHALM.S.M.TempLowAlarmSupported |Does the device support the TempLow
alarm? |O.a+ |

|DISHALM.S.M.TempHighAlarmSupported |Does the device support the
TempHigh alarm? |O.a+ |

|DISHALM.S.M.WaterLevelAlarmSupported |Does the device support the
WaterLevel alarm? |O.a+ |
|===

[[_events_12]]
===== link:#_events_12[]195.2.4. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHALM.S.E00(Notify) |Does the device implement the _Notify_ event_?
|M |
|===

[[_commands_received_31]]
===== link:#_commands_received_31[]195.2.5. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|DISHALM.S.C00.Rsp(Reset) |Does the device implement receiving the
_Reset_ command? |Reset |

|DISHALM.S.C01.Rsp(ModifyEnabledAlarms) |Does the device implement
receiving the _ModifyEnabledAlarms_ command? |O |
|===

[[_test_case_list_59]]
=== link:#_test_case_list_59[]196. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-DISHALM-1.1 |Global attributes with DUT as Server
|TC-DISHALM-2.1 |Attributes with DUT as Server
|TC-DISHALM-3.1 |Inflow alarm functionality with DUT as Server
|TC-DISHALM-3.2 |Drain alarm functionality with DUT as Server
|TC-DISHALM-3.3 |Door alarm functionality with DUT as Server
|TC-DISHALM-3.4 |Temperature Low alarm functionality with DUT as Server
|TC-DISHALM-3.5 |Temperature High alarm functionality with DUT as Server
|TC-DISHALM-3.6 |Water Level alarm functionality with DUT as Server
|===

[[_test_cases_59]]
=== link:#_test_cases_59[]197. Test Cases

'''''

[[_generic_test_cases_51]]
==== link:#_generic_test_cases_51[]197.1. Generic test cases

'''''

[[_tc_dishalm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_dishalm_1_1_global_attributes_with_dut_as_server[]197.1.1. [TC-DISHALM-1.1] Global attributes with DUT as Server

[[_category_361]]
====== link:#_category_361[]Category

Functional conformance

[[_purpose_367]]
====== link:#_purpose_367[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_366]]
====== link:#_pics_366[]PICS

* DISHALM.S

[[_required_devices_367]]
====== link:#_required_devices_367[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_296]]
====== link:#_device_topology_296[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_317]]
====== link:#_test_setup_317[]Test Setup

Commission DUT to TH

[[_test_procedure_367]]
====== link:#_test_procedure_367[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if DISHALM.S.F00(Reset) +

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0002, 0x0003, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list include entries based on feature support: +
- 0x0001: SHALL be included if and only if DISHALM.S.F00(Reset).

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

The list SHALL include all the mandatory entries: +
0x00

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list MAY include these optional entries: +
- 0x01: SHALL be included if and only if
DISHALM.S.C01.Rsp(ModifyEnabledAlarms) +

The list include entries based on feature support: +
- 0x00: SHALL be included if and only if DISHALM.S.C00.Rsp(Reset)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_280]]
====== link:#_notestesting_considerations_280[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut_28]]
==== link:#_server_as_dut_28[]197.2. Server as DUT

[[_tc_dishalm_2_1_attributes_with_dut_as_server]]
===== link:#_tc_dishalm_2_1_attributes_with_dut_as_server[]197.2.1. [TC-DISHALM-2.1] Attributes with DUT as Server

[[_category_362]]
====== link:#_category_362[]Category

Functional conformance

[[_purpose_368]]
====== link:#_purpose_368[]Purpose

This test case verifies that the DUT can respond to Dishwasher Alarm
cluster attribute read commands.

[[_pics_367]]
====== link:#_pics_367[]PICS

* DISHALM.S

[[_required_devices_368]]
====== link:#_required_devices_368[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_297]]
====== link:#_device_topology_297[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_318]]
====== link:#_test_setup_318[]Test Setup

Commission DUT to TH

[[_test_procedure_368]]
====== link:#_test_procedure_368[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |DISHALM.S.A0000(Mask) |TH reads from the DUT the _Mask_ attribute
|Verify that the DUT response contains a 32-bit value.

|3 | |DISHALM.S.F00(Reset)& DISHALM.S.A0001(Latch) |TH reads from the
DUT the _Latch_ attribute |Verify that the DUT response contains a
32-bit value.

|4 | |DISHALM.S.A0002(State) |TH reads from the DUT the _State_
attribute |Verify that the DUT response contains a 32-bit value.

|4 | |DISHALM.S.A0003(Supported) |TH reads from the DUT the _Supported_
attribute |Verify that the DUT response contains a 32-bit value.
|===

[[_tc_dishalm_3_1_inflow_alarm_functionality_with_dut_as_server]]
===== link:#_tc_dishalm_3_1_inflow_alarm_functionality_with_dut_as_server[]197.2.2. [TC-DISHALM-3.1] Inflow alarm functionality with DUT as Server

[[_category_363]]
====== link:#_category_363[]Category

Functional

[[_purpose_369]]
====== link:#_purpose_369[]Purpose

This test case verifies the optional Inflow functionality of the
Dishwasher Alarm cluster server.

[[_pics_368]]
====== link:#_pics_368[]PICS

* DISHALM.S
* DISHALM.S.M.InflowAlarmSupported

[[_required_devices_369]]
====== link:#_required_devices_369[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_298]]
====== link:#_device_topology_298[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_319]]
====== link:#_test_setup_319[]Test Setup

Commission DUT to TH

[[_test_procedure_369]]
====== link:#_test_procedure_369[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | | |Commission DUT to TH |

|1b | |DISHALM.S.E00(Notify) |Set up subscription to _Notify_ event |

|1c | |DISHALM.S.A0001(Latch) |TH reads from the DUT the _Latch_
attribute. |Save the value returned in the response as LatchResponse.

|1d | |!DISHALM.S.A0001(Latch) | |Set the value of LatchResponse to 0.

|2a | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to raise the _Inflow_ alarm |Receive _Notify_ event with State
bit 0 set to TRUE.

|2b | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 0 of response SHALL be 1.

|2c | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to lower the _Inflow_ alarm |Receive _Notify_ event with State
bit 0 set to FALSE if bit 0 in LatchResponse is 0.

|2d | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 0 of response SHALL be 0 if bit 0 of
LatchResponse is 0. +
Bit 0 of response SHALL be 1 if bit 0 of LatchResponse is 1.

|3a | |DISHALM.S.F00(Reset)& DISHALM.S.C00.Rsp(Reset) |TH sends command
_Reset_ to DUT with bit 0 (Inflow) of Alarms set to 1 |Receive _Notify_
event with State bit 0 set to FALSE if bit 0 of LatchResponse is 1.

|3b | |DISHALM.S.F00(Reset)& DISHALM.S.A0002(State) |After a few
seconds, TH reads from the DUT the _State_ attribute |Bit 0 of response
SHALL be 0.
|===

[[_tc_dishalm_3_2_drain_alarm_functionality_with_dut_as_server]]
===== link:#_tc_dishalm_3_2_drain_alarm_functionality_with_dut_as_server[]197.2.3. [TC-DISHALM-3.2] Drain alarm functionality with DUT as Server

[[_category_364]]
====== link:#_category_364[]Category

Functional

[[_purpose_370]]
====== link:#_purpose_370[]Purpose

This test case verifies the optional Drain functionality of the
Dishwasher Alarm cluster server.

[[_pics_369]]
====== link:#_pics_369[]PICS

* DISHALM.S
* DISHALM.S.M.DrainAlarmSupported

[[_required_devices_370]]
====== link:#_required_devices_370[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_299]]
====== link:#_device_topology_299[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_320]]
====== link:#_test_setup_320[]Test Setup

Commission DUT to TH

[[_test_procedure_370]]
====== link:#_test_procedure_370[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | | |Commission DUT to TH |

|1b | |DISHALM.S.E00(Notify) |Set up subscription to _Notify_ event |

|1c | |DISHALM.S.A0001(Latch) |TH reads from the DUT the _Latch_
attribute. |Save the value returned in the response as LatchResponse.

|1d | |!DISHALM.S.A0001(Latch) | |Set the value of LatchResponse to 0.

|2a | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to raise the _Drain_ alarm |Receive _Notify_ event with State
bit 1 set to TRUE.

|2b | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 1 of response SHALL be 1.

|2c | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to lower the _Drain_ alarm |Receive _Notify_ event with State
bit 1 set to FALSE if bit 1 in LatchResponse is 0.

|2d | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 1 of response SHALL be 0 if bit 1 of
LatchResponse is 0. +
Bit 1 of response SHALL be 1 if bit 1 of LatchResponse is 1.

|3a | |DISHALM.S.F00(Reset)& DISHALM.S.C00.Rsp(Reset) |TH sends command
_Reset_ to DUT with bit 1 (Drain) of Alarms set to 1 |Receive _Notify_
event with State bit 1 set to FALSE if bit 1 of LatchResponse is 1.

|3b | |DISHALM.S.F00(Reset)& DISHALM.S.A0002(State) |After a few
seconds, TH reads from the DUT the _State_ attribute |Bit 1 of response
SHALL be 0.
|===

[[_tc_dishalm_3_3_door_alarm_functionality_with_dut_as_server]]
===== link:#_tc_dishalm_3_3_door_alarm_functionality_with_dut_as_server[]197.2.4. [TC-DISHALM-3.3] Door alarm functionality with DUT as Server

[[_category_365]]
====== link:#_category_365[]Category

Functional

[[_purpose_371]]
====== link:#_purpose_371[]Purpose

This test case verifies the optional Door functionality of the
Dishwasher Alarm cluster server.

[[_pics_370]]
====== link:#_pics_370[]PICS

* DISHALM.S
* DISHALM.S.M.DoorAlarmSupported

[[_required_devices_371]]
====== link:#_required_devices_371[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_300]]
====== link:#_device_topology_300[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_321]]
====== link:#_test_setup_321[]Test Setup

Commission DUT to TH

[[_test_procedure_371]]
====== link:#_test_procedure_371[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | | |Commission DUT to TH |

|1b | |DISHALM.S.E00(Notify) |Set up subscription to _Notify_ event |

|1c | |DISHALM.S.A0001(Latch) |TH reads from the DUT the _Latch_
attribute. |Save the value returned in the response as LatchResponse.

|1d | |!DISHALM.S.A0001(Latch) | |Set the value of LatchResponse to 0.

|2a | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to raise the _Door_ alarm |Receive _Notify_ event with State
bit 2 set to TRUE.

|2b | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 2 of response SHALL be 1.

|2c | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to lower the _Door_ alarm |Receive _Notify_ event with State
bit 2 set to FALSE if bit 2 in LatchResponse is 0.

|2d | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 2 of response SHALL be 0 if bit 2 of
LatchResponse is 0. +
Bit 2 of response SHALL be 1 if bit 2 of LatchResponse is 1.

|3a | |DISHALM.S.F00(Reset)& DISHALM.S.C00.Rsp(Reset) |TH sends command
_Reset_ to DUT with bit 2 (Door) of Alarms set to 1 |Receive _Notify_
event with State bit 2 set to FALSE if bit 2 of LatchResponse is 1.

|3b | |DISHALM.S.F00(Reset)& DISHALM.S.A0002(State) |After a few
seconds, TH reads from the DUT the _State_ attribute |Bit 2 of response
SHALL be 0.
|===

[[_tc_dishalm_3_4_temperature_low_alarm_functionality_with_dut_as_server]]
===== link:#_tc_dishalm_3_4_temperature_low_alarm_functionality_with_dut_as_server[]197.2.5. [TC-DISHALM-3.4] Temperature Low alarm functionality with DUT as Server

[[_category_366]]
====== link:#_category_366[]Category

Functional

[[_purpose_372]]
====== link:#_purpose_372[]Purpose

This test case verifies the optional TempLow functionality of the
Dishwasher Alarm cluster server.

[[_pics_371]]
====== link:#_pics_371[]PICS

* DISHALM.S
* DISHALM.S.M.TempLowAlarmSupported

[[_required_devices_372]]
====== link:#_required_devices_372[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_301]]
====== link:#_device_topology_301[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_322]]
====== link:#_test_setup_322[]Test Setup

Commission DUT to TH

[[_test_procedure_372]]
====== link:#_test_procedure_372[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | | |Commission DUT to TH |

|1b | |DISHALM.S.E00(Notify) |Set up subscription to _Notify_ event |

|1c | |DISHALM.S.A0001(Latch) |TH reads from the DUT the _Latch_
attribute. |Save the value returned in the response as LatchResponse.

|1d | |!DISHALM.S.A0001(Latch) | |Set the value of LatchResponse to 0.

|2a | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to raise the _TempLow_ alarm |Receive _Notify_ event with
State bit 3 set to TRUE.

|2b | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 3 of response SHALL be 1.

|2c | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to lower the _TempLow_ alarm |Receive _Notify_ event with
State bit 3 set to FALSE if bit 3 in LatchResponse is 0.

|2d | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 3 of response SHALL be 0 if bit 3 of
LatchResponse is 0. +
Bit 3 of response SHALL be 1 if bit 3 of LatchResponse is 1.

|3a | |DISHALM.S.F00(Reset)& DISHALM.S.C00.Rsp(Reset) |TH sends command
_Reset_ to DUT with bit 3 (TempLow) of Alarms set to 1 |Receive _Notify_
event with State bit 3 set to FALSE if bit 3 of LatchResponse is 1.

|3b | |DISHALM.S.F00(Reset)& DISHALM.S.A0002(State) |After a few
seconds, TH reads from the DUT the _State_ attribute |Bit 3 of response
SHALL be 0.
|===

[[_tc_dishalm_3_5_temperature_high_alarm_functionality_with_dut_as_server]]
===== link:#_tc_dishalm_3_5_temperature_high_alarm_functionality_with_dut_as_server[]197.2.6. [TC-DISHALM-3.5] Temperature High alarm functionality with DUT as Server

[[_category_367]]
====== link:#_category_367[]Category

Functional

[[_purpose_373]]
====== link:#_purpose_373[]Purpose

This test case verifies the optional TempHigh functionality of the
Dishwasher Alarm cluster server.

[[_pics_372]]
====== link:#_pics_372[]PICS

* DISHALM.S
* DISHALM.S.M.TempHighAlarmSupported

[[_required_devices_373]]
====== link:#_required_devices_373[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_302]]
====== link:#_device_topology_302[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_323]]
====== link:#_test_setup_323[]Test Setup

Commission DUT to TH

[[_test_procedure_373]]
====== link:#_test_procedure_373[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | | |Commission DUT to TH |

|1b | |DISHALM.S.E00(Notify) |Set up subscription to _Notify_ event |

|1c | |DISHALM.S.A0001(Latch) |TH reads from the DUT the _Latch_
attribute. |Save the value returned in the response as LatchResponse.

|1d | |!DISHALM.S.A0001(Latch) | |Set the value of LatchResponse to 0.

|2a | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to raise the _TempHigh_ alarm |Receive _Notify_ event with
State bit 4 set to TRUE.

|2b | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 4 of response SHALL be 1.

|2c | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to lower the _TempHigh_ alarm |Receive _Notify_ event with
State bit 4 set to FALSE if bit 4 in LatchResponse is 0.

|2d | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 4 of response SHALL be 0 if bit 4 of
LatchResponse is 0. +
Bit 4 of response SHALL be 1 if bit 4 of LatchResponse is 1.

|3a | |DISHALM.S.F00(Reset)& DISHALM.S.C00.Rsp(Reset) |TH sends command
_Reset_ to DUT with bit 4 (TempHigh) of Alarms set to 1 |Receive
_Notify_ event with State bit 4 set to FALSE if bit 4 of LatchResponse
is 1.

|3b | |DISHALM.S.F00(Reset)& DISHALM.S.A0002(State) |After a few
seconds, TH reads from the DUT the _State_ attribute |Bit 4 of response
SHALL be 0.
|===

[[_tc_dishalm_3_6_water_level_alarm_functionality_with_dut_as_server]]
===== link:#_tc_dishalm_3_6_water_level_alarm_functionality_with_dut_as_server[]197.2.7. [TC-DISHALM-3.6] Water Level alarm functionality with DUT as Server

[[_category_368]]
====== link:#_category_368[]Category

Functional

[[_purpose_374]]
====== link:#_purpose_374[]Purpose

This test case verifies the optional WaterLevel functionality of the
Dishwasher Alarm cluster server.

[[_pics_373]]
====== link:#_pics_373[]PICS

* DISHALM.S
* DISHALM.S.M.WaterLevelAlarmSupported

[[_required_devices_374]]
====== link:#_required_devices_374[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_303]]
====== link:#_device_topology_303[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_324]]
====== link:#_test_setup_324[]Test Setup

Commission DUT to TH

[[_test_procedure_374]]
====== link:#_test_procedure_374[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1a | | |Commission DUT to TH |

|1b | |DISHALM.S.E00(Notify) |Set up subscription to _Notify_ event |

|1c | |DISHALM.S.A0001(Latch) |TH reads from the DUT the _Latch_
attribute. |Save the value returned in the response as LatchResponse.

|1d | |!DISHALM.S.A0001(Latch) | |Set the value of LatchResponse to 0.

|2a | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to raise the _WaterLevel_ alarm |Receive _Notify_ event with
State bit 5 set to TRUE.

|2b | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 5 of response SHALL be 1.

|2c | |DISHALM.S.M.ManuallyControlled |Operate device to set the
condition to lower the _WaterLevel_ alarm |Receive _Notify_ event with
State bit 5 set to FALSE if bit 5 in LatchResponse is 0.

|2d | |DISHALM.S.A0002(State) |After a few seconds, TH reads from the
DUT the _State_ attribute |Bit 5 of response SHALL be 0 if bit 5 of
LatchResponse is 0. +
Bit 5 of response SHALL be 1 if bit 5 of LatchResponse is 1.

|3a | |DISHALM.S.F00(Reset)& DISHALM.S.C00.Rsp(Reset) |TH sends command
_Reset_ to DUT with bit 5 (WaterLevel) of Alarms set to 1 |Receive
_Notify_ event with State bit 5 set to FALSE if bit 5 of LatchResponse
is 1.

|3b | |DISHALM.S.F00(Reset)& DISHALM.S.A0002(State) |After a few
seconds, TH reads from the DUT the _State_ attribute |Bit 5 of response
SHALL be 0.
|===

[[_operational_state_cluster_test_plan]]
== link:#_operational_state_cluster_test_plan[]**Operational State Cluster Test Plan**

[[_pics_definition_58]]
=== link:#_pics_definition_58[]198. PICS Definition

This section covers the Operational State Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_60]]
==== link:#_role_60[]198.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPSTATE.S |Does the device implement the Operational State cluster as a
server? |O |

|OPSTATE.C |Does the device implement the Operational State cluster as a
client? |O |
|===

[[_server_71]]
==== link:#_server_71[]198.2. Server

[[_attributes_64]]
===== link:#_attributes_64[]198.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPSTATE.S.A0000(PhaseList) |Does the device implement the PhaseList
attribute? |M |

|OPSTATE.S.A0001(CurrentPhase) |Does the device implement the
CurrentPhase attribute? |M |

|OPSTATE.S.A0002(CountdownTime) |Does the device implement the
CountdownTime attribute? |O |

|OPSTATE.S.A0003(OperationalStateList) |Does the device implement the
OperationalStateList attribute? |M |

|OPSTATE.S.A0004(OperationalState) |Does the device implement the
OperationalState attribute? |M |

|OPSTATE.S.A0005(OperationalError) |Does the device implement the
OperationalError attribute? |M |
|===

[[_commands_received_32]]
===== link:#_commands_received_32[]198.2.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPSTATE.S.C00.Rsp(Pause) |Does the device implement receiving the Pause
command? |O |

|OPSTATE.S.C01.Rsp(Stop) |Does the device implement receiving the Stop
command? |O |

|OPSTATE.S.C02.Rsp(Start) |Does the device implement receiving the Start
command? |O |

|OPSTATE.S.C03.Rsp(Resume) |Does the device implement receiving the
Resume command? |O |
|===

[[_commands_generated_31]]
===== link:#_commands_generated_31[]198.2.3. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPSTATE.S.C04.Tx(OperationalCommandResponse) |Does the device implement
generating the OperationalCommandResponse command?
|OPSTATE.S.C00.Rsp(Pause) | OPSTATE.S.C01.Rsp(Stop) |
OPSTATE.S.C02.Rsp(Start) | OPSTATE.S.C03.Rsp(Resume) |
|===

[[_events_13]]
===== link:#_events_13[]198.2.4. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPSTATE.S.E00(OperationalError) |Does the device implement the
OperationalError Event ? |M |

|OPSTATE.S.E01(OperationCompletion) |Does the device implement the
OperationCompletion Event ? |O |
|===

[[_manual_controllable_23]]
===== link:#_manual_controllable_23[]198.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|OPSTATE.S.M.ST_STOPPED |Does the DUT support testing the Stopped(0x00)
operational state? |O |Declared by manufacturer

|OPSTATE.S.M.ST_RUNNING |Does the DUT support testing the Running(0x01)
operational state? |O |Declared by manufacturer

|OPSTATE.S.M.ST_PAUSED |Does the DUT support testing the Paused(0x02)
operational state? |O |Declared by manufacturer

|OPSTATE.S.M.ST_ERROR |Does the DUT support testing the Error(0x03)
operational state? |O |Declared by manufacturer

|OPSTATE.S.M.ERR_NO_ERROR |Does the DUT support testing the
NoError(0x00) error state? |O |Declared by manufacturer

|OPSTATE.S.M.ERR_UNABLE_TO_START_OR_RESUME |Does the DUT support testing
the UnableToStartOrResume(0x01) error state? |O |Declared by
manufacturer

|OPSTATE.S.M.ERR_UNABLE_TO_COMPLETE_OPERATION |Does the DUT support
testing the UnableToCompleteOperation(0x02) error state? |O |Declared by
manufacturer

|OPSTATE.S.M.ERR_COMMAND_INVALID_IN_STATE |Does the DUT support testing
the CommandInvalidInState(0x03) error state? |O |Declared by
manufacturer
|===

[[_pixit_definition_14]]
=== link:#_pixit_definition_14[]199. PIXIT Definition

This section covers the Operational State’s Test Plan related PIXIT
items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.OPSTATE.ErrorEventGen |Boolean indicating whether manual or app
stimulation on the DUT to generate an OperationalError is supported |M |
|===

[[_test_case_list_60]]
=== link:#_test_case_list_60[]200. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*
|TC-OPSTATE-1.1 |Global Attributes with DUT as Server
|TC-OPSTATE-2.1 |Attributes with DUT as Server
|TC-OPSTATE-2.2 |Start and Stop Commands with DUT as Server
|TC-OPSTATE-2.3 |Pause and Resume Commands with DUT as Server
|TC-OPSTATE-2.4 |Mandatory Events with DUT as Server
|===

[[_test_cases_60]]
=== link:#_test_cases_60[]201. Test Cases

'''''

[[_generic_test_cases_52]]
==== link:#_generic_test_cases_52[]201.1. Generic test cases

'''''

[[_tc_opstate_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_opstate_1_1_global_attributes_with_dut_as_server[]201.1.1. [TC-OPSTATE-1.1] Global Attributes with DUT as Server

[[_category_369]]
====== link:#_category_369[]Category

Functional conformance

[[_purpose_375]]
====== link:#_purpose_375[]Purpose

This test case verifies the global attributes of the cluster server

[[_pics_374]]
====== link:#_pics_374[]PICS

* OPSTATE.S

[[_required_devices_375]]
====== link:#_required_devices_375[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_375]]
====== link:#_test_procedure_375[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute |Verify
that the DUT response contains the _FeatureMap_ attribute with the value
0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute a|
Verify that the DUT response contains the _AttributeList_ attribute with
the list of supported attributes

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0003, 0x0004, 0x0005, 0xfff8, 0xfff9, 0xfffb, 0xfffc &
0xfffd

The list MAY include these optional entries: +
- 0x0002 SHALL be included if and only if OPSTATE.S.A0002(CountdownTime)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute a|
Verify that the DUT response contains the _EventList_ attribute with the
list of supported events

\{mandatory entries} +
- 0x00

\{optional entries} +
- 0x01: SHALL be included if and only if
OPSTATE.S.E01(OperationCompletion)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute with the list of Accepted Commands:

The list MAY include these optional entries: +

- 0x00 SHALL be included if OPSTATE.S.C00.Rsp(Pause) or SHALL be
included if OPSTATE.S.C03.Rsp(Resume)

- 0x01 SHALL be included if OPSTATE.S.C01.Rsp(Stop) or SHALL be included
if OPSTATE.S.C02.Rsp(Start)

- 0x02 SHALL be included if and only if OPSTATE.S.C02.Rsp(Start)

- 0x03 SHALL be included if OPSTATE.S.C03.Rsp(Resume) or SHALL be
included if OPSTATE.S.C00.Rsp(Pause)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute with the list of Generated Commands:

The list MAY include these optional entries: +

- 0x04 SHALL be included if OPSTATE.S.C00.Rsp(Pause) or
OPSTATE.S.C01.Rsp(Stop) or OPSTATE.S.C02.Rsp(Start) or
OPSTATE.S.C03.Rsp(Resume).

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_281]]
====== link:#_notestesting_considerations_281[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_29]]
==== link:#_server_as_dut_29[]201.2. Server as DUT

'''''

[[_tc_opstate_2_1_attributes_with_dut_as_server]]
===== link:#_tc_opstate_2_1_attributes_with_dut_as_server[]201.2.1. [TC-OPSTATE-2.1] Attributes with DUT as Server

[[_category_370]]
====== link:#_category_370[]Category

Functional conformance

[[_purpose_376]]
====== link:#_purpose_376[]Purpose

This test case verifies the Operational State Cluster attributes with
server as DUT

[[_pics_375]]
====== link:#_pics_375[]PICS

* OPSTATE.S

[[_required_devices_376]]
====== link:#_required_devices_376[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_376]]
====== link:#_test_procedure_376[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 |1.12.6 |OPSTATE.S.A0000(PhaseList) |TH reads from the DUT the
_PhaseList_ attribute |Verify that the DUT response contains a list of
strings, no more than 32 or null. Record 'phase-list-size', the number
of entries in the list if not null or an empty list, for use in step 3.

|3 |1.12.6 |OPSTATE.S.A0001(CurrentPhase) |TH reads from the DUT the
_CurrentPhase_ attribute |Verify that the DUT response contains a uint8
value or null. This shall only be null if _PhaseList_ is also null or an
empty list. If not null or an empty list, ensure that it is equal to a
value between 0 and 'phase-list-size' minus 1.

|4 |1.12.6 |OPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains an
instance of elapsed-s (derived from uint32) or null. If not null, Value
has to be between a range of 0 to 259200.

|5 |1.12.6 |OPSTATE.S.A0003(OperationalStateList) |TH reads from the DUT
the _OperationalStateList_ attribute |Verify that the DUT response
contains a list of states (each being an instance of
OperationalStateStruct). Each struct shall contain an OperationalStateID
(enum8 that defines the state) and an OperationalStateLabel, which is a
user understandable string describing the state. For each instance of an
OperationalStateID, verify the OperationalStateID is a defined state
(Stopped(0x00), Running(0x01), Paused(0x02), Error(0x03)) or in the
range 0x80 to 0xBF. The list shall include a struct with an
OperationalStateID of Error(0x03).

|6 |1.12.6 |OPSTATE.S.A0004(OperationalState) |TH reads from the DUT the
_OperationalState_ attribute |Verify that the DUT response contains an
instance of enum8. This is an OperationalStateID (value that defines the
state) from the set of OperationalStateIDs in the list of structs
returned in step 5. Verify the OperationalStateID is a defined state
(Stopped(0x00), Running(0x01), Paused(0x02), Error(0x03)) or in the
range 0x80 to 0xBF.

|6a |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_STOPPED
a|
manually put the device in the Stopped(0x00) operational state

a|

|6b |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_STOPPED
a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Stopped(0x00)

|6c |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_RUNNING
a|
manually put the device in the Running(0x01) operational state

a|

|6d |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_RUNNING
a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Running(0x01)

|6e |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_PAUSED
a|
manually put the device in the Paused(0x02) operational state

a|

|6f |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_PAUSED
a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Paused(0x02)

|6g |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_ERROR a|
manually put the device in the Error(0x03) operational state

a|

|6h |1.12.6 |OPSTATE.S.A0004(OperationalState) & OPSTATE.S.M.ST_ERROR a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Error(0x03)

|7 |1.12.6 |OPSTATE.S.A0005(OperationalError) |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. +
This shall contain an ErrorStateId (enum8 value that defines the
error). +
If the ErrorStateId is in the range 0x80 to 0xBF then an
ErrorStateLabel, which is a user understandable string describing the
state which may be empty. +
If the ErrorStateId is not in the range 0x80 to 0xBF then no
ErrorStateLabel shall be present. +
Optionally an ErrorStateDetails, which is an additional user
understandable string. +
Verify the ErrorStateID is a defined error (NoError(0x00),
UnableToStartOrResume(0x01), UnableToCompleteOperation(0x02),
CommandInvalidInState(0x03)) or in the range 0x80 to 0xBF.

|7a |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_NO_ERROR |manually put the device in the NoError(0x00)
error state |

|7b |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_NO_ERROR |TH reads from the DUT the _OperationalError_
attribute |Verify that the DUT response contains an instance of
ErrorStateStruct. This shall contain an ErrorStateId with a value of
NoError(0x00)

|7c |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_UNABLE_TO_START_OR_RESUME |manually put the device in
the UnableToStartOrResume(0x01) error state |

|7d |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_UNABLE_TO_START_OR_RESUME |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of UnableToStartOrResume(0x01)

|7e |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_UNABLE_TO_COMPLETE_OPERATION |manually put the device in
the UnableToCompleteOperation(0x02) error state |

|7f |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_UNABLE_TO_COMPLETE_OPERATION |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of UnableToCompleteOperation(0x02)

|7g |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_COMMAND_INVALID_IN_STATE |manually put the device in the
CommandInvalidInState(0x03) error state |

|7h |1.12.6 |OPSTATE.S.A0005(OperationalError) &
OPSTATE.S.M.ERR_COMMAND_INVALID_IN_STATE |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of CommandInvalidInState(0x03)
|===

[[_notestesting_considerations_282]]
====== link:#_notestesting_considerations_282[]Notes/Testing Considerations

[[_tc_opstate_2_2_start_and_stop_commands_with_dut_as_server]]
===== link:#_tc_opstate_2_2_start_and_stop_commands_with_dut_as_server[]201.2.2. [TC-OPSTATE-2.2] Start and Stop commands with DUT as Server

[[_category_371]]
====== link:#_category_371[]Category

Functional

[[_purpose_377]]
====== link:#_purpose_377[]Purpose

This test case verifies the operation of the Start and Stop commands of
the Operational State cluster server.

[[_pics_376]]
====== link:#_pics_376[]PICS

* OPSTATE.S

[[_preconditions_82]]
====== link:#_preconditions_82[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |OPSTATE.S.C02.Rsp(Start) and OPSTATE.S.C01.Rsp(Stop) |
|===

[[_required_devices_377]]
====== link:#_required_devices_377[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_377]]
====== link:#_test_procedure_377[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 | | |Manually put the DUT into a state wherein it can receive a Start
Command |

|3 |1.12.6 |OPSTATE.S.A0003(OperationalStateList) |TH reads from the DUT
the _OperationalStateList_ attribute |Verify that the DUT response
contains a list of states (each being an instance of
OperationalStateStruct). The list shall include structs with the
following OperationalStateIds: Running(0x01), Stopped(0x00), and
Error(0x03).

|4 |1.12.7.3
|OPSTATE.S.C02.Rsp(Start),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Start command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|5 |1.12.7.3 |OPSTATE.S.A0004(OperationalState) |TH reads from the DUT
the _OperationalState_ attribute |Verify that the DUT response contains
an enum8 set to Running(0x01).

|6 |1.12.7.3 |OPSTATE.S.A0005(OperationalError) |TH reads from the DUT
the _OperationalError_ attribute |Verify that the DUT response contains
the ErrorStateId set to NoError(0x00).

|7 |1.12.6 |OPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains an
integer value, Value has to be between a range of 1 to 259200 or null.
Record this value in 'initial-countdown-time'.

|8 |1.12.6 |OPSTATE.S.A0000(PhaseList) |TH reads from the DUT the
_PhaseList_ attribute |Verify that the DUT response contains a list of
possible phases or null. If null jump to step 10, otherwise record
'phase-list-size', the number of entries in the list and perform step 9.

|9 |1.12.6 |OPSTATE.S.A0001(CurrentPhase) |TH reads from the DUT the
_CurrentPhase_ attribute |Verify that the DUT response contains a uint8
value. Value has to be between a range of 0 to the size of
'phase-list-size' minus 1.

|10 | | |TH waits for a vendor defined wait time, this being a period of
time less than the expected duration of the operation that has been
started |

|11 |1.12.6 |OPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains a
non-zero integer value that is approximately the wait time from step 10
less than 'initial-countdown-time' or null.

|12 |1.12.7.3
|OPSTATE.S.C02.Rsp(Start),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Start command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|13 |1.12.7.2
|OPSTATE.S.C01.Rsp(Stop),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Stop command to the DUT |Verify that the DUT response contains
an instance of OperationalCommandResponse. Verify that the ErrorStateId
field is set to NoError(0x00).

|14 |1.12.7.2 |OPSTATE.S.A0004(OperationalState) |TH reads from the DUT
the _OperationalState_ attribute |Verify that the DUT response contains
an enum8 set to Stopped(0x00).

|15 |1.12.7.2
|OPSTATE.S.C01.Rsp(Stop),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Stop command to the DUT |Verify that the DUT response contains
an instance of OperationalCommandResponse. Verify that the ErrorStateId
field is set to NoError(0x00).

|16 | | |Manually put the DUT into a state wherein it cannot receive a
Start Command |

|17 |1.12.7.3
|OPSTATE.S.C02.Rsp(Start),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Start command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to UnableToStartOrResume(0x01).
|===

[[_notestesting_considerations_283]]
====== link:#_notestesting_considerations_283[]Notes/Testing Considerations

[[_tc_opstate_2_3_pause_and_resume_commands_with_dut_as_server]]
===== link:#_tc_opstate_2_3_pause_and_resume_commands_with_dut_as_server[]201.2.3. [TC-OPSTATE-2.3] Pause and Resume commands with DUT as Server

[[_category_372]]
====== link:#_category_372[]Category

Functional

[[_purpose_378]]
====== link:#_purpose_378[]Purpose

This test case verifies the operation of the Pause and Resume commands
of the Operational State cluster server.

[[_pics_377]]
====== link:#_pics_377[]PICS

* OPSTATE.S

[[_preconditions_83]]
====== link:#_preconditions_83[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |OPSTATE.S.C00.Rsp(Pause) and OPSTATE.S.C03.Rsp(Resume) |
|===

[[_required_devices_378]]
====== link:#_required_devices_378[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_378]]
====== link:#_test_procedure_378[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 | | |Manually put the DUT into a state wherein it can receive a Pause
Command |

|3 |1.12.6 |OPSTATE.S.A0003(OperationalStateList) |TH reads from the DUT
the _OperationalStateList_ attribute |Verify that the DUT response
contains a list of states (each being an instance of
OperationalStateStruct). The list shall include structs with the
following OperationalStateIds: Running(0x01), Paused(0x02), and
Error(0x03).

|4 |1.12.7.1
|OPSTATE.S.C00.Rsp(Pause),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Pause command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|5 |1.12.7.1 |OPSTATE.S.A0004(OperationalState) |TH reads from the DUT
the _OperationalState_ attribute |Verify that the DUT response contains
an enum8 set to Paused(0x02).

|6 |1.12.6 |OPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains an
integer value, Value has to be between a range of 1 to 259200 or null.
Record this value in 'initial-countdown-time'.

|7 | | |TH waits for 5 seconds |

|8 |1.12.6 |OPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains a
non-zero integer value that is the same as 'initial-countdown-time' or
null.

|9 |1.12.7.1
|OPSTATE.S.C00.Rsp(Pause),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Pause command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|10 |1.12.7.4
|OPSTATE.S.C03.Rsp(Resume),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Resume command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|11 |1.12.6 |OPSTATE.S.A0004(OperationalState) |TH reads from the DUT
the _OperationalState_ attribute |Verify that the DUT response contains
an enum8 set to Running(0x01).

|12 |1.12.7.4
|OPSTATE.S.C03.Rsp(Resume),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Resume command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|13 | | |Manually put the DUT into a state wherein it cannot receive a
Pause command (e.g. Stopped state) |

|14 |1.12.7.1
|OPSTATE.S.C00.Rsp(Pause),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Pause command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to CommandInvalidInState(0x03).

|15 | | |Manually put the DUT into a state wherein it cannot receive a
Resume command (e.g. Stopped state) |

|16 |1.12.7.4
|OPSTATE.S.C03.Rsp(Resume),OPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Resume command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to CommandInvalidInState(0x03).
|===

[[_notestesting_considerations_284]]
====== link:#_notestesting_considerations_284[]Notes/Testing Considerations

[[_tc_opstate_2_4_mandatory_events_with_dut_as_server]]
===== link:#_tc_opstate_2_4_mandatory_events_with_dut_as_server[]201.2.4. [TC-OPSTATE-2.4] Mandatory Events with DUT as Server

[[_category_373]]
====== link:#_category_373[]Category

Functional

[[_purpose_379]]
====== link:#_purpose_379[]Purpose

This test case verifies the generation and population of the
OperationalError event of the Operational State cluster server.

[[_pics_378]]
====== link:#_pics_378[]PICS

* OPSTATE.S

[[_preconditions_84]]
====== link:#_preconditions_84[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |PIXIT.OPSTATE.ErrorEventGen set to TRUE |
|===

[[_required_devices_379]]
====== link:#_required_devices_379[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_379]]
====== link:#_test_procedure_379[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |OPSTATE.S.E00(OperationalError) |Set up a subscription to the
_OperationalError_ event |

|3 | |OPSTATE.S.E00(OperationalError) |At the DUT take the vendor
defined action to generate an +
_OperationalError_ event |Receive an _OperationalError_ event containing
an ErrorState struct populated as follows: +
An ErrorStateID that shall contain an enum 8. Verify the ErrorStateID is
a defined error (NoError(0x00), UnableToStartOrResume(0x01),
UnableToCompleteOperation(0x02), CommandInvalidInState(0x03)) or in the
range 0x80 to 0xBF. +
If the ErrorStateID is in the range 0x80 to 0xBF, then an
ErrorStateLabel that is a human readable string. +
If the ErrorStateId is not in the range 0x80 to 0xBF then no
ErrorStateLabel shall be present. +
Optionally an ErrorStateDetails. If present, this shall be a human
readable string.

|4 | |OPSTATE.S.A0004(OperationalState) |TH reads from the DUT the
_OperationalState_ attribute |Verify that the DUT response contains an
enum8 set to Error(0x03).
|===

[[_notestesting_considerations_285]]
====== link:#_notestesting_considerations_285[]Notes/Testing Considerations

[[_air_quality_cluster_test_plan]]
== link:#_air_quality_cluster_test_plan[]**Air Quality Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |2023-05-09 |`Thomas Hartwig` |Initial Test Plan for AIRQUAL

|0.1.1 |2023-08-15 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_59]]
=== link:#_pics_definition_59[]202. PICS Definition

This section covers the Air Quality Cluster Test Plan related PICS items
that are referenced in the following test cases. Support for an item is
considered as "true" for conditional statements within the test case
steps.

[[_role_61]]
==== link:#_role_61[]202.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|AIRQUAL.S |Does the device implement the Air Quality cluster as a
server? |O |

|AIRQUAL.C |Does the device implement the Air Quality cluster as a
client? |O |
|===

[[_server_72]]
==== link:#_server_72[]202.2. Server

[[_features_44]]
===== link:#_features_44[]202.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|AIRQUAL.S.F00(Fair) |Does the device support this Fair feature? |O |

|AIRQUAL.S.F01(Moderate) |Does the device support this Moderate feature?
|O |

|AIRQUAL.S.F02(VeryPoor) |Does the device support this VeryPoor feature?
|O |

|AIRQUAL.S.F03(ExtremelyPoor) |Does the device support this
ExtremelyPoor feature? |O |
|===

[[_attributes_65]]
===== link:#_attributes_65[]202.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|AIRQUAL.S.A0000(AirQuality) |Does the device implement the _AirQuality_
attribute? |M |
|===

[[_test_case_list_61]]
=== link:#_test_case_list_61[]203. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-AIRQUAL-1.1 |Global Attributes with DUT as Server
|2 |TC-AIRQUAL-2.1 |Attributes with DUT as Server
|3 |TC-AIRQUAL-2.2 |Primary functionality with DUT as Server
|===

[[_test_cases_61]]
=== link:#_test_cases_61[]204. Test Cases

'''''

[[_generic_test_cases_53]]
==== link:#_generic_test_cases_53[]204.1. Generic test cases

'''''

[[_tc_airqual_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_airqual_1_1_global_attributes_with_dut_as_server[]204.1.1. [TC-AIRQUAL-1.1] Global attributes with DUT as Server

[[_category_374]]
====== link:#_category_374[]Category

Functional conformance.

[[_purpose_380]]
====== link:#_purpose_380[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_379]]
====== link:#_pics_379[]PICS

* AIRQUAL.S

[[_required_devices_380]]
====== link:#_required_devices_380[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_380]]
====== link:#_test_procedure_380[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if AIRQUAL.S.F00(Fair)

- bit 1: SHALL be 1 if and only if AIRQUAL.S.F01(Moderate)

- bit 2: SHALL be 1 if and only if AIRQUAL.S.F02(VeryPoor)

- bit 3: SHALL be 1 if and only if AIRQUAL.S.F03(ExtremelyPoor)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_286]]
====== link:#_notestesting_considerations_286[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_73]]
==== link:#_server_73[]204.2. Server

'''''

[[_tc_airqual_2_1_attributes_with_dut_as_server]]
===== link:#_tc_airqual_2_1_attributes_with_dut_as_server[]204.2.1. [TC-AIRQUAL-2.1] Attributes with DUT as Server

[[_category_375]]
====== link:#_category_375[]Category

Functional.

[[_purpose_381]]
====== link:#_purpose_381[]Purpose

This test case verifies the non-global attributes of the Air Quality
cluster server.

[[_pics_380]]
====== link:#_pics_380[]PICS

* AIRQUAL.S

[[_required_devices_381]]
====== link:#_required_devices_381[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_304]]
====== link:#_device_topology_304[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_325]]
====== link:#_test_setup_325[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_381]]
====== link:#_test_procedure_381[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.9.6.1 |AIRQUAL.S.A0000(AirQuality) |TH reads from the DUT the
_AirQuality_ attribute. a|
Verify that the DUT response contains an enum8 value. +

Value has to be 0, 1 or 4. +
2: If AIRQUAL.S.F00(Fair) +
3: If AIRQUAL.S.F01(Moderate) +
5: If AIRQUAL.S.F02(VeryPoor) +
6: If AIRQUAL.S.F03(ExtremelyPoor) +

|===

[[_notestesting_considerations_287]]
====== link:#_notestesting_considerations_287[]Notes/Testing Considerations

[[_hepa_filter_monitoring_cluster_test_plan]]
== link:#_hepa_filter_monitoring_cluster_test_plan[]**HEPA Filter Monitoring Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |2023-05-15 |`Thomas Hartwig` |Initial Test Plan for HEPAFREMON

|0.2 |2023-06-27 |`Cliff Chung` |Addition of test for
ReplacementProductList and LastChangedTime attributes

|0.2.1 |2023-08-15 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_60]]
=== link:#_pics_definition_60[]205. PICS Definition

This section covers the HEPA Filter Monitoring Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_62]]
==== link:#_role_62[]205.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|HEPAFREMON.S |Does the device implement the HEPA Filter Monitoring
cluster as a server? |O |

|HEPAFREMON.C |Does the device implement the HEPA Filter Monitoring
cluster as a client? |O |
|===

[[_server_74]]
==== link:#_server_74[]205.2. Server

[[_features_45]]
===== link:#_features_45[]205.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|HEPAFREMON.S.F00(Condition) |Does the device support this Condition
feature? |O |

|HEPAFREMON.S.F01(Warning) |Does the device support this Warning
feature? |O |

|HEPAFREMON.S.F02(ReplacementProductList) |Does the device support this
ReplacementProductList feature? |O |
|===

[[_attributes_66]]
===== link:#_attributes_66[]205.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|HEPAFREMON.S.A0000(Condition) |Does the device implement the
_Condition_ attribute? |Condition |

|HEPAFREMON.S.A0001(DegradationDirection) |Does the device implement the
_DegradationDirection_ attribute? |Condition |

|HEPAFREMON.S.A0002(ChangeIndication) |Does the device implement the
_ChangeIndication_ attribute? |M |

|HEPAFREMON.S.A0003(InPlaceIndicator) |Does the device implement the
_InPlaceIndicator_ attribute? |O |

|HEPAFREMON.S.A0004(LastChangedTime) |Does the device implement the
_LastChangedTime_ attribute? |O |

|HEPAFREMON.S.A0005(ReplacementProductList) |Does the device implement
the _ReplacementProductList_ attribute? |ReplacementProductList |
|===

[[_commands_received_33]]
===== link:#_commands_received_33[]205.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|HEPAFREMON.S.C00.Rsp(ResetCondition) |Does the device implement
receiving the _ResetCondition_ command? |O |
|===

[[_test_case_list_62]]
=== link:#_test_case_list_62[]206. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-HEPAFREMON-1.1 |Global Attributes with DUT as Server
|2 |TC-HEPAFREMON-2.1 |Attributes with DUT as Server
|===

[[_test_cases_62]]
=== link:#_test_cases_62[]207. Test Cases

'''''

[[_generic_test_cases_54]]
==== link:#_generic_test_cases_54[]207.1. Generic test cases

'''''

[[_tc_hepafremon_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_hepafremon_1_1_global_attributes_with_dut_as_server[]207.1.1. [TC-HEPAFREMON-1.1] Global attributes with DUT as Server

[[_category_376]]
====== link:#_category_376[]Category

Functional conformance.

[[_purpose_382]]
====== link:#_purpose_382[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_381]]
====== link:#_pics_381[]PICS

* HEPAFREMON.S

[[_required_devices_382]]
====== link:#_required_devices_382[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_382]]
====== link:#_test_procedure_382[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if HEPAFREMON.S.F00(Condition)

- bit 1: SHALL be 1 if and only if HEPAFREMON.S.F01(Warning)

- bit 2: SHALL be 1 if and only if
HEPAFREMON.S.F02(ReplacementProductList)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0002, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0003: SHALL be included if and only if
HEPAFREMON.S.A0003(InPlaceIndicator)

- 0x0004: SHALL be included if and only if
HEPAFREMON.S.A0004(LastChangedTime)

The list include entries based on feature support: +
- 0x0000: SHALL be included if and only if HEPAFREMON.S.F00(Condition)

- 0x0001: SHALL be included if and only if HEPAFREMON.S.F00(Condition)

- 0x0005: SHALL be included if and only if
HEPAFREMON.S.F02(ReplacementProductList)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_288]]
====== link:#_notestesting_considerations_288[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_75]]
==== link:#_server_75[]207.2. Server

'''''

[[_tc_hepafremon_2_1_attributes_with_dut_as_server]]
===== link:#_tc_hepafremon_2_1_attributes_with_dut_as_server[]207.2.1. [TC-HEPAFREMON-2.1] Attributes with DUT as Server

[[_category_377]]
====== link:#_category_377[]Category

Functional.

[[_purpose_383]]
====== link:#_purpose_383[]Purpose

This test case verifies the non-global attributes of the HEPA Filter
Monitoring cluster server.

[[_pics_382]]
====== link:#_pics_382[]PICS

* HEPAFREMON.S

[[_required_devices_383]]
====== link:#_required_devices_383[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_305]]
====== link:#_device_topology_305[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_326]]
====== link:#_test_setup_326[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_383]]
====== link:#_test_procedure_383[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.8.6.1 |HEPAFREMON.S.A0000(Condition) |TH reads from the DUT the
_Condition_ attribute. a|
Verify that the DUT response contains a uint8 value. +

The value has to be in the range of 0 to 100.

|3 |AC.2.8.6.2 |HEPAFREMON.S.A0001(DegradationDirection) |TH reads from
the DUT the _DegradationDirection_ attribute. a|
Verify that the DUT response contains an enum8 value. +

Value has to be 0 or 1.

|4 |AC.2.8.6.3 |HEPAFREMON.S.A0002(ChangeIndication) |TH reads from the
DUT the _ChangeIndication_ attribute. a|
Verify that the DUT response contains an enum8 value. +

Value has to be 0 or 2. +
1: If HEPAFREMON.S.F01(Warning) +

|5 |AC.2.8.6.4 |HEPAFREMON.S.A0003(InPlaceIndicator) |TH reads from the
DUT the _InPlaceIndicator_ attribute. |Verify that the DUT response
contains any boolean value.

|6 |AC.2.8.6.6 |HEPAFREMON.S.A0004(LastChangedTime) |TH reads from the
DUT the _LastChangedTime_ attribute. |Verify that the DUT response
contains a null or a epoch_s value.

|7 |AC.2.8.6.5 |HEPAFREMON.S.A0005(ReplacementProductList) |TH reads
from the DUT the _ReplacementProductList_ attribute. a|
Verify that the DUT response contains a list of zero or more product
replacement options (each being an instance of
ReplacementProductStruct). +

All fields have values present and conformance matches.

|===

[[_notestesting_considerations_289]]
====== link:#_notestesting_considerations_289[]Notes/Testing Considerations

[[_activated_carbon_filter_monitoring_cluster_test_plan]]
== link:#_activated_carbon_filter_monitoring_cluster_test_plan[]**Activated Carbon Filter Monitoring Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |2023-05-15 |`Thomas Hartwig` |Initial Test Plan for ACFREMON

|0.2 |2023-06-27 |`Cliff Chung` |Addition of test for
ReplacementProductList and LastChangedTime attributes

|0.2.1 |2023-08-15 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_61]]
=== link:#_pics_definition_61[]208. PICS Definition

This section covers the Activated Carbon Filter Monitoring Cluster Test
Plan related PICS items that are referenced in the following test cases.
Support for an item is considered as "true" for conditional statements
within the test case steps.

[[_role_63]]
==== link:#_role_63[]208.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACFREMON.S |Does the device implement the Activated Carbon Filter
Monitoring cluster as a server? |O |

|ACFREMON.C |Does the device implement the Activated Carbon Filter
Monitoring cluster as a client? |O |
|===

[[_server_76]]
==== link:#_server_76[]208.2. Server

[[_features_46]]
===== link:#_features_46[]208.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACFREMON.S.F00(Condition) |Does the device support this Condition
feature? |O |

|ACFREMON.S.F01(Warning) |Does the device support this Warning feature?
|O |

|ACFREMON.S.F02(ReplacementProductList) |Does the device support this
ReplacementProductList feature? |O |
|===

[[_attributes_67]]
===== link:#_attributes_67[]208.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACFREMON.S.A0000(Condition) |Does the device implement the _Condition_
attribute? |Condition |

|ACFREMON.S.A0001(DegradationDirection) |Does the device implement the
_DegradationDirection_ attribute? |Condition |

|ACFREMON.S.A0002(ChangeIndication) |Does the device implement the
_ChangeIndication_ attribute? |M |

|ACFREMON.S.A0003(InPlaceIndicator) |Does the device implement the
_InPlaceIndicator_ attribute? |O |

|ACFREMON.S.A0004(LastChangedTime) |Does the device implement the
_LastChangedTime_ attribute? |O |

|ACFREMON.S.A0005(ReplacementProductList) |Does the device implement the
_ReplacementProductList_ attribute? |ReplacementProductList |
|===

[[_commands_received_34]]
===== link:#_commands_received_34[]208.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ACFREMON.S.C00.Rsp(ResetCondition) |Does the device implement receiving
the _ResetCondition_ command? |O |
|===

[[_test_case_list_63]]
=== link:#_test_case_list_63[]209. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-ACFREMON-1.1 |Global Attributes with DUT as Server
|2 |TC-ACFREMON-2.1 |Attributes with DUT as Server
|===

[[_test_cases_63]]
=== link:#_test_cases_63[]210. Test Cases

'''''

[[_generic_test_cases_55]]
==== link:#_generic_test_cases_55[]210.1. Generic test cases

'''''

[[_tc_acfremon_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_acfremon_1_1_global_attributes_with_dut_as_server[]210.1.1. [TC-ACFREMON-1.1] Global attributes with DUT as Server

[[_category_378]]
====== link:#_category_378[]Category

Functional conformance.

[[_purpose_384]]
====== link:#_purpose_384[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_383]]
====== link:#_pics_383[]PICS

* ACFREMON.S

[[_required_devices_384]]
====== link:#_required_devices_384[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_384]]
====== link:#_test_procedure_384[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

- bit 0: SHALL be 1 if and only if ACFREMON.S.F00(Condition)

- bit 1: SHALL be 1 if and only if ACFREMON.S.F01(Warning)

- bit 2: SHALL be 1 if and only if
ACFREMON.S.F02(ReplacementProductList)

All remaining bits SHALL be 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0002, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0003: SHALL be included if and only if
ACFREMON.S.A0003(InPlaceIndicator)

- 0x0004: SHALL be included if and only if
ACFREMON.S.A0004(LastChangedTime)

The list include entries based on feature support: +
- 0x0000: SHALL be included if and only if ACFREMON.S.F00(Condition)

- 0x0001: SHALL be included if and only if ACFREMON.S.F00(Condition)

- 0x0005: SHALL be included if and only if
ACFREMON.S.F02(ReplacementProductList)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +
0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

This cluster has no entries in the standard or scoped range.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_290]]
====== link:#_notestesting_considerations_290[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_77]]
==== link:#_server_77[]210.2. Server

'''''

[[_tc_acfremon_2_1_attributes_with_dut_as_server]]
===== link:#_tc_acfremon_2_1_attributes_with_dut_as_server[]210.2.1. [TC-ACFREMON-2.1] Attributes with DUT as Server

[[_category_379]]
====== link:#_category_379[]Category

Functional.

[[_purpose_385]]
====== link:#_purpose_385[]Purpose

This test case verifies the non-global attributes of the Activated
Carbon Filter Monitoring cluster server.

[[_pics_384]]
====== link:#_pics_384[]PICS

* ACFREMON.S

[[_required_devices_385]]
====== link:#_required_devices_385[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_306]]
====== link:#_device_topology_306[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_327]]
====== link:#_test_setup_327[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_385]]
====== link:#_test_procedure_385[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |AC.2.8.6.1 |ACFREMON.S.A0000(Condition) |TH reads from the DUT the
_Condition_ attribute. a|
Verify that the DUT response contains a uint8 value. +

The value has to be in the range of 0 to 100.

|3 |AC.2.8.6.2 |ACFREMON.S.A0001(DegradationDirection) |TH reads from
the DUT the _DegradationDirection_ attribute. a|
Verify that the DUT response contains an enum8 value. +

Value has to be 0 or 1.

|4 |AC.2.8.6.3 |ACFREMON.S.A0002(ChangeIndication) |TH reads from the
DUT the _ChangeIndication_ attribute. a|
Verify that the DUT response contains an enum8 value. +

Value has to be 0 or 2. +
1: If ACFREMON.S.F01(Warning) +

|5 |AC.2.8.6.4 |ACFREMON.S.A0003(InPlaceIndicator) |TH reads from the
DUT the _InPlaceIndicator_ attribute. |Verify that the DUT response
contains any boolean value.

|6 |AC.2.8.6.6 |ACFREMON.S.A0004(LastChangedTime) |TH reads from the DUT
the _LastChangedTime_ attribute. |Verify that the DUT response contains
a null or a epoch_s value.

|7 |AC.2.8.6.5 |ACFREMON.S.A0005(ReplacementProductList) |TH reads from
the DUT the _ReplacementProductList_ attribute. a|
Verify that the DUT response contains a list of zero or more product
replacement options (each being an instance of
ReplacementProductStruct). +

All fields have values present and conformance matches.

|===

[[_notestesting_considerations_291]]
====== link:#_notestesting_considerations_291[]Notes/Testing Considerations

[[_icd_management_cluster_test_plan]]
== link:#_icd_management_cluster_test_plan[]**ICD Management Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |2023-05-01 |`Yinyi Hu` |Initial Test Plan for ICDM

|0.1.1 |2023-08-15 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_62]]
=== link:#_pics_definition_62[]211. PICS Definition

This section covers the ICD Management Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_64]]
==== link:#_role_64[]211.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.S |Does the device implement the ICD Management cluster as a
server? |O |

|ICDM.C |Does the device implement the ICD Management cluster as a
client? |O |
|===

[[_server_78]]
==== link:#_server_78[]211.2. Server

[[_features_47]]
===== link:#_features_47[]211.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.S.F00(CIP) |Does the device support this specific cluster feature?
|O |
|===

[[_attributes_68]]
===== link:#_attributes_68[]211.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.S.A0000(IdleModeInterval) |Does the device implement the
_IdleModeInterval_ attribute? |M |

|ICDM.S.A0001(ActiveModeInterval) |Does the device implement the
_ActiveModeInterval_ attribute? |M |

|ICDM.S.A0002(ActiveModeThreshold) |Does the device implement the
_ActiveModeThreshold_ attribute? |M |

|ICDM.S.A0003(RegisteredClients) |Does the device implement the
_RegisteredClients_ attribute? |CIP |

|ICDM.S.A0004(IcdCounter) |Does the device implement the _IcdCounter_
attribute? |CIP |

|ICDM.S.A0005(ClientsSupportedPerFabric) |Does the device implement the
_ClientsSupportedPerFabric_ attribute? |CIP |
|===

[[_commands_received_35]]
===== link:#_commands_received_35[]211.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.S.C00.Rsp(RegisterClient) |Does the device implement receiving the
_RegisterClient_ command? |CIP |

|ICDM.S.C02.Rsp(UnregisterClient) |Does the device implement receiving
the _UnregisterClient_ command? |CIP |

|ICDM.S.C03.Rsp(StayActiveRequest) |Does the device implement receiving
the _StayActiveRequest_ command? |O |
|===

[[_commands_generated_32]]
===== link:#_commands_generated_32[]211.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.S.C01.Tx(RegisterClientResponse) |Does the device implement
sending the _RegisterClientResponse_ command? |CIP |
|===

[[_client_22]]
==== link:#_client_22[]211.3. Client

[[_attributes_69]]
===== link:#_attributes_69[]211.3.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.C.A0000(IdleModeInterval) |Does the device implement the
_IdleModeInterval_ attribute? |O |

|ICDM.C.A0001(ActiveModeInterval) |Does the device implement the
_ActiveModeInterval_ attribute? |O |

|ICDM.C.A0002(ActiveModeThreshold) |Does the device implement the
_ActiveModeThreshold_ attribute? |O |

|ICDM.C.A0003(RegisteredClients) |Does the device implement the
_RegisteredClients_ attribute? |O |

|ICDM.C.A0004(IcdCounter) |Does the device implement the _IcdCounter_
attribute? |O |

|ICDM.C.A0005(ClientsSupportedPerFabric) |Does the device implement the
_ClientsSupportedPerFabric_ attribute? |O |
|===

[[_commands_received_36]]
===== link:#_commands_received_36[]211.3.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|ICDM.C.C00.Rsp(RegisterClientResponse) |Does the device support
receiving the _RegisterClientResponse_ command? |O |
|===

[[_test_case_list_64]]
=== link:#_test_case_list_64[]212. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-ICDM-1.1 |Global Attributes with DUT as Server
|2 |TC-ICDM-2.1 |Attributes with DUT as Server
|3 |TC-ICDM-2.2 |Primary functionality with DUT as Server - REMOVED
|4 |TC-ICDM-2.3 |Secondary functionality with DUT as Server - REMOVED
|===

[[_test_cases_64]]
=== link:#_test_cases_64[]213. Test Cases

'''''

[[_generic_test_cases_56]]
==== link:#_generic_test_cases_56[]213.1. Generic test cases

'''''

[[_tc_icdm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_icdm_1_1_global_attributes_with_dut_as_server[]213.1.1. [TC-ICDM-1.1] Global attributes with DUT as Server

[[_category_380]]
====== link:#_category_380[]Category

Functional conformance.

[[_purpose_386]]
====== link:#_purpose_386[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_385]]
====== link:#_pics_385[]PICS

* ICDM.S

[[_required_devices_386]]
====== link:#_required_devices_386[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_386]]
====== link:#_test_procedure_386[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the following bitmap32

- bit 0 is set to 1 if ICDM.S.F00(CIP) is true, and 0 otherwise - other
bits SHALL be set to 0

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0002

The list include entries based on feature support: +
0x0003: SHALL be included if and only if ICDM.S.A0003(RegisteredClients)
0x0004: SHALL be included if and only if ICDM.S.A0004(IcdCounter)
0x0005: SHALL be included if and only if
ICDM.S.A0005(ClientsSupportedPerFabric)

0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute.
|Verify that the DUT response contains a list of supported events empty
for this cluster.

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list include entries based on feature support: +
0x00, 0x02: SHALL be included if and only if ICDM.S.F00(CIP)

The list MAY include these optional entries: +
0x03: SHALL be included if and only if ICDM.S.C03.Rsp(StayActiveRequest)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list include entries based on feature support: +
0x01: SHALL be included if and only if ICDM.S.F00(CIP)

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_292]]
====== link:#_notestesting_considerations_292[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_79]]
==== link:#_server_79[]213.2. Server

'''''

[[_tc_icdm_2_1_attributes_with_dut_as_server]]
===== link:#_tc_icdm_2_1_attributes_with_dut_as_server[]213.2.1. [TC-ICDM-2.1] Attributes with DUT as Server

[[_category_381]]
====== link:#_category_381[]Category

Functional.

[[_purpose_387]]
====== link:#_purpose_387[]Purpose

This test case verifies the non-global attributes of the ICD Management
cluster server.

[[_pics_386]]
====== link:#_pics_386[]PICS

* ICDM.S

[[_required_devices_387]]
====== link:#_required_devices_387[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_307]]
====== link:#_device_topology_307[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_328]]
====== link:#_test_setup_328[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_387]]
====== link:#_test_procedure_387[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |11.23.5.1 |ICDM.S.A0000(IdleModeInterval) |TH reads from the DUT the
_IdleModeInterval_ attribute. |Verify that the DUT response contains an
uint32; Value has to be between a range of 500 and 64800000

|3 |11.23.5.2 |ICDM.S.A0001(ActiveModeInterval) |TH reads from the DUT
the _ActiveModeInterval_ attribute. |Verify that the DUT response
contains an uint32; value is 300 or higher, and shall be less than
IdleModeInterval

|4 |11.23.5.3 |ICDM.S.A0002(ActiveModeThreshold) |TH reads from the DUT
the _ActiveModeThreshold_ attribute. |Verify that the DUT response
contains an uint16; value is 300 or higher

|5 |11.23.5.4 |ICDM.S.A0003(RegisteredClients) |TH reads from the DUT
the _RegisteredClients_ attribute. |Verify that the DUT response
contains a list

|6 |11.23.5.5 |ICDM.S.A0004(IcdCounter) |TH reads from the DUT the
_ICDM.S.A0004(IcdCounter)_ attribute. |Verify that the DUT response
contains an uint32

|7 |11.23.5.6 |ICDM.S.A0005(ClientsSupportedPerFabric) |TH reads from
the DUT the _ICDM.S.A0005(ClientsSupportedPerFabric)_ attribute. |Verify
that the DUT response contains an uint16; Value has to be between a
range of 1 and up
|===

[[_notestesting_considerations_293]]
====== link:#_notestesting_considerations_293[]Notes/Testing Considerations

[[_tc_icdm_2_2_primary_functionality_with_dut_as_server_removed]]
===== link:#_tc_icdm_2_2_primary_functionality_with_dut_as_server_removed[]213.2.2. [TC-ICDM-2.2] Primary functionality with DUT as Server - REMOVED

[[_category_382]]
====== link:#_category_382[]Category

Functional.

[[_purpose_388]]
====== link:#_purpose_388[]Purpose

This test case verifies the primary functionality of the ICD Management
cluster server.

[[_pics_387]]
====== link:#_pics_387[]PICS

* ICDM.S
* ICDM.S.C00.Rsp(RegisterClient)
* ICDM.S.C02.Rsp(UnregisterClient)

[[_required_devices_388]]
====== link:#_required_devices_388[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_308]]
====== link:#_device_topology_308[]Device Topology

TH and DUT are on the same fabric.

[width="100%",cols="50%,50%",options="header",]
|===
|*#* |*Pre-Condition*
|1 |Commission DUT to TH (can be skipped if done in a preceding test).

|2a |TH reads from the DUT the _RegisteredClients_ attribute.

|2b |If list of registered clients is not empty, unregister existing
clients

|2c |TH reads from the DUT the _RegisteredClients_ attribute. Verify
that the DUT response contains empty list of registered clients.
|===

[[_test_setup_329]]
====== link:#_test_setup_329[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_388]]
====== link:#_test_procedure_388[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.23.7.1 |ICDM.S.C00.Rsp(RegisterClient) a|
TH sends _RegisterClient_ command.

- CheckInNodeID: registering client’s node ID - MonitoredSubject:
monitored subject ID - Key: shared secret between the client and the ICD
used in the encryption of the check-in message payload.

|Verify DUT responds w/ status SUCCESS(0x00).

|2 |11.23.5.4 |ICDM.S.A0003(RegisteredClients) |TH reads from the DUT
the _RegisteredClients_ attribute. |Verify that the DUT response
contains a list of 1 registered client of given CheckInNodeID,
MonitoredSubject, and Key

|3a |11.23.7.1 |ICDM.S.A0005(ClientsSupportedPerFabric) |TH reads from
the DUT the _ICDM.S.A0005(ClientsSupportedPerFabric)_ attribute. |Verify
that the DUT response contains an uint16; Value has to be between a
range of 1 and up

|3b |11.23.7.1 |ICDM.S.C00.Rsp(RegisterClient) |If _RegisteredClients_
is less than _ClientsSupportedPerFabric_, TH repeats _RegisterClient_
command with a different CheckInNodeID until the number of
_RegisteredClients_ equals _ClientsSupportedPerFabric_. |Verify DUT
responds w/ status SUCCESS(0x00).

|3c |11.23.7.1 |ICDM.S.C00.Rsp(RegisterClient) |TH sends
_RegisterClient_ command with a different CheckInNodeID. |Verify DUT
responds w/ status RESOURCE_EXHAUSTED(0x89).

|4 |11.23.5.4 |ICDM.S.A0003(RegisteredClients) |TH reads from the DUT
the _RegisteredClients_ attribute. |Verify that the DUT response
contains a list of registered clients from Step 1 and 3b; each entry
contains CheckInNodeID, MonitoredSubject, and Key.

|5a |11.23.7.3 |ICDM.S.C02.Rsp(UnregisterClient) |TH sends
_UnregisterClient_ command with a CheckInNodeID which is not in the list
of _RegisteredClients_ from Step 4. |Verify DUT responds w/ status
NOT_FOUND(0x8b).

|5b |11.23.7.3 |ICDM.S.C02.Rsp(UnregisterClient) |TH sends
_UnregisterClient_ command with the CheckInNodeID from Step 1. |Verify
DUT responds w/ status SUCCESS(0x00).

|5c |11.23.7.3 |ICDM.S.C02.Rsp(UnregisterClient) |Repeat Step 5b with
the rest of CheckInNodeIDs from the list of _RegisteredClients_ from
Step 4, if any. |Verify DUT responds w/ status SUCCESS(0x00).

|6 |11.23.5.4 |ICDM.S.A0003(RegisteredClients) |TH reads from the DUT
the _RegisteredClients_ attribute. |Verify that the DUT response
contains empty list of registered clients.

|7 |11.23.7.3 |ICDM.S.C02.Rsp(UnregisterClient) |TH sends
_UnregisterClient_ command with the CheckInNodeID from Step 1. |Verify
DUT responds w/ status NOT_FOUND(0x8b).
|===

[[_notestesting_considerations_294]]
====== link:#_notestesting_considerations_294[]Notes/Testing Considerations

[[_tc_icdm_2_3_secondary_functionality_with_dut_as_server_removed]]
===== link:#_tc_icdm_2_3_secondary_functionality_with_dut_as_server_removed[]213.2.3. [TC-ICDM-2.3] Secondary functionality with DUT as Server - REMOVED

[[_category_383]]
====== link:#_category_383[]Category

Functional.

[[_purpose_389]]
====== link:#_purpose_389[]Purpose

This test case verifies the secondary functionality of the ICD
Management cluster server.

[[_pics_388]]
====== link:#_pics_388[]PICS

* ICDM.S
* ICDM.S.C00.Rsp(RegisterClient)
* ICDM.S.C02.Rsp(UnregisterClient)
* ICDM.S.C03.Rsp(StayActiveRequest)

[[_required_devices_389]]
====== link:#_required_devices_389[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_309]]
====== link:#_device_topology_309[]Device Topology

TH and DUT are on the same fabric.

[width="100%",cols="50%,50%",]
|===
|*#* a|
*Pre-Condition*

Commission DUT to TH (can be skipped if done in a preceding test).

|===

[[_test_setup_330]]
====== link:#_test_setup_330[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_389]]
====== link:#_test_procedure_389[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 |11.23.5.3 |ICDM.S.A0002(ActiveModeThreshold) |TH reads from the DUT
the _ActiveModeThreshold_ attribute. |Verify that the DUT response
contains an uint16; value is 300 or higher

|2 |11.23.7.4 |ICDM.S.C03.Rsp(StayActiveRequest) |TH sends
_StayActiveRequest_ command. |Verify DUT responds w/ status
SUCCESS(0x00).

|3^*^ | |ICDM.S.C03.Rsp(StayActiveRequest) | |Verify DUT increases the
remaining time in active mode by one _ActiveModeThreshold_
|===

[[_notestesting_considerations_295]]
====== link:#_notestesting_considerations_295[]Notes/Testing Considerations

* Design details pending.

[[_refrigerator_and_temperature_controlled_cabinet_mode_cluster_test_plan]]
== link:#_refrigerator_and_temperature_controlled_cabinet_mode_cluster_test_plan[]**Refrigerator and Temperature Controlled Cabinet Mode Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|0.1 |8-May-2023 |`Jeff Drake` |Initial Document upload to github
|0.2 |24-May-2023 |`Jeff Drake` |Fixing spelling errors on initial merge
|0.3 |14-Jul-2023 |`Rob Bultman` |Fix test names, test plan name
|===

[[_refrigerator_and_temperature_controlled_cabinet_mode_cluster_testing_overview]]
=== link:#_refrigerator_and_temperature_controlled_cabinet_mode_cluster_testing_overview[]214. Refrigerator and Temperature Controlled Cabinet Mode Cluster Testing Overview

The Refrigerator and Temperature Controlled Cabinet Mode cluster is a
derived version of the Mode Base cluster. This document describes the
tests specific to this derived cluster.

[[_pics_definition_63]]
=== link:#_pics_definition_63[]215. PICS Definition

This section covers the Refrigerator and Temperature Controlled Cabinet
Mode Cluster related PICS items that are referenced in the following
test cases. Support for an item is considered as "true" for conditional
statements within the test case steps.

[[_role_65]]
==== link:#_role_65[]215.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S |Does the device implement the TCCM cluster as a server? |O |
|===

[[_server_80]]
==== link:#_server_80[]215.2. Server

[[_features_48]]
===== link:#_features_48[]215.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S.F00(DEPONOFF) |Does the device support depending on an On/Off
cluster implemented on the same endpoint? |O |
|===

[[_attributes_70]]
===== link:#_attributes_70[]215.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S.A0000(SupportedModes) |Does the device implement the
_SupportedModes_ attribute? |M |

|TCCM.S.A0001(CurrentMode) |Does the device implement the _CurrentMode_
attribute? |M |

|TCCM.S.A0002(StartUpMode) |Does the device implement the _StartUpMode_
attribute? |O |

|TCCM.S.A0003(OnMode) |Does the device implement the _OnMode_ attribute?
|DEPONOFF |
|===

[[_commands_received_37]]
===== link:#_commands_received_37[]215.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S.C00.Rsp(ChangeToMode) |Does the device implement receiving the
_ChangeToMode_ command? |M |
|===

[[_commands_generated_33]]
===== link:#_commands_generated_33[]215.2.4. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S.C01.Tx(ChangeToModeResponse) |Does the device implement sending
the _ChangeToModeResponse_ command? |M |
|===

[[_manual_controllable_24]]
===== link:#_manual_controllable_24[]215.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S.M.CAN_TEST_MODE_FAILURE |Does the DUT support testing the failed
_ChangeToMode_ command? |O |Declared by manufacturer
|===

[[_pixit_definition_15]]
=== link:#_pixit_definition_15[]216. PIXIT Definition

This section covers the Refrigerator and Temperature Controlled Cabinet
Mode Test Plan related PIXIT items that might be required in the
following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.TCCM.MODE_CHANGE_FAIL |Id of mode the device will fail to
transition to, given its current state |O |

|PIXIT.TCCM.MODE_CHANGE_OK |Id of mode the device will successfully
transition to, given its current state |O |
|===

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|TCCM.S.ST4000(RapidCool) |Has mode with the _RapidCool_ semantic tag
value? |O |

|TCCM.S.ST4001(RapidFreeze) |Has mode with the _RapidFreeze_ semantic
tag value? |O |
|===

[[_test_case_list_65]]
=== link:#_test_case_list_65[]217. Test Case List

[width="100%",cols="50%,50%",]
|===
|*TC UUID* |*Test Case Name*

|[TC-TCCM-1.1] |Global attributes with DUT as Server

|[TC-TCCM-1.2] |Cluster attributes with DUT as Server

|[TC-TCCM-2.1] |Change to Mode functionality with DUT as Server

|[TC-TCCM-3.1] |On Mode functionality with DUT as Server

|[TC-TCCM-3.2] |Startup Mode functionality with DUT as Server

|[TC-TCCM-3.3] |On Mode and Startup Mode functionality with DUT as
Server
|===

[[_test_cases_65]]
=== link:#_test_cases_65[]218. Test Cases

'''''

[[_attribute_test_cases_4]]
==== link:#_attribute_test_cases_4[]218.1. Attribute test cases

'''''

[[_tc_tccm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_tccm_1_1_global_attributes_with_dut_as_server[]218.1.1. [TC-TCCM-1.1] Global attributes with DUT as Server

[[_category_384]]
====== link:#_category_384[]Category

Functional conformance

[[_purpose_390]]
====== link:#_purpose_390[]Purpose

This test case verifies the cluster server global attributes.

[[_pics_389]]
====== link:#_pics_389[]PICS

* TCCM.S

[[_required_devices_390]]
====== link:#_required_devices_390[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_310]]
====== link:#_device_topology_310[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_331]]
====== link:#_test_setup_331[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_390]]
====== link:#_test_procedure_390[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test). |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute.
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute. a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

* bit 0: SHALL be 1 if and only if TCCM.S.F00(DEPONOFF)

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute. a|
Verify that the DUT response contains the _AttributeList_ attribute and
have the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

The list MAY include these optional entries: +
- 0x0002: SHALL be included if and only if TCCM.S.A0002(StartUpMode)

The list include entries based on feature support: +

* 0x0003 SHALL be included if and only if TCCM.S.F00(DEPONOFF)

and SHALL NOT be included otherwise.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1) +

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute with a
list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the _AcceptedCommandList_
attribute and have the list of Accepted Command:

The list SHALL include all the mandatory entries: +

0x00

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the _GeneratedCommandList_
attribute and have the list of Generated Command:

The list SHALL include all the mandatory entries: +

0x01

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|===

[[_notestesting_considerations_296]]
====== link:#_notestesting_considerations_296[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_tc_tccm_1_2_cluster_attributes_with_dut_as_server]]
===== link:#_tc_tccm_1_2_cluster_attributes_with_dut_as_server[]218.1.2. [TC-TCCM-1.2] Cluster attributes with DUT as Server

[[_category_385]]
====== link:#_category_385[]Category

Functional.

[[_purpose_391]]
====== link:#_purpose_391[]Purpose

This test case verifies the non-global attributes of the Refrigerator
and Temperature Controlled Cabinet Mode cluster server.

[[_pics_390]]
====== link:#_pics_390[]PICS

* TCCM.S

[[_required_devices_391]]
====== link:#_required_devices_391[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_311]]
====== link:#_device_topology_311[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_332]]
====== link:#_test_setup_332[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_391]]
====== link:#_test_procedure_391[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8, AC.8.8.5 |TCCM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has at least 2 and at most 255 entries
* Verify that each ModeOptionsStruct entry has a unique Mode field value
* Verify that each ModeOptionsStruct entry has a unique Label field
value
* Verify that each ModeOptionsStruct entry’s ModeTags field, if not
empty, has:
+
** the values of the Value fields that are not larger than 16 bits
** for each Value field: Is the semantic tag value a defined common tag
value (Auto(0x0000), Quick(0x0001), Quiet(0x0002), LowNoise(0x0003),
LowEnergy(0x0004), Vacation(0x0005), Min(0x0006), Max(0x0007),
Night(0x0008), Day(0x0009)) or a defined cluster alias tag value
(RapidCool, RapidFreeze) or in the MfgTags (0x8000 to 0xBFFF) range
** if the Value field is in the MfgTags (0x8000 to 0xBFFF) range, the
TagName field is a string with a length between 1 and 64
* Verify that at least one ModeOptionsStruct entry includes either the
RapidCool semantic tag or the RapidFreeze semantic tag in the
SemanticTags field
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut`

|4 |AC.1.9.6.4 |TCCM.S.A0003(OnMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|5 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer from
`supported_modes_dut` or null

|===

[[_notestesting_considerations_297]]
====== link:#_notestesting_considerations_297[]Notes/Testing Considerations

. Step 2 - The mode tag values may be standard (if from the CommonTags
range) or manufacturer specific (if from the MfgTags range). Refer to
the manufacturer documentation for details regarding the MfgTags values.

[[_changetomode_test_cases_6]]
==== link:#_changetomode_test_cases_6[]218.2. ChangeToMode Test Cases

'''''

[[_tc_tccm_2_1_change_to_mode_functionality_with_dut_as_server]]
===== link:#_tc_tccm_2_1_change_to_mode_functionality_with_dut_as_server[]218.2.1. [TC-TCCM-2.1] Change to Mode functionality with DUT as Server

[[_category_386]]
====== link:#_category_386[]Category

Functional conformance

[[_purpose_392]]
====== link:#_purpose_392[]Purpose

This test case verifies the functionality associated with the
ChangeToMode command.

[[_pics_391]]
====== link:#_pics_391[]PICS

* TCCM.S

[[_required_devices_392]]
====== link:#_required_devices_392[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_312]]
====== link:#_device_topology_312[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_333]]
====== link:#_test_setup_333[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_392]]
====== link:#_test_procedure_392[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.1, AC.1.9.8 |TCCM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`

|3 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* Select a value which is NOT in `supported_modes_dut` and save it as
`invalid_mode_th`

|4 |AC.1.9.7.1, AC.1.9.7.2 |TCCM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`old_current_mode_dut`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|5 | |TCCM.S.M.CAN_TEST_MODE_FAILURE a|
Manually put the device in a state from which it will FAIL to transition
to PIXIT.TCCM.MODE_CHANGE_FAIL

a|

|6 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|7 |AC.1.9.7.1, AC.1.9.7.2 |TCCM.S.M.CAN_TEST_MODE_FAILURE &
TCCM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.TCCM.MODE_CHANGE_FAIL

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to GenericFailure(0x02) or in the
MfgCodes (0x80 to 0xBF) range
* Verify that the StatusText field has a length between 1 and 64

|8 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
`old_current_mode_dut`

|9 | | a|
Manually put the device in a state from which it will SUCCESSFULLY
transition to PIXIT.TCCM.MODE_CHANGE_OK

a|

|10 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`

|11 |AC.1.9.7.1, AC.1.9.7.2 |TCCM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
PIXIT.TCCM.MODE_CHANGE_OK

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to Success(0x00)

|12 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.TCCM.MODE_CHANGE_OK

|13 |AC.1.9.7.1, AC.1.9.7.2 |TCCM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`invalid_mode_th`

a|
* Verify that the DUT responds with a _ChangeToModeResponse_ command.
* Verify that the Status field is set to UnsupportedMode(0x01).

|14 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value equal to
PIXIT.TCCM.MODE_CHANGE_OK

|===

[[_notestesting_considerations_298]]
====== link:#_notestesting_considerations_298[]Notes/Testing Considerations

[[_onoff_and_startup_mode_test_cases_6]]
==== link:#_onoff_and_startup_mode_test_cases_6[]218.3. On/Off and StartUp Mode Test Cases

'''''

[[_tc_tccm_3_1_on_mode_functionality_with_dut_as_server]]
===== link:#_tc_tccm_3_1_on_mode_functionality_with_dut_as_server[]218.3.1. [TC-TCCM-3.1] On Mode functionality with DUT as Server

[[_category_387]]
====== link:#_category_387[]Category

Functional conformance

[[_purpose_393]]
====== link:#_purpose_393[]Purpose

This test case verifies that the DUT switches to the proper OnMode when
the On/Off attribute of the On/Off cluster changes.

[[_pics_392]]
====== link:#_pics_392[]PICS

* TCCM.S

[[_preconditions_85]]
====== link:#_preconditions_85[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |Refrigerator and Temperature Controlled Cabinet Mode and OnOff
clusters are available on the same endpoint |

|2 | |The _OnMode_ attribute is set to a non-NULL value from the mode
values indicated by the _SupportedModes_ attribute. |
|===

[[_required_devices_393]]
====== link:#_required_devices_393[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_313]]
====== link:#_device_topology_313[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_334]]
====== link:#_test_setup_334[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_393]]
====== link:#_test_procedure_393[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.4 |TCCM.S.A0003(OnMode), TCCM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `on_mode_dut`

|3 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode), TCCM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `on_mode_dut` is equal to `old_current_mode_dut` proceed to step 4.
Else proceed to step 6.

|4 |AC.1.9.6.1 |TCCM.S.A0000(SupportedModes), TCCM.S.F00(DEPONOFF) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`on_mode_dut`. Save the value as `new_mode_th`.

|5 |AC.1.9.7.1, AC.1.9.7.2 |TCCM.S.C00.Rsp(ChangeToMode),
TCCM.S.F00(DEPONOFF) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|6 |AC.1.5.7.1 |OO.S.C00.Rsp TCCM.S.F00(DEPONOFF) a|
TH sends a _Off_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|7 |AC.1.5.7.2 |OO.S.C01.Rsp, TCCM.S.F00(DEPONOFF) a|
TH sends a _On_ command to the DUT

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode), TCCM.S.F00(DEPONOFF) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `on_mode_dut`

|===

[[_notestesting_considerations_299]]
====== link:#_notestesting_considerations_299[]Notes/Testing Considerations

[[_tc_tccm_3_2_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_tccm_3_2_startup_mode_functionality_with_dut_as_server[]218.3.2. [TC-TCCM-3.2] Startup Mode functionality with DUT as Server

[[_category_388]]
====== link:#_category_388[]Category

Functional conformance

[[_purpose_394]]
====== link:#_purpose_394[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled.

[[_pics_393]]
====== link:#_pics_393[]PICS

* TCCM.S

[[_preconditions_86]]
====== link:#_preconditions_86[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*

|1 | |!TCCM.S.F00(DEPONOFF) | OnOff cluster’s _StartUpOnOff_ attribute
is NULL | _StartUpOnOff_ is 0 | _OnMode_ is NULL |
|===

[[_required_devices_394]]
====== link:#_required_devices_394[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_314]]
====== link:#_device_topology_314[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_335]]
====== link:#_test_setup_335[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_394]]
====== link:#_test_procedure_394[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |TCCM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_current_mode_dut`
* If `startup_mode_dut` is equal to `old_current_mode_dut` proceed to
step 6. Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |TCCM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.7.1, AC.1.9.7.2 |TCCM.S.C00.Rsp(ChangeToMode) a|
TH sends a _ChangeToMode_ command to the DUT with NewMode set to
`new_mode_th`

a|
Verify that the DUT response contains a _ChangeToModeResponse_ command
w/ data fields: * Status, set to Success(0x00).

|8 | | a|
Physically power cycle the device

a|

|9 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_start_up_mode_dut`
* The value is equal to `new_start_up_mode_th`

|10 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_dut`

|===

[[_notestesting_considerations_300]]
====== link:#_notestesting_considerations_300[]Notes/Testing Considerations

[[_tc_tccm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server]]
===== link:#_tc_tccm_3_3_on_mode_and_startup_mode_functionality_with_dut_as_server[]218.3.3. [TC-TCCM-3.3] On Mode and Startup Mode functionality with DUT as Server

[[_category_389]]
====== link:#_category_389[]Category

Functional conformance

[[_purpose_395]]
====== link:#_purpose_395[]Purpose

This test case verifies that the DUT switches to the proper mode when
power cycled, if the device supports OnMode, and StartUpOnOff (from the
OnOff cluster).

[[_pics_394]]
====== link:#_pics_394[]PICS

* TCCM.S

[[_required_devices_395]]
====== link:#_required_devices_395[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_315]]
====== link:#_device_topology_315[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_336]]
====== link:#_test_setup_336[]Test Setup

Commission DUT to TH (can be skipped if done in a preceding test).

[[_test_procedure_395]]
====== link:#_test_procedure_395[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | a|
Commission DUT to TH (can be skipped if done in a preceding test).

a|

|2 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value or null
* Save the value as `startup_mode_dut`
* if `startup_mode_dut` is null proceed to step 3. Else save
`startup_mode_dut` as `new_start_up_mode_th` and proceed to step 5.

|3 |AC.1.9.6.1 |TCCM.S.A0000(SupportedModes) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` and save the value as
`new_start_up_mode_th`.

|4 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH writes to the DUT the _StartUpMode_ attribute with the
`new_start_up_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|5 |AC.1.9.6.4 |TCCM.S.A0003(OnMode), TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `old_on_mode_dut`
* If `startup_mode_dut` is equal to `old_on_mode_dut` proceed to step 6.
Else proceed to step 8.

|6 |AC.1.9.6.1, AC.1.9.8 |TCCM.S.A0000(SupportedModes),
TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _SupportedModes_ attribute.

a|
* Verify that the DUT response contains a list of ModeOptionsStruct
entries
* Verify that the list has two or more entries
* Save the Mode field values as `supported_modes_dut`
* Select a value from `supported_modes_dut` different from
`startup_mode_dut`. Save the value as `new_mode_th`.

|7 |AC.1.9.6.4 |TCCM.S.A0003(OnMode) a|
TH writes to the DUT the _OnMode_ attribute with the `new_mode_th` value

a|
Verify DUT responds w/ status SUCCESS(0x00)

|8 |AC.1.9.6.4 |TCCM.S.A0003(OnMode), TCCM.S.F00(DEPONOFF) a|
TH reads from the DUT the _OnMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* Save the value as `new_on_mode_dut`
* The value is equal to `new_mode_th`

|9 |AC.1.5.6.5 |OO.S.A4003 a|
TH writes to the DUT the _StartUpOnOff_ attribute with the value 1.

a|
Verify DUT responds w/ status SUCCESS(0x00)

|10 | | a|
Physically power cycle the device

a|

|11 |AC.1.9.6.3 |TCCM.S.A0002(StartUpMode) a|
TH reads from the DUT the _StartUpMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_start_up_mode_th`

|12 |AC.1.9.6.2 |TCCM.S.A0001(CurrentMode) a|
TH reads from the DUT the _CurrentMode_ attribute.

a|
* Verify that the DUT response contains an integer value
* The value is equal to `new_on_mode_dut`

|===

[[_notestesting_considerations_301]]
====== link:#_notestesting_considerations_301[]Notes/Testing Considerations

[[_refrigerator_alarm_cluster_test_plan]]
== link:#_refrigerator_alarm_cluster_test_plan[]**Refrigerator Alarm Cluster Test Plan**

[[_pics_definition_64]]
=== link:#_pics_definition_64[]219. PICS Definition

This section covers the Refrigerator Alarm Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_66]]
==== link:#_role_66[]219.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|REFALM.S |Does the device implement the Refrigerator Alarm cluster as a
server? |O |

|REFALM.C |Does the device implement the Refrigerator Alarm cluster as a
client? |O |
|===

[[_server_81]]
==== link:#_server_81[]219.2. Server

[[_attributes_71]]
===== link:#_attributes_71[]219.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|REFALM.S.A0000(Mask) |Does the device implement the _Mask_ attribute?
|M |

|REFALM.S.A0001(Latch) |Does the device implement the _Latch_ attribute?
|X |

|REFALM.S.A0002(State) |Does the device implement the _State_ attribute?
|M |

|REFALM.S.A0003(Supported) |Does the device implement the _Supported_
attribute? |M |
|===

[[_events_14]]
===== link:#_events_14[]219.2.2. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|REFALM.S.E00(Notify) |Does the device implement the _Notify_ event? |M
|
|===

[[_commands_received_38]]
===== link:#_commands_received_38[]219.2.3. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|REFALM.S.C00.Rsp(Reset) |Does the device implement receiving the
_Reset_ command? |X |

|REFALM.S.C01.Rsp(ModifyEnabledAlarms) |Does the device implement
receiving the _ModifyEnabledAlarms_ command? |X |
|===

[[_pixit_definition_16]]
=== link:#_pixit_definition_16[]220. PIXIT Definition

This section covers the Refrigerator Alarm’s Test Plan related PIXIT
items that might be required in the following test cases.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.REFALM.AlarmThreshold |The amount of time in seconds before the
door alarm is set for the DUT |M |

|PIXIT.REFALM.LocalSuppress |Boolean indicating whether (TRUE) or not
(FALSE) the door alarm can be locally suppressed. |M |
|===

[[_test_case_list_66]]
=== link:#_test_case_list_66[]221. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*

|1 |TC-REFALM-1.1 |Global attributes with DUT as Server

|2 |TC-REFALM-2.1 |Attributes with DUT as Server

|3 |TC-REFALM-2.2 |Primary functionality with DUT as Server

|4 |TC-REFALM-2.3 |Local suppression of the door alarm with DUT as
Server
|===

[[_test_cases_66]]
=== link:#_test_cases_66[]222. Test Cases

'''''

[[_generic_test_cases_57]]
==== link:#_generic_test_cases_57[]222.1. Generic test cases

'''''

[[_tc_refalm_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_refalm_1_1_global_attributes_with_dut_as_server[]222.1.1. [TC-REFALM-1.1] Global attributes with DUT as Server

[[_category_390]]
====== link:#_category_390[]Category

Functional conformance

[[_purpose_396]]
====== link:#_purpose_396[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_395]]
====== link:#_pics_395[]PICS

* REFALM.S

[[_required_devices_396]]
====== link:#_required_devices_396[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_316]]
====== link:#_device_topology_316[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_396]]
====== link:#_test_procedure_396[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision_ attribute
|Verify that the DUT response contains the _ClusterRevision_ attribute
and has the value 1.

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap_ attribute |Verify
that the DUT response contains the _FeatureMap_ attribute and has the
value 0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList_ attribute a|
Verify that the DUT response contains the _AttributeList_ attribute with
the list of supported attributes:

The list SHALL include all the mandatory entries: +
0x0000, 0x0002, 0x0003, 0xfff8, 0xfff9, 0xfffb, 0xfffc & 0xfffd.

This list SHALL NOT include 0x0001.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_4FFF) and (0x0000_F000 -
0x0000_FFFE)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_4FFF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored.

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_5000 - 0x0000_EFFF and 0x0000_FFFF), (0xXXXX_5000 -
0xXXXX_FFFF) and (0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed
MEI range (0x0001 - 0xFFF1)

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList_ attribute. a|
Verify that the DUT response contains the _EventList_ attribute and have
the list of supported events:

This cluster has no entries in the standard or scoped range. +

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF) +

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored. +

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1) +

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList_
attribute. a|
Verify that the DUT response contains the AcceptedCommandList attribute
and have the list of Accepted Command:

This cluster has no entries in the standard or scoped range.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored.

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1)

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList_
attribute. a|
Verify that the DUT response contains the GeneratedCommandList attribute
and have the list of Generated Command:

This cluster has no entries in the standard or scoped range.

The list SHALL NOT contain any additional values in the standard or
scoped range: (0x0000_0000 - 0x0000_00FF)

The list MAY contain values in the Manufacturer Extensible Identifier
(MEI) range: (0xXXXX_0000 - 0xXXXX_00FF), where XXXX is the allowed MEI
range (0x0001 - 0xFFF1), these values SHALL be ignored.

The list SHALL NOT contain any values in the Test Vendor or invalid
range: (0x0000_0100 - 0x0000_FFFF), (0xXXXX_0100 - 0xXXXX_FFFF) and
(0xFFF1_0000 - 0xFFFF_FFFF), where XXXX is the allowed MEI range (0x0001
- 0xFFF1)

|===

[[_notestesting_considerations_302]]
====== link:#_notestesting_considerations_302[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

[[_server_as_dut_30]]
==== link:#_server_as_dut_30[]222.2. Server as DUT

[[_tc_refalm_2_1_attributes_with_dut_as_server]]
===== link:#_tc_refalm_2_1_attributes_with_dut_as_server[]222.2.1. [TC-REFALM-2.1] Attributes with DUT as Server

[[_category_391]]
====== link:#_category_391[]Category

Functional conformance

[[_purpose_397]]
====== link:#_purpose_397[]Purpose

This test case verifies the non-global attributes of the Refrigerator
Alarm cluster server.

[[_pics_396]]
====== link:#_pics_396[]PICS

* REFALM.S

[[_required_devices_397]]
====== link:#_required_devices_397[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_317]]
====== link:#_device_topology_317[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_397]]
====== link:#_test_procedure_397[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 | | |Ensure that the door alarm is not locally suppressed and the
door is closed |

|3 | |REFALM.S.A0000(Mask) |TH reads from the DUT the _Mask_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
1.

|4 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
0.

|5 | |REFALM.S.A0003(Supported) |TH reads from the DUT the _Supported_
attribute |Verify that the DUT response contains a 32-bit value with bit
0 set to 1.
|===

[[_notestesting_considerations_303]]
====== link:#_notestesting_considerations_303[]Notes/Testing Considerations

[[_tc_refalm_2_2_primary_functionality_with_dut_as_server]]
===== link:#_tc_refalm_2_2_primary_functionality_with_dut_as_server[]222.2.2. [TC-REFALM-2.2] Primary functionality with DUT as Server

[[_category_392]]
====== link:#_category_392[]Category

Functional

[[_purpose_398]]
====== link:#_purpose_398[]Purpose

This test case verifies the primary functionality of the Refrigerator
Alarm cluster server.

[[_pics_397]]
====== link:#_pics_397[]PICS

* REFALM.S

[[_required_devices_398]]
====== link:#_required_devices_398[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_318]]
====== link:#_device_topology_318[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_398]]
====== link:#_test_procedure_398[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 | | |Ensure that the door on the DUT is closed |

|3 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
0

|4 | | |Manually open the door on the DUT |

|5 | | |Wait for the time defined in PIXIT.REFALM.AlarmThreshold |

|6 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
1

|7 | | |Ensure that the door on the DUT is closed |

|8 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
0

|9 | |REFALM.S.C00.Rsp(Reset) |TH sends _Reset_ command to the DUT
|Verify DUT responds w/ status UNSUPPORTED_COMMAND(0x81)

|10 | |REFALM.S.C01.Rsp(ModifyEnabledAlarms) |TH sends
_ModifyEnabledAlarms_ command to the DUT |Verify DUT responds w/ status
UNSUPPORTED_COMMAND(0x81)

|11 | |REFALM.S.E00(Notify),REFALM.S.A0002(State) |Set up subscription
to the _Notify_ event. |

|12 | |REFALM.S.E00(Notify) |Repeat steps 4 then 5 |After step 5
(repeated), receive a _Notify_ event with the _State_ attribute bit 0
set to 1.

|13 | |REFALM.S.E00(Notify) |Repeat step 7 |Receive a _Notify_ event
with the _State_ attribute bit 0 set to 0.
|===

[[_notestesting_considerations_304]]
====== link:#_notestesting_considerations_304[]Notes/Testing Considerations

[[_tc_refalm_2_3_local_suppression_of_the_door_alarm_with_dut_as_server]]
===== link:#_tc_refalm_2_3_local_suppression_of_the_door_alarm_with_dut_as_server[]222.2.3. [TC-REFALM-2.3] Local suppression of the door alarm with DUT as Server

[[_category_393]]
====== link:#_category_393[]Category

Functional

[[_purpose_399]]
====== link:#_purpose_399[]Purpose

This test case verifies the behaviour if the door alarm can be locally
suppressed of the Refrigerator Alarm cluster server.

[[_pics_398]]
====== link:#_pics_398[]PICS

* REFALM.S

[[_preconditions_87]]
====== link:#_preconditions_87[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Ref* |*Condition* |*Notes*
|1 | |PIXIT.REFALM.LocalSuppress set to TRUE |
|===

[[_required_devices_399]]
====== link:#_required_devices_399[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_319]]
====== link:#_device_topology_319[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_399]]
====== link:#_test_procedure_399[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 | | |Ensure that the door on the DUT is closed |

|3 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
0

|4 | |REFALM.S.A0000(Mask) |TH reads from the DUT the _Mask_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
1

|5 | | |Manually open the door on the DUT |

|6 | | |Wait for the time defined in PIXIT.REFALM.AlarmThreshold |

|7 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
1

|8 | | |Invoke the on DUT sequence to suppress the alarm, do not close
the door |

|9 | |REFALM.S.A0002(State) |TH reads from the DUT the _State_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
0

|10 | |REFALM.S.A0000(Mask) |TH reads from the DUT the _Mask_ attribute
|Verify that the DUT response contains a 32-bit value with bit 0 set to
0

|11 | |REFALM.S.A0003(Supported) |TH reads from the DUT the _Supported_
attribute |Verify that the DUT response contains a 32-bit value with bit
0 set to 1
|===

[[_rvc_operational_state_cluster_test_plan]]
== link:#_rvc_operational_state_cluster_test_plan[]**RVC Operational State Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*

|0.1 |2023-05-08 |`Various` |Initial Document upload to github

|0.2 |2023-05-24 |`Various` |Remove Client side tests

|0.3 |2023-05-25 |`Various` |Alignment with YAML

|0.4 |2023-07-26 |`Various` |Fix typos

|0.5 |2023-07-27 |`Various` |Improve operational state and error
testing. Remove client test leftovers. Fix state and error ranges.

|0.5.1 |2023-08-15 |`René Josefsen` |Mark EventList as not supported
(#3302)
|===

[[_pics_definition_65]]
=== link:#_pics_definition_65[]223. PICS Definition

This section covers the RVC Operational State Cluster Test Plan related
PICS items that are referenced in the following test cases. Support for
an item is considered as "true" for conditional statements within the
test case steps.

[[_role_67]]
==== link:#_role_67[]223.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCOPSTATE.S |Does the device implement the RVC Operational State
cluster as a server? |O |
|===

[[_server_82]]
==== link:#_server_82[]223.2. Server

[[_attributes_72]]
===== link:#_attributes_72[]223.2.1. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCOPSTATE.S.A0000(PhaseList) |Does the device implement the PhaseList
attribute? |M |

|RVCOPSTATE.S.A0001(CurrentPhase) |Does the device implement the
CurrentPhase attribute? |M |

|RVCOPSTATE.S.A0002(CountdownTime) |Does the device implement the
CountdownTime attribute? |O |

|RVCOPSTATE.S.A0003(OperationalStateList) |Does the device implement the
OperationalStateList attribute? |M |

|RVCOPSTATE.S.A0004(OperationalState) |Does the device implement the
OperationalState attribute? |M |

|RVCOPSTATE.S.A0005(OperationalError) |Does the device implement the
OperationalError attribute? |M |
|===

[[_commands_received_39]]
===== link:#_commands_received_39[]223.2.2. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCOPSTATE.S.C00.Rsp(Pause) |Does the device implement receiving the
Pause command? |O |

|RVCOPSTATE.S.C01.Rsp(Stop) |Does the device implement receiving the
Stop command? |O |

|RVCOPSTATE.S.C02.Rsp(Start) |Does the device implement receiving the
Start command? |O |

|RVCOPSTATE.S.C03.Rsp(Resume) |Does the device implement receiving the
Resume command? |O |
|===

[[_commands_generated_34]]
===== link:#_commands_generated_34[]223.2.3. Commands generated

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCOPSTATE.S.C04.Tx(OperationalCommandResponse) |Does the device
implement generating the OperationalCommandResponse command?
|RVCOPSTATE.S.C00.Rsp(Pause) | RVCOPSTATE.S.C01.Rsp(Stop) |
RVCOPSTATE.S.C02.Rsp(Start) | RVCOPSTATE.S.C03.Rsp(Resume) |
|===

[[_events_15]]
===== link:#_events_15[]223.2.4. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCOPSTATE.S.E00(OperationalError) |Does the device implement the
OperationalError Event ? |M |

|RVCOPSTATE.S.E01(OperationCompletion) |Does the device implement the
OperationCompletion Event ? |O |
|===

[[_manual_controllable_25]]
===== link:#_manual_controllable_25[]223.2.5. Manual controllable

This section describes manually controllable PICS codes.

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|RVCOPSTATE.S.M.ST_STOPPED |Does the DUT support testing the
Stopped(0x00) operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ST_RUNNING |Does the DUT support testing the
Running(0x01) operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ST_PAUSED |Does the DUT support testing the Paused(0x02)
operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ST_ERROR |Does the DUT support testing the Error(0x03)
operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ST_SEEKING_CHARGER |Does the DUT support testing the
SeekingCharger(0x40) operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ST_CHARGING |Does the DUT support testing the
Charging(0x41) operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ST_DOCKED |Does the DUT support testing the Docked(0x42)
operational state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_NO_ERROR |Does the DUT support testing the
NoError(0x00) error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_UNABLE_TO_START_OR_RESUME |Does the DUT support
testing the UnableToStartOrResume(0x01) error state? |O |Declared by
manufacturer

|RVCOPSTATE.S.M.ERR_UNABLE_TO_COMPLETE_OPERATION |Does the DUT support
testing the UnableToCompleteOperation(0x02) error state? |O |Declared by
manufacturer

|RVCOPSTATE.S.M.ERR_COMMAND_INVALID_IN_STATE |Does the DUT support
testing the CommandInvalidInState(0x03) error state? |O |Declared by
manufacturer

|RVCOPSTATE.S.M.ERR_FAILED_TO_FIND_CHARGING_DOCK |Does the DUT support
testing the FailedToFindChargingDock(0x40) error state? |O |Declared by
manufacturer

|RVCOPSTATE.S.M.ERR_STUCK |Does the DUT support testing the Stuck(0x41)
error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_DUST_BIN_MISSING |Does the DUT support testing the
DustBinMissing(0x42) error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_DUST_BIN_FULL |Does the DUT support testing the
DustBinFull(0x43) error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_WATER_TANK_EMPTY |Does the DUT support testing the
WaterTankEmpty(0x44) error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_WATER_TANK_MISSING |Does the DUT support testing the
WaterTankMissing(0x45) error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_WATER_TANK_LID_OPEN |Does the DUT support testing
the WaterTankLidOpen(0x46) error state? |O |Declared by manufacturer

|RVCOPSTATE.S.M.ERR_MOP_CLEANING_PAD_MISSING |Does the DUT support
testing the MopCleaningPadMissing(0x47) error state? |O |Declared by
manufacturer
|===

[[_test_case_list_67]]
=== link:#_test_case_list_67[]224. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*
|1 |TC-RVCOPSTATE-1.1 |Global attributes [DUT as Server]
|2 |TC-RVCOPSTATE-2.1 |Attribute verification [DUT as Server]
|3 |TC-RVCOPSTATE-2.2 |Start and Stop Commands [DUT as Server]
|4 |TC-RVCOPSTATE-2.3 |Pause and Resume Commands [DUT as Server]
|===

[[_test_cases_67]]
=== link:#_test_cases_67[]225. Test Cases

'''''

[[_generic_test_cases_58]]
==== link:#_generic_test_cases_58[]225.1. Generic test cases

'''''

[[_tc_rvcopstate_1_1_global_attributes_dut_as_server]]
===== link:#_tc_rvcopstate_1_1_global_attributes_dut_as_server[]225.1.1. [TC-RVCOPSTATE-1.1] Global attributes [DUT as Server]

[[_category_394]]
====== link:#_category_394[]Category

Functional conformance

[[_purpose_400]]
====== link:#_purpose_400[]Purpose

This test case verifies the global attributes of the cluster server

[[_pics_399]]
====== link:#_pics_399[]PICS

* RVCOPSTATE.S

[[_required_devices_400]]
====== link:#_required_devices_400[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_400]]
====== link:#_test_procedure_400[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 |C.7.13.1 | |TH reads from the DUT the _ClusterRevision attribute_
|Verify that the DUT response contains the _ClusterRevision_ attribute
with the value 1

|3 |C.7.13.2 | |TH reads from the DUT the _FeatureMap attribute_ |Verify
that the DUT response contains the _FeatureMap_ attribute with the value
0.

|4 |C.7.13.3 | |TH reads from the DUT the _AttributeList attribute_ a|
Verify that the DUT response contains the _AttributeList_ attribute with
the list of supported attributes

The list SHALL include all the mandatory entries: +
0x0000, 0x0001, 0x0003, 0x0004, 0x0005, 0xfff8, 0xfff9, 0xfffb, 0xfffc &
0xfffd

The list MAY include these optional entries: +
- 0x0002 SHALL be included if and only if
RVCOPSTATE.S.A0002(CountdownTime)

|5^*^ |C.7.13.6 | |TH reads from the DUT the _EventList attribute_ a|
Verify that the DUT response contains the _EventList_ attribute with the
list of supported events

\{mandatory entries} +
- 0x00

\{optional entries} +
- 0x01: SHALL be included if and only if
RVCOPSTATE.S.E01(OperationCompletion)

|6 |C.7.13.4 | |TH reads from the DUT the _AcceptedCommandList
attribute_ a|
Verify that the DUT response contains the list of Accepted commands :

The list MAY include these optional entries: +

- 0x00 SHALL be included if RVCOPSTATE.S.C00.Rsp(Pause) or SHALL be
included if RVCOPSTATE.S.C03.Rsp(Resume)

- 0x01 SHALL be included if RVCOPSTATE.S.C01.Rsp(Stop) or SHALL be
included if RVCOPSTATE.S.C02.Rsp(Start)

- 0x02 SHALL be included if and only if RVCOPSTATE.S.C02.Rsp(Start)

- 0x03 SHALL be included if RVCOPSTATE.S.C03.Rsp(Resume) or SHALL be
included if RVCOPSTATE.S.C00.Rsp(Pause)

|7 |C.7.13.5 | |TH reads from the DUT the _GeneratedCommandList
attribute_ a|
Verify that the DUT response contains the list of Generated commands:

The list MAY include these optional entries: +

- 0x04 SHALL be included if RVCOPSTATE.S.C00.Rsp(Pause) or
RVCOPSTATE.S.C01.Rsp(Stop) or RVCOPSTATE.S.C02.Rsp(Start) or
RVCOPSTATE.S.C03.Rsp(Resume). The list SHALL be empty otherwise.

|===

[[_notestesting_considerations_305]]
====== link:#_notestesting_considerations_305[]Notes/Testing Considerations

^*^ Step 5 is currently not supported and SHALL be skipped.

'''''

[[_server_as_dut_31]]
==== link:#_server_as_dut_31[]225.2. Server as DUT

'''''

[[_tc_rvcopstate_2_1_attribute_verification_dut_as_server]]
===== link:#_tc_rvcopstate_2_1_attribute_verification_dut_as_server[]225.2.1. [TC-RVCOPSTATE-2.1] Attribute verification [DUT as Server]

[[_category_395]]
====== link:#_category_395[]Category

Functional conformance

[[_purpose_401]]
====== link:#_purpose_401[]Purpose

This test case verifies the RVC Operational State Cluster attributes
with server as DUT

[[_pics_400]]
====== link:#_pics_400[]PICS

* RVCOPSTATE.S

[[_required_devices_401]]
====== link:#_required_devices_401[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_401]]
====== link:#_test_procedure_401[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 |1.12.6 |RVCOPSTATE.S.A0000(PhaseList) |TH reads from the DUT the
_PhaseList_ attribute |Verify that the DUT response contains a list of
strings, no more than 32 or null. Record 'phase-list-size', the number
of entries in the list if not null for use in step 3.

|3 |1.12.6 |RVCOPSTATE.S.A0001(CurrentPhase) |TH reads from the DUT the
_CurrentPhase_ attribute |Verify that the DUT response contains a uint8
value or null. This shall only be null if _PhaseList_ is also null. If
not null, ensure that it is equal to a value between 0 and
'phase-list-size' minus 1.

|4 |1.12.6 |RVCOPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains an
instance of elapsed-s (derived from uint32) or null. If not null, Value
has to be between a range of 0 to 259200.

|5 |1.12.6 |RVCOPSTATE.S.A0003(OperationalStateList) |TH reads from the
DUT the _OperationalStateList_ attribute |Verify that the DUT response
contains a list of states (each being an instance of
OperationalStateStruct). Each struct shall contain an OperationalStateId
(integer that defines the state) and an OperationalStateLabel, which is
a user understandable string describing the state. For each instance of
an OperationalStateID, verify the OperationalStateID is a defined state
(Stopped(0x00), Running(0x01), Paused(0x02), Error(0x03),
SeekingCharger(0x40), Charging(0x41), Docked(0x42)) or in the range 0x80
to 0xBF. The list shall include a struct with an OperationalStateId of
Error(0x03).

|6 |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) |TH reads from the DUT
the _OperationalState_ attribute |Verify that the DUT response contains
an OperationalStateEnum value. Verify the OperationalStateID is a
defined state (Stopped(0x00), Running(0x01), Paused(0x02), Error(0x03),
SeekingCharger(0x40), Charging(0x41), Docked(0x42)) or in the range 0x80
to 0xBF.

|6a |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_STOPPED a|
manually put the device in the Stopped(0x00) operational state

a|

|6b |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_STOPPED a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Stopped(0x00)

|6c |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_RUNNING a|
manually put the device in the Running(0x01) operational state

a|

|6d |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_RUNNING a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Running(0x01)

|6e |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_PAUSED a|
manually put the device in the Paused(0x02) operational state

a|

|6f |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_PAUSED a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Paused(0x02)

|6g |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_ERROR a|
manually put the device in the Error(0x03) operational state

a|

|6h |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_ERROR a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Error(0x03)

|6i |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_SEEKING_CHARGER a|
manually put the device in the SeekingCharger(0x40) operational state

a|

|6j |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_SEEKING_CHARGER a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to SeekingCharger(0x40)

|6k |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_CHARGING a|
manually put the device in the Charging(0x41) operational state

a|

|6l |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_CHARGING a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Charging(0x41)

|6m |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_DOCKED a|
manually put the device in the Docked(0x42) operational state

a|

|6n |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) &
RVCOPSTATE.S.M.ST_DOCKED a|
TH reads from the DUT the _OperationalState_ attribute

a|
Verify that the DUT response contains an OperationalStateEnum value.
Verify this is set to Docked(0x42)

|7 |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) |TH reads from the DUT
the _OperationalError_ attribute |Verify that the DUT response contains
an instance of ErrorStateStruct. This shall contain an ErrorStateId
(enum8 value that defines the error), an ErrorStateLabel, which is a
user understandable string describing the state which may be null, and
an ErrorStateDetails, which is an additional user understandable string.
Verify the ErrorStateID is a defined error (NoError(0x00),
UnableToStartOrResume(0x01), UnableToCompleteOperation(0x02),
CommandInvalidInState(0x03), FailedToFindChargingDock(0x40),
Stuck(0x41), DustBinMissing(0x42), DustBinFull(0x43),
WaterTankEmpty(0x44), WaterTankMissing(0x45), WaterTankLidOpen(0x46),
MopCleaningPadMissing(0x47)) or in the range 0x80 to 0xBF.

|7a |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_NO_ERROR |manually put the device in the
NoError(0x00) error state |

|7b |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_NO_ERROR |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of NoError(0x00)

|7c |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_UNABLE_TO_START_OR_RESUME |manually put the device in
the UnableToStartOrResume(0x01) error state |

|7d |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_UNABLE_TO_START_OR_RESUME |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of UnableToStartOrResume(0x01)

|7e |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_UNABLE_TO_COMPLETE_OPERATION |manually put the device
in the UnableToCompleteOperation(0x02) error state |

|7f |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_UNABLE_TO_COMPLETE_OPERATION |TH reads from the DUT
the _OperationalError_ attribute |Verify that the DUT response contains
an instance of ErrorStateStruct. This shall contain an ErrorStateId with
a value of UnableToCompleteOperation(0x02)

|7g |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_COMMAND_INVALID_IN_STATE |manually put the device in
the CommandInvalidInState(0x03) error state |

|7h |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_COMMAND_INVALID_IN_STATE |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of CommandInvalidInState(0x03)

|7i |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_FAILED_TO_FIND_CHARGING_DOCK |manually put the device
in the FailedToFindChargingDock(0x40) error state |

|7j |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_FAILED_TO_FIND_CHARGING_DOCK |TH reads from the DUT
the _OperationalError_ attribute |Verify that the DUT response contains
an instance of ErrorStateStruct. This shall contain an ErrorStateId with
a value of FailedToFindChargingDock(0x40)

|7k |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_STUCK |manually put the device in the Stuck(0x41)
error state |

|7l |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_STUCK |TH reads from the DUT the _OperationalError_
attribute |Verify that the DUT response contains an instance of
ErrorStateStruct. This shall contain an ErrorStateId with a value of
Stuck(0x41)

|7m |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_DUST_BIN_MISSING |manually put the device in the
DustBinMissing(0x42) error state |

|7n |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_DUST_BIN_MISSING |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of DustBinMissing(0x42)

|7o |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_DUST_BIN_FULL |manually put the device in the
DustBinFull(0x43) error state |

|7p |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_DUST_BIN_FULL |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of DustBinFull(0x43)

|7q |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_WATER_TANK_EMPTY |manually put the device in the
WaterTankEmpty(0x44) error state |

|7r |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_WATER_TANK_EMPTY |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of WaterTankEmpty(0x44)

|7s |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_WATER_TANK_MISSING |manually put the device in the
WaterTankMissing(0x45) error state |

|7t |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_WATER_TANK_MISSING |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of WaterTankMissing(0x45)

|7u |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_WATER_TANK_LID_OPEN |manually put the device in the
WaterTankLidOpen(0x46) error state |

|7v |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_WATER_TANK_LID_OPEN |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of WaterTankLidOpen(0x46)

|7w |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_MOP_CLEANING_PAD_MISSING |manually put the device in
the MopCleaningPadMissing(0x47) error state |

|7x |1.12.6 |RVCOPSTATE.S.A0005(OperationalError) &
RVCOPSTATE.S.M.ERR_MOP_CLEANING_PAD_MISSING |TH reads from the DUT the
_OperationalError_ attribute |Verify that the DUT response contains an
instance of ErrorStateStruct. This shall contain an ErrorStateId with a
value of MopCleaningPadMissing(0x47)
|===

[[_notestesting_considerations_306]]
====== link:#_notestesting_considerations_306[]Notes/Testing Considerations

[[_tc_rvcopstate_2_2_start_and_stop_commands_dut_as_server]]
===== link:#_tc_rvcopstate_2_2_start_and_stop_commands_dut_as_server[]225.2.2. [TC-RVCOPSTATE-2.2] Start and Stop commands [DUT as Server]

[[_category_396]]
====== link:#_category_396[]Category

Functional

[[_purpose_402]]
====== link:#_purpose_402[]Purpose

This test case verifies the operation of the Start and Stop commands of
the RVC Operational State cluster server.

[[_pics_401]]
====== link:#_pics_401[]PICS

* RVCOPSTATE.S

[[_preconditions_88]]
====== link:#_preconditions_88[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |RVCOPSTATE.S.C02.Rsp(Start) and RVCOPSTATE.S.C01.Rsp(Stop) |
|===

[[_required_devices_402]]
====== link:#_required_devices_402[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_402]]
====== link:#_test_procedure_402[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 | | |Manually put the DUT into a state wherein it can receive a Start
Command |

|3 |1.12.6 |RVCOPSTATE.S.A0003(OperationalStateList) |TH reads from the
DUT the _OperationalStateList_ attribute |Verify that the DUT response
contains a list of states (each being an instance of
OperationalStateStruct). The list shall include structs with the
following OperationalStateIds: Running(0x01), Stopped(0x00), and
Error(0x03).

|4 |1.12.7.3
|RVCOPSTATE.S.C02.Rsp(Start),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Start command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|5 |1.12.7.3 |RVCOPSTATE.S.A0004(OperationalState) |TH reads from the
DUT the _OperationalState_ attribute |Verify that the DUT response
contains the OperationalStateId set to Running(0x01).

|6 |1.12.7.3 |RVCOPSTATE.S.A0005(OperationalError) |TH reads from the
DUT the _OperationalError_ attribute |Verify that the DUT response
contains the ErrorStateId set to NoError(0x00).

|7 |1.12.6 |RVCOPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains an
integer value, Value has to be between a range of 1 to 259200 or null.
Record this value in 'initial-countdown-time'.

|8 |1.12.6 |RVCOPSTATE.S.A0000(PhaseList) |TH reads from the DUT the
_PhaseList_ attribute |Verify that the DUT response contains a list of
possible phases or null. If null jump to step 10, otherwise record
'phase-list-size', the number of entries in the list and perform step 9.

|9 |1.12.6 |RVCOPSTATE.S.A0001(CurrentPhase) |TH reads from the DUT the
_CurrentPhase_ attribute |Verify that the DUT response contains a uint8
value. Value has to be between a range of 0 to the size of
'phase-list-size' minus 1.

|10 | | |TH waits for a vendor defined wait time, this being a period of
time less than the expected duration of the operation that has been
started |

|11 |1.12.6 |RVCOPSTATE.S.A0002(CountdownTime) |TH reads from the DUT
the _CountdownTime_ attribute |Verify that the DUT response contains a
non-zero integer value that is approximately the wait time from step 10
less than 'initial-countdown-time' or null.

|12 |1.12.7.3
|RVCOPSTATE.S.C02.Rsp(Start),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Start command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|13 |1.12.7.2
|RVCOPSTATE.S.C01.Rsp(Stop),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Stop command to the DUT |Verify that the DUT response contains
an instance of OperationalCommandResponse. Verify that the ErrorStateId
field is set to NoError(0x00).

|14 |1.12.7.2 |RVCOPSTATE.S.A0004(OperationalState) |TH reads from the
DUT the _OperationalState_ attribute |Verify that the DUT response
contains the OperationalStateId set to Stopped(0x00).

|15 |1.12.7.2
|RVCOPSTATE.S.C01.Rsp(Stop),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Stop command to the DUT |Verify that the DUT response contains
an instance of OperationalCommandResponse. Verify that the ErrorStateId
field is set to NoError(0x00).

|16 | | |Manually put the DUT into a state wherein it cannot receive a
Start Command |

|17 |1.12.7.3
|RVCOPSTATE.S.C02.Rsp(Start),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Start command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to UnableToStartOrResume(0x01).
|===

[[_notestesting_considerations_307]]
====== link:#_notestesting_considerations_307[]Notes/Testing Considerations

[[_tc_rvcopstate_2_3_pause_and_resume_commands_dut_as_server]]
===== link:#_tc_rvcopstate_2_3_pause_and_resume_commands_dut_as_server[]225.2.3. [TC-RVCOPSTATE-2.3] Pause and Resume commands [DUT as Server]

[[_category_397]]
====== link:#_category_397[]Category

Functional

[[_purpose_403]]
====== link:#_purpose_403[]Purpose

This test case verifies the operation of the Pause and Resume commands
of the RVC Operational State cluster server.

[[_pics_402]]
====== link:#_pics_402[]PICS

* RVCOPSTATE.S

[[_preconditions_89]]
====== link:#_preconditions_89[]Preconditions

[width="100%",cols="25%,25%,25%,25%",]
|===
|*#* |*Doc. Ref.* |*Condition* |*Notes*
|1 | |RVCOPSTATE.S.C00.Rsp(Pause) and RVCOPSTATE.S.C03.Rsp(Resume) |
|===

[[_required_devices_403]]
====== link:#_required_devices_403[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_test_procedure_403]]
====== link:#_test_procedure_403[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH (can be skipped if done in a preceding
test) |

|2 |1.12.6 |RVCOPSTATE.S.C00.Rsp(Pause) |Manually put the DUT into a
state wherein it can receive a Pause Command |

|3 |1.12.6 |RVCOPSTATE.S.A0003(OperationalStateList) |TH reads from the
DUT the _OperationalStateList_ attribute |Verify that the DUT response
contains a list of states (each being an instance of
OperationalStateStruct). The list shall include structs with the
following OperationalStateIds: Running(0x01), Paused(0x02), and
Error(0x03).

|4 |1.12.7.1
|RVCOPSTATE.S.C00.Rsp(Pause),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Pause command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|5 |1.12.7.1 |RVCOPSTATE.S.A0004(OperationalState) |TH reads from the
DUT the _OperationalState_ attribute |Verify that the DUT response
contains the OperationalStateId set to Paused(0x02).

|6 |1.12.6 |RVCOPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains an
integer value, Value has to be between a range of 1 to 259200 or null.
Record this value in 'initial-countdown-time'.

|7 | | |TH waits for 5 seconds |

|8 |1.12.6 |RVCOPSTATE.S.A0002(CountdownTime) |TH reads from the DUT the
_CountdownTime_ attribute |Verify that the DUT response contains a
non-zero integer value that is the same as 'initial-countdown-time' or
null.

|9 |1.12.7.1
|RVCOPSTATE.S.C00.Rsp(Pause),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Pause command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|10 |1.12.7.4
|RVCOPSTATE.S.C03.Rsp(Resume),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Resume command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|11 |1.12.6 |RVCOPSTATE.S.A0004(OperationalState) |TH reads from the DUT
the _OperationalState_ attribute |Verify that the DUT response contains
the OperationalStateId set to Running(0x01).

|12 |1.12.7.4
|RVCOPSTATE.S.C03.Rsp(Resume),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Resume command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to NoError(0x00).

|13 |1.12.6 |RVCOPSTATE.S.C00.Rsp(Pause) |Manually put the DUT into a
state wherein it cannot receive a Pause command (e.g. Stopped state) |

|14 |1.12.7.1
|RVCOPSTATE.S.C00.Rsp(Pause),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Pause command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to CommandInvalidInState(0x03).

|15 |1.12.6 |RVCOPSTATE.S.C03.Rsp(Resume) |Manually put the DUT into a
state wherein it cannot receive a Resume command (e.g. Stopped state) |

|16 |1.12.7.4
|RVCOPSTATE.S.C03.Rsp(Resume),RVCOPSTATE.S.C04.Tx(OperationalCommandResponse)
|TH sends Resume command to the DUT |Verify that the DUT response
contains an instance of OperationalCommandResponse. Verify that the
ErrorStateId field is set to CommandInvalidInState(0x03).
|===

[[_notestesting_considerations_308]]
====== link:#_notestesting_considerations_308[]Notes/Testing Considerations

[[_smoke_co_alarm_cluster_test_plan]]
== link:#_smoke_co_alarm_cluster_test_plan[]**Smoke CO Alarm Cluster Test Plan**

*Document History*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Rev* |*Date* |*Author* |*Description*
|0.1 |26-April-2023 |`James Li` |Initial Test Plan for SMOKECO
|===

[[_pics_definition_66]]
=== link:#_pics_definition_66[]226. PICS Definition

This section covers the Smoke CO Alarm Cluster Test Plan related PICS
items that are referenced in the following test cases. Support for an
item is considered as "true" for conditional statements within the test
case steps.

[[_role_68]]
==== link:#_role_68[]226.1. Role

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SMOKECO.S |Does the device implement the SMOKECO cluster as a server?
|O |

|SMOKECO.C |Does the device implement the SMOKECO cluster as a client?
|O |
|===

[[_server_83]]
==== link:#_server_83[]226.2. Server

[[_features_49]]
===== link:#_features_49[]226.2.1. Features

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SMOKECO.S.F00(SMOKE) |Does the device support this specific cluster
feature? |O.a+ |

|SMOKECO.S.F01(CO) |Does the device support this specific cluster
feature? |O.a+ |
|===

[[_attributes_73]]
===== link:#_attributes_73[]226.2.2. Attributes

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SMOKECO.S.A0000(ExpressedState) |Does the device implement the
_ExpressedState_ attribute? |M |

|SMOKECO.S.A0001(SmokeState) |Does the device implement the _SmokeState_
attribute? |SMOKE |

|SMOKECO.S.A0002(COState) |Does the device implement the _COState_
attribute? |CO |

|SMOKECO.S.A0003(BatteryAlert) |Does the device implement the
_BatteryAlert_ attribute? |M |

|SMOKECO.S.A0004(DeviceMuted) |Does the device implement the
_DeviceMuted_ attribute? |O |

|SMOKECO.S.A0005(TestInProgress) |Does the device implement the
_TestInProgress_ attribute? |M |

|SMOKECO.S.A0006(HardwareFaultAlert) |Does the device implement the
_HardwareFaultAlert_ attribute? |M |

|SMOKECO.S.A0007(EndOfServiceAlert) |Does the device implement the
_EndOfServiceAlert_ attribute? |M |

|SMOKECO.S.A0008(InterconnectSmokeAlarm) |Does the device implement the
_InterconnectSmokeAlarm_ attribute? |O |

|SMOKECO.S.A0009(InterconnectCOAlarm) |Does the device implement the
_InterconnectCOAlarm_ attribute? |O |

|SMOKECO.S.A000a(ContaminationState) |Does the device implement the
_ContaminationState_ attribute? |[SMOKE] |

|SMOKECO.S.A000b(SmokeSensitivityLevel) |Does the device implement the
_SmokeSensitivityLevel_ attribute? |[SMOKE] |

|SMOKECO.S.A000c(ExpiryDate) |Does the device implement the _ExpiryDate_
attribute? |O |
|===

[[_events_16]]
===== link:#_events_16[]226.2.3. Events

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SMOKECO.S.E00(SmokeAlarm) |Does the device implement the _SmokeAlarm_
event? |SMOKE |

|SMOKECO.S.E01(COAlarm) |Does the device implement the _COAlarm_ event?
|CO |

|SMOKECO.S.E02(LowBattery) |Does the device implement the _LowBattery_
event? |M |

|SMOKECO.S.E03(HardwareFault) |Does the device implement the
_HardwareFault_ event? |M |

|SMOKECO.S.E04(EndOfService) |Does the device implement the
_EndOfService_ event? |M |

|SMOKECO.S.E05(SelfTestComplete) |Does the device implement the
_SelfTestComplete_ event? |M |

|SMOKECO.S.E06(AlarmMuted) |Does the device implement the _AlarmMuted_
event? |O |

|SMOKECO.S.E07(MuteEnded) |Does the device implement the _MuteEnded_
event? |O |

|SMOKECO.S.E08(InterconnectSmokeAlarm) |Does the device implement the
_InterconnectSmokeAlarm_ event? |[SMOKE] |

|SMOKECO.S.E09(InterconnectCOAlarm) |Does the device implement the
_InterconnectCOAlarm_ event? |[CO] |

|SMOKECO.S.E0a(AllClear) |Does the device implement the _AllClear_
event? |M |
|===

[[_manual_controllable_26]]
===== link:#_manual_controllable_26[]226.2.4. Manual controllable

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SMOKECO.M.ManuallyControlledTest |Can the TestInProgress attribute
changed by physical control at the device? |O |

|SMOKECO.M.ManuallyControlledMute |Can the DeviceMuted attribute changed
by physical control at the device? |O |
|===

[[_commands_received_40]]
===== link:#_commands_received_40[]226.2.5. Commands received

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|SMOKECO.S.C00.Rsp(SelfTestRequest) |Does the device implement receiving
the _SelfTestRequest_ command? |O |
|===

[[_pixit_definition_17]]
=== link:#_pixit_definition_17[]227. PIXIT Definition

This section covers the Smoke CO Alarm Cluster Test Plan related PIXIT
items that might be required in the following test cases.

*Table 2.1: Defined Variables*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*Variable* |*Description* |*Mandatory/Optional* |*Notes/Additional
Constraints*

|PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY |128-bit test event trigger enable
key |M |Variable value is specific to each device manufacturer.

|PIXIT.SMOKECO.TEST_EVENT_TRIGGER |64-bit device test event trigger key
|M |Variable value for trigger event is defined in table below.

|PIXIT.SMOKECO.HIEST_PRI_ALARM |Highest priority alarm in multiple alarm
condition |M |Variable value is specific to each device manufacturer.
|===

*Table 2.2: PIXIT.SMOKECO.TEST_EVENT_TRIGGER vs. Triggered Event*

[width="100%",cols="25%,25%,25%,25%",]
|===
|*PIXIT.SMOKECO.TEST_EVENT_TRIGGER* |*Triggered Event* |*Conformance*
|*Notes/Additional Constraints*

|0xffffffff00000090 |Warning Smoke Alarm Test Event |Smoke |

|0xffffffff0000009c |Critical Smoke Alarm Test Event |Smoke |

|0xffffffff000000a0 |Smoke Alarm Test Event Clear |Smoke |

|0xffffffff00000091 |Warning CO Alarm Test Event |CO |

|0xffffffff0000009d |Critical CO Alarm Test Event |CO |

|0xffffffff000000a1 |CO Alarm Test Event Clear |CO |

|0xffffffff00000095 |Warning Battery Alert Test Event |M |

|0xffffffff0000009e |Critical Battery Alert Test Event |M |

|0xffffffff000000a5 |Battery Alert Test Event Clear |M |

|0xffffffff00000093 |Hardware Fault Alert Test Event |M |

|0xffffffff000000a3 |Hardware Fault Alert Test Event Clear |M |

|0xffffffff0000009a |End of Service Alert Test Event |M |

|0xffffffff000000aa |End of Service Alert Test Event Clear |M |

|0xffffffff0000009b |Manual Device Mute Test Event |O |

|0xffffffff000000ab |Manual Device Mute Test Event Clear |O |

|0xffffffff00000092 |Interconnect Smoke Alarm Test Event |O |

|0xffffffff000000a2 |Interconnect Smoke Alarm Test Event Clear |O |

|0xffffffff00000094 |Interconnect CO Alarm Test Event |O |

|0xffffffff000000a4 |Interconnect CO Alarm Test Event Clear |O |

|0xffffffff00000096 |Contamination State (High) Test Event |[Smoke] |

|0xffffffff00000097 |Contamination State (Low) Test Event |[Smoke] |

|0xffffffff000000a6 |Contamination State Test Event Clear |[Smoke] |

|0xffffffff00000098 |Smoke Sensitivity Level (High) Test Event |[Smoke]
|

|0xffffffff00000099 |Smoke Sensitivity Level (Low) Test Event |[Smoke] |

|0xffffffff000000a8 |Smoke Sensitivity Level Test Event Clear |[Smoke] |
|===

Note: 'Test Event Clear' returns the device to pre-test status for that
test event.

[[_test_case_list_68]]
=== link:#_test_case_list_68[]228. Test Case List

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*TC UUID* |*Test Case Name*

|1 |TC-SMOKECO-1.1 |Global Attributes with DUT as Server

|2 |TC-SMOKECO-2.1 |Attributes with DUT as Server

|3 |TC-SMOKECO-2.2 |Primary Functionality - Smoke Alarm with DUT as
Server

|4 |TC-SMOKECO-2.3 |Primary Functionality - CO Alarm with DUT as Server

|5 |TC-SMOKECO-2.4 |Secondary Functionality - Mandatory with DUT as
Server

|6 |TC-SMOKECO-2.5 |Secondary Functionality - Optional with DUT as
Server

|7 |TC-SMOKECO-2.6 |ExpressedState Attribute - Multiple Alarms with DUT
as Server
|===

[[_test_cases_68]]
=== link:#_test_cases_68[]229. Test Cases

'''''

[[_generic_test_cases_59]]
==== link:#_generic_test_cases_59[]229.1. Generic test cases

'''''

[[_tc_smokeco_1_1_global_attributes_with_dut_as_server]]
===== link:#_tc_smokeco_1_1_global_attributes_with_dut_as_server[]229.1.1. [TC-SMOKECO-1.1] Global attributes with DUT as Server

[[_category_398]]
====== link:#_category_398[]Category

Functional conformance.

[[_purpose_404]]
====== link:#_purpose_404[]Purpose

This test case verifies the global attributes of the cluster server.

[[_pics_403]]
====== link:#_pics_403[]PICS

* SMOKECO.S

[[_required_devices_404]]
====== link:#_required_devices_404[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_320]]
====== link:#_device_topology_320[]Device Topology

TH and DUT are on the same fabric.

[[_test_procedure_404]]
====== link:#_test_procedure_404[]Test Procedure

[width="100%",cols="6%,9%,9%,38%,38%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |REF_CLUSTERREVISION | |TH reads the _ClusterRevision attribute_ from
the DUT |Verify that the ClusterRevision attribute is of uint16 and
reflects the highest revision number.

|3 |REF_FEATUREMAP | |TH reads from the DUT the _FeatureMap_ attribute.
a|
Verify that the DUT response contains the _FeatureMap_ attribute and
have the following bit set:

bit 0 set to 1 if DUT supports Smoke Alarm and bit 1 set to 1 if DUT
supports CO Alarm.

|4 |REF_ATTRIBUTELIST | |TH reads from the DUT the _AttributeList_
attribute. |Verify that the DUT response contains the _AttributeList_
attribute and have the list of supported attributes. +
The list shall include all mandatory attributes: 0x0000, 0x0003, 0x0005,
0x0006, and 0x0007. +
Depending on its feature support it shall also include the following
mandatory attributes: +
if SMOKECO.S.F00(SMOKE): 0x0001 +
if SMOKECO.S.F01(CO): 0x0002. +
It may include these optional attributes: 0x0004, 0x0008, 0x0009,
0x000a, 0x000b, and 0x000c. +
It shall include global attributes (0xFFFD)ClusterRevision,
(0xFFFC)FeatureMap, (0xFFFB)AttributeList, (0xFFF9)AcceptedCommandList &
(0xFFF8)GeneratedCommandList.

|5 |REF_EVENTLIST | |TH reads from the DUT the _EventList_ attribute.
|Verify that the DUT response contains the _EventList_ attribute and
have the list of eleven (11) supported events: 0x00, 0x01, 0x02, 0x03,
0x04, 0x05, 0x06, 0x07, 0x08, 0x09, and 0x0a.

|6 |REF_ACCEPTEDCOMMANDLIST | |TH reads from the DUT the
_AcceptedCommandList_ attribute. |Verify that the DUT response contains
the _AcceptedCommandList_ attribute and have the list of Accepted
Command: Optional: 0x00.

|7 |REF_GENERATEDCOMMANDLIST | |TH reads from the DUT the
_GeneratedCommandList_ attribute. |Verify that the DUT response contains
the _GeneratedCommandList_ attribute and have the list of Generated
Command. For this cluster the list is usually empty.
|===

[[_notestesting_considerations_309]]
====== link:#_notestesting_considerations_309[]Notes/Testing Considerations

'''''

[[_server_as_dut_32]]
==== link:#_server_as_dut_32[]229.2. Server as DUT

'''''

[[_tc_smokeco_2_1_attributes_with_dut_as_server]]
===== link:#_tc_smokeco_2_1_attributes_with_dut_as_server[]229.2.1. [TC-SMOKECO-2.1] Attributes with DUT as Server

[[_category_399]]
====== link:#_category_399[]Category

Functional.

[[_purpose_405]]
====== link:#_purpose_405[]Purpose

This test case verifies the non-global attributes of the Smoke CO Alarm
cluster server.

[[_pics_404]]
====== link:#_pics_404[]PICS

* SMOKECO.S

[[_required_devices_405]]
====== link:#_required_devices_405[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_321]]
====== link:#_device_topology_321[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_337]]
====== link:#_test_setup_337[]Test Setup

Commission DUT to TH.

[[_test_procedure_405]]
====== link:#_test_procedure_405[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 |REF_SMOKECO_A_ExpressedState |SMOKECO.S.A0000(ExpressedState) |TH
reads from the DUT the _ExpressedState_ attribute. |Verify that the DUT
response contains a value between 0 and 8

|3 |REF_SMOKECO_A_SmokeState |SMOKECO.S.A0001(SmokeState) |TH reads from
the DUT the _SmokeState_ attribute. |Verify that the DUT response
contains a value between 0 and 2

|4 |REF_SMOKECO_A_COState |SMOKECO.S.A0002(COState) |TH reads from the
DUT the _COState_ attribute. |Verify that the DUT response contains a
value between 0 and 2

|5 |REF_SMOKECO_A_BatteryAlert |SMOKECO.S.A0003(BatteryAlert) |TH reads
from the DUT the _BatteryAlert_ attribute. |Verify that the DUT response
contains a value between 0 and 2

|6 |REF_SMOKECO_A_DeviceMuted |SMOKECO.S.A0004(DeviceMuted) |TH reads
from the DUT the _DeviceMuted_ attribute. |Verify that the DUT response
contains a value between 0 and 1

|7 |REF_SMOKECO_A_TestInProgress |SMOKECO.S.A0005(TestInProgress) |TH
reads from the DUT the _TestInProgress_ attribute. |Verify that the DUT
response contains a bool value

|8 |REF_SMOKECO_A_HardwareFaultAlert
|SMOKECO.S.A0006(HardwareFaultAlert) |TH reads from the DUT the
_HardwareFaultAlert_ attribute. |Verify that the DUT response contains a
bool value

|9 |REF_SMOKECO_A_EndOfServiceAlert |SMOKECO.S.A0007(EndOfServiceAlert)
|TH reads from the DUT the _EndOfServiceAlert_ attribute. |Verify that
the DUT response contains a value between 0 and 1

|10 |REF_SMOKECO_A_InterconnectSmokeAlarm
|SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH reads from the DUT the
_InterconnectSmokeAlarm_ attribute. |Verify that the DUT response
contains a value between 0 and 2

|11 |REF_SMOKECO_A_InterconnectCOAlarm
|SMOKECO.S.A0009(InterconnectCOAlarm) |TH reads from the DUT the
_InterconnectCOAlarm_ attribute. |Verify that the DUT response contains
a value between 0 and 2

|12 |REF_SMOKECO_A_ContaminationState
|SMOKECO.S.A000a(ContaminationState) |TH reads from the DUT the
_ContaminationState_ attribute. |Verify that the DUT response contains a
value between 0 and 3

|13 |REF_SMOKECO_A_SensitivityLevel
|SMOKECO.S.A000b(SmokeSensitivityLevel) |TH reads from the DUT the
_SmokeSensitivityLevel_ attribute. |Verify that the DUT response
contains a value between 0 and 2

|14 |REF_SMOKECO_A_ExpiryDate |SMOKECO.S.A000c(ExpiryDate) |TH reads
from the DUT the _ExpiryDate_ attribute. |Verify that the DUT response
contains epoch-s format
|===

[[_notestesting_considerations_310]]
====== link:#_notestesting_considerations_310[]Notes/Testing Considerations

[[_tc_smokeco_2_2_primary_functionality_smoke_alarm_with_dut_as_server]]
===== link:#_tc_smokeco_2_2_primary_functionality_smoke_alarm_with_dut_as_server[]229.2.2. [TC-SMOKECO-2.2] Primary Functionality - Smoke Alarm with DUT as Server

[[_category_400]]
====== link:#_category_400[]Category

Functional.

[[_purpose_406]]
====== link:#_purpose_406[]Purpose

This test case verifies the smoke alarm functionality of the Smoke CO
Alarm cluster server. The test also verifies that device self-test is
not permitted to run during an alarm condition. The test case is Not
Applicable if DUT only has CO alarm functionality.

[[_pics_405]]
====== link:#_pics_405[]PICS

* SMOKECO.S

[[_required_devices_406]]
====== link:#_required_devices_406[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_322]]
====== link:#_device_topology_322[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_338]]
====== link:#_test_setup_338[]Test Setup

Commission DUT to TH.

[[_test_procedure_406]]
====== link:#_test_procedure_406[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |SMOKECO.S.A0001(SmokeState) |TH subscribes to SmokeState attribute
from DUT |Verify that SmokeState attribute has a value of 0 (Normal)

|3 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|4 | |DGGEN.S.A0008(TestEventTriggersEnabled) |TH reads
TestEventTriggersEnabled attribute from General Diagnostics Cluster
|Verify that TestEventTriggersEnabled attribute has a value of 1 (True)

|5 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning Smoke Alarm Test
Event |

|6 | |SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 1 (Warning)

|7 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 1
(SmokeAlarm)

|8 | |SMOKECO.S.E00(SmokeAlarm) |TH reads SmokeAlarm event from DUT
|Verify that SmokeAlarm event has a new event record and
AlarmSeverityLevel field indicates the SmokeState attribute current
value of 1

|9 | |SMOKECO.M.ManuallyControlledTest |Start manually DUT self-test |

|10 | |SMOKECO.S.A0005(TestInProgress) |After a few seconds, TH reads
TestInProgress attribute from DUT |Verify that TestInProgress attribute
has a value of 0 (False)

|11 | |SMOKECO.S.C00.Rsp(SelfTestRequest) |TH sends _SelfTestRequest_
command to DUT |

|12 | | |After a few seconds, TH receives the cluster-specific Status
Code from DUT |Verify that Status Code shows BUSY

|13 | |SMOKECO.S.A0005(TestInProgress) |TH reads TestInProgress
attribute from DUT |Verify that TestInProgress attribute has a value of
0 (False)

|14 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Critical Smoke Alarm Test
Event |

|15 | |SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 2 (Critical)

|16 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
1 (SmokeAlarm)

|17 | |SMOKECO.S.E00(SmokeAlarm) |TH reads SmokeAlarm event from DUT
|Verify that SmokeAlarm event has a new event record and
AlarmSeverityLevel field indicates the SmokeState attribute current
value of 2

|18 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Alarm Test Event Clear
|

|19 | |SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 0 (Normal)

|20 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|21 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record
|===

[[_notestesting_considerations_311]]
====== link:#_notestesting_considerations_311[]Notes/Testing Considerations

This test case requires Subscribe Request Action. The following
configuration of two mandatory Action Fields should be considered:

* MinIntervalFloor: 1~3 seconds
* MaxIntervalCeiling: 30~60 seconds.

[[_tc_smokeco_2_3_primary_functionality_co_alarm_with_dut_as_server]]
===== link:#_tc_smokeco_2_3_primary_functionality_co_alarm_with_dut_as_server[]229.2.3. [TC-SMOKECO-2.3] Primary Functionality - CO Alarm with DUT as Server

[[_category_401]]
====== link:#_category_401[]Category

Functional.

[[_purpose_407]]
====== link:#_purpose_407[]Purpose

This test case verifies the CO alarm functionality of the Smoke CO Alarm
cluster server. The test also verifies that device self-test is not
permitted to run during an alarm condition. The test case is Not
Applicable if DUT only has smoke alarm functionality.

[[_pics_406]]
====== link:#_pics_406[]PICS

* SMOKECO.S

[[_required_devices_407]]
====== link:#_required_devices_407[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_323]]
====== link:#_device_topology_323[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_339]]
====== link:#_test_setup_339[]Test Setup

Commission DUT to TH.

[[_test_procedure_407]]
====== link:#_test_procedure_407[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |SMOKECO.S.A0002(COState) |TH subscribes to COState attribute from
DUT |Verify that COState attribute has a value of 0 (Normal)

|3 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|4 | |DGGEN.S.A0008(TestEventTriggersEnabled) |TH reads
TestEventTriggersEnabled attribute from General Diagnostics Cluster
|Verify that TestEventTriggersEnabled attribute has a value of 1 (True)

|5 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning CO Alarm Test Event
|

|6 | |SMOKECO.S.A0002(COState) |TH waits for a report of COState
attribute from DUT with a timeout of 300 seconds |Verify that COState
attribute has a value of 1 (Warning)

|7 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 2
(COAlarm)

|8 | |SMOKECO.S.E01(COAlarm) |TH reads COAlarm event from DUT |Verify
that COAlarm event has a new event record and AlarmSeverityLevel field
indicates the COState attribute current value of 1

|9 | |SMOKECO.M.ManuallyControlledTest |Start manually DUT self-test |

|10 | |SMOKECO.S.A0005(TestInProgress) |After a few seconds, TH reads
TestInProgress attribute from DUT |Verify that TestInProgress attribute
has a value of 0 (False)

|11 | |SMOKECO.S.C00.Rsp(SelfTestRequest) |TH sends _SelfTestRequest_
command to DUT |

|12 | | |After a few seconds, TH receives the cluster-specific Status
Code from DUT |Verify that Status Code shows BUSY

|13 | |SMOKECO.S.A0005(TestInProgress) |TH reads TestInProgress
attribute from DUT |Verify that TestInProgress attribute has a value of
0 (False)

|14 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Critical CO Alarm Test Event
|

|15 | |SMOKECO.S.A0002(COState) |TH waits for a report of COState
attribute from DUT with a timeout of 300 seconds |Verify that COState
attribute has a value of 2 (Critical)

|16 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
2 (COAlarm)

|17 | |SMOKECO.S.E01(COAlarm) |TH reads COAlarm event from DUT |Verify
that COAlarm event has a new event record and AlarmSeverityLevel field
indicates the COState attribute current value of 2

|18 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for CO Alarm Test Event Clear |

|19 | |SMOKECO.S.A0002(COState) |TH waits for a report of COState
attribute from DUT with a timeout of 300 seconds |Verify that COState
attribute has a value of 0 (Normal)

|20 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|21 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record
|===

[[_notestesting_considerations_312]]
====== link:#_notestesting_considerations_312[]Notes/Testing Considerations

This test case requires Subscribe Request Action. The following
configuration of two mandatory Action Fields should be considered:

* MinIntervalFloor: 1~3 seconds
* MaxIntervalCeiling: 30~60 seconds.

[[_tc_smokeco_2_4_secondary_functionality_mandatory_with_dut_as_server]]
===== link:#_tc_smokeco_2_4_secondary_functionality_mandatory_with_dut_as_server[]229.2.4. [TC-SMOKECO-2.4] Secondary Functionality - Mandatory with DUT as Server

[[_category_402]]
====== link:#_category_402[]Category

Functional.

[[_purpose_408]]
====== link:#_purpose_408[]Purpose

This test case verifies the secondary functionality - mandatory of the
Smoke CO Alarm cluster server. It verifies Battery Alert, Hardware Fault
Alert, End of Service Alert and Test in Progress.

[[_pics_407]]
====== link:#_pics_407[]PICS

* SMOKECO.S

[[_required_devices_408]]
====== link:#_required_devices_408[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_324]]
====== link:#_device_topology_324[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_340]]
====== link:#_test_setup_340[]Test Setup

Commission DUT to TH.

[[_test_procedure_408]]
====== link:#_test_procedure_408[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |SMOKECO.S.A0003(BatteryAlert) |TH subscribes to BatteryAlert
attribute from DUT |Verify that BatteryAlert attribute has a value of 0
(Normal)

|3 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|4 | |DGGEN.S.A0008(TestEventTriggersEnabled) |TH reads
TestEventTriggersEnabled attribute from General Diagnostics Cluster
|Verify that TestEventTriggersEnabled attribute has a value of 1 (True)

|5 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning Battery Alert Test
Event |

|6 | |SMOKECO.S.A0003(BatteryAlert) |TH waits for a report of
BatteryAlert attribute from DUT with a timeout of 300 seconds |Verify
that BatteryAlert attribute has a value of 1 (Warning)

|7 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 3
(BatteryAlert)

|8 | |SMOKECO.S.E02(LowBattery) |TH reads LowBattery event from DUT
|Verify that LowBattery event has a new event record and
AlarmSeverityLevel field indicates the BatteryAlert attribute current
value of 1

|9 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Critical Battery Alert Test
Event |

|10 | |SMOKECO.S.A0003(BatteryAlert) |TH waits for a report of
BatteryAlert attribute from DUT with a timeout of 300 seconds |Verify
that BatteryAlert attribute has a value of 2 (Critical)

|11 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
3 (BatteryAlert)

|12 | |SMOKECO.S.E02(LowBattery) |TH reads LowBattery event from DUT
|Verify that LowBattery event has a new event record and
AlarmSeverityLevel field indicates the BatteryAlert attribute current
value of 2

|13 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Battery Alert Test Event
Clear |

|14 | |SMOKECO.S.A0003(BatteryAlert) |TH waits for a report of
BatteryAlert attribute from DUT with a timeout of 300 seconds |Verify
that BatteryAlert attribute has a value of 0 (Normal)

|15 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|16 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record

|17 | |SMOKECO.S.A0006(HardwareFaultAlert) |TH subscribes to
HardwareFaultAlert attribute from DUT |Verify that HardwareFaultAlert
attribute has a value of 0 (False)

|18 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Hardware Fault Alert Test
Event |

|19 | |SMOKECO.S.A0006(HardwareFaultAlert) |TH waits for a report of
HardwareFaultAlert attribute from DUT with a timeout of 300 seconds
|Verify that HardwareFaultAlert attribute has a value of 1 (True)

|20 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
5 (HardwareFault)

|21 | |SMOKECO.S.E03(HardwareFault) |TH reads HardwareFault event from
DUT |Verify that HardwareFault event has a new event record

|22 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Hardware Fault Alert Test
Event Clear |

|23 | |SMOKECO.S.A0006(HardwareFaultAlert) |TH waits for a report of
HardwareFaultAlert attribute from DUT with a timeout of 300 seconds
|Verify that HardwareFaultAlert attribute has a value of 0 (False)

|24 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|25 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record

|26 | |SMOKECO.S.A0007(EndOfServiceAlert) |TH subscribes to
EndOfServiceAlert attribute from DUT |Verify that EndOfServiceAlert
attribute has a value of 0 (Normal)

|27 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for End of Service Alert Test
Event |

|28 | |SMOKECO.S.A0007(EndOfServiceAlert) |TH waits for a report of
EndOfServiceAlert attribute from DUT with a timeout of 300 seconds
|Verify that EndOfServiceAlert attribute has a value of 1 (Expired)

|29 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
6 (EndOfService)

|30 | |SMOKECO.S.E04(EndOfService) |TH reads EndOfService event from DUT
|Verify that EndOfService event has a new event record

|31 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for End of Service Alert Test
Event Clear |

|32 | |SMOKECO.S.A0007(EndOfServiceAlert) |TH waits for a report of
EndOfServiceAlert attribute from DUT with a timeout of 300 seconds
|Verify that EndOfServiceAlert attribute has a value of 0 (Normal)

|33 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|34 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record

|35 | |SMOKECO.S.A0005(TestInProgress) |TH subscribes to TestInProgress
attribute from DUT |Verify that TestInProgress attribute has a value of
0 (False)

|36 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|37 | |SMOKECO.M.ManuallyControlledTest |Start manually DUT self-test |

|38 | |SMOKECO.S.A0005(TestInProgress) |TH waits for a report of
TestInProgress attribute from DUT with a timeout of 180 seconds |Verify
that TestInProgress attribute has a value of 1 (True)

|39 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
4 (Testing)

|40 | |SMOKECO.S.A0005(TestInProgress) |TH waits for a report of
TestInProgress attribute from DUT with a timeout of 180 seconds |Verify
that TestInProgress attribute has a value of 0 (False)

|41 | |SMOKECO.S.E05(SelfTestComplete) |TH reads SelfTestComplete event
from DUT |Verify that SelfTestComplete event has a new event record

|42 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|43 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record

|44 | |SMOKECO.S.C00.Rsp(SelfTestRequest) |TH sends _SelfTestRequest_
command to DUT |

|45 | |SMOKECO.S.A0005(TestInProgress) |TH waits for a report of
TestInProgress attribute from DUT with a timeout of 180 seconds |Verify
that TestInProgress attribute has a value of 1 (True)

|46 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
4 (Testing)

|47 | |SMOKECO.S.A0005(TestInProgress) |TH waits for a report of
TestInProgress attribute from DUT with a timeout of 180 seconds |Verify
that TestInProgress attribute has a value of 0 (False)

|48 | |SMOKECO.S.E05(SelfTestComplete) |TH reads SelfTestComplete event
from DUT |Verify that SelfTestComplete event has a new event record

|49 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)

|50 | |SMOKECO.S.E0a(AllClear) |TH reads AllClear event from DUT |Verify
that AllClear event has a new event record
|===

[[_notestesting_considerations_313]]
====== link:#_notestesting_considerations_313[]Notes/Testing Considerations

This test case requires Subscribe Request Action. The following
configuration of two mandatory Action Fields should be considered:

* MinIntervalFloor: 1~3 seconds
* MaxIntervalCeiling: 30~60 seconds.

[[_tc_smokeco_2_5_secondary_functionality_optional_with_dut_as_server]]
===== link:#_tc_smokeco_2_5_secondary_functionality_optional_with_dut_as_server[]229.2.5. [TC-SMOKECO-2.5] Secondary Functionality - Optional with DUT as Server

[[_category_403]]
====== link:#_category_403[]Category

Functional.

[[_purpose_409]]
====== link:#_purpose_409[]Purpose

This test case verifies the secondary functionality - optional of the
Smoke CO Alarm cluster server. It verifies interconnect smoke alarm,
interconnect CO alarm, contamination state, smoke sensitivity level ,
and manual device mute.

[[_pics_408]]
====== link:#_pics_408[]PICS

* SMOKECO.S

[[_required_devices_409]]
====== link:#_required_devices_409[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_325]]
====== link:#_device_topology_325[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_341]]
====== link:#_test_setup_341[]Test Setup

Commission DUT to TH.

[[_test_procedure_409]]
====== link:#_test_procedure_409[]Test Procedure

[width="100%",cols="5%,5%,10%,40%,40%",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*

|1 | | |Commission DUT to TH |

|2 | |SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH subscribes to
InterconnectSmokeAlarm attribute from DUT |Verify that
InterconnectSmokeAlarm attribute has a value of 0 (Normal)

|3 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute from
DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|4 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
DGGEN.S.A0008(TestEventTriggersEnabled) |TH reads
TestEventTriggersEnabled attribute from General Diagnostics Cluster
|Verify that TestEventTriggersEnabled attribute has a value of 1 (True)

|5 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect Smoke Alarm Test Event
|

|6 | |SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH waits for a report of
InterconnectSmokeAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectSmokeAlarm attribute has a value of 2
(Critical) or 1 (Warning)

|7 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
SMOKECO.S.E08(InterconnectSmokeAlarm) |TH reads InterconnectSmokeAlarm
event from DUT |Verify that InterconnectSmokeAlarm event has a new event
record and AlarmSeverityLevel field indicates the current value of
InterconnectSmokeAlarm attribute

|8 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute from
DUT |Verify that ExpressedState attribute has a value of 7
(InterconnectSmoke)

|9 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect Smoke Alarm Test Event
Clear |

|10 | |SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH waits for a report of
InterconnectSmokeAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectSmokeAlarm attribute has a value of 0 (Normal)

|11 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute from
DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|12 | |SMOKECO.S.A0008(InterconnectSmokeAlarm), SMOKECO.S.E0a(AllClear)
|TH reads AllClear event from DUT |Verify that AllClear event has a new
event record

|13 | |SMOKECO.S.A0009(InterconnectCOAlarm) |TH subscribes to
InterconnectCOAlarm attribute from DUT |Verify that InterconnectCOAlarm
attribute has a value of 0 (Normal)

|14 | |SMOKECO.S.A0009(InterconnectCOAlarm),
SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute from
DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|15 | |SMOKECO.S.A0009(InterconnectCOAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect CO Alarm Test Event |

|16 | |SMOKECO.S.A0009(InterconnectCOAlarm) |TH waits for a report of
InterconnectCOAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectCOAlarm attribute has a value of 2 (Critical)
or 1 (Warning)

|17 | |SMOKECO.S.A0009(InterconnectCOAlarm),
SMOKECO.S.E09(InterconnectCOAlarm) |TH reads InterconnectCOAlarm event
from DUT |Verify that InterconnectCOAlarm event has a new event record
and AlarmSeverityLevel field indicates the current value of
InterconnectCOAlarm attribute

|18 | |SMOKECO.S.A0009(InterconnectCOAlarm),
SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute from
DUT |Verify that ExpressedState attribute has a value of 8
(InterconnectCO)

|19 | |SMOKECO.S.A0009(InterconnectCOAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect CO Alarm Test Event
Clear |

|20 | |SMOKECO.S.A0009(InterconnectCOAlarm) |TH waits for a report of
InterconnectCOAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectCOAlarm attribute has a value of 0 (Normal)

|21 | |SMOKECO.S.A0009(InterconnectCOAlarm),
SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute from
DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|22 | |SMOKECO.S.A0009(InterconnectCOAlarm), SMOKECO.S.E0a(AllClear) |TH
reads AllClear event from DUT |Verify that AllClear event has a new
event record

|23 | |SMOKECO.S.A000a(ContaminationState) |TH subscribes to
ContaminationState attribute from DUT |Verify that ContaminationState
attribute has a value of 0 (Normal)

|24 | |SMOKECO.S.A000a(ContaminationState),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Contamination State (High) Test
Event |

|25 | |SMOKECO.S.A000a(ContaminationState) |TH waits for a report of
ContaminationState attribute from DUT with a timeout of 300 seconds
|Verify that ContaminationState attribute has a value of 2 (Warning) or
3 (Critical)

|26 | |SMOKECO.S.A000a(ContaminationState),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Contamination State Test Event
Clear |

|27 | |SMOKECO.S.A000a(ContaminationState) |TH waits for a report of
ContaminationState attribute from DUT with a timeout of 300 seconds
|Verify that ContaminationState attribute has a value of 0 (Normal)

|28 | |SMOKECO.S.A000a(ContaminationState),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Contamination State (Low) Test
Event |

|29 | |SMOKECO.S.A000a(ContaminationState) |TH waits for a report of
ContaminationState attribute from DUT with a timeout of 300 seconds
|Verify that ContaminationState attribute has a value of 1 (Low)

|30 | |SMOKECO.S.A000a(ContaminationState),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Contamination State Test Event
Clear |

|31 | |SMOKECO.S.A000a(ContaminationState) |TH waits for a report of
ContaminationState attribute from DUT with a timeout of 300 seconds
|Verify that ContaminationState attribute has a value of 0 (Normal)

|32 | |SMOKECO.S.A000b(SmokeSensitivityLevel) |TH subscribes to
SmokeSensitivityLevel attribute from DUT |Verify that
SmokeSensitivityLevel attribute has a value of 1 (Standard)

|33 | |SMOKECO.S.A000b(SmokeSensitivityLevel),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Sensitivity Level (High) Test
Event |

|34 | |SMOKECO.S.A000b(SmokeSensitivityLevel) |TH waits for a report of
SmokeSensitivityLevel attribute from DUT with a timeout of 300 seconds
|Verify that SmokeSensitivityLevel attribute has a value of 0 (High)

|35 | |SMOKECO.S.A000b(SmokeSensitivityLevel),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Sensitivity Level Test Event
Clear |

|36 | |\{PICS_SA_SmokeSensitivityLevel } |TH waits for a report of
SmokeSensitivityLevel attribute from DUT with a timeout of 300 seconds
|Verify that SmokeSensitivityLevel attribute has a value of 1 (Standard)

|37 | |SMOKECO.S.A000b(SmokeSensitivityLevel),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Sensitivity Level (Low) Test
Event |

|38 | |SMOKECO.S.A000b(SmokeSensitivityLevel) |TH waits for a report of
SmokeSensitivityLevel attribute from DUT with a timeout of 300 seconds
|Verify that SmokeSensitivityLevel attribute has a value of 2 (Low)

|39 | |SMOKECO.S.A000b(SmokeSensitivityLevel),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Sensitivity Level Test Event
Clear |

|40 | |SMOKECO.S.A000b(SmokeSensitivityLevel) |TH waits for a report of
SmokeSensitivityLevel attribute from DUT with a timeout of 300 seconds
|Verify that SmokeSensitivityLevel attribute has a value of 1 (Standard)

|41 | |SMOKECO.S.A0004(DeviceMuted) |TH subscribes to DeviceMuted
attribute from DUT |Verify that DeviceMuted attribute has a value of 0
(NotMuted)

|42 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE) |TH reads
_FeatureMap_ attribute from DUT |Verify that Smoke Alarm feature is
supported

|43 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
SMOKECO.S.A0001(SmokeState) |TH subscribes to SmokeState attribute from
DUT |Verify that SmokeState attribute has a value of 0 (Normal)

|44 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning Smoke Alarm Test Event |

|45 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 1 (Warning)

|46 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Manual Device Mute Test Event |

|47 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE) |TH waits for
a report of DeviceMuted attribute from DUT with a timeout of 120 seconds
|Verify that DeviceMuted attribute has a value of 1 (Muted)

|48 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
SMOKECO.S.E06(AlarmMuted) |TH reads AlarmMuted event from DUT |Verify
that AlarmMuted event has a new record

|49 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Manual Device Mute Test Event Clear
|

|50 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE) |TH waits for
a report of DeviceMuted attribute from DUT with a timeout of 120 seconds
|Verify that DeviceMuted attribute has a value of 0 (NotMuted)

|51 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
SMOKECO.S.E07(MuteEnded) |TH reads MuteEnded event from DUT |Verify that
MuteEnded event has a new record

|52 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Critical Smoke Alarm Test Event |

|53 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 2 (Critical)

|54 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Manual Device Mute Test Event |

|55 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE) |TH waits 60
seconds and then reads DeviceMuted attribute from DUT |Verify that
DeviceMuted attribute has a value of 0 (NotMuted)

|56 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Alarm Test Event Clear |

|57 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F00(SMOKE),
SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 0 (Normal)

|58 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO) |TH reads
_FeatureMap_ attribute from DUT |Verify that CO Alarm feature is
supported

|59 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
SMOKECO.S.A0002(COState) |TH subscribes to COState attribute from DUT
|Verify that COState attribute has a value of 0 (Normal)

|60 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning CO Alarm Test Event |

|61 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
SMOKECO.S.A0002(COState) |TH waits for a report of COState attribute
from DUT with a timeout of 300 seconds |Verify that COState attribute
has a value of 1 (Warning)

|62 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Manual Device Mute Test Event |

|63 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO) |TH waits for a
report of DeviceMuted attribute from DUT with a timeout of 120 seconds
|Verify that DeviceMuted attribute has a value of 1 (Muted)

|64 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
SMOKECO.S.E06(AlarmMuted) |TH reads AlarmMuted event from DUT |Verify
that AlarmMuted event has a new record

|65 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Manual Device Mute Test Event Clear
|

|66 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO) |TH waits for a
report of DeviceMuted attribute from DUT with a timeout of 120 seconds
|Verify that DeviceMuted attribute has a value of 0 (NotMuted)

|67 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
SMOKECO.S.E07(MuteEnded) |TH reads MuteEnded event from DUT |Verify that
MuteEnded event has a new record

|68 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Critical CO Alarm Test Event |

|69 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
SMOKECO.S.A0002(COState) |TH waits for a report of COState attribute
from DUT with a timeout of 300 seconds |Verify that COState attribute
has a value of 2 (Critical)

|70 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Manual Device Mute Test Event |

|71 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO) |TH waits 60
seconds and then reads DeviceMuted attribute from DUT |Verify that
DeviceMuted attribute has a value of 0 (NotMuted)

|72 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for CO Alarm Test Event Clear |

|73 | |SMOKECO.S.A0004(DeviceMuted), SMOKECO.S.F01(CO),
SMOKECO.S.A0002(COState) |TH waits for a report of COState attribute
from DUT with a timeout of 300 seconds |Verify that COState attribute
has a value of 0 (Normal)
|===

[[_notestesting_considerations_314]]
====== link:#_notestesting_considerations_314[]Notes/Testing Considerations

This test case requires Subscribe Request Action. The following
configuration of two mandatory Action Fields should be considered:

* MinIntervalFloor: 1~3 seconds
* MaxIntervalCeiling: 30~60 seconds.

[[_tc_smokeco_2_6_expressedstate_attribute_multiple_alarms_with_dut_as_server]]
===== link:#_tc_smokeco_2_6_expressedstate_attribute_multiple_alarms_with_dut_as_server[]229.2.6. [TC-SMOKECO-2.6] ExpressedState Attribute - Multiple Alarms with DUT as Server

[[_category_404]]
====== link:#_category_404[]Category

Functional.

[[_purpose_410]]
====== link:#_purpose_410[]Purpose

This test case verifies that the ExpressedState Attribute indicates the
highest priority alarm during multiple alarms condition of the Smoke CO
Alarm cluster server. The design of the test case intends to include
both Smoke and CO alarms in multiple alarms condition, therefore a Smoke
and CO combo device is required.

[[_pics_409]]
====== link:#_pics_409[]PICS

* SMOKECO.S

[[_required_devices_410]]
====== link:#_required_devices_410[]Required Devices

[width="100%",cols="34%,33%,33%",]
|===
|*#* |*Device Name* |*Device Description*
|1 |TH |TH as Client.
|2 |DUT |DUT as Server.
|===

[[_device_topology_326]]
====== link:#_device_topology_326[]Device Topology

TH and DUT are on the same fabric.

[[_test_setup_342]]
====== link:#_test_setup_342[]Test Setup

Commission DUT to TH.

[[_test_procedure_410]]
====== link:#_test_procedure_410[]Test Procedure

[width="100%",cols="7%,4%,9%,38%,42%",options="header",]
|===
|*#* |*Ref* |*PICS* |*Test Step* |*Expected Outcome*
|1 | | |Commission DUT to TH |

|2 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState attribute
from DUT |Verify that ExpressedState attribute has a value of 0 (Normal)

|3 | |SMOKECO.S.A0003(BatteryAlert) |TH subscribes to BatteryAlert
attribute from DUT |Verify that BatteryAlert attribute has a value of 0
(Normal)

|4 | |SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH subscribes to
InterconnectSmokeAlarm attribute from DUT |Verify that
InterconnectSmokeAlarm attribute has a value of 0 (Normal)

|5 | |SMOKECO.S.A0009(InterconnectCOAlarm) |TH subscribes to
InterconnectCOAlarm attribute from DUT |Verify that InterconnectCOAlarm
attribute has a value of 0 (Normal)

|6 | |SMOKECO.S.A0002(COState) |TH subscribes to COState attribute from
DUT |Verify that COState attribute has a value of 0 (Normal)

|7 | |SMOKECO.S.A0001(SmokeState) |TH subscribes to SmokeState attribute
from DUT |Verify that SmokeState attribute has a value of 0 (Normal)

|8 | |DGGEN.S.A0008(TestEventTriggersEnabled) |TH reads
TestEventTriggersEnabled attribute from General Diagnostics Cluster
|Verify that TestEventTriggersEnabled attribute has a value of 1 (True)

|9 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning Battery Alert Test
Event |

|10 | |SMOKECO.S.A0003(BatteryAlert) |TH waits for a report of
BatteryAlert attribute from DUT with a timeout of 300 seconds |Verify
that BatteryAlert attribute has a value of 1 (Warning)

|11 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect Smoke Alarm Test Event
|

|12 | |SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH waits for a report of
InterconnectSmokeAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectSmokeAlarm attribute has a value of 2
(Critical) or 1 (Warning)

|13 | |SMOKECO.S.A0009(InterconnectCOAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect CO Alarm Test Event |

|14 | |SMOKECO.S.A0009(InterconnectCOAlarm) |TH waits for a report of
InterconnectCOAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectCOAlarm attribute has a value of 2 (Critical)
or 1 (Warning)

|15 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning CO Alarm Test Event
|

|16 | |SMOKECO.S.A0002(COState) |TH waits for a report of COState
attribute from DUT with a timeout of 300 seconds |Verify that COState
attribute has a value of 1 (Warning)

|17 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Warning Smoke Alarm Test
Event |

|18 | |SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 1 (Warning)

|19 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value
that indicates PIXIT.SMOKECO.HIEST_PRI_ALARM

|20 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Smoke Alarm Test Event Clear
|

|21 | |SMOKECO.S.A0001(SmokeState) |TH waits for a report of SmokeState
attribute from DUT with a timeout of 300 seconds |Verify that SmokeState
attribute has a value of 0 (Normal)

|22 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value
that indicates PIXIT.SMOKECO.HIEST_PRI_ALARM

|23 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for CO Alarm Test Event clear |

|24 | |SMOKECO.S.A0002(COState) |TH waits for a report of COState
attribute from DUT with a timeout of 300 seconds |Verify that COState
attribute has a value of 0 (Normal)

|25 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value
that indicates PIXIT.SMOKECO.HIEST_PRI_ALARM

|26 | |SMOKECO.S.A0009(InterconnectCOAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect CO Alarm Test Event
Clear |

|27 | |SMOKECO.S.A0009(InterconnectCOAlarm) |TH waits for a report of
InterconnectCOAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectCOAlarm attribute has a value of 0 (Normal)

|28 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value
that indicates PIXIT.SMOKECO.HIEST_PRI_ALARM

|29 | |SMOKECO.S.A0008(InterconnectSmokeAlarm),
DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger command to
General Diagnostics Cluster on Endpoint 0 with EnableKey field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field set to
PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Interconnect Smoke Alarm Test Event
Clear |

|30 | |SMOKECO.S.A0008(InterconnectSmokeAlarm) |TH waits for a report of
InterconnectSmokeAlarm attribute from DUT with a timeout of 300 seconds
|Verify that InterconnectSmokeAlarm attribute has a value of 0 (Normal)

|31 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value
that indicates PIXIT.SMOKECO.HIEST_PRI_ALARM

|32 | |DGGEN.S.C00.Rsp(TestEventTrigger) |TH sends TestEventTrigger
command to General Diagnostics Cluster on Endpoint 0 with EnableKey
field set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER_KEY and EventTrigger field
set to PIXIT.SMOKECO.TEST_EVENT_TRIGGER for Battery Alert Test Event
Clear |

|33 | |SMOKECO.S.A0003(BatteryAlert) |TH waits for a report of
BatteryAlert attribute from DUT with a timeout of 300 seconds |Verify
that BatteryAlert attribute has a value of 0 (Normal)

|34 | |SMOKECO.S.A0000(ExpressedState) |TH reads ExpressedState
attribute from DUT |Verify that ExpressedState attribute has a value of
0 (Normal)
|===

[[_notestesting_considerations_315]]
====== link:#_notestesting_considerations_315[]Notes/Testing Considerations

This test case requires Subscribe Request Action. The following
configuration of two mandatory Action Fields should be considered:

* MinIntervalFloor: 1~3 seconds
* MaxIntervalCeiling: 30~60 seconds.

[[footer]]
[[footer-text]]
Version master d055a55 +
Last updated 2023-08-18 23:56:16 UTC
